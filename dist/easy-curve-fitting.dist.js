(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],3:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],4:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":3,"_process":1,"inherits":2}],5:[function(require,module,exports){
var math = require('./math-custom.js');
var optimize = require('./optimize.js');



var easyCurveFitting = function () {};

easyCurveFitting.prototype.log = function (obj) {
  console.log(util.inspect(obj));
};


easyCurveFitting.prototype.doLeastSquares = function(modelStr, data, guessStr) {
  
  var model = parseModel(modelStr);
    
  var guess = parseGuesses(guessStr);
  
  // Initialize any unspecified guess values to 0
  for(var param in model.params) {
    if(model.params.hasOwnProperty(param) && !guess.hasOwnProperty(param)) {
      guess[param] = 0;
    }
  }
    
  // Compile the parsed expression tree
  var code = model.node.compile();


  // Build the guess arrays
  var guessCoeff = [];
  var guessValue = [];
  for(var key in guess) {
    if(guess.hasOwnProperty(key) && key !== 'x') {
      guessCoeff.push(key);
      guessValue.push(guess[key]);
    }
  }

  // Build the objective function
  var objective = function(c) {
    var SSE = 0;
    var scope = {};
    for(var j=0; j<c.length; j++) {
      scope[guessCoeff[j]] = c[j];
    }
    for(var i=0; i<data.length; i++) {
      var x = data[i].x;
      var y = data[i].y;
      scope.x = x;
      
      var pred = code.eval(scope);
      SSE += (y - pred) * (y - pred);
    }
    return SSE;
  };


  var result = optimize(objective, guessValue);

  
  // Display the results
  var guessStr = "";
  var optimized = {};
  for(var i=0; i<result.length; i++) {
    optimized[guessCoeff[i]] = result[i];
  }
      
    
      
  return {
    guesses: guess,
    modelStr: modelStr,
    data: data,
    optimized: optimized
  };
      
      /*
      $('#guess').val(guessStr);

			var dataStr = "x\ty\tpred\tsq.err\n";
			var SSE = 0;
			var minX = data[0].x;
			var maxX = data[0].x;
			for(var i=0; i<data.length; i++) {
				var x = data[i].x;
				var y = data[i].y;
				if(x > maxX)
					maxX = x;
				if(x < minX)
					minX = x;
				coeffs.x = x;
				var pred = code.eval(coeffs);
				data[i].pred = pred;
				var SE = (pred-y);
				SE = SE * SE;
				SSE += SE;
				dataStr += x.toString() + "\t" + y.toString() + "\t" + pred.toString() + "\t" + SE.toString() + "\n";
			}
			dataStr = "Sum of squared errors:\t" + SSE.toString() + "\n" + dataStr;
			$('#data').val(dataStr);

			
			var domain = maxX - minX;
			minX = minX - domain * 0.1;
			maxX = maxX + domain * 0.1;
			var smooth = [];
			for(var x = minX; x<maxX; x += domain * 0.002) {
				coeffs.x = x;
				var pred = code.eval(coeffs);
				smooth.push({x: x, y: pred});
			}

			plotter.setData(data, smooth);
			plotter.draw();
*/
  
}


function parseModel(modelStr) {
  
  if(typeof(modelStr) !== "string") {
    throw new TypeError("parseModel expected parameter 1 (modelStr) to be of type 'String'");
  }
 
  var node = math.parse(modelStr);
  
  // Find the SymbolNodes
  var params = {};
  var hasx = false;
  var hasParams = false;
  var symbols = node.filter(function(node) {
    return node.isSymbolNode;
  });

  symbols.forEach(function(node) {
    if(node.name === 'x') {
      hasx = true;
    }
    else {
      params[node.name] = 0;
      hasParams = true;
    }
  });
  
  if(!hasx) {
    throw new Error("Model does not contain 'x'.");
  }
  if(!hasParams) {
    throw new Error("Model does not contain any parameters.");
  }
  
  return {
    node: node,
    params: params
  };
}

function parseGuesses(lines) {
  if(!lines) {
    return {};
  }
  
  // Get the guess values
  var guess = {};
  
  for(var i=0; i<lines.length; i++) {
    if(lines[i].trim().length === 0) {
      continue;
    }
    var parts = lines[i].split('=');
    if(parts.length !== 2) {
      throw new ParseError("Guess values must be one value on each line, like this: \"a = 2\"");
    }
    var g = parseFloat(parts[1]);
    if(isNaN(g)) {
      alert("Invalid guess value: " + parts[1]);
      return;
    }
    guess[parts[0].trim()] = g;
  }
  
  return guess;
}
  
  

/*

$(function() {

	



		function doTheThing(fit) {

			// Save the data for later
			localStorage.curveFit_data = $('#data').val();
			localStorage.curveFit_guess = $('#guess').val();
			localStorage.curveFit_form = $('#form').val();

			// Read the data
			var lines = $('#data').val().split('\n');
			if(lines.length === 0) {
				alert("Please enter some data.");
				return;
			}
			var data = [];
			for(var i=0; i<lines.length; i++) {
				if(lines[i].trim().length === 0) {
					continue;
				}
				var xy = lines[i].split(/[\s,]+/);
				if(xy.length < 2) {
					alert("Error, only one value found on line " + (i+1).toString() + ". Please enter two columns.");
					return;
				}
				var xFloat = parseFloat(xy[0]);
				var yFloat = parseFloat(xy[1]);
				if(isNaN(xFloat) || isNaN(yFloat)) {
					continue;
				}
				data.push({x: xFloat, y: yFloat});
			}

			// Parse the form
			var form = $('#form').val();
			if(form.length === 0) {
				alert("Please enter a form of the curve to fit, such as \"a x^2 + b x + c\".");
				return;
			}
      
      

		

		}

	});
*/
  
  module.exports = new easyCurveFitting();
},{"./math-custom.js":7,"./optimize.js":8}],6:[function(require,module,exports){
curve = require('./easy-curve-fitting.js');

},{"./easy-curve-fitting.js":5}],7:[function(require,module,exports){
var core = require('../node_modules/mathjs/core.js');

var math = core.create();

math.import(require('../node_modules/mathjs/lib/type/number.js'));
math.import(require('../node_modules/mathjs/lib/function/arithmetic'));
math.import(require('../node_modules/mathjs/lib/function/trigonometry'));
math.import(require('../node_modules/mathjs/lib/expression'));

module.exports = math;
},{"../node_modules/mathjs/core.js":9,"../node_modules/mathjs/lib/expression":206,"../node_modules/mathjs/lib/function/arithmetic":257,"../node_modules/mathjs/lib/function/trigonometry":314,"../node_modules/mathjs/lib/type/number.js":342}],8:[function(require,module,exports){
//var util = require('util');

/**
 * Optimize guess according to minimize objective function.
 */
module.exports = function(objective, guess) {
	
	// Parameters
	var alpha = 1.0;		// Reflection
	var gamma = 2.0;		// Expansion
	var rho = -0.5;			// Contraction
	var sigma = 0.5;		// Reduction

	// How many variables?
	var n = guess.length;
	
	// Construct the simplex
	var simplex = [];
	for(var i=0; i<n+1; i++) {
		simplex[i] = {x:[]};
		for(var j=0; j<n; j++) {
			simplex[i].x[j] = guess[j] * (1 + (Math.random() - 0.5) * 1e-6) + (Math.random() - 0.5) * 1e-9;
		}
		simplex[i].f = objective(simplex[i].x);
	}
	
	var iter = -1;

	while(iter < 1000) {
	
	  // Step 1: Order vertices
		iter++;
		simplex.sort(function(a, b) { return a.f - b.f; } );
		if(simplex[n].f - simplex[0].f < 1e-14 ) {
			break;
		}

		var diff = 0;
		for(var j=0; j<n; j++) {
			diff += (simplex[n].x[j] - simplex[0].x[j]) * (simplex[n].x[j] - simplex[0].x[j]);
		}
		if(diff < 1e-28) {
			break;
		}

		// Step 2: Compute centroid
		var centroid = [];
		for(var j=0; j<n; j++) {
			centroid[j] = 0;
			for(var i=0; i<n; i++) {		// Iterate only over the first n simplex points (not the last one)
				centroid[j] += simplex[i].x[j];
			}
			centroid[j] /= n;
		}

		// Step 3: Reflection
		var reflected = [];
		for(var j=0; j<n; j++) {
			reflected[j] = centroid[j] + alpha * (centroid[j] - simplex[n].x[j]);
		}
		var fReflected = objective(reflected);
		if (fReflected < simplex[n-1].f && fReflected >= simplex[0].f) {
			// Replace worst point with reflected point
			simplex[n] = {f: fReflected, x:reflected};
			continue;
		}

		// Step 4: Expansion
		if (fReflected < simplex[0].f) {
			var expanded = [];
			for(var j=0; j<n; j++) {
				expanded[j] = centroid[j] + gamma * (centroid[j] - simplex[n].x[j]);
			}
			var fExpanded = objective(expanded);
			if (fExpanded < fReflected) {
				// Replace worst point with expanded point
				simplex[n] = {f: fExpanded, x:expanded};
				continue;
			}
			else {
				// Replace worst point with reflected point
				simplex[n] = {f: fReflected, x:reflected};
				continue;
			}
		}

		// Step 5: Contraction
		var contracted = [];
		for(var j=0; j<n; j++) {
			contracted[j] = centroid[j] + rho * (centroid[j] - simplex[n].x[j]);
		}
		var fContracted = objective(contracted);
		if (fContracted < simplex[n].f) {
			// Replace worst point with contracted point
			simplex[n] = {f: fContracted, x:contracted};
			continue;
		}

		// Step 6: Reduction
		for(var i=1; i<n+1; i++) {
			for(var j=0; j<n; j++) {
				simplex[i].x[j] = simplex[0].x[j] + sigma * (simplex[i].x[j] - simplex[0].x[j]);
			}
			simplex[i].f = objective(simplex[i].x);
		}
	}

	return simplex[0].x;
}

// Generate some random data
/*
var data = [];
for(var i=0; i<100; i++) {
	data[i] = {};
	data[i].x = i * 0.1;
	data[i].y = 2 * data[i].x / (data[i].x + 4);
}

function test(c) {
	var SSE = 0;
	for(var i=0; i<data.length; i++) {
		var x = data[i].x;
		var y = data[i].y;
		var pred = c[0] * x / (x + c[1]) + c[2];
		SSE += (y-pred) * (y-pred);
	}
	return SSE;
}

var guess = [0, 0, 0];

optimize(test, guess);
*/
},{}],9:[function(require,module,exports){
module.exports = require('./lib/core/core');
},{"./lib/core/core":10}],10:[function(require,module,exports){
var isFactory = require('./../utils/object').isFactory;
var deepExtend = require('./../utils/object').deepExtend;
var typedFactory = require('./typed');
var emitter = require('./../utils/emitter');

var importFactory = require('./function/import');
var configFactory = require('./function/config');

/**
 * Math.js core. Creates a new, empty math.js instance
 * @param {Object} [options] Available options:
 *                            {number} epsilon
 *                              Minimum relative difference between two
 *                              compared values, used by all comparison functions.
 *                            {string} matrix
 *                              A string 'Matrix' (default) or 'Array'.
 *                            {string} number
 *                              A string 'number' (default), 'BigNumber', or 'Fraction'
 *                            {number} precision
 *                              The number of significant digits for BigNumbers.
 *                              Not applicable for Numbers.
 *                            {boolean} predictable
 *                              Predictable output type of functions. When true,
 *                              output type depends only on the input types. When
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-2)`
 *                              returns `NaN` when predictable is false, and
 *                              returns `complex('2i')` when true.
 * @returns {Object} Returns a bare-bone math.js instance containing
 *                   functions:
 *                   - `import` to add new functions
 *                   - `config` to change configuration
 *                   - `on`, `off`, `once`, `emit` for events
 */
exports.create = function create (options) {
  // simple test for ES5 support
  if (typeof Object.create !== 'function') {
    throw new Error('ES5 not supported by this JavaScript engine. ' +
    'Please load the es5-shim and es5-sham library for compatibility.');
  }

  // cached factories and instances
  var factories = [];
  var instances = [];

  // create a namespace for the mathjs instance, and attach emitter functions
  var math = emitter.mixin({});
  math.type = {};
  math.expression = {
    transform: Object.create(math)
  };
  math.algebra = {};

  // create a new typed instance
  math.typed = typedFactory.create(math.type);

  // create configuration options. These are private
  var _config = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,

    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: 'Matrix',

    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: 'number',

    // number of significant digits in BigNumbers
    precision: 64,

    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-2)` returns `NaN` when
    // predictable is false, and returns `complex('2i')` when true.
    predictable: false
  };

  /**
   * Load a function or data type from a factory.
   * If the function or data type already exists, the existing instance is
   * returned.
   * @param {{type: string, name: string, factory: Function}} factory
   * @returns {*}
   */
  function load (factory) {
    if (!isFactory(factory)) {
      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');
    }

    var index = factories.indexOf(factory);
    var instance;
    if (index === -1) {
      // doesn't yet exist
      if (factory.math === true) {
        // pass with math namespace
        instance = factory.factory(math.type, _config, load, math.typed, math);
      }
      else {
        instance = factory.factory(math.type, _config, load, math.typed);
      }

      // append to the cache
      factories.push(factory);
      instances.push(instance);
    }
    else {
      // already existing function, return the cached instance
      instance = instances[index];
    }

    return instance;
  }

  // load the import and config functions
  math['import'] = load(importFactory);
  math['config'] = load(configFactory);

  // apply options
  if (options) {
    math.config(options);
  }

  return math;
};

},{"./../utils/emitter":357,"./../utils/object":362,"./function/config":11,"./function/import":12,"./typed":13}],11:[function(require,module,exports){
'use strict';

var object = require('../../utils/object');

function factory (type, config, load, typed, math) {
  var MATRIX = ['Matrix', 'Array'];                   // valid values for option matrix
  var NUMBER = ['number', 'BigNumber', 'Fraction'];   // valid values for option number

  /**
   * Set configuration options for math.js, and get current options.
   * Will emit a 'config' event, with arguments (curr, prev).
   *
   * Syntax:
   *
   *     math.config(config: Object): Object
   *
   * Examples:
   *
   *     math.config().number;                // outputs 'number'
   *     math.eval('0.4');                    // outputs number 0.4
   *     math.config({number: 'Fraction'});
   *     math.eval('0.4');                    // outputs Fraction 2/5
   *
   * @param {Object} [options] Available options:
   *                            {number} epsilon
   *                              Minimum relative difference between two
   *                              compared values, used by all comparison functions.
   *                            {string} matrix
   *                              A string 'Matrix' (default) or 'Array'.
   *                            {string} number
   *                              A string 'number' (default), 'BigNumber', or 'Fraction'
   *                            {number} precision
   *                              The number of significant digits for BigNumbers.
   *                              Not applicable for Numbers.
   *                            {string} parenthesis
   *                              How to display parentheses in LaTeX and string
   *                              output.
   * @return {Object} Returns the current configuration
   */
  function _config(options) {
    if (options) {
      var prev = object.clone(config);

      // validate some of the options
      validateOption(options, 'matrix', MATRIX);
      validateOption(options, 'number', NUMBER);

      // merge options
      object.deepExtend(config, options);

      var curr = object.clone(config);

      // emit 'config' event
      math.emit('config', curr, prev);

      return curr;
    }
    else {
      return object.clone(config);
    }
  }

  // attach the valid options to the function so they can be extended
  _config.MATRIX = MATRIX;
  _config.NUMBER = NUMBER;

  return _config;
}

/**
 * Test whether an Array contains a specific item.
 * @param {Array.<string>} array
 * @param {string} item
 * @return {boolean}
 */
function contains (array, item) {
  return array.indexOf(item) !== -1;
}

/**
 * Find a string in an array. Case insensitive search
 * @param {Array.<string>} array
 * @param {string} item
 * @return {number} Returns the index when found. Returns -1 when not found
 */
function findIndex (array, item) {
  return array
      .map(function (i) {
        return i.toLowerCase();
      })
      .indexOf(item.toLowerCase());
}

/**
 * Validate an option
 * @param {Object} options         Object with options
 * @param {string} name            Name of the option to validate
 * @param {Array.<string>} values  Array with valid values for this option
 */
function validateOption(options, name, values) {
  if (options[name] !== undefined && !contains(values, options[name])) {
    var index = findIndex(values, options[name]);
    if (index !== -1) {
      // right value, wrong casing
      // TODO: lower case values are deprecated since v3, remove this warning some day.
      console.warn('Warning: Wrong casing for configuration option "' + name + '", should be "' + values[index] + '" instead of "' + options[name] + '".');

      options[name] = values[index]; // change the option to the right casing
    }
    else {
      // unknown value
      console.warn('Warning: Unknown value "' + options[name] + '" for configuration option "' + name + '". Available options: ' + values.map(JSON.stringify).join(', ') + '.');
    }
  }
}

exports.name = 'config';
exports.math = true; // request the math namespace as fifth argument
exports.factory = factory;

},{"../../utils/object":362}],12:[function(require,module,exports){
'use strict';

var lazy = require('../../utils/object').lazy;
var isFactory = require('../../utils/object').isFactory;
var traverse = require('../../utils/object').traverse;
var extend = require('../../utils/object').extend;
var ArgumentsError = require('../../error/ArgumentsError');

function factory (type, config, load, typed, math) {
  /**
   * Import functions from an object or a module
   *
   * Syntax:
   *
   *    math.import(object)
   *    math.import(object, options)
   *
   * Where:
   *
   * - `object: Object`
   *   An object with functions to be imported.
   * - `options: Object` An object with import options. Available options:
   *   - `override: boolean`
   *     If true, existing functions will be overwritten. False by default.
   *   - `silent: boolean`
   *     If true, the function will not throw errors on duplicates or invalid
   *     types. False by default.
   *   - `wrap: boolean`
   *     If true, the functions will be wrapped in a wrapper function
   *     which converts data types like Matrix to primitive data types like Array.
   *     The wrapper is needed when extending math.js with libraries which do not
   *     support these data type. False by default.
   *
   * Examples:
   *
   *    // define new functions and variables
   *    math.import({
   *      myvalue: 42,
   *      hello: function (name) {
   *        return 'hello, ' + name + '!';
   *      }
   *    });
   *
   *    // use the imported function and variable
   *    math.myvalue * 2;               // 84
   *    math.hello('user');             // 'hello, user!'
   *
   *    // import the npm module 'numbers'
   *    // (must be installed first with `npm install numbers`)
   *    math.import(require('numbers'), {wrap: true});
   *
   *    math.fibonacci(7); // returns 13
   *
   * @param {Object | Array} object   Object with functions to be imported.
   * @param {Object} [options]        Import options.
   */
  function math_import(object, options) {
    var num = arguments.length;
    if (num != 1 && num != 2) {
      throw new ArgumentsError('import', num, 1, 2);
    }

    if (!options) {
      options = {};
    }

    if (isFactory(object)) {
      _importFactory(object, options);
    }
    // TODO: allow a typed-function with name too
    else if (Array.isArray(object)) {
      object.forEach(function (entry) {
        math_import(entry, options);
      });
    }
    else if (typeof object === 'object') {
      // a map with functions
      for (var name in object) {
        if (object.hasOwnProperty(name)) {
          var value = object[name];
          if (isSupportedType(value)) {
            _import(name, value, options);
          }
          else if (isFactory(object)) {
            _importFactory(object, options);
          }
          else {
            math_import(value, options);
          }
        }
      }
    }
    else {
      if (!options.silent) {
        throw new TypeError('Factory, Object, or Array expected');
      }
    }
  }

  /**
   * Add a property to the math namespace and create a chain proxy for it.
   * @param {string} name
   * @param {*} value
   * @param {Object} options  See import for a description of the options
   * @private
   */
  function _import(name, value, options) {
    if (options.wrap && typeof value === 'function') {
      // create a wrapper around the function
      value = _wrap(value);
    }

    if (isTypedFunction(math[name]) && isTypedFunction(value)) {
      if (options.override) {
        // give the typed function the right name
        value = typed(name, value.signatures);
      }
      else {
        // merge the existing and typed function
        value = typed(math[name], value);
      }

      math[name] = value;
      _importTransform(name, value);
      math.emit('import', name, function resolver() {
        return value;
      });
      return;
    }

    if (math[name] === undefined || options.override) {
      math[name] = value;
      _importTransform(name, value);
      math.emit('import', name, function resolver() {
        return value;
      });
      return;
    }

    if (!options.silent) {
      throw new Error('Cannot import "' + name + '": already exists');
    }
  }

  function _importTransform (name, value) {
    if (value && typeof value.transform === 'function') {
      math.expression.transform[name] = value.transform;
    }
  }

  /**
   * Create a wrapper a round an function which converts the arguments
   * to their primitive values (like convert a Matrix to Array)
   * @param {Function} fn
   * @return {Function} Returns the wrapped function
   * @private
   */
  function _wrap (fn) {
    var wrapper = function wrapper () {
      var args = [];
      for (var i = 0, len = arguments.length; i < len; i++) {
        var arg = arguments[i];
        args[i] = arg && arg.valueOf();
      }
      return fn.apply(math, args);
    };

    if (fn.transform) {
      wrapper.transform = fn.transform;
    }

    return wrapper;
  }

  /**
   * Import an instance of a factory into math.js
   * @param {{factory: Function, name: string, path: string, math: boolean}} factory
   * @param {Object} options  See import for a description of the options
   * @private
   */
  function _importFactory(factory, options) {
    if (typeof factory.name === 'string') {
      var name = factory.name;
      var namespace = factory.path ? traverse(math, factory.path) : math;
      var existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;

      var resolver = function () {
        var instance = load(factory);
        if (instance && typeof instance.transform === 'function') {
          throw new Error('Transforms cannot be attached to factory functions. ' +
              'Please create a separate function for it with exports.path="expression.transform"');
        }

        if (isTypedFunction(existing) && isTypedFunction(instance)) {
          if (options.override) {
            // replace the existing typed function (nothing to do)
          }
          else {
            // merge the existing and new typed function
            instance = typed(existing, instance);
          }

          return instance;
        }

        if (existing === undefined || options.override) {
          return instance;
        }

        if (!options.silent) {
          throw new Error('Cannot import "' + name + '": already exists');
        }
      };

      if (factory.lazy !== false) {
        lazy(namespace, name, resolver);
      }
      else {
        namespace[name] = resolver();
      }

      math.emit('import', name, resolver, factory.path);
    }
    else {
      // unnamed factory.
      // no lazy loading
      load(factory);
    }
  }

  /**
   * Check whether given object is a type which can be imported
   * @param {Function | number | string | boolean | null | Unit | Complex} object
   * @return {boolean}
   * @private
   */
  function isSupportedType(object) {
    return typeof object == 'function'
        || typeof object === 'number'
        || typeof object === 'string'
        || typeof object === 'boolean'
        || object === null
        || (object && object.isUnit === true)
        || (object && object.isComplex === true)
        || (object && object.isBigNumber === true)
        || (object && object.isFraction === true)
        || (object && object.isMatrix === true)
        || (object && Array.isArray(object) === true)
  }

  /**
   * Test whether a given thing is a typed-function
   * @param {*} fn
   * @return {boolean} Returns true when `fn` is a typed-function
   */
  function isTypedFunction (fn) {
    return typeof fn === 'function' && typeof fn.signatures === 'object';
  }

  return math_import;
}

exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.name = 'import';
exports.factory = factory;
exports.lazy = true;

},{"../../error/ArgumentsError":14,"../../utils/object":362}],13:[function(require,module,exports){
var typedFunction = require('typed-function');
var digits = require('./../utils/number').digits;

// returns a new instance of typed-function
var createTyped = function () {
  // initially, return the original instance of typed-function
  // consecutively, return a new instance from typed.create.
  createTyped = typedFunction.create;
  return typedFunction;
};

/**
 * Factory function for creating a new typed instance
 * @param {Object} type   Object with data types like Complex and BigNumber
 * @returns {Function}
 */
exports.create = function create(type) {
  // TODO: typed-function must be able to silently ignore signatures with unknown data types

  // get a new instance of typed-function
  var typed = createTyped();

  // define all types. The order of the types determines in which order function
  // arguments are type-checked (so for performance it's important to put the
  // most used types first).
  typed.types = [
    { name: 'number',          test: function (x) { return typeof x === 'number' } },
    { name: 'Complex',         test: function (x) { return x && x.isComplex } },
    { name: 'BigNumber',       test: function (x) { return x && x.isBigNumber } },
    { name: 'Fraction',        test: function (x) { return x && x.isFraction } },
    { name: 'Unit',            test: function (x) { return x && x.isUnit } },
    { name: 'string',          test: function (x) { return typeof x === 'string' } },
    { name: 'Array',           test: Array.isArray },
    { name: 'Matrix',          test: function (x) { return x && x.isMatrix } },
    { name: 'DenseMatrix',     test: function (x) { return x && x.isDenseMatrix } },
    { name: 'SparseMatrix',    test: function (x) { return x && x.isSparseMatrix } },
    { name: 'Range',           test: function (x) { return x && x.isRange } },
    { name: 'Index',           test: function (x) { return x && x.isIndex } },
    { name: 'boolean',         test: function (x) { return typeof x === 'boolean' } },
    { name: 'ResultSet',       test: function (x) { return x && x.isResultSet } },
    { name: 'Help',            test: function (x) { return x && x.isHelp } },
    { name: 'function',        test: function (x) { return typeof x === 'function'} },
    { name: 'Date',            test: function (x) { return x instanceof Date } },
    { name: 'RegExp',          test: function (x) { return x instanceof RegExp } },
    { name: 'Object',          test: function (x) { return typeof x === 'object' } },
    { name: 'null',            test: function (x) { return x === null } },
    { name: 'undefined',       test: function (x) { return x === undefined } },
    
    { name: 'OperatorNode',    test: function (x) { return x && x.isOperatorNode } },
    { name: 'ConstantNode',    test: function (x) { return x && x.isConstantNode } },
    { name: 'SymbolNode',      test: function (x) { return x && x.isSymbolNode } },
    { name: 'ParenthesisNode', test: function (x) { return x && x.isParenthesisNode } },
    { name: 'FunctionNode',    test: function (x) { return x && x.isFunctionNode } },
    { name: 'FunctionAssignmentNode',    test: function (x) { return x && x.isFunctionAssignmentNode } },
    { name: 'ArrayNode',                 test: function (x) { return x && x.isArrayNode } },
    { name: 'AssignmentNode',            test: function (x) { return x && x.isAssignmentNode } },
    { name: 'BlockNode',                 test: function (x) { return x && x.isBlockNode } },
    { name: 'ConditionalNode',           test: function (x) { return x && x.isConditionalNode } },
    { name: 'IndexNode',                 test: function (x) { return x && x.isIndexNode } },
    { name: 'RangeNode',                 test: function (x) { return x && x.isRangeNode } },
    { name: 'UpdateNode',                test: function (x) { return x && x.isUpdateNode } },
    { name: 'Node',                      test: function (x) { return x && x.isNode } }
  ];

  // TODO: add conversion from BigNumber to number?
  typed.conversions = [
    {
      from: 'number',
      to: 'BigNumber',
      convert: function (x) {
        // note: conversion from number to BigNumber can fail if x has >15 digits
        if (digits(x) > 15) {
          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' +
          '(value: ' + x + '). ' +
          'Use function bignumber(x) to convert to BigNumber.');
        }
        return new type.BigNumber(x);
      }
    }, {
      from: 'number',
      to: 'Complex',
      convert: function (x) {
        return new type.Complex(x, 0);
      }
    }, {
      from: 'number',
      to: 'string',
      convert: function (x) {
        return x + '';
      }
    }, {
      from: 'BigNumber',
      to: 'Complex',
      convert: function (x) {
        return new type.Complex(x.toNumber(), 0);
      }
    }, {
      from: 'Fraction',
      to: 'BigNumber',
      convert: function (x) {
        throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
            'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
      }
    }, {
      from: 'Fraction',
      to: 'Complex',
      convert: function (x) {
        return new type.Complex(x.valueOf(), 0);
      }
    }, {
      from: 'number',
      to: 'Fraction',
      convert: function (x) {
        if (digits(x) > 15) {
          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to Fraction ' +
              '(value: ' + x + '). ' +
              'Use function fraction(x) to convert to Fraction.');
        }
        return new type.Fraction(x);
      }
    }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf();
    //  }
    //}, {
      from: 'string',
      to: 'number',
      convert: function (x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: 'boolean',
      to: 'number',
      convert: function (x) {
        return +x;
      }
    }, {
      from: 'boolean',
      to: 'BigNumber',
      convert: function (x) {
        return new type.BigNumber(+x);
      }
    }, {
      from: 'boolean',
      to: 'Fraction',
      convert: function (x) {
        return new type.Fraction(+x);
      }
    }, {
      from: 'boolean',
      to: 'string',
      convert: function (x) {
        return +x;
      }
    }, {
      from: 'null',
      to: 'number',
      convert: function () {
        return 0;
      }
    }, {
      from: 'null',
      to: 'string',
      convert: function () {
        return 'null';
      }
    }, {
      from: 'null',
      to: 'BigNumber',
      convert: function () {
        return new type.BigNumber(0);
      }
    }, {
      from: 'null',
      to: 'Fraction',
      convert: function () {
        return new type.Fraction(0);
      }
    }, {
      from: 'Array',
      to: 'Matrix',
      convert: function (array) {
        // TODO: how to decide on the right type of matrix to create?
        return new type.DenseMatrix(array);
      }
    }, {
      from: 'Matrix',
      to: 'Array',
      convert: function (matrix) {
        return matrix.valueOf();
      }
    }
  ];

  return typed;
};

},{"./../utils/number":361,"typed-function":367}],14:[function(require,module,exports){
'use strict';

/**
 * Create a syntax error with the message:
 *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'
 * @param {string} fn     Function name
 * @param {number} count  Actual argument count
 * @param {number} min    Minimum required argument count
 * @param {number} [max]  Maximum required argument count
 * @extends Error
 */
function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}

ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = 'ArgumentsError';
ArgumentsError.prototype.isArgumentsError = true;

module.exports = ArgumentsError;

},{}],15:[function(require,module,exports){
'use strict';

/**
 * Create a range error with the message:
 *     'Dimension mismatch (<actual size> != <expected size>)'
 * @param {number | number[]} actual        The actual size
 * @param {number | number[]} expected      The expected size
 * @param {string} [relation='!=']          Optional relation between actual
 *                                          and expected size: '!=', '<', etc.
 * @extends RangeError
 */
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}

DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = 'DimensionError';
DimensionError.prototype.isDimensionError = true;

module.exports = DimensionError;

},{}],16:[function(require,module,exports){
'use strict';

/**
 * Create a range error with the message:
 *     'Index out of range (index < min)'
 *     'Index out of range (index < max)'
 *
 * @param {number} index     The actual index
 * @param {number} [min=0]   Minimum index (included)
 * @param {number} [max]     Maximum index (excluded)
 * @extends RangeError
 */
function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined && this.index < this.min) {
    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
  }
  else if (this.max !== undefined && this.index >= this.max) {
    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}

IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = 'IndexError';
IndexError.prototype.isIndexError = true;

module.exports = IndexError;

},{}],17:[function(require,module,exports){
'use strict';

var object = require('../utils/object');
var string = require('../utils/string');

function factory (type, config, load, typed) {
  var parser = load(require('./function/parser'))();

  /**
   * Documentation object
   * @param {Object} doc  Object containing properties:
   *                      {string} name
   *                      {string} category
   *                      {string} description
   *                      {string[]} syntax
   *                      {string[]} examples
   *                      {string[]} seealso
   * @constructor
   */
  function Help(doc) {
    if (!(this instanceof Help)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (!doc)  throw new Error('Argument "doc" missing');

    this.doc = doc;
  }

  /**
   * Attach type information
   */
  Help.prototype.type = 'Help';
  Help.prototype.isHelp = true;

  /**
   * Generate a string representation of the Help object
   * @return {string} Returns a string
   * @private
   */
  Help.prototype.toString = function () {
    var doc = this.doc || {};
    var desc = '\n';

    if (doc.name) {
      desc += 'Name: ' + doc.name + '\n\n';
    }
    if (doc.category) {
      desc += 'Category: ' + doc.category + '\n\n';
    }
    if (doc.description) {
      desc += 'Description:\n    ' + doc.description + '\n\n';
    }
    if (doc.syntax) {
      desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
    }
    if (doc.examples) {
      desc += 'Examples:\n';
      for (var i = 0; i < doc.examples.length; i++) {
        var expr = doc.examples[i];
        desc += '    ' + expr + '\n';

        var res;
        try {
          res = parser.eval(expr);
        }
        catch (e) {
          res = e;
        }
        if (res && !res.isHelp) {
          desc += '        ' + string.format(res, {precision: 14}) + '\n';
        }
      }
      desc += '\n';
    }
    if (doc.seealso) {
      desc += 'See also: ' + doc.seealso.join(', ') + '\n';
    }

    return desc;
  };

  /**
   * Export the help object to JSON
   */
  Help.prototype.toJSON = function () {
    var obj = object.clone(this.doc);
    obj.mathjs = 'Help';
    return obj;
  };

  /**
   * Instantiate a Help object from a JSON object
   * @param {Object} json
   * @returns {Help} Returns a new Help object
   */
  Help.fromJSON = function (json) {
    var doc = {};
    for (var prop in json) {
      if (prop !== 'mathjs') { // ignore mathjs field
        doc[prop] = json[prop];
      }
    }
    return new Help(doc);
  };

  /**
   * Returns a string representation of the Help object
   */
  Help.prototype.valueOf = Help.prototype.toString;

  return Help;
}

exports.name = 'Help';
exports.path = 'type';
exports.factory = factory;

},{"../utils/object":362,"../utils/string":363,"./function/parser":205}],18:[function(require,module,exports){
'use strict';

var extend = require('../utils/object').extend;

function factory (type, config, load, typed, math) {
  var _parse = load(require('./parse'));

  /**
   * @constructor Parser
   * Parser contains methods to evaluate or parse expressions, and has a number
   * of convenience methods to get, set, and remove variables from memory. Parser
   * keeps a scope containing variables in memory, which is used for all
   * evaluations.
   *
   * Methods:
   *    var result = parser.eval(expr);    // evaluate an expression
   *    var value = parser.get(name);      // retrieve a variable from the parser
   *    var values = parser.getAll();      // retrieve all defined variables
   *    parser.set(name, value);           // set a variable in the parser
   *    parser.remove(name);               // clear a variable from the
   *                                       // parsers scope
   *    parser.clear();                    // clear the parsers scope
   *
   * Example usage:
   *    var parser = new Parser();
   *    // Note: there is a convenience method which can be used instead:
   *    // var parser = new math.parser();
   *
   *    // evaluate expressions
   *    parser.eval('sqrt(3^2 + 4^2)');         // 5
   *    parser.eval('sqrt(-4)');                // 2i
   *    parser.eval('2 inch in cm');            // 5.08 cm
   *    parser.eval('cos(45 deg)');             // 0.7071067811865476
   *
   *    // define variables and functions
   *    parser.eval('x = 7 / 2');               // 3.5
   *    parser.eval('x + 3');                   // 6.5
   *    parser.eval('function f(x, y) = x^y');  // f(x, y)
   *    parser.eval('f(2, 3)');                 // 8
   *
   *    // get and set variables and functions
   *    var x = parser.get('x');                // 7
   *    var f = parser.get('f');                // function
   *    var g = f(3, 2);                        // 9
   *    parser.set('h', 500);
   *    var i = parser.eval('h / 2');           // 250
   *    parser.set('hello', function (name) {
   *        return 'hello, ' + name + '!';
   *    });
   *    parser.eval('hello("user")');           // "hello, user!"
   *
   *    // clear defined functions and variables
   *    parser.clear();
   *
   */
  function Parser() {
    if (!(this instanceof Parser)) {
      throw new SyntaxError(
          'Constructor must be called with the new operator');
    }
    this.scope = {};
  }

  /**
   * Attach type information
   */
  Parser.prototype.type = 'Parser';
  Parser.prototype.isParser = true;

  /**
   * Parse an expression and return the parsed function node.
   * The node tree can be compiled via `code = node.compile(math)`,
   * and the compiled code can be executed as `code.eval([scope])`
   * @param {string} expr
   * @return {Node} node
   * @throws {Error}
   */
  Parser.prototype.parse = function (expr) {
    throw new Error('Parser.parse is deprecated. Use math.parse instead.');
  };

  /**
   * Parse and compile an expression, return the compiled javascript code.
   * The node can be evaluated via code.eval([scope])
   * @param {string} expr
   * @return {{eval: function}} code
   * @throws {Error}
   */
  Parser.prototype.compile = function (expr) {
    throw new Error('Parser.compile is deprecated. Use math.compile instead.');
  };

  /**
   * Parse and evaluate the given expression
   * @param {string} expr   A string containing an expression, for example "2+3"
   * @return {*} result     The result, or undefined when the expression was empty
   * @throws {Error}
   */
  Parser.prototype.eval = function (expr) {
    // TODO: validate arguments
    return _parse(expr)
        .compile()
        .eval(this.scope);
  };

  /**
   * Get a variable (a function or variable) by name from the parsers scope.
   * Returns undefined when not found
   * @param {string} name
   * @return {* | undefined} value
   */
  Parser.prototype.get = function (name) {
    // TODO: validate arguments
    return this.scope[name];
  };

  /**
   * Get a map with all defined variables
   * @return {Object} values
   */
  Parser.prototype.getAll = function () {
    return extend({}, this.scope);
  };

  /**
   * Set a symbol (a function or variable) by name from the parsers scope.
   * @param {string} name
   * @param {* | undefined} value
   */
  Parser.prototype.set = function (name, value) {
    // TODO: validate arguments
    return this.scope[name] = value;
  };

  /**
   * Remove a variable from the parsers scope
   * @param {string} name
   */
  Parser.prototype.remove = function (name) {
    // TODO: validate arguments
    delete this.scope[name];
  };

  /**
   * Clear the scope with variables and functions
   */
  Parser.prototype.clear = function () {
    for (var name in this.scope) {
      if (this.scope.hasOwnProperty(name)) {
        delete this.scope[name];
      }
    }
  };

  return Parser;
}

exports.name = 'Parser';
exports.path = 'expression';
exports.factory = factory;
exports.math = true; // requires the math namespace as 5th argument

},{"../utils/object":362,"./parse":228}],19:[function(require,module,exports){
module.exports = {
  'name': 'Infinity',
  'category': 'Constants',
  'syntax': [
    'Infinity'
  ],
  'description': 'Infinity, a number which is larger than the maximum number that can be handled by a floating point number.',
  'examples': [
    'Infinity',
    '1 / 0'
  ],
  'seealso': []
};

},{}],20:[function(require,module,exports){
module.exports = {
  'name': 'LN10',
  'category': 'Constants',
  'syntax': [
    'LN10'
  ],
  'description': 'Returns the natural logarithm of 10, approximately equal to 2.302',
  'examples': [
    'LN10',
    'log(10)'
  ],
  'seealso': []
};

},{}],21:[function(require,module,exports){
module.exports = {
  'name': 'LN2',
  'category': 'Constants',
  'syntax': [
    'LN2'
  ],
  'description': 'Returns the natural logarithm of 2, approximately equal to 0.693',
  'examples': [
    'LN2',
    'log(2)'
  ],
  'seealso': []
};

},{}],22:[function(require,module,exports){
module.exports = {
  'name': 'LOG10E',
  'category': 'Constants',
  'syntax': [
    'LOG10E'
  ],
  'description': 'Returns the base-10 logarithm of E, approximately equal to 0.434',
  'examples': [
    'LOG10E',
    'log(e, 10)'
  ],
  'seealso': []
};

},{}],23:[function(require,module,exports){
module.exports = {
  'name': 'LOG2E',
  'category': 'Constants',
  'syntax': [
    'LOG2E'
  ],
  'description': 'Returns the base-2 logarithm of E, approximately equal to 1.442',
  'examples': [
    'LOG2E',
    'log(e, 2)'
  ],
  'seealso': []
};

},{}],24:[function(require,module,exports){
module.exports = {
  'name': 'NaN',
  'category': 'Constants',
  'syntax': [
    'NaN'
  ],
  'description': 'Not a number',
  'examples': [
    'NaN',
    '0 / 0'
  ],
  'seealso': []
};

},{}],25:[function(require,module,exports){
module.exports = {
  'name': 'SQRT1_2',
  'category': 'Constants',
  'syntax': [
    'SQRT1_2'
  ],
  'description': 'Returns the square root of 1/2, approximately equal to 0.707',
  'examples': [
    'SQRT1_2',
    'sqrt(1/2)'
  ],
  'seealso': []
};

},{}],26:[function(require,module,exports){
module.exports = {
  'name': 'SQRT2',
  'category': 'Constants',
  'syntax': [
    'SQRT2'
  ],
  'description': 'Returns the square root of 2, approximately equal to 1.414',
  'examples': [
    'SQRT2',
    'sqrt(2)'
  ],
  'seealso': []
};

},{}],27:[function(require,module,exports){
module.exports = {
  'name': 'e',
  'category': 'Constants',
  'syntax': [
    'e'
  ],
  'description': 'Euler\'s number, the base of the natural logarithm. Approximately equal to 2.71828',
  'examples': [
    'e',
    'e ^ 2',
    'exp(2)',
    'log(e)'
  ],
  'seealso': ['exp']
};

},{}],28:[function(require,module,exports){
module.exports = {
  'name': 'false',
  'category': 'Constants',
  'syntax': [
    'false'
  ],
  'description': 'Boolean value false',
  'examples': [
    'false'
  ],
  'seealso': ['true']
};

},{}],29:[function(require,module,exports){
module.exports = {
  'name': 'i',
  'category': 'Constants',
  'syntax': [
    'i'
  ],
  'description': 'Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.',
  'examples': [
    'i',
    'i * i',
    'sqrt(-1)'
  ],
  'seealso': []
};

},{}],30:[function(require,module,exports){
module.exports = {
  'name': 'null',
  'category': 'Constants',
  'syntax': [
    'null'
  ],
  'description': 'Value null',
  'examples': [
    'null'
  ],
  'seealso': ['true', 'false']
};

},{}],31:[function(require,module,exports){
module.exports = {
  'name': 'phi',
  'category': 'Constants',
  'syntax': [
    'phi'
  ],
  'description': 'Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...',
  'examples': [
    'tau'
  ],
  'seealso': []
};

},{}],32:[function(require,module,exports){
module.exports = {
  'name': 'pi',
  'category': 'Constants',
  'syntax': [
    'pi'
  ],
  'description': 'The number pi is a mathematical constant that is the ratio of a circle\'s circumference to its diameter, and is approximately equal to 3.14159',
  'examples': [
    'pi',
    'sin(pi/2)'
  ],
  'seealso': ['tau']
};

},{}],33:[function(require,module,exports){
module.exports = {
  'name': 'tau',
  'category': 'Constants',
  'syntax': [
    'tau'
  ],
  'description': 'Tau is the ratio constant of a circle\'s circumference to radius, equal to 2 * pi, approximately 6.2832.',
  'examples': [
    'tau',
    '2 * pi'
  ],
  'seealso': ['pi']
};

},{}],34:[function(require,module,exports){
module.exports = {
  'name': 'true',
  'category': 'Constants',
  'syntax': [
    'true'
  ],
  'description': 'Boolean value true',
  'examples': [
    'true'
  ],
  'seealso': ['false']
};

},{}],35:[function(require,module,exports){
module.exports = {
  'name': 'version',
  'category': 'Constants',
  'syntax': [
    'version'
  ],
  'description': 'A string with the version number of math.js',
  'examples': [
    'version'
  ],
  'seealso': []
};

},{}],36:[function(require,module,exports){
module.exports = {
  'name': 'bignumber',
  'category': 'Construction',
  'syntax': [
    'bignumber(x)'
  ],
  'description':
      'Create a big number from a number or string.',
  'examples': [
    '0.1 + 0.2',
    'bignumber(0.1) + bignumber(0.2)',
    'bignumber("7.2")',
    'bignumber("7.2e500")',
    'bignumber([0.1, 0.2, 0.3])'
  ],
  'seealso': [
    'boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],37:[function(require,module,exports){
module.exports = {
  'name': 'boolean',
  'category': 'Construction',
  'syntax': [
    'x',
    'boolean(x)'
  ],
  'description':
      'Convert a string or number into a boolean.',
  'examples': [
    'boolean(0)',
    'boolean(1)',
    'boolean(3)',
    'boolean("true")',
    'boolean("false")',
    'boolean([1, 0, 1, 1])'
  ],
  'seealso': [
    'bignumber', 'complex', 'index', 'matrix', 'number', 'string', 'unit'
  ]
};

},{}],38:[function(require,module,exports){
module.exports = {
  'name': 'complex',
  'category': 'Construction',
  'syntax': [
    'complex()',
    'complex(re, im)',
    'complex(string)'
  ],
  'description':
      'Create a complex number.',
  'examples': [
    'complex()',
    'complex(2, 3)',
    'complex("7 - 2i")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'index', 'matrix', 'number', 'string', 'unit'
  ]
};

},{}],39:[function(require,module,exports){
module.exports = {
  'name': 'createUnit',
  'category': 'Construction',
  'syntax': [
    'createUnit(definitions)',
    'createUnit(name, definition)'
  ],
  'description':
      'Create a user-defined unit and register it with the Unit type.',
  'examples': [
    'createUnit("foo")',
    'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})',
    'createUnit("mph", "1 mile/hour")'
  ],
  'seealso': [
    'unit', 'splitUnit'
  ]
};

},{}],40:[function(require,module,exports){
module.exports = {
  'name': 'fraction',
  'category': 'Construction',
  'syntax': [
    'fraction(num)',
    'fraction(num,den)'
  ],
  'description':
    'Create a fraction from a number or from a numerator and denominator.',
  'examples': [
    'fraction(0.125)',
    'fraction(1, 3) + fraction(2, 5)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],41:[function(require,module,exports){
module.exports = {
  'name': 'index',
  'category': 'Construction',
  'syntax': [
    '[start]',
    '[start:end]',
    '[start:step:end]',
    '[start1, start 2, ...]',
    '[start1:end1, start2:end2, ...]',
    '[start1:step1:end1, start2:step2:end2, ...]'
  ],
  'description':
      'Create an index to get or replace a subset of a matrix',
  'examples': [
    '[]',
    '[1, 2, 3]',
    'A = [1, 2, 3; 4, 5, 6]',
    'A[1, :]',
    'A[1, 2] = 50',
    'A[0:2, 0:2] = ones(2, 2)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'matrix,', 'number', 'range', 'string', 'unit'
  ]
};

},{}],42:[function(require,module,exports){
module.exports = {
  'name': 'matrix',
  'category': 'Construction',
  'syntax': [
    '[]',
    '[a1, b1, ...; a2, b2, ...]',
    'matrix()',
    'matrix("dense")',
    'matrix([...])'
  ],
  'description':
      'Create a matrix.',
  'examples': [
    '[]',
    '[1, 2, 3]',
    '[1, 2, 3; 4, 5, 6]',
    'matrix()',
    'matrix([3, 4])',
    'matrix([3, 4; 5, 6], "sparse")',
    'matrix([3, 4; 5, 6], "sparse", "number")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'sparse'
  ]
};

},{}],43:[function(require,module,exports){
module.exports = {
  'name': 'number',
  'category': 'Construction',
  'syntax': [
    'x',
    'number(x)'
  ],
  'description':
      'Create a number or convert a string or boolean into a number.',
  'examples': [
    '2',
    '2e3',
    '4.05',
    'number(2)',
    'number("7.2")',
    'number(true)',
    'number([true, false, true, true])',
    'number("52cm", "m")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'fraction', 'index', 'matrix', 'string', 'unit'
  ]
};

},{}],44:[function(require,module,exports){
module.exports = {
  'name': 'sparse',
  'category': 'Construction',
  'syntax': [
    'sparse()',
    'sparse([a1, b1, ...; a1, b2, ...])',
    'sparse([a1, b1, ...; a1, b2, ...], "number")'
  ],
  'description':
  'Create a sparse matrix.',
  'examples': [
    'sparse()',
    'sparse([3, 4; 5, 6])',
    'sparse([3, 0; 5, 0], "number")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'number', 'string', 'unit', 'matrix'
  ]
};

},{}],45:[function(require,module,exports){
module.exports = {
  'name': 'splitUnit',
  'category': 'Construction',
  'syntax': [
    'splitUnit(unit: Unit, parts: Unit[])'
  ],
  'description':
      'Split a unit in an array of units whose sum is equal to the original unit.',
  'examples': [
    'splitUnit(1 m, ["feet", "inch"])'
  ],
  'seealso': [
    'unit', 'createUnit'
  ]
};

},{}],46:[function(require,module,exports){
module.exports = {
  'name': 'string',
  'category': 'Construction',
  'syntax': [
    '"text"',
    'string(x)'
  ],
  'description':
      'Create a string or convert a value to a string',
  'examples': [
    '"Hello World!"',
    'string(4.2)',
    'string(3 + 2i)'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'unit'
  ]
};

},{}],47:[function(require,module,exports){
module.exports = {
  'name': 'unit',
  'category': 'Construction',
  'syntax': [
    'value unit',
    'unit(value, unit)',
    'unit(string)'
  ],
  'description':
      'Create a unit.',
  'examples': [
    '5.5 mm',
    '3 inch',
    'unit(7.1, "kilogram")',
    'unit("23 deg")'
  ],
  'seealso': [
    'bignumber', 'boolean', 'complex', 'index', 'matrix', 'number', 'string'
  ]
};

},{}],48:[function(require,module,exports){
module.exports = {
  'name': 'config',
  'category': 'Core',
  'syntax': [
    'config()',
    'config(options)'
  ],
  'description': 'Get configuration or change configuration.',
  'examples': [
    'config()',
    '1/3 + 1/4',
    'config({number: "Fraction"})',
    '1/3 + 1/4'
  ],
  'seealso': []
};

},{}],49:[function(require,module,exports){
module.exports = {
  'name': 'import',
  'category': 'Core',
  'syntax': [
    'import(functions)',
    'import(functions, options)'
  ],
  'description': 'Import functions or constants from an object.',
  'examples': [
    'import({myFn: f(x)=x^2, myConstant: 32 })',
    'myFn(2)',
    'myConstant'
  ],
  'seealso': []
};

},{}],50:[function(require,module,exports){
module.exports = {
  'name': 'typed',
  'category': 'Core',
  'syntax': [
    'typed(signatures)',
    'typed(name, signatures)'
  ],
  'description': 'Create a typed function.',
  'examples': [
    'double = typed({ "number, number": f(x)=x+x })',
    'double(2)',
    'double("hello")'
  ],
  'seealso': []
};

},{}],51:[function(require,module,exports){
module.exports = {
  'name': 'derivative',
  'category': 'Algebra',
  'syntax': [
    'derivative(expr)',
    'derivative(expr, {simplify: boolean})'
  ],
  'description': 'Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.',
  'examples': [
    'derivative("2x^3", "x")',
    'derivative("2x^3", "x", {simplify: false})',
    'derivative("2x^2 + 3x + 4", "x")',
    'derivative("sin(2x)", "x")',
    'f = parse("x^2 + x")',
    'x = parse("x")',
    'df = derivative(f, x)',
    'df.eval({x: 3})'
  ],
  'seealso': [
    'simplify', 'parse', 'eval'
  ]
};

},{}],52:[function(require,module,exports){
module.exports = {
  'name': 'lsolve',
  'category': 'Algebra',
  'syntax': [
    'x=lsolve(L, b)'
  ],
  'description':
  'Solves the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.',
  'examples': [
    'a = [-2, 3; 2, 1]',
    'b = [11, 9]',
    'x = lsolve(a, b)'
  ],
  'seealso': [
    'lup', 'lusolve', 'usolve', 'matrix', 'sparse'
  ]
};

},{}],53:[function(require,module,exports){
module.exports = {
  'name': 'lup',
  'category': 'Algebra',
  'syntax': [
    'lup(m)'
  ],
  'description':
  'Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U',
  'examples': [
    'lup([[2, 1], [1, 4]])',
    'lup(matrix([[2, 1], [1, 4]]))',
    'lup(sparse([[2, 1], [1, 4]]))'
  ],
  'seealso': [
    'lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'slu'
  ]
};

},{}],54:[function(require,module,exports){
module.exports = {
  'name': 'lusolve',
  'category': 'Algebra',
  'syntax': [
    'x=lusolve(A, b)',
    'x=lusolve(lu, b)'
  ],
  'description': 'Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.',
  'examples': [
    'a = [-2, 3; 2, 1]',
    'b = [11, 9]',
    'x = lusolve(a, b)'
  ],
  'seealso': [
    'lup', 'slu', 'lsolve', 'usolve', 'matrix', 'sparse'
  ]
};

},{}],55:[function(require,module,exports){
module.exports = {
  'name': 'simplify',
  'category': 'Algebra',
  'syntax': [
    'simplify(expr)',
    'simplify(expr, rules)'
  ],
  'description': 'Simplify an expression tree.',
  'examples': [
    'simplify("3 + 2 / 4")',
    'simplify("2x + x")',
    'f = parse("x * (x + 2 + x)")',
    'simplified = simplify(f)',
    'simplified.eval({x: 2})'
  ],
  'seealso': [
    'derivative', 'parse', 'eval'
  ]
};

},{}],56:[function(require,module,exports){
module.exports = {
  'name': 'slu',
  'category': 'Algebra',
  'syntax': [
    'slu(A, order, threshold)'
  ],
  'description': 'Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U',
  'examples': [
    'slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)'
  ],
  'seealso': [
    'lusolve', 'lsolve', 'usolve', 'matrix', 'sparse', 'lup'
  ]
};

},{}],57:[function(require,module,exports){
module.exports = {
  'name': 'usolve',
  'category': 'Algebra',
  'syntax': [
    'x=usolve(U, b)'
  ],
  'description':
  'Solves the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.',
  'examples': [
    'x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])'
  ],
  'seealso': [
    'lup', 'lusolve', 'lsolve', 'matrix', 'sparse'
  ]
};

},{}],58:[function(require,module,exports){
module.exports = {
  'name': 'abs',
  'category': 'Arithmetic',
  'syntax': [
    'abs(x)'
  ],
  'description': 'Compute the absolute value.',
  'examples': [
    'abs(3.5)',
    'abs(-4.2)'
  ],
  'seealso': ['sign']
};

},{}],59:[function(require,module,exports){
module.exports = {
  'name': 'add',
  'category': 'Operators',
  'syntax': [
    'x + y',
    'add(x, y)'
  ],
  'description': 'Add two values.',
  'examples': [
    'a = 2.1 + 3.6',
    'a - 3.6',
    '3 + 2i',
    '3 cm + 2 inch',
    '"2.3" + "4"'
  ],
  'seealso': [
    'subtract'
  ]
};

},{}],60:[function(require,module,exports){
module.exports = {
  'name': 'cbrt',
  'category': 'Arithmetic',
  'syntax': [
    'cbrt(x)',
    'cbrt(x, allRoots)'
  ],
  'description':
      'Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned',
  'examples': [
    'cbrt(64)',
    'cube(4)',
    'cbrt(-8)',
    'cbrt(2 + 3i)',
    'cbrt(8i)',
    'cbrt(8i, true)',
    'cbrt(27 m^3)'
  ],
  'seealso': [
    'square',
    'sqrt',
    'cube',
    'multiply'
  ]
};

},{}],61:[function(require,module,exports){
module.exports = {
  'name': 'ceil',
  'category': 'Arithmetic',
  'syntax': [
    'ceil(x)'
  ],
  'description':
      'Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.',
  'examples': [
    'ceil(3.2)',
    'ceil(3.8)',
    'ceil(-4.2)'
  ],
  'seealso': ['floor', 'fix', 'round']
};

},{}],62:[function(require,module,exports){
module.exports = {
  'name': 'cube',
  'category': 'Arithmetic',
  'syntax': [
    'cube(x)'
  ],
  'description': 'Compute the cube of a value. The cube of x is x * x * x.',
  'examples': [
    'cube(2)',
    '2^3',
    '2 * 2 * 2'
  ],
  'seealso': [
    'multiply',
    'square',
    'pow'
  ]
};

},{}],63:[function(require,module,exports){
module.exports = {
  'name': 'divide',
  'category': 'Operators',
  'syntax': [
    'x / y',
    'divide(x, y)'
  ],
  'description': 'Divide two values.',
  'examples': [
    'a = 2 / 3',
    'a * 3',
    '4.5 / 2',
    '3 + 4 / 2',
    '(3 + 4) / 2',
    '18 km / 4.5'
  ],
  'seealso': [
    'multiply'
  ]
};

},{}],64:[function(require,module,exports){
module.exports = {
  'name': 'dotDivide',
  'category': 'Operators',
  'syntax': [
    'x ./ y',
    'dotDivide(x, y)'
  ],
  'description': 'Divide two values element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'b = [2, 1, 1; 3, 2, 5]',
    'a ./ b'
  ],
  'seealso': [
    'multiply',
    'dotMultiply',
    'divide'
  ]
};

},{}],65:[function(require,module,exports){
module.exports = {
  'name': 'dotMultiply',
  'category': 'Operators',
  'syntax': [
    'x .* y',
    'dotMultiply(x, y)'
  ],
  'description': 'Multiply two values element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'b = [2, 1, 1; 3, 2, 5]',
    'a .* b'
  ],
  'seealso': [
    'multiply',
    'divide',
    'dotDivide'
  ]
};

},{}],66:[function(require,module,exports){
module.exports = {
  'name': 'dotpow',
  'category': 'Operators',
  'syntax': [
    'x .^ y',
    'dotpow(x, y)'
  ],
  'description':
      'Calculates the power of x to y element wise.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'a .^ 2'
  ],
  'seealso': [
    'pow'
  ]
};

},{}],67:[function(require,module,exports){
module.exports = {
  'name': 'exp',
  'category': 'Arithmetic',
  'syntax': [
    'exp(x)'
  ],
  'description': 'Calculate the exponent of a value.',
  'examples': [
    'exp(1.3)',
    'e ^ 1.3',
    'log(exp(1.3))',
    'x = 2.4',
    '(exp(i*x) == cos(x) + i*sin(x))   # Euler\'s formula'
  ],
  'seealso': [
    'pow',
    'log'
  ]
};

},{}],68:[function(require,module,exports){
module.exports = {
  'name': 'fix',
  'category': 'Arithmetic',
  'syntax': [
    'fix(x)'
  ],
  'description':
      'Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.',
  'examples': [
    'fix(3.2)',
    'fix(3.8)',
    'fix(-4.2)',
    'fix(-4.8)'
  ],
  'seealso': ['ceil', 'floor', 'round']
};

},{}],69:[function(require,module,exports){
module.exports = {
  'name': 'floor',
  'category': 'Arithmetic',
  'syntax': [
    'floor(x)'
  ],
  'description':
      'Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.',
  'examples': [
    'floor(3.2)',
    'floor(3.8)',
    'floor(-4.2)'
  ],
  'seealso': ['ceil', 'fix', 'round']
};

},{}],70:[function(require,module,exports){
module.exports = {
  'name': 'gcd',
  'category': 'Arithmetic',
  'syntax': [
    'gcd(a, b)',
    'gcd(a, b, c, ...)'
  ],
  'description': 'Compute the greatest common divisor.',
  'examples': [
    'gcd(8, 12)',
    'gcd(-4, 6)',
    'gcd(25, 15, -10)'
  ],
  'seealso': [ 'lcm', 'xgcd' ]
};

},{}],71:[function(require,module,exports){
module.exports = {
  'name': 'hypot',
  'category': 'Arithmetic',
  'syntax': [
    'hypot(a, b, c, ...)',
    'hypot([a, b, c, ...])'
  ],
  'description': 'Calculate the hypotenusa of a list with values. ',
  'examples': [
    'hypot(3, 4)',
    'sqrt(3^2 + 4^2)',
    'hypot(-2)',
    'hypot([3, 4, 5])'
  ],
  'seealso': [ 'abs', 'norm' ]
};

},{}],72:[function(require,module,exports){
module.exports = {
  'name': 'lcm',
  'category': 'Arithmetic',
  'syntax': [
    'lcm(x, y)'
  ],
  'description': 'Compute the least common multiple.',
  'examples': [
    'lcm(4, 6)',
    'lcm(6, 21)',
    'lcm(6, 21, 5)'
  ],
  'seealso': [ 'gcd' ]
};

},{}],73:[function(require,module,exports){
module.exports = {
  'name': 'log',
  'category': 'Arithmetic',
  'syntax': [
    'log(x)',
    'log(x, base)'
  ],
  'description': 'Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).',
  'examples': [
    'log(3.5)',
    'a = log(2.4)',
    'exp(a)',
    '10 ^ 4',
    'log(10000, 10)',
    'log(10000) / log(10)',
    'b = log(1024, 2)',
    '2 ^ b'
  ],
  'seealso': [
    'exp',
    'log10'
  ]
};
},{}],74:[function(require,module,exports){
module.exports = {
  'name': 'log10',
  'category': 'Arithmetic',
  'syntax': [
    'log10(x)'
  ],
  'description': 'Compute the 10-base logarithm of a value.',
  'examples': [
    'log10(0.00001)',
    'log10(10000)',
    '10 ^ 4',
    'log(10000) / log(10)',
    'log(10000, 10)'
  ],
  'seealso': [
    'exp',
    'log'
  ]
};

},{}],75:[function(require,module,exports){
module.exports = {
  'name': 'mod',
  'category': 'Operators',
  'syntax': [
    'x % y',
    'x mod y',
    'mod(x, y)'
  ],
  'description':
      'Calculates the modulus, the remainder of an integer division.',
  'examples': [
    '7 % 3',
    '11 % 2',
    '10 mod 4',
    'function isOdd(x) = x % 2',
    'isOdd(2)',
    'isOdd(3)'
  ],
  'seealso': ['divide']
};

},{}],76:[function(require,module,exports){
module.exports = {
  'name': 'multiply',
  'category': 'Operators',
  'syntax': [
    'x * y',
    'multiply(x, y)'
  ],
  'description': 'multiply two values.',
  'examples': [
    'a = 2.1 * 3.4',
    'a / 3.4',
    '2 * 3 + 4',
    '2 * (3 + 4)',
    '3 * 2.1 km'
  ],
  'seealso': [
    'divide'
  ]
};

},{}],77:[function(require,module,exports){
module.exports = {
  'name': 'norm',
  'category': 'Arithmetic',
  'syntax': [
    'norm(x)',
    'norm(x, p)'
  ],
  'description': 'Calculate the norm of a number, vector or matrix.',
  'examples': [
    'abs(-3.5)',
    'norm(-3.5)',
    'norm(3 - 4i))',
    'norm([1, 2, -3], Infinity)',
    'norm([1, 2, -3], -Infinity)',
    'norm([3, 4], 2)',
    'norm([[1, 2], [3, 4]], 1)',
    'norm([[1, 2], [3, 4]], \'inf\')',
    'norm([[1, 2], [3, 4]], \'fro\')'
  ]
};

},{}],78:[function(require,module,exports){
module.exports = {
  'name': 'nthRoot',
  'category': 'Arithmetic',
  'syntax': [
    'nthRoot(a)',
    'nthRoot(a, root)'
  ],
  'description': 'Calculate the nth root of a value. ' +
      'The principal nth root of a positive real number A, ' +
      'is the positive real solution of the equation "x^root = A".',
  'examples': [
    '4 ^ 3',
    'nthRoot(64, 3)',
    'nthRoot(9, 2)',
    'sqrt(9)'
  ],
  'seealso': [
    'sqrt',
    'pow'
  ]
};
},{}],79:[function(require,module,exports){
module.exports = {
  'name': 'pow',
  'category': 'Operators',
  'syntax': [
    'x ^ y',
    'pow(x, y)'
  ],
  'description':
      'Calculates the power of x to y, x^y.',
  'examples': [
    '2^3 = 8',
    '2*2*2',
    '1 + e ^ (pi * i)'
  ],
  'seealso': [ 'multiply' ]
};

},{}],80:[function(require,module,exports){
module.exports = {
  'name': 'round',
  'category': 'Arithmetic',
  'syntax': [
    'round(x)',
    'round(x, n)'
  ],
  'description':
      'round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.',
  'examples': [
    'round(3.2)',
    'round(3.8)',
    'round(-4.2)',
    'round(-4.8)',
    'round(pi, 3)',
    'round(123.45678, 2)'
  ],
  'seealso': ['ceil', 'floor', 'fix']
};

},{}],81:[function(require,module,exports){
module.exports = {
  'name': 'sign',
  'category': 'Arithmetic',
  'syntax': [
    'sign(x)'
  ],
  'description':
      'Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.',
  'examples': [
    'sign(3.5)',
    'sign(-4.2)',
    'sign(0)'
  ],
  'seealso': [
    'abs'
  ]
};

},{}],82:[function(require,module,exports){
module.exports = {
  'name': 'sqrt',
  'category': 'Arithmetic',
  'syntax': [
    'sqrt(x)'
  ],
  'description':
      'Compute the square root value. If x = y * y, then y is the square root of x.',
  'examples': [
    'sqrt(25)',
    '5 * 5',
    'sqrt(-1)'
  ],
  'seealso': [
    'square',
    'multiply'
  ]
};

},{}],83:[function(require,module,exports){
module.exports = {
  'name': 'square',
  'category': 'Arithmetic',
  'syntax': [
    'square(x)'
  ],
  'description':
      'Compute the square of a value. The square of x is x * x.',
  'examples': [
    'square(3)',
    'sqrt(9)',
    '3^2',
    '3 * 3'
  ],
  'seealso': [
    'multiply',
    'pow',
    'sqrt',
    'cube'
  ]
};

},{}],84:[function(require,module,exports){
module.exports = {
  'name': 'subtract',
  'category': 'Operators',
  'syntax': [
    'x - y',
    'subtract(x, y)'
  ],
  'description': 'subtract two values.',
  'examples': [
    'a = 5.3 - 2',
    'a + 2',
    '2/3 - 1/6',
    '2 * 3 - 3',
    '2.1 km - 500m'
  ],
  'seealso': [
    'add'
  ]
};

},{}],85:[function(require,module,exports){
module.exports = {
  'name': 'unaryMinus',
  'category': 'Operators',
  'syntax': [
    '-x',
    'unaryMinus(x)'
  ],
  'description':
      'Inverse the sign of a value. Converts booleans and strings to numbers.',
  'examples': [
    '-4.5',
    '-(-5.6)',
    '-"22"'
  ],
  'seealso': [
    'add', 'subtract', 'unaryPlus'
  ]
};

},{}],86:[function(require,module,exports){
module.exports = {
  'name': 'unaryPlus',
  'category': 'Operators',
  'syntax': [
    '+x',
    'unaryPlus(x)'
  ],
  'description':
      'Converts booleans and strings to numbers.',
  'examples': [
    '+true',
    '+"2"'
  ],
  'seealso': [
    'add', 'subtract', 'unaryMinus'
  ]
};

},{}],87:[function(require,module,exports){
module.exports = {
  'name': 'xgcd',
  'category': 'Arithmetic',
  'syntax': [
    'xgcd(a, b)'
  ],
  'description': 'Calculate the extended greatest common divisor for two values',
  'examples': [
    'xgcd(8, 12)',
    'gcd(8, 12)',
    'xgcd(36163, 21199)'
  ],
  'seealso': [ 'gcd', 'lcm' ]
};

},{}],88:[function(require,module,exports){
module.exports = {
  'name': 'bitAnd',
  'category': 'Bitwise',
  'syntax': [
    'x & y',
    'bitAnd(x, y)'
  ],
  'description': 'Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0',
  'examples': [
    '5 & 3',
    'bitAnd(53, 131)',
    '[1, 12, 31] & 42'
  ],
  'seealso': [
    'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],89:[function(require,module,exports){
module.exports = {
  'name': 'bitNot',
  'category': 'Bitwise',
  'syntax': [
    '~x',
    'bitNot(x)'
  ],
  'description': 'Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.',
  'examples': [
    '~1',
    '~2',
    'bitNot([2, -3, 4])'
  ],
  'seealso': [
    'bitAnd', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],90:[function(require,module,exports){
module.exports = {
  'name': 'bitOr',
  'category': 'Bitwise',
  'syntax': [
    'x | y',
    'bitOr(x, y)'
  ],
  'description': 'Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.',
  'examples': [
    '5 | 3',
    'bitOr([1, 2, 3], 4)'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitXor', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],91:[function(require,module,exports){
module.exports = {
  'name': 'bitXor',
  'category': 'Bitwise',
  'syntax': [
    'bitXor(x, y)'
  ],
  'description': 'Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.',
  'examples': [
    'bitOr(1, 2)',
    'bitXor([2, 3, 4], 4)'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'leftShift', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],92:[function(require,module,exports){
module.exports = {
  'name': 'leftShift',
  'category': 'Bitwise',
  'syntax': [
    'x << y',
    'leftShift(x, y)'
  ],
  'description': 'Bitwise left logical shift of a value x by y number of bits.',
  'examples': [
    '4 << 1',
    '8 >> 1'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'bitXor', 'rightArithShift', 'rightLogShift'
  ]
};

},{}],93:[function(require,module,exports){
module.exports = {
  'name': 'rightArithShift',
  'category': 'Bitwise',
  'syntax': [
    'x >> y',
    'leftShift(x, y)'
  ],
  'description': 'Bitwise right arithmetic shift of a value x by y number of bits.',
  'examples': [
    '8 >> 1',
    '4 << 1',
    '-12 >> 2'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightLogShift'
  ]
};

},{}],94:[function(require,module,exports){
module.exports = {
  'name': 'rightLogShift',
  'category': 'Bitwise',
  'syntax': [
    'x >> y',
    'leftShift(x, y)'
  ],
  'description': 'Bitwise right logical shift of a value x by y number of bits.',
  'examples': [
    '8 >>> 1',
    '4 << 1',
    '-12 >>> 2'
  ],
  'seealso': [
    'bitAnd', 'bitNot', 'bitOr', 'bitXor', 'leftShift', 'rightArithShift'
  ]
};

},{}],95:[function(require,module,exports){
module.exports = {
  'name': 'bellNumbers',
  'category': 'Combinatorics',
  'syntax': [
    'bellNumbers(n)'
  ],
  'description': 'The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.',
  'examples': [
    'bellNumbers(3)',
    'bellNumbers(8)'
  ],
  'seealso': ['stirlingS2']
};
},{}],96:[function(require,module,exports){
module.exports = {
  'name': 'catalan',
  'category': 'Combinatorics',
  'syntax': [
    'catalan(n)'
  ],
  'description': 'The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.',
  'examples': [
    'catalan(3)',
    'catalan(8)'
  ],
  'seealso': ['bellNumbers']
};
},{}],97:[function(require,module,exports){
module.exports = {
  'name': 'composition',
  'category': 'Combinatorics',
  'syntax': [
    'composition(n, k)'
  ],
  'description': 'The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.',
  'examples': [
    'composition(5, 3)'
  ],
  'seealso': ['combinations']
};
},{}],98:[function(require,module,exports){
module.exports = {
  'name': 'stirlingS2',
  'category': 'Combinatorics',
  'syntax': [
    'stirlingS2(n, k)'
  ],
  'description': 'he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.',
  'examples': [
    'stirlingS2(5, 3)'
  ],
  'seealso': ['bellNumbers']
};

},{}],99:[function(require,module,exports){
module.exports = {
  'name': 'arg',
  'category': 'Complex',
  'syntax': [
    'arg(x)'
  ],
  'description':
      'Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).',
  'examples': [
    'arg(2 + 2i)',
    'atan2(3, 2)',
    'arg(2 + 3i)'
  ],
  'seealso': [
    're',
    'im',
    'conj',
    'abs'
  ]
};

},{}],100:[function(require,module,exports){
module.exports = {
  'name': 'conj',
  'category': 'Complex',
  'syntax': [
    'conj(x)'
  ],
  'description':
      'Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.',
  'examples': [
    'conj(2 + 3i)',
    'conj(2 - 3i)',
    'conj(-5.2i)'
  ],
  'seealso': [
    're',
    'im',
    'abs',
    'arg'
  ]
};

},{}],101:[function(require,module,exports){
module.exports = {
  'name': 'im',
  'category': 'Complex',
  'syntax': [
    'im(x)'
  ],
  'description': 'Get the imaginary part of a complex number.',
  'examples': [
    'im(2 + 3i)',
    're(2 + 3i)',
    'im(-5.2i)',
    'im(2.4)'
  ],
  'seealso': [
    're',
    'conj',
    'abs',
    'arg'
  ]
};

},{}],102:[function(require,module,exports){
module.exports = {
  'name': 're',
  'category': 'Complex',
  'syntax': [
    're(x)'
  ],
  'description': 'Get the real part of a complex number.',
  'examples': [
    're(2 + 3i)',
    'im(2 + 3i)',
    're(-5.2i)',
    're(2.4)'
  ],
  'seealso': [
    'im',
    'conj',
    'abs',
    'arg'
  ]
};

},{}],103:[function(require,module,exports){
module.exports = {
  'name': 'eval',
  'category': 'Expression',
  'syntax': [
    'eval(expression)',
    'eval([expr1, expr2, expr3, ...])'
  ],
  'description': 'Evaluate an expression or an array with expressions.',
  'examples': [
    'eval("2 + 3")',
    'eval("sqrt(" + 4 + ")")'
  ],
  'seealso': []
};

},{}],104:[function(require,module,exports){
module.exports = {
  'name': 'help',
  'category': 'Expression',
  'syntax': [
    'help(object)',
    'help(string)'
  ],
  'description': 'Display documentation on a function or data type.',
  'examples': [
    'help(sqrt)',
    'help("complex")'
  ],
  'seealso': []
};

},{}],105:[function(require,module,exports){
module.exports = {
  'name': 'distance',
  'category': 'Geometry',
  'syntax': [
    'distance([x1, y1], [x2, y2])',
    'distance([[x1, y1], [x2, y2])'
  ],
  'description': 'Calculates the Euclidean distance between two points.',
  'examples': [
    'distance([0,0], [4,4])',
    'distance([[0,0], [4,4]])'
  ],
  'seealso': []
};

},{}],106:[function(require,module,exports){
module.exports = {
  'name': 'intersect',
  'category': 'Geometry',
  'syntax': [
    'intersect(expr1, expr2, expr3, expr4)',
    'intersect(expr1, expr2, expr3)'
  ],
  'description': 'Computes the intersection point of lines and/or planes.',
  'examples': [
    'intersect([0, 0], [10, 10], [10, 0], [0, 10])',
    'intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])'
  ],
  'seealso': []
};

},{}],107:[function(require,module,exports){
module.exports = {
  'name': 'and',
  'category': 'Logical',
  'syntax': [
    'x and y',
    'and(x, y)'
  ],
  'description': 'Logical and. Test whether two values are both defined with a nonzero/nonempty value.',
  'examples': [
    'true and false',
    'true and true',
    '2 and 4'
  ],
  'seealso': [
    'not', 'or', 'xor'
  ]
};

},{}],108:[function(require,module,exports){
module.exports = {
  'name': 'not',
  'category': 'Logical',
  'syntax': [
    'not x',
    'not(x)'
  ],
  'description': 'Logical not. Flips the boolean value of given argument.',
  'examples': [
    'not true',
    'not false',
    'not 2',
    'not 0'
  ],
  'seealso': [
    'and', 'or', 'xor'
  ]
};

},{}],109:[function(require,module,exports){
module.exports = {
  'name': 'or',
  'category': 'Logical',
  'syntax': [
    'x or y',
    'or(x, y)'
  ],
  'description': 'Logical or. Test if at least one value is defined with a nonzero/nonempty value.',
  'examples': [
    'true or false',
    'false or false',
    '0 or 4'
  ],
  'seealso': [
    'not', 'and', 'xor'
  ]
};

},{}],110:[function(require,module,exports){
module.exports = {
  'name': 'xor',
  'category': 'Logical',
  'syntax': [
    'x or y',
    'or(x, y)'
  ],
  'description': 'Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.',
  'examples': [
    'true xor false',
    'false xor false',
    'true xor true',
    '0 or 4'
  ],
  'seealso': [
    'not', 'and', 'or'
  ]
};

},{}],111:[function(require,module,exports){
module.exports = {
  'name': 'concat',
  'category': 'Matrix',
  'syntax': [
    'concat(A, B, C, ...)',
    'concat(A, B, C, ..., dim)'
  ],
  'description': 'Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.',
  'examples': [
    'A = [1, 2; 5, 6]',
    'B = [3, 4; 7, 8]',
    'concat(A, B)',
    'concat(A, B, 1)',
    'concat(A, B, 2)'
  ],
  'seealso': [
    'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],112:[function(require,module,exports){
module.exports = {
  'name': 'cross',
  'category': 'Matrix',
  'syntax': [
    'cross(A, B)'
  ],
  'description': 'Calculate the cross product for two vectors in three dimensional space.',
  'examples': [
    'cross([1, 1, 0],  [0, 1, 1])',
    'cross([3, -3, 1], [4, 9, 2])',
    'cross([2, 3, 4],  [5, 6, 7])'
  ],
  'seealso': [
    'multiply',
    'dot'
  ]
};

},{}],113:[function(require,module,exports){
module.exports = {
  'name': 'det',
  'category': 'Matrix',
  'syntax': [
    'det(x)'
  ],
  'description': 'Calculate the determinant of a matrix',
  'examples': [
    'det([1, 2; 3, 4])',
    'det([-2, 2, 3; -1, 1, 3; 2, 0, -1])'
  ],
  'seealso': [
    'concat', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],114:[function(require,module,exports){
module.exports = {
  'name': 'diag',
  'category': 'Matrix',
  'syntax': [
    'diag(x)',
    'diag(x, k)'
  ],
  'description': 'Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.',
  'examples': [
    'diag(1:3)',
    'diag(1:3, 1)',
    'a = [1, 2, 3; 4, 5, 6; 7, 8, 9]',
    'diag(a)'
  ],
  'seealso': [
    'concat', 'det', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],115:[function(require,module,exports){
module.exports = {
  'name': 'dot',
  'category': 'Matrix',
  'syntax': [
    'dot(A, B)'
  ],
  'description': 'Calculate the dot product of two vectors. ' +
      'The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] ' +
      'is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn',
  'examples': [
    'dot([2, 4, 1], [2, 2, 3])',
    '[2, 4, 1] * [2, 2, 3]'
  ],
  'seealso': [
    'multiply',
    'cross'
  ]
};

},{}],116:[function(require,module,exports){
module.exports = {
  'name': 'eye',
  'category': 'Matrix',
  'syntax': [
    'eye(n)',
    'eye(m, n)',
    'eye([m, n])',
    'eye'
  ],
  'description': 'Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.',
  'examples': [
    'eye(3)',
    'eye(3, 5)',
    'a = [1, 2, 3; 4, 5, 6]',
    'eye(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],117:[function(require,module,exports){
module.exports = {
  'name': 'filter',
  'category': 'Matrix',
  'syntax': [
    'filter(x, test)'
  ],
  'description': 'Filter items in a matrix.',
  'examples': [
    'isPositive(x) = x > 0',
    'filter([6, -2, -1, 4, 3], isPositive)',
    'filter([6, -2, 0, 1, 0], x != 0)'
  ],
  'seealso': ['sort', 'map', 'forEach']
};

},{}],118:[function(require,module,exports){
module.exports = {
  'name': 'flatten',
  'category': 'Matrix',
  'syntax': [
    'flatten(x)'
  ],
  'description': 'Flatten a multi dimensional matrix into a single dimensional matrix.',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'size(a)',
    'b = flatten(a)',
    'size(b)'
  ],
  'seealso': [
    'concat', 'resize', 'size', 'squeeze'
  ]
};

},{}],119:[function(require,module,exports){
module.exports = {
  'name': 'forEach',
  'category': 'Matrix',
  'syntax': [
    'forEach(x, callback)'
  ],
  'description': 'Iterates over all elements of a matrix/array, and executes the given callback function.',
  'examples': [
    'forEach([1, 2, 3], function(val) { console.log(val) })'
  ],
  'seealso': ['map', 'sort', 'filter']
};

},{}],120:[function(require,module,exports){
module.exports = {
  'name': 'inv',
  'category': 'Matrix',
  'syntax': [
    'inv(x)'
  ],
  'description': 'Calculate the inverse of a matrix',
  'examples': [
    'inv([1, 2; 3, 4])',
    'inv(4)',
    '1 / 4'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],121:[function(require,module,exports){
module.exports = {
  'name': 'kron',
  'category': 'Matrix',
  'syntax': [
    'math.kron(x, y)'
  ],
  'description': 'Calculates the kronecker product of 2 matrices or vectors.',
  'examples': [
    'kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])',
    'kron([1,1], [2,3,4])'
  ],
  'seealso': [
    'multiply', 'dot', 'cross'
  ]
};

},{}],122:[function(require,module,exports){
module.exports = {
  'name': 'map',
  'category': 'Matrix',
  'syntax': [
    'map(x, callback)'
  ],
  'description': 'Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.',
  'examples': [
    'map([1, 2, 3], function(val) { return value * value })'
  ],
  'seealso': ['filter', 'forEach']
};

},{}],123:[function(require,module,exports){
module.exports = {
  'name': 'ones',
  'category': 'Matrix',
  'syntax': [
    'ones(m)',
    'ones(m, n)',
    'ones(m, n, p, ...)',
    'ones([m])',
    'ones([m, n])',
    'ones([m, n, p, ...])',
    'ones'
  ],
  'description': 'Create a matrix containing ones.',
  'examples': [
    'ones(3)',
    'ones(3, 5)',
    'ones([2,3]) * 4.5',
    'a = [1, 2, 3; 4, 5, 6]',
    'ones(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],124:[function(require,module,exports){
module.exports = {
  'name': 'partitionSelect',
  'category': 'Matrix',
  'syntax': [
    'partitionSelect(x, k)',
    'partitionSelect(x, k, compare)'
  ],
  'description': 'Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.',
  'examples': [
    'partitionSelect([5, 10, 1], 2)',
    'partitionSelect(["C", "B", "A", "D"], 1)'
  ],
  'seealso': ['sort']
};

},{}],125:[function(require,module,exports){
module.exports = {
  'name': 'range',
  'category': 'Type',
  'syntax': [
    'start:end',
    'start:step:end',
    'range(start, end)',
    'range(start, end, step)',
    'range(string)'
  ],
  'description':
      'Create a range. Lower bound of the range is included, upper bound is excluded.',
  'examples': [
    '1:5',
    '3:-1:-3',
    'range(3, 7)',
    'range(0, 12, 2)',
    'range("4:10")',
    'a = [1, 2, 3, 4; 5, 6, 7, 8]',
    'a[1:2, 1:2]'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'size', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],126:[function(require,module,exports){
module.exports = {
  'name': 'resize',
  'category': 'Matrix',
  'syntax': [
    'resize(x, size)',
    'resize(x, size, defaultValue)'
  ],
  'description': 'Resize a matrix.',
  'examples': [
    'resize([1,2,3,4,5], [3])',
    'resize([1,2,3], [5])',
    'resize([1,2,3], [5], -1)',
    'resize(2, [2, 3])',
    'resize("hello", [8], "!")'
  ],
  'seealso': [
    'size', 'subset', 'squeeze'
  ]
};

},{}],127:[function(require,module,exports){
module.exports = {
  'name': 'size',
  'category': 'Matrix',
  'syntax': [
    'size(x)'
  ],
  'description': 'Calculate the size of a matrix.',
  'examples': [
    'size(2.3)',
    'size("hello world")',
    'a = [1, 2; 3, 4; 5, 6]',
    'size(a)',
    'size(1:6)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'squeeze', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],128:[function(require,module,exports){
module.exports = {
  'name': 'sort',
  'category': 'Matrix',
  'syntax': [
    'sort(x)',
    'sort(x, compare)'
  ],
  'description': 'Sort the items in a matrix. Compare can be a string "asc" or "desc", or a custom sort function.',
  'examples': [
    'sort([5, 10, 1])',
    'sort(["C", "B", "A", "D"])',
    'sortByLength(a, b) = size(a)[1] - size(b)[1]',
    'sort(["Langdon", "Tom", "Sara"], sortByLength)'
  ],
  'seealso': ['map', 'filter', 'forEach']
};

},{}],129:[function(require,module,exports){
module.exports = {
  'name': 'squeeze',
  'category': 'Matrix',
  'syntax': [
    'squeeze(x)'
  ],
  'description': 'Remove inner and outer singleton dimensions from a matrix.',
  'examples': [
    'a = zeros(3,2,1)',
    'size(squeeze(a))',
    'b = zeros(1,1,3)',
    'size(squeeze(b))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'subset', 'trace', 'transpose', 'zeros'
  ]
};

},{}],130:[function(require,module,exports){
module.exports = {
  'name': 'subset',
  'category': 'Matrix',
  'syntax': [
    'value(index)',
    'value(index) = replacement',
    'subset(value, [index])',
    'subset(value, [index], replacement)'
  ],
  'description': 'Get or set a subset of a matrix or string. ' +
      'Indexes are one-based. ' +
      'Both the ranges lower-bound and upper-bound are included.',
  'examples': [
    'd = [1, 2; 3, 4]',
    'e = []',
    'e[1, 1:2] = [5, 6]',
    'e[2, :] = [7, 8]',
    'f = d * e',
    'f[2, 1]',
    'f[:, 1]'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'trace', 'transpose', 'zeros'
  ]
};

},{}],131:[function(require,module,exports){
module.exports = {
  'name': 'trace',
  'category': 'Matrix',
  'syntax': [
    'trace(A)'
  ],
  'description': 'Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.',
  'examples': [
    'A = [1, 2, 3; -1, 2, 3; 2, 0, 3]',
    'trace(A)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'transpose', 'zeros'
  ]
};

},{}],132:[function(require,module,exports){
module.exports = {
  'name': 'transpose',
  'category': 'Matrix',
  'syntax': [
    'x\'',
    'transpose(x)'
  ],
  'description': 'Transpose a matrix',
  'examples': [
    'a = [1, 2, 3; 4, 5, 6]',
    'a\'',
    'transpose(a)'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'zeros'
  ]
};

},{}],133:[function(require,module,exports){
module.exports = {
  'name': 'zeros',
  'category': 'Matrix',
  'syntax': [
    'zeros(m)',
    'zeros(m, n)',
    'zeros(m, n, p, ...)',
    'zeros([m])',
    'zeros([m, n])',
    'zeros([m, n, p, ...])',
    'zeros'
  ],
  'description': 'Create a matrix containing zeros.',
  'examples': [
    'zeros(3)',
    'zeros(3, 5)',
    'a = [1, 2, 3; 4, 5, 6]',
    'zeros(size(a))'
  ],
  'seealso': [
    'concat', 'det', 'diag', 'eye', 'inv', 'ones', 'range', 'size', 'squeeze', 'subset', 'trace', 'transpose'
  ]
};

},{}],134:[function(require,module,exports){
module.exports = {
  'name': 'combinations',
  'category': 'Probability',
  'syntax': [
    'combinations(n, k)'
  ],
  'description': 'Compute the number of combinations of n items taken k at a time',
  'examples': [
    'combinations(7, 5)'
  ],
  'seealso': ['permutations', 'factorial']
};

},{}],135:[function(require,module,exports){
module.exports = {
  'name': 'factorial',
  'category': 'Probability',
  'syntax': [
    'kldivergence(x, y)'
  ],
  'description': 'Compute the factorial of a value',
  'examples': [
    '5!',
    '5 * 4 * 3 * 2 * 1',
    '3!'
  ],
  'seealso': ['combinations', 'permutations', 'gamma']
};

},{}],136:[function(require,module,exports){
module.exports = {
  'name': 'gamma',
  'category': 'Probability',
  'syntax': [
    'gamma(n)'
  ],
  'description': 'Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.',
  'examples': [
    'gamma(4)',
    '3!',
    'gamma(1/2)',
    'sqrt(pi)'
  ],
  'seealso': ['factorial']
};

},{}],137:[function(require,module,exports){
module.exports = {
  'name': 'kldivergence',
  'category': 'Probability',
  'syntax': [
    'n!',
    'factorial(n)'
  ],
  'description': 'Calculate the Kullback-Leibler (KL) divergence  between two distributions.',
  'examples': [
    'math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])'
  ],
  'seealso': []
};

},{}],138:[function(require,module,exports){
module.exports = {
  'name': 'multinomial',
  'category': 'Probability',
  'syntax': [
    'multinomial(A)'
  ],
  'description': 'Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai <= 0.',
  'examples': [
    'multinomial([1, 2, 1])'
  ],
  'seealso': ['combinations', 'factorial']
};
},{}],139:[function(require,module,exports){
module.exports = {
  'name': 'permutations',
  'category': 'Probability',
  'syntax': [
    'permutations(n)',
    'permutations(n, k)'
  ],
  'description': 'Compute the number of permutations of n items taken k at a time',
  'examples': [
    'permutations(5)',
    'permutations(5, 3)'
  ],
  'seealso': ['combinations', 'factorial']
};

},{}],140:[function(require,module,exports){
module.exports = {
  'name': 'pickRandom',
  'category': 'Probability',
  'syntax': [
    'pickRandom(array)',
    'pickRandom(array, number)',
    'pickRandom(array, weights)',
    'pickRandom(array, number, weights)',
    'pickRandom(array, weights, number)'
  ],
  'description':
      'Pick a random entry from a given array.',
  'examples': [
    'pickRandom(0:10)',
    'pickRandom([1, 3, 1, 6])',
    'pickRandom([1, 3, 1, 6], 2)',
    'pickRandom([1, 3, 1, 6], [2, 3, 2, 1])',
    'pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])',
    'pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)'
  ],
  'seealso': ['random', 'randomInt']
};

},{}],141:[function(require,module,exports){
module.exports = {
  'name': 'random',
  'category': 'Probability',
  'syntax': [
    'random()',
    'random(max)',
    'random(min, max)',
    'random(size)',
    'random(size, max)',
    'random(size, min, max)'
  ],
  'description':
      'Return a random number.',
  'examples': [
    'random()',
    'random(10, 20)',
    'random([2, 3])'
  ],
  'seealso': ['pickRandom', 'randomInt']
};

},{}],142:[function(require,module,exports){
module.exports = {
  'name': 'randInt',
  'category': 'Probability',
  'syntax': [
    'randInt(max)',
    'randInt(min, max)',
    'randInt(size)',
    'randInt(size, max)',
    'randInt(size, min, max)'
  ],
  'description':
      'Return a random integer number',
  'examples': [
    'randInt(10, 20)',
    'randInt([2, 3], 10)'
  ],
  'seealso': ['pickRandom', 'random']
};
},{}],143:[function(require,module,exports){
module.exports = {
  'name': 'compare',
  'category': 'Relational',
  'syntax': [
    'compare(x, y)'
  ],
  'description':
      'Compare two values. Returns 1 if x is larger than y, -1 if x is smaller than y, and 0 if x and y are equal.',
  'examples': [
    'compare(2, 3)',
    'compare(3, 2)',
    'compare(2, 2)',
    'compare(5cm, 40mm)',
    'compare(2, [1, 2, 3])'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'smallerEq', 'largerEq'
  ]
};

},{}],144:[function(require,module,exports){
module.exports = {
  'name': 'deepEqual',
  'category': 'Relational',
  'syntax': [
    'deepEqual(x, y)'
  ],
  'description':
      'Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.',
  'examples': [
    '[1,3,4] == [1,3,4]',
    '[1,3,4] == [1,3]'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],145:[function(require,module,exports){
module.exports = {
  'name': 'equal',
  'category': 'Relational',
  'syntax': [
    'x == y',
    'equal(x, y)'
  ],
  'description':
      'Check equality of two values. Returns true if the values are equal, and false if not.',
  'examples': [
    '2+2 == 3',
    '2+2 == 4',
    'a = 3.2',
    'b = 6-2.8',
    'a == b',
    '50cm == 0.5m'
  ],
  'seealso': [
    'unequal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual'
  ]
};

},{}],146:[function(require,module,exports){
module.exports = {
  'name': 'larger',
  'category': 'Relational',
  'syntax': [
    'x > y',
    'larger(x, y)'
  ],
  'description':
      'Check if value x is larger than y. Returns true if x is larger than y, and false if not.',
  'examples': [
    '2 > 3',
    '5 > 2*2',
    'a = 3.3',
    'b = 6-2.8',
    '(a > b)',
    '(b < a)',
    '5 cm > 2 inch'
  ],
  'seealso': [
    'equal', 'unequal', 'smaller', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],147:[function(require,module,exports){
module.exports = {
  'name': 'largerEq',
  'category': 'Relational',
  'syntax': [
    'x >= y',
    'largerEq(x, y)'
  ],
  'description':
      'Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.',
  'examples': [
    '2 > 1+1',
    '2 >= 1+1',
    'a = 3.2',
    'b = 6-2.8',
    '(a > b)'
  ],
  'seealso': [
    'equal', 'unequal', 'smallerEq', 'smaller', 'largerEq', 'compare'
  ]
};

},{}],148:[function(require,module,exports){
module.exports = {
  'name': 'smaller',
  'category': 'Relational',
  'syntax': [
    'x < y',
    'smaller(x, y)'
  ],
  'description':
      'Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.',
  'examples': [
    '2 < 3',
    '5 < 2*2',
    'a = 3.3',
    'b = 6-2.8',
    '(a < b)',
    '5 cm < 2 inch'
  ],
  'seealso': [
    'equal', 'unequal', 'larger', 'smallerEq', 'largerEq', 'compare'
  ]
};

},{}],149:[function(require,module,exports){
module.exports = {
  'name': 'smallerEq',
  'category': 'Relational',
  'syntax': [
    'x <= y',
    'smallerEq(x, y)'
  ],
  'description':
      'Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.',
  'examples': [
    '2 < 1+1',
    '2 <= 1+1',
    'a = 3.2',
    'b = 6-2.8',
    '(a < b)'
  ],
  'seealso': [
    'equal', 'unequal', 'larger', 'smaller', 'largerEq', 'compare'
  ]
};

},{}],150:[function(require,module,exports){
module.exports = {
  'name': 'unequal',
  'category': 'Relational',
  'syntax': [
    'x != y',
    'unequal(x, y)'
  ],
  'description':
      'Check unequality of two values. Returns true if the values are unequal, and false if they are equal.',
  'examples': [
    '2+2 != 3',
    '2+2 != 4',
    'a = 3.2',
    'b = 6-2.8',
    'a != b',
    '50cm != 0.5m',
    '5 cm != 2 inch'
  ],
  'seealso': [
    'equal', 'smaller', 'larger', 'smallerEq', 'largerEq', 'compare', 'deepEqual'
  ]
};

},{}],151:[function(require,module,exports){
module.exports = {
  'name': 'erf',
  'category': 'Special',
  'syntax': [
    'erf(x)'
  ],
  'description': 'Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x',
  'examples': [
    'erf(0.2)',
    'erf(-0.5)',
    'erf(4)'
  ],
  'seealso': []
};

},{}],152:[function(require,module,exports){
module.exports = {
  'name': 'mad',
  'category': 'Statistics',
  'syntax': [
    'mad(a, b, c, ...)',
    'mad(A)'
  ],
  'description': 'Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.',
  'examples': [
    'mad(10, 20, 30)',
    'mad([1, 2, 3])',
    'mad(10, 20, 30)'
  ],
  'seealso': [
    'mean',
    'median',
    'std',
    'abs'
  ]
};

},{}],153:[function(require,module,exports){
module.exports = {
  'name': 'max',
  'category': 'Statistics',
  'syntax': [
    'max(a, b, c, ...)',
    'max(A)',
    'max(A, dim)'
  ],
  'description': 'Compute the maximum value of a list of values.',
  'examples': [
    'max(2, 3, 4, 1)',
    'max([2, 3, 4, 1])',
    'max([2, 5; 4, 3])',
    'max([2, 5; 4, 3], 1)',
    'max([2, 5; 4, 3], 2)',
    'max(2.7, 7.1, -4.5, 2.0, 4.1)',
    'min(2.7, 7.1, -4.5, 2.0, 4.1)'
  ],
  'seealso': [
    'mean',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],154:[function(require,module,exports){
module.exports = {
  'name': 'mean',
  'category': 'Statistics',
  'syntax': [
    'mean(a, b, c, ...)',
    'mean(A)',
    'mean(A, dim)'
  ],
  'description': 'Compute the arithmetic mean of a list of values.',
  'examples': [
    'mean(2, 3, 4, 1)',
    'mean([2, 3, 4, 1])',
    'mean([2, 5; 4, 3])',
    'mean([2, 5; 4, 3], 1)',
    'mean([2, 5; 4, 3], 2)',
    'mean([1.0, 2.7, 3.2, 4.0])'
  ],
  'seealso': [
    'max',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],155:[function(require,module,exports){
module.exports = {
  'name': 'median',
  'category': 'Statistics',
  'syntax': [
    'median(a, b, c, ...)',
    'median(A)'
  ],
  'description': 'Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.',
  'examples': [
    'median(5, 2, 7)',
    'median([3, -1, 5, 7])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],156:[function(require,module,exports){
module.exports = {
  'name': 'min',
  'category': 'Statistics',
  'syntax': [
    'min(a, b, c, ...)',
    'min(A)',
    'min(A, dim)'
  ],
  'description': 'Compute the minimum value of a list of values.',
  'examples': [
    'min(2, 3, 4, 1)',
    'min([2, 3, 4, 1])',
    'min([2, 5; 4, 3])',
    'min([2, 5; 4, 3], 1)',
    'min([2, 5; 4, 3], 2)',
    'min(2.7, 7.1, -4.5, 2.0, 4.1)',
    'max(2.7, 7.1, -4.5, 2.0, 4.1)'
  ],
  'seealso': [
    'max',
    'mean',
    'median',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],157:[function(require,module,exports){
module.exports = {
  'name': 'mode',
  'category': 'Statistics',
  'syntax': [
    'mode(a, b, c, ...)',
    'mode(A)',
    'mode(A, a, b, B, c, ...)'
  ],
  'description': 'Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.',
  'examples': [
    'mode(5, 2, 7)',
    'mode([3, -1, 5, 7])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],158:[function(require,module,exports){
module.exports = {
  'name': 'prod',
  'category': 'Statistics',
  'syntax': [
    'prod(a, b, c, ...)',
    'prod(A)'
  ],
  'description': 'Compute the product of all values.',
  'examples': [
    'prod(2, 3, 4)',
    'prod([2, 3, 4])',
    'prod([2, 5; 4, 3])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'std',
    'sum',
    'var'
  ]
};

},{}],159:[function(require,module,exports){
module.exports = {
  'name': 'quantileSeq',
  'category': 'Statistics',
  'syntax': [
    'quantileSeq(A, prob[, sorted])',
    'quantileSeq(A, [prob1, prob2, ...][, sorted])',
    'quantileSeq(A, N[, sorted])'
  ],
  'description': 'Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.',
  'examples': [
    'quantileSeq([3, -1, 5, 7], 0.5)',
    'quantileSeq([3, -1, 5, 7], [1/3, 2/3])',
    'quantileSeq([3, -1, 5, 7], 2)',
    'quantileSeq([-1, 3, 5, 7], 0.5, true)'
  ],
  'seealso': [
    'mean',
    'median',
    'min',
    'max',
    'prod',
    'std',
    'sum',
    'var'
  ]
};
},{}],160:[function(require,module,exports){
module.exports = {
  'name': 'std',
  'category': 'Statistics',
  'syntax': [
    'std(a, b, c, ...)',
    'std(A)',
    'std(A, normalization)'
  ],
  'description': 'Compute the standard deviation of all values, defined as std(A) = sqrt(var(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  'examples': [
    'std(2, 4, 6)',
    'std([2, 4, 6, 8])',
    'std([2, 4, 6, 8], "uncorrected")',
    'std([2, 4, 6, 8], "biased")',
    'std([1, 2, 3; 4, 5, 6])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'prod',
    'sum',
    'var'
  ]
};

},{}],161:[function(require,module,exports){
module.exports = {
  'name': 'sum',
  'category': 'Statistics',
  'syntax': [
    'sum(a, b, c, ...)',
    'sum(A)'
  ],
  'description': 'Compute the sum of all values.',
  'examples': [
    'sum(2, 3, 4, 1)',
    'sum([2, 3, 4, 1])',
    'sum([2, 5; 4, 3])'
  ],
  'seealso': [
    'max',
    'mean',
    'median',
    'min',
    'prod',
    'std',
    'sum',
    'var'
  ]
};

},{}],162:[function(require,module,exports){
module.exports = {
  'name': 'var',
  'category': 'Statistics',
  'syntax': [
    'var(a, b, c, ...)',
    'var(A)',
    'var(A, normalization)'
  ],
  'description': 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  'examples': [
    'var(2, 4, 6)',
    'var([2, 4, 6, 8])',
    'var([2, 4, 6, 8], "uncorrected")',
    'var([2, 4, 6, 8], "biased")',
    'var([1, 2, 3; 4, 5, 6])'
  ],
  'seealso': [
    'max',
    'mean',
    'min',
    'median',
    'min',
    'prod',
    'std',
    'sum'
  ]
};

},{}],163:[function(require,module,exports){
module.exports = {
  'name': 'acos',
  'category': 'Trigonometry',
  'syntax': [
    'acos(x)'
  ],
  'description': 'Compute the inverse cosine of a value in radians.',
  'examples': [
    'acos(0.5)',
    'acos(cos(2.3))'
  ],
  'seealso': [
    'cos',
    'atan',
    'asin'
  ]
};

},{}],164:[function(require,module,exports){
module.exports = {
  'name': 'acosh',
  'category': 'Trigonometry',
  'syntax': [
    'acosh(x)'
  ],
  'description': 'Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.',
  'examples': [
    'acosh(1.5)'
  ],
  'seealso': [
    'cosh',
    'asinh',
    'atanh'
  ]
};
},{}],165:[function(require,module,exports){
module.exports = {
  'name': 'acot',
  'category': 'Trigonometry',
  'syntax': [
    'acot(x)'
  ],
  'description': 'Calculate the inverse cotangent of a value.',
  'examples': [
    'acot(0.5)',
    'acot(cot(0.5))',
    'acot(2)'
  ],
  'seealso': [
    'cot',
    'atan'
  ]
};

},{}],166:[function(require,module,exports){
module.exports = {
  'name': 'acoth',
  'category': 'Trigonometry',
  'syntax': [
    'acoth(x)'
  ],
  'description': 'Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.',
  'examples': [
    'acoth(0.5)'
  ],
  'seealso': [
    'acsch',
    'asech'
  ]
};
},{}],167:[function(require,module,exports){
module.exports = {
  'name': 'acsc',
  'category': 'Trigonometry',
  'syntax': [
    'acsc(x)'
  ],
  'description': 'Calculate the inverse cotangent of a value.',
  'examples': [
    'acsc(0.5)',
    'acsc(csc(0.5))',
    'acsc(2)'
  ],
  'seealso': [
    'csc',
    'asin',
    'asec'
  ]
};

},{}],168:[function(require,module,exports){
module.exports = {
  'name': 'acsch',
  'category': 'Trigonometry',
  'syntax': [
    'acsch(x)'
  ],
  'description': 'Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.',
  'examples': [
    'acsch(0.5)'
  ],
  'seealso': [
    'asech',
    'acoth'
  ]
};

},{}],169:[function(require,module,exports){
module.exports = {
  'name': 'asec',
  'category': 'Trigonometry',
  'syntax': [
    'asec(x)'
  ],
  'description': 'Calculate the inverse secant of a value.',
  'examples': [
    'asec(0.5)',
    'asec(sec(0.5))',
    'asec(2)'
  ],
  'seealso': [
    'acos',
    'acot',
    'acsc'
  ]
};

},{}],170:[function(require,module,exports){
module.exports = {
  'name': 'asech',
  'category': 'Trigonometry',
  'syntax': [
    'asech(x)'
  ],
  'description': 'Calculate the inverse secant of a value.',
  'examples': [
    'asech(0.5)'
  ],
  'seealso': [
    'acsch',
    'acoth'
  ]
};

},{}],171:[function(require,module,exports){
module.exports = {
  'name': 'asin',
  'category': 'Trigonometry',
  'syntax': [
    'asin(x)'
  ],
  'description': 'Compute the inverse sine of a value in radians.',
  'examples': [
    'asin(0.5)',
    'asin(sin(2.3))'
  ],
  'seealso': [
    'sin',
    'acos',
    'atan'
  ]
};

},{}],172:[function(require,module,exports){
module.exports = {
  'name': 'asinh',
  'category': 'Trigonometry',
  'syntax': [
    'asinh(x)'
  ],
  'description': 'Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.',
  'examples': [
    'asinh(0.5)'
  ],
  'seealso': [
    'acosh',
    'atanh'
  ]
};

},{}],173:[function(require,module,exports){
module.exports = {
  'name': 'atan',
  'category': 'Trigonometry',
  'syntax': [
    'atan(x)'
  ],
  'description': 'Compute the inverse tangent of a value in radians.',
  'examples': [
    'atan(0.5)',
    'atan(tan(2.3))'
  ],
  'seealso': [
    'tan',
    'acos',
    'asin'
  ]
};

},{}],174:[function(require,module,exports){
module.exports = {
  'name': 'atan2',
  'category': 'Trigonometry',
  'syntax': [
    'atan2(y, x)'
  ],
  'description':
      'Computes the principal value of the arc tangent of y/x in radians.',
  'examples': [
    'atan2(2, 2) / pi',
    'angle = 60 deg in rad',
    'x = cos(angle)',
    'y = sin(angle)',
    'atan2(y, x)'
  ],
  'seealso': [
    'sin',
    'cos',
    'tan'
  ]
};

},{}],175:[function(require,module,exports){
module.exports = {
  'name': 'atanh',
  'category': 'Trigonometry',
  'syntax': [
    'atanh(x)'
  ],
  'description': 'Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.',
  'examples': [
    'atanh(0.5)'
  ],
  'seealso': [
    'acosh',
    'asinh'
  ]
};

},{}],176:[function(require,module,exports){
module.exports = {
  'name': 'cos',
  'category': 'Trigonometry',
  'syntax': [
    'cos(x)'
  ],
  'description': 'Compute the cosine of x in radians.',
  'examples': [
    'cos(2)',
    'cos(pi / 4) ^ 2',
    'cos(180 deg)',
    'cos(60 deg)',
    'sin(0.2)^2 + cos(0.2)^2'
  ],
  'seealso': [
    'acos',
    'sin',
    'tan'
  ]
};

},{}],177:[function(require,module,exports){
module.exports = {
  'name': 'cosh',
  'category': 'Trigonometry',
  'syntax': [
    'cosh(x)'
  ],
  'description': 'Compute the hyperbolic cosine of x in radians.',
  'examples': [
    'cosh(0.5)'
  ],
  'seealso': [
    'sinh',
    'tanh',
    'coth'
  ]
};

},{}],178:[function(require,module,exports){
module.exports = {
  'name': 'cot',
  'category': 'Trigonometry',
  'syntax': [
    'cot(x)'
  ],
  'description': 'Compute the cotangent of x in radians. Defined as 1/tan(x)',
  'examples': [
    'cot(2)',
    '1 / tan(2)'
  ],
  'seealso': [
    'sec',
    'csc',
    'tan'
  ]
};

},{}],179:[function(require,module,exports){
module.exports = {
  'name': 'coth',
  'category': 'Trigonometry',
  'syntax': [
    'coth(x)'
  ],
  'description': 'Compute the hyperbolic cotangent of x in radians.',
  'examples': [
    'coth(2)',
    '1 / tanh(2)'
  ],
  'seealso': [
    'sech',
    'csch',
    'tanh'
  ]
};

},{}],180:[function(require,module,exports){
module.exports = {
  'name': 'csc',
  'category': 'Trigonometry',
  'syntax': [
    'csc(x)'
  ],
  'description': 'Compute the cosecant of x in radians. Defined as 1/sin(x)',
  'examples': [
    'csc(2)',
    '1 / sin(2)'
  ],
  'seealso': [
    'sec',
    'cot',
    'sin'
  ]
};

},{}],181:[function(require,module,exports){
module.exports = {
  'name': 'csch',
  'category': 'Trigonometry',
  'syntax': [
    'csch(x)'
  ],
  'description': 'Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)',
  'examples': [
    'csch(2)',
    '1 / sinh(2)'
  ],
  'seealso': [
    'sech',
    'coth',
    'sinh'
  ]
};

},{}],182:[function(require,module,exports){
module.exports = {
  'name': 'sec',
  'category': 'Trigonometry',
  'syntax': [
    'sec(x)'
  ],
  'description': 'Compute the secant of x in radians. Defined as 1/cos(x)',
  'examples': [
    'sec(2)',
    '1 / cos(2)'
  ],
  'seealso': [
    'cot',
    'csc',
    'cos'
  ]
};

},{}],183:[function(require,module,exports){
module.exports = {
  'name': 'sech',
  'category': 'Trigonometry',
  'syntax': [
    'sech(x)'
  ],
  'description': 'Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)',
  'examples': [
    'sech(2)',
    '1 / cosh(2)'
  ],
  'seealso': [
    'coth',
    'csch',
    'cosh'
  ]
};

},{}],184:[function(require,module,exports){
module.exports = {
  'name': 'sin',
  'category': 'Trigonometry',
  'syntax': [
    'sin(x)'
  ],
  'description': 'Compute the sine of x in radians.',
  'examples': [
    'sin(2)',
    'sin(pi / 4) ^ 2',
    'sin(90 deg)',
    'sin(30 deg)',
    'sin(0.2)^2 + cos(0.2)^2'
  ],
  'seealso': [
    'asin',
    'cos',
    'tan'
  ]
};

},{}],185:[function(require,module,exports){
module.exports = {
  'name': 'sinh',
  'category': 'Trigonometry',
  'syntax': [
    'sinh(x)'
  ],
  'description': 'Compute the hyperbolic sine of x in radians.',
  'examples': [
    'sinh(0.5)'
  ],
  'seealso': [
    'cosh',
    'tanh'
  ]
};

},{}],186:[function(require,module,exports){
module.exports = {
  'name': 'tan',
  'category': 'Trigonometry',
  'syntax': [
    'tan(x)'
  ],
  'description': 'Compute the tangent of x in radians.',
  'examples': [
    'tan(0.5)',
    'sin(0.5) / cos(0.5)',
    'tan(pi / 4)',
    'tan(45 deg)'
  ],
  'seealso': [
    'atan',
    'sin',
    'cos'
  ]
};

},{}],187:[function(require,module,exports){
module.exports = {
  'name': 'tanh',
  'category': 'Trigonometry',
  'syntax': [
    'tanh(x)'
  ],
  'description': 'Compute the hyperbolic tangent of x in radians.',
  'examples': [
    'tanh(0.5)',
    'sinh(0.5) / cosh(0.5)'
  ],
  'seealso': [
    'sinh',
    'cosh'
  ]
};

},{}],188:[function(require,module,exports){
module.exports = {
  'name': 'to',
  'category': 'Units',
  'syntax': [
    'x to unit',
    'to(x, unit)'
  ],
  'description': 'Change the unit of a value.',
  'examples': [
    '5 inch to cm',
    '3.2kg to g',
    '16 bytes in bits'
  ],
  'seealso': []
};

},{}],189:[function(require,module,exports){
module.exports = {
  'name': 'clone',
  'category': 'Utils',
  'syntax': [
    'clone(x)'
  ],
  'description': 'Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices',
  'examples': [
    'clone(3.5)',
    'clone(2 - 4i)',
    'clone(45 deg)',
    'clone([1, 2; 3, 4])',
    'clone("hello world")'
  ],
  'seealso': []
};

},{}],190:[function(require,module,exports){
module.exports = {
  'name': 'format',
  'category': 'Utils',
  'syntax': [
    'format(value)',
    'format(value, precision)'
  ],
  'description': 'Format a value of any type as string.',
  'examples': [
    'format(2.3)',
    'format(3 - 4i)',
    'format([])',
    'format(pi, 3)'
  ],
  'seealso': ['print']
};

},{}],191:[function(require,module,exports){
module.exports = {
  'name': 'isInteger',
  'category': 'Utils',
  'syntax': [
    'isInteger(x)'
  ],
  'description': 'Test whether a value is an integer number.',
  'examples': [
    'isInteger(2)',
    'isInteger(3.5)',
    'isInteger([3, 0.5, -2])'
  ],
  'seealso': ['isNegative', 'isNumeric', 'isPositive', 'isZero']
};

},{}],192:[function(require,module,exports){
module.exports = {
  'name': 'isNaN',
  'category': 'Utils',
  'syntax': [
    'isNaN(x)'
  ],
  'description': 'Test whether a value is NaN (not a number)',
  'examples': [
    'isNaN(2)',
    'isNaN(0 / 0)',
    'isNaN(NaN)',
    'isNaN(Infinity)'
  ],
  'seealso': ['isNegative', 'isNumeric', 'isPositive', 'isZero']
};

},{}],193:[function(require,module,exports){
module.exports = {
  'name': 'isNegative',
  'category': 'Utils',
  'syntax': [
    'isNegative(x)'
  ],
  'description': 'Test whether a value is negative: smaller than zero.',
  'examples': [
    'isNegative(2)',
    'isNegative(0)',
    'isNegative(-4)',
    'isNegative([3, 0.5, -2])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isPositive', 'isZero']
};

},{}],194:[function(require,module,exports){
module.exports = {
  'name': 'isNumeric',
  'category': 'Utils',
  'syntax': [
    'isNumeric(x)'
  ],
  'description': 'Test whether a value is a numeric value. ' +
    'Returns true when the input is a number, BigNumber, Fraction, or boolean.',
  'examples': [
    'isNumeric(2)',
    'isNumeric(0)',
    'isNumeric(bignumber(500))',
    'isNumeric(fraction(0.125))',
    'isNumeric("3")',
    'isNumeric(2 + 3i)',
    'isNumeric([2.3, "foo", false])'
  ],
  'seealso': ['isInteger', 'isZero', 'isNegative', 'isPositive', 'isNaN']
};

},{}],195:[function(require,module,exports){
module.exports = {
  'name': 'isPositive',
  'category': 'Utils',
  'syntax': [
    'isPositive(x)'
  ],
  'description': 'Test whether a value is positive: larger than zero.',
  'examples': [
    'isPositive(2)',
    'isPositive(0)',
    'isPositive(-4)',
    'isPositive([3, 0.5, -2])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isNegative', 'isZero']
};

},{}],196:[function(require,module,exports){
module.exports = {
  'name': 'isPrime',
  'category': 'Utils',
  'syntax': [
    'isPrime(x)'
  ],
  'description': 'Test whether a value is prime: has no divisors other than itself and one.',
  'examples': [
    'isPrime(3)',
    'isPrime(-2)',
    'isPrime([2, 17, 100])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isNegative', 'isZero']
};
},{}],197:[function(require,module,exports){
module.exports = {
  'name': 'isZero',
  'category': 'Utils',
  'syntax': [
    'isZero(x)'
  ],
  'description': 'Test whether a value is zero.',
  'examples': [
    'isZero(2)',
    'isZero(0)',
    'isZero(-4)',
    'isZero([3, 0, -2, 0])'
  ],
  'seealso': ['isInteger', 'isNumeric', 'isNegative', 'isPositive']
};

},{}],198:[function(require,module,exports){
module.exports = {
  'name': 'typeof',
  'category': 'Utils',
  'syntax': [
    'typeof(x)'
  ],
  'description': 'Get the type of a variable.',
  'examples': [
    'typeof(3.5)',
    'typeof(2 - 4i)',
    'typeof(45 deg)',
    'typeof("hello world")'
  ],
  'seealso': []
};

},{}],199:[function(require,module,exports){
function factory (construction, config, load, typed) {
  var docs = {};


  // construction functions
  docs.bignumber = require('./construction/bignumber');
  docs['boolean'] = require('./construction/boolean');
  docs.complex = require('./construction/complex');
  docs.createUnit = require('./construction/createUnit');
  docs.fraction = require('./construction/fraction');
  docs.index = require('./construction/index');
  docs.matrix = require('./construction/matrix');
  docs.number = require('./construction/number');
  docs.sparse = require('./construction/sparse');
  docs.splitUnit = require('./construction/splitUnit');
  docs.string = require('./construction/string');
  docs.unit = require('./construction/unit');

  // constants
  docs.e = require('./constants/e');
  docs.E = require('./constants/e');
  docs['false'] = require('./constants/false');
  docs.i = require('./constants/i');
  docs['Infinity'] = require('./constants/Infinity');
  docs.LN2 = require('./constants/LN2');
  docs.LN10 = require('./constants/LN10');
  docs.LOG2E = require('./constants/LOG2E');
  docs.LOG10E = require('./constants/LOG10E');
  docs.NaN = require('./constants/NaN');
  docs['null'] = require('./constants/null');
  docs.pi = require('./constants/pi');
  docs.PI = require('./constants/pi');
  docs.phi = require('./constants/phi');
  docs.SQRT1_2 = require('./constants/SQRT1_2');
  docs.SQRT2 = require('./constants/SQRT2');
  docs.tau = require('./constants/tau');
  docs['true'] = require('./constants/true');
  docs.version = require('./constants/version');

  // physical constants
  // TODO: more detailed docs for physical constants
  docs.speedOfLight = {description: 'Speed of light in vacuum', examples: ['speedOfLight']};
  docs.gravitationConstant = {description: 'Newtonian constant of gravitation', examples: ['gravitationConstant']};
  docs.planckConstant = {description: 'Planck constant', examples: ['planckConstant']};
  docs.reducedPlanckConstant = {description: 'Reduced Planck constant', examples: ['reducedPlanckConstant']};

  docs.magneticConstant = {description: 'Magnetic constant (vacuum permeability)', examples: ['magneticConstant']};
  docs.electricConstant = {description: 'Electric constant (vacuum permeability)', examples: ['electricConstant']};
  docs.vacuumImpedance = {description: 'Characteristic impedance of vacuum', examples: ['vacuumImpedance']};
  docs.coulomb = {description: 'Coulomb\'s constant', examples: ['coulomb']};
  docs.elementaryCharge = {description: 'Elementary charge', examples: ['elementaryCharge']};
  docs.bohrMagneton = {description: 'Borh magneton', examples: ['bohrMagneton']};
  docs.conductanceQuantum = {description: 'Conductance quantum', examples: ['conductanceQuantum']};
  docs.inverseConductanceQuantum = {description: 'Inverse conductance quantum', examples: ['inverseConductanceQuantum']};
  //docs.josephson = {description: 'Josephson constant', examples: ['josephson']};
  docs.magneticFluxQuantum = {description: 'Magnetic flux quantum', examples: ['magneticFluxQuantum']};
  docs.nuclearMagneton = {description: 'Nuclear magneton', examples: ['nuclearMagneton']};
  docs.klitzing = {description: 'Von Klitzing constant', examples: ['klitzing']};

  docs.bohrRadius = {description: 'Borh radius', examples: ['bohrRadius']};
  docs.classicalElectronRadius = {description: 'Classical electron radius', examples: ['classicalElectronRadius']};
  docs.electronMass = {description: 'Electron mass', examples: ['electronMass']};
  docs.fermiCoupling = {description: 'Fermi coupling constant', examples: ['fermiCoupling']};
  docs.fineStructure = {description: 'Fine-structure constant', examples: ['fineStructure']};
  docs.hartreeEnergy = {description: 'Hartree energy', examples: ['hartreeEnergy']};
  docs.protonMass = {description: 'Proton mass', examples: ['protonMass']};
  docs.deuteronMass = {description: 'Deuteron Mass', examples: ['deuteronMass']};
  docs.neutronMass = {description: 'Neutron mass', examples: ['neutronMass']};
  docs.quantumOfCirculation = {description: 'Quantum of circulation', examples: ['quantumOfCirculation']};
  docs.rydberg = {description: 'Rydberg constant', examples: ['rydberg']};
  docs.thomsonCrossSection = {description: 'Thomson cross section', examples: ['thomsonCrossSection']};
  docs.weakMixingAngle = {description: 'Weak mixing angle', examples: ['weakMixingAngle']};
  docs.efimovFactor = {description: 'Efimov factor', examples: ['efimovFactor']};

  docs.atomicMass = {description: 'Atomic mass constant', examples: ['atomicMass']};
  docs.avogadro = {description: 'Avogadro\'s number', examples: ['avogadro']};
  docs.boltzmann = {description: 'Boltzmann constant', examples: ['boltzmann']};
  docs.faraday = {description: 'Faraday constant', examples: ['faraday']};
  docs.firstRadiation = {description: 'First radiation constant', examples: ['firstRadiation']};
  docs.loschmidt = {description: 'Loschmidt constant at T=273.15 K and p=101.325 kPa', examples: ['loschmidt']};
  docs.gasConstant = {description: 'Gas constant', examples: ['gasConstant']};
  docs.molarPlanckConstant = {description: 'Molar Planck constant', examples: ['molarPlanckConstant']};
  docs.molarVolume = {description: 'Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa', examples: ['molarVolume']};
  docs.sackurTetrode = {description: 'Sackur-Tetrode constant at T=1 K and p=101.325 kPa', examples: ['sackurTetrode']};
  docs.secondRadiation = {description: 'Second radiation constant', examples: ['secondRadiation']};
  docs.stefanBoltzmann = {description: 'Stefan-Boltzmann constant', examples: ['stefanBoltzmann']};
  docs.wienDisplacement = {description: 'Wien displacement law constant', examples: ['wienDisplacement']};
  //docs.spectralRadiance = {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']};

  docs.molarMass = {description: 'Molar mass constant', examples: ['molarMass']};
  docs.molarMassC12 = {description: 'Molar mass constant of carbon-12', examples: ['molarMassC12']};
  docs.gravity = {description: 'Standard acceleration of gravity (standard acceleration of free-fall on Earth)', examples: ['gravity']};

  docs.planckLength = {description: 'Planck length', examples: ['planckLength']};
  docs.planckMass = {description: 'Planck mass', examples: ['planckMass']};
  docs.planckTime = {description: 'Planck time', examples: ['planckTime']};
  docs.planckCharge = {description: 'Planck charge', examples: ['planckCharge']};
  docs.planckTemperature = {description: 'Planck temperature', examples: ['planckTemperature']};

  // functions - algebra
  docs.derivative = require('./function/algebra/derivative');
  docs.lsolve = require('./function/algebra/lsolve');
  docs.lup = require('./function/algebra/lup');
  docs.lusolve = require('./function/algebra/lusolve');
  docs.simplify = require('./function/algebra/simplify');
  docs.slu = require('./function/algebra/slu');
  docs.usolve = require('./function/algebra/usolve');

  // functions - arithmetic
  docs.abs = require('./function/arithmetic/abs');
  docs.add = require('./function/arithmetic/add');
  docs.cbrt = require('./function/arithmetic/cbrt');
  docs.ceil = require('./function/arithmetic/ceil');
  docs.cube = require('./function/arithmetic/cube');
  docs.divide = require('./function/arithmetic/divide');
  docs.dotDivide = require('./function/arithmetic/dotDivide');
  docs.dotMultiply = require('./function/arithmetic/dotMultiply');
  docs.dotPow = require('./function/arithmetic/dotPow');
  docs.exp = require('./function/arithmetic/exp');
  docs.fix = require('./function/arithmetic/fix');
  docs.floor = require('./function/arithmetic/floor');
  docs.gcd = require('./function/arithmetic/gcd');
  docs.hypot = require('./function/arithmetic/hypot');
  docs.lcm = require('./function/arithmetic/lcm');
  docs.log = require('./function/arithmetic/log');
  docs.log10 = require('./function/arithmetic/log10');
  docs.mod = require('./function/arithmetic/mod');
  docs.multiply = require('./function/arithmetic/multiply');
  docs.norm = require('./function/arithmetic/norm');
  docs.nthRoot = require('./function/arithmetic/nthRoot');
  docs.pow = require('./function/arithmetic/pow');
  docs.round = require('./function/arithmetic/round');
  docs.sign = require('./function/arithmetic/sign');
  docs.sqrt = require('./function/arithmetic/sqrt');
  docs.square = require('./function/arithmetic/square');
  docs.subtract = require('./function/arithmetic/subtract');
  docs.unaryMinus = require('./function/arithmetic/unaryMinus');
  docs.unaryPlus = require('./function/arithmetic/unaryPlus');
  docs.xgcd = require('./function/arithmetic/xgcd');

  // functions - bitwise
  docs.bitAnd = require('./function/bitwise/bitAnd');
  docs.bitNot = require('./function/bitwise/bitNot');
  docs.bitOr = require('./function/bitwise/bitOr');
  docs.bitXor = require('./function/bitwise/bitXor');
  docs.leftShift = require('./function/bitwise/leftShift');
  docs.rightArithShift = require('./function/bitwise/rightArithShift');
  docs.rightLogShift = require('./function/bitwise/rightLogShift');

  // functions - combinatorics
  docs.bellNumbers = require('./function/combinatorics/bellNumbers');
  docs.catalan = require('./function/combinatorics/catalan');
  docs.composition = require('./function/combinatorics/composition');
  docs.stirlingS2 = require('./function/combinatorics/stirlingS2');

  // functions - core
  docs['config'] =  require('./core/config');
  docs['import'] =  require('./core/import');
  docs['typed'] =  require('./core/typed');

  // functions - complex
  docs.arg = require('./function/complex/arg');
  docs.conj = require('./function/complex/conj');
  docs.re = require('./function/complex/re');
  docs.im = require('./function/complex/im');

  // functions - expression
  docs['eval'] =  require('./function/expression/eval');
  docs.help =  require('./function/expression/help');

  // functions - geometry
  docs.distance = require('./function/geometry/distance');
  docs.intersect = require('./function/geometry/intersect');

  // functions - logical
  docs['and'] = require('./function/logical/and');
  docs['not'] = require('./function/logical/not');
  docs['or'] = require('./function/logical/or');
  docs['xor'] = require('./function/logical/xor');

  // functions - matrix
  docs['concat'] = require('./function/matrix/concat');
  docs.cross = require('./function/matrix/cross');
  docs.det = require('./function/matrix/det');
  docs.diag = require('./function/matrix/diag');
  docs.dot = require('./function/matrix/dot');
  docs.eye = require('./function/matrix/eye');
  docs.filter =  require('./function/matrix/filter');
  docs.flatten = require('./function/matrix/flatten');
  docs.forEach =  require('./function/matrix/forEach');
  docs.inv = require('./function/matrix/inv');
  docs.kron = require('./function/matrix/kron');
  docs.map =  require('./function/matrix/map');
  docs.ones = require('./function/matrix/ones');
  docs.partitionSelect =  require('./function/matrix/partitionSelect');
  docs.range = require('./function/matrix/range');
  docs.resize = require('./function/matrix/resize');
  docs.size = require('./function/matrix/size');
  docs.sort =  require('./function/matrix/sort');
  docs.squeeze = require('./function/matrix/squeeze');
  docs.subset = require('./function/matrix/subset');
  docs.trace = require('./function/matrix/trace');
  docs.transpose = require('./function/matrix/transpose');
  docs.zeros = require('./function/matrix/zeros');

  // functions - probability
  docs.combinations = require('./function/probability/combinations');
  //docs.distribution = require('./function/probability/distribution');
  docs.factorial = require('./function/probability/factorial');
  docs.gamma = require('./function/probability/gamma');
  docs.kldivergence = require('./function/probability/kldivergence');
  docs.multinomial = require('./function/probability/multinomial');
  docs.permutations = require('./function/probability/permutations');
  docs.pickRandom = require('./function/probability/pickRandom');
  docs.random = require('./function/probability/random');
  docs.randomInt = require('./function/probability/randomInt');

  // functions - relational
  docs.compare = require('./function/relational/compare');
  docs.deepEqual = require('./function/relational/deepEqual');
  docs['equal'] = require('./function/relational/equal');
  docs.larger = require('./function/relational/larger');
  docs.largerEq = require('./function/relational/largerEq');
  docs.smaller = require('./function/relational/smaller');
  docs.smallerEq = require('./function/relational/smallerEq');
  docs.unequal = require('./function/relational/unequal');

  // functions - special
  docs.erf = require('./function/special/erf');

  // functions - statistics
  docs.mad = require('./function/statistics/mad');
  docs.max = require('./function/statistics/max');
  docs.mean = require('./function/statistics/mean');
  docs.median = require('./function/statistics/median');
  docs.min = require('./function/statistics/min');
  docs.mode = require('./function/statistics/mode');
  docs.prod = require('./function/statistics/prod');
  docs.quantileSeq = require('./function/statistics/quantileSeq');
  docs.std = require('./function/statistics/std');
  docs.sum = require('./function/statistics/sum');
  docs['var'] = require('./function/statistics/var');

  // functions - trigonometry
  docs.acos = require('./function/trigonometry/acos');
  docs.acosh = require('./function/trigonometry/acosh');
  docs.acot = require('./function/trigonometry/acot');
  docs.acoth = require('./function/trigonometry/acoth');
  docs.acsc = require('./function/trigonometry/acsc');
  docs.acsch = require('./function/trigonometry/acsch');
  docs.asec = require('./function/trigonometry/asec');
  docs.asech = require('./function/trigonometry/asech');
  docs.asin = require('./function/trigonometry/asin');
  docs.asinh = require('./function/trigonometry/asinh');
  docs.atan = require('./function/trigonometry/atan');
  docs.atanh = require('./function/trigonometry/atanh');
  docs.atan2 = require('./function/trigonometry/atan2');
  docs.cos = require('./function/trigonometry/cos');
  docs.cosh = require('./function/trigonometry/cosh');
  docs.cot = require('./function/trigonometry/cot');
  docs.coth = require('./function/trigonometry/coth');
  docs.csc = require('./function/trigonometry/csc');
  docs.csch = require('./function/trigonometry/csch');
  docs.sec = require('./function/trigonometry/sec');
  docs.sech = require('./function/trigonometry/sech');
  docs.sin = require('./function/trigonometry/sin');
  docs.sinh = require('./function/trigonometry/sinh');
  docs.tan = require('./function/trigonometry/tan');
  docs.tanh = require('./function/trigonometry/tanh');

  // functions - units
  docs.to = require('./function/units/to');

  // functions - utils
  docs.clone = require('./function/utils/clone');
  docs.format = require('./function/utils/format');
  docs.isNaN = require('./function/utils/isNaN');
  docs.isInteger = require('./function/utils/isInteger');
  docs.isNegative = require('./function/utils/isNegative');
  docs.isNumeric = require('./function/utils/isNumeric');
  docs.isPositive = require('./function/utils/isPositive');
  docs.isPrime = require('./function/utils/isPrime');
  docs.isZero = require('./function/utils/isZero');
  // docs.print = require('./function/utils/print'); // TODO: add documentation for print as soon as the parser supports objects.
  docs['typeof'] =  require('./function/utils/typeof');

  return docs;
}

exports.name = 'docs';
exports.path = 'expression';
exports.factory = factory;

},{"./constants/Infinity":19,"./constants/LN10":20,"./constants/LN2":21,"./constants/LOG10E":22,"./constants/LOG2E":23,"./constants/NaN":24,"./constants/SQRT1_2":25,"./constants/SQRT2":26,"./constants/e":27,"./constants/false":28,"./constants/i":29,"./constants/null":30,"./constants/phi":31,"./constants/pi":32,"./constants/tau":33,"./constants/true":34,"./constants/version":35,"./construction/bignumber":36,"./construction/boolean":37,"./construction/complex":38,"./construction/createUnit":39,"./construction/fraction":40,"./construction/index":41,"./construction/matrix":42,"./construction/number":43,"./construction/sparse":44,"./construction/splitUnit":45,"./construction/string":46,"./construction/unit":47,"./core/config":48,"./core/import":49,"./core/typed":50,"./function/algebra/derivative":51,"./function/algebra/lsolve":52,"./function/algebra/lup":53,"./function/algebra/lusolve":54,"./function/algebra/simplify":55,"./function/algebra/slu":56,"./function/algebra/usolve":57,"./function/arithmetic/abs":58,"./function/arithmetic/add":59,"./function/arithmetic/cbrt":60,"./function/arithmetic/ceil":61,"./function/arithmetic/cube":62,"./function/arithmetic/divide":63,"./function/arithmetic/dotDivide":64,"./function/arithmetic/dotMultiply":65,"./function/arithmetic/dotPow":66,"./function/arithmetic/exp":67,"./function/arithmetic/fix":68,"./function/arithmetic/floor":69,"./function/arithmetic/gcd":70,"./function/arithmetic/hypot":71,"./function/arithmetic/lcm":72,"./function/arithmetic/log":73,"./function/arithmetic/log10":74,"./function/arithmetic/mod":75,"./function/arithmetic/multiply":76,"./function/arithmetic/norm":77,"./function/arithmetic/nthRoot":78,"./function/arithmetic/pow":79,"./function/arithmetic/round":80,"./function/arithmetic/sign":81,"./function/arithmetic/sqrt":82,"./function/arithmetic/square":83,"./function/arithmetic/subtract":84,"./function/arithmetic/unaryMinus":85,"./function/arithmetic/unaryPlus":86,"./function/arithmetic/xgcd":87,"./function/bitwise/bitAnd":88,"./function/bitwise/bitNot":89,"./function/bitwise/bitOr":90,"./function/bitwise/bitXor":91,"./function/bitwise/leftShift":92,"./function/bitwise/rightArithShift":93,"./function/bitwise/rightLogShift":94,"./function/combinatorics/bellNumbers":95,"./function/combinatorics/catalan":96,"./function/combinatorics/composition":97,"./function/combinatorics/stirlingS2":98,"./function/complex/arg":99,"./function/complex/conj":100,"./function/complex/im":101,"./function/complex/re":102,"./function/expression/eval":103,"./function/expression/help":104,"./function/geometry/distance":105,"./function/geometry/intersect":106,"./function/logical/and":107,"./function/logical/not":108,"./function/logical/or":109,"./function/logical/xor":110,"./function/matrix/concat":111,"./function/matrix/cross":112,"./function/matrix/det":113,"./function/matrix/diag":114,"./function/matrix/dot":115,"./function/matrix/eye":116,"./function/matrix/filter":117,"./function/matrix/flatten":118,"./function/matrix/forEach":119,"./function/matrix/inv":120,"./function/matrix/kron":121,"./function/matrix/map":122,"./function/matrix/ones":123,"./function/matrix/partitionSelect":124,"./function/matrix/range":125,"./function/matrix/resize":126,"./function/matrix/size":127,"./function/matrix/sort":128,"./function/matrix/squeeze":129,"./function/matrix/subset":130,"./function/matrix/trace":131,"./function/matrix/transpose":132,"./function/matrix/zeros":133,"./function/probability/combinations":134,"./function/probability/factorial":135,"./function/probability/gamma":136,"./function/probability/kldivergence":137,"./function/probability/multinomial":138,"./function/probability/permutations":139,"./function/probability/pickRandom":140,"./function/probability/random":141,"./function/probability/randomInt":142,"./function/relational/compare":143,"./function/relational/deepEqual":144,"./function/relational/equal":145,"./function/relational/larger":146,"./function/relational/largerEq":147,"./function/relational/smaller":148,"./function/relational/smallerEq":149,"./function/relational/unequal":150,"./function/special/erf":151,"./function/statistics/mad":152,"./function/statistics/max":153,"./function/statistics/mean":154,"./function/statistics/median":155,"./function/statistics/min":156,"./function/statistics/mode":157,"./function/statistics/prod":158,"./function/statistics/quantileSeq":159,"./function/statistics/std":160,"./function/statistics/sum":161,"./function/statistics/var":162,"./function/trigonometry/acos":163,"./function/trigonometry/acosh":164,"./function/trigonometry/acot":165,"./function/trigonometry/acoth":166,"./function/trigonometry/acsc":167,"./function/trigonometry/acsch":168,"./function/trigonometry/asec":169,"./function/trigonometry/asech":170,"./function/trigonometry/asin":171,"./function/trigonometry/asinh":172,"./function/trigonometry/atan":173,"./function/trigonometry/atan2":174,"./function/trigonometry/atanh":175,"./function/trigonometry/cos":176,"./function/trigonometry/cosh":177,"./function/trigonometry/cot":178,"./function/trigonometry/coth":179,"./function/trigonometry/csc":180,"./function/trigonometry/csch":181,"./function/trigonometry/sec":182,"./function/trigonometry/sech":183,"./function/trigonometry/sin":184,"./function/trigonometry/sinh":185,"./function/trigonometry/tan":186,"./function/trigonometry/tanh":187,"./function/units/to":188,"./function/utils/clone":189,"./function/utils/format":190,"./function/utils/isInteger":191,"./function/utils/isNaN":192,"./function/utils/isNegative":193,"./function/utils/isNumeric":194,"./function/utils/isPositive":195,"./function/utils/isPrime":196,"./function/utils/isZero":197,"./function/utils/typeof":198}],200:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var parse = load(require('../parse'));

  /**
   * Parse and compile an expression.
   * Returns a an object with a function `eval([scope])` to evaluate the
   * compiled expression.
   *
   * Syntax:
   *
   *     math.compile(expr)                       // returns one node
   *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
   *
   * Examples:
   *
   *     var code = math.compile('sqrt(3^2 + 4^2)');
   *     code.eval(); // 5
   *
   *     var scope = {a: 3, b: 4}
   *     var code = math.compile('a * b'); // 12
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.compile(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].eval(); // 12
   *
   * See also:
   *
   *    parse, eval
   *
   * @param {string | string[] | Array | Matrix} expr
   *            The expression to be compiled
   * @return {{eval: Function} | Array.<{eval: Function}>} code
   *            An object with the compiled expression
   * @throws {Error}
   */
  return typed('compile', {
    'string': function (expr) {
      return parse(expr).compile();
    },

    'Array | Matrix': function (expr) {
      return deepMap(expr, function (entry) {
        return parse(entry).compile();
      });
    }
  });
}

exports.name = 'compile';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../parse":228}],201:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var parse = load(require('../parse'));

  /**
   * Evaluate an expression.
   *
   * Syntax:
   *
   *     math.eval(expr)
   *     math.eval(expr, scope)
   *     math.eval([expr1, expr2, expr3, ...])
   *     math.eval([expr1, expr2, expr3, ...], scope)
   *
   * Example:
   *
   *     math.eval('(2+3)/4');                // 1.25
   *     math.eval('sqrt(3^2 + 4^2)');        // 5
   *     math.eval('sqrt(-4)');               // 2i
   *     math.eval(['a=3', 'b=4', 'a*b']);,   // [3, 4, 12]
   *
   *     var scope = {a:3, b:4};
   *     math.eval('a * b', scope);           // 12
   *
   * See also:
   *
   *    parse, compile
   *
   * @param {string | string[] | Matrix} expr   The expression to be evaluated
   * @param {Object} [scope]                    Scope to read/write variables
   * @return {*} The result of the expression
   * @throws {Error}
   */
  return typed('compile', {
    'string': function (expr) {
      var scope = {};
      return parse(expr).compile().eval(scope);
    },

    'string, Object': function (expr, scope) {
      return parse(expr).compile().eval(scope);
    },

    'Array | Matrix': function (expr) {
      var scope = {};
      return deepMap(expr, function (entry) {
        return parse(entry).compile().eval(scope);
      });
    },

    'Array | Matrix, Object': function (expr, scope) {
      return deepMap(expr, function (entry) {
        return parse(entry).compile().eval(scope);
      });
    }
  });
}

exports.name = 'eval';
exports.factory = factory;
},{"../../utils/collection/deepMap":353,"../parse":228}],202:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed, math) {
  var docs = load(require('../docs'));

  /**
   * Retrieve help on a function or data type.
   * Help files are retrieved from the documentation in math.expression.docs.
   *
   * Syntax:
   *
   *    math.help(search)
   *
   * Examples:
   *
   *    console.log(math.help('sin').toString());
   *    console.log(math.help(math.add).toString());
   *    console.log(math.help(math.add).toJSON());
   *
   * @param {Function | string | Object} search   A function or function name
   *                                              for which to get help
   * @return {Help} A help object
   */
  return typed('help', {
    'any': function (search) {
      var prop;
      var name = search;

      if (typeof search !== 'string') {
        for (prop in math) {
          // search in functions and constants
          if (math.hasOwnProperty(prop) && (search === math[prop])) {
            name = prop;
            break;
          }
        }

        /* TODO: implement help for data types
         if (!text) {
         // search data type
         for (prop in math.type) {
         if (math.type.hasOwnProperty(prop)) {
         if (search === math.type[prop]) {
         text = prop;
         break;
         }
         }
         }
         }
         */
      }

      var doc = docs[name];
      if (!doc) {
        throw new Error('No documentation found on "' + name + '"');
      }
      return new type.Help(doc);
    }
  });
}

exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.name = 'help';
exports.factory = factory;

},{"../docs":199}],203:[function(require,module,exports){
module.exports = [
  require('./compile'),
  require('./eval'),
  require('./help'),
  require('./parse'),
  require('./parser')
];

},{"./compile":200,"./eval":201,"./help":202,"./parse":204,"./parser":205}],204:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var parse = load(require('../parse'));

  /**
   * Parse an expression. Returns a node tree, which can be evaluated by
   * invoking node.eval();
   *
   * Syntax:
   *
   *     math.parse(expr)
   *     math.parse(expr, options)
   *     math.parse([expr1, expr2, expr3, ...])
   *     math.parse([expr1, expr2, expr3, ...], options)
   *
   * Example:
   *
   *     var node = math.parse('sqrt(3^2 + 4^2)');
   *     node.compile().eval(); // 5
   *
   *     var scope = {a:3, b:4}
   *     var node = math.parse('a * b'); // 12
   *     var code = node.compile();
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].compile().eval(); // 12
   *
   * See also:
   *
   *     eval, compile
   *
   * @param {string | string[] | Matrix} expr          Expression to be parsed
   * @param {{nodes: Object<string, Node>}} [options]  Available options:
   *                                                   - `nodes` a set of custom nodes
   * @return {Node | Node[]} node
   * @throws {Error}
   */
  return typed('parse', {
    'string | Array | Matrix': parse,
    'string | Array | Matrix, Object': parse
  });
}

exports.name = 'parse';
exports.factory = factory;

},{"../parse":228}],205:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed, math) {
  var Parser = load(require('../Parser'));

  /**
   * Create a parser. The function creates a new `math.expression.Parser` object.
   *
   * Syntax:
   *
   *    math.parser()
   *
   * Examples:
   *
   *     var parser = new math.parser();
   *
   *     // evaluate expressions
   *     var a = parser.eval('sqrt(3^2 + 4^2)'); // 5
   *     var b = parser.eval('sqrt(-4)');        // 2i
   *     var c = parser.eval('2 inch in cm');    // 5.08 cm
   *     var d = parser.eval('cos(45 deg)');     // 0.7071067811865476
   *
   *     // define variables and functions
   *     parser.eval('x = 7 / 2');               // 3.5
   *     parser.eval('x + 3');                   // 6.5
   *     parser.eval('function f(x, y) = x^y');  // f(x, y)
   *     parser.eval('f(2, 3)');                 // 8
   *
   *     // get and set variables and functions
   *     var x = parser.get('x');                // 7
   *     var f = parser.get('f');                // function
   *     var g = f(3, 2);                        // 9
   *     parser.set('h', 500);
   *     var i = parser.eval('h / 2');           // 250
   *     parser.set('hello', function (name) {
   *       return 'hello, ' + name + '!';
   *     });
   *     parser.eval('hello("user")');           // "hello, user!"
   *
   *     // clear defined functions and variables
   *     parser.clear();
   *
   * See also:
   *
   *    eval, compile, parse
   *
   * @return {Parser} Parser
   */
  return typed('parser', {
    '': function () {
      return new Parser(math);
    }
  });
}

exports.name = 'parser';
exports.factory = factory;
exports.math = true; // requires the math namespace as 5th argument

},{"../Parser":18}],206:[function(require,module,exports){
module.exports = [
  require('./docs'),
  require('./function'),
  require('./node'),
  require('./transform'),

  require('./Help'),
  require('./parse'),
  require('./Parser')
];

},{"./Help":17,"./Parser":18,"./docs":199,"./function":203,"./node":224,"./parse":228,"./transform":233}],207:[function(require,module,exports){
'use strict';

// Reserved keywords not allowed to use in the parser
module.exports = {
  end: true
};

},{}],208:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var access = load(require('./utils/access'));

  /**
   * @constructor AccessorNode
   * @extends {Node}
   * Access an object property or get a matrix subset
   *
   * @param {Node} object                 The object from which to retrieve
   *                                      a property or subset.
   * @param {IndexNode} index             IndexNode containing ranges
   */
  function AccessorNode(object, index) {
    if (!(this instanceof AccessorNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (!(object && object.isNode)) {
      throw new TypeError('Node expected for parameter "object"');
    }
    if (!(index && index.isIndexNode)) {
      throw new TypeError('IndexNode expected for parameter "index"');
    }

    this.object = object || null;
    this.index = index;

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        if (this.index) {
          return (this.index.isObjectProperty())
              ? this.index.getObjectProperty()
              : '';
        }
        else {
          return this.object.name || '';
        }
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });
  }

  AccessorNode.prototype = new Node();

  AccessorNode.prototype.type = 'AccessorNode';

  AccessorNode.prototype.isAccessorNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
    defs.access = access;

    var object = this.object._compile(defs, args);
    var index = this.index._compile(defs, args);

    if (this.index.isObjectProperty()) {
      return object + '["' + this.index.getObjectProperty() + '"]';
    }
    else if (this.index.needsSize()) {
      // if some parameters use the 'end' parameter, we need to calculate the size
      return '(function () {' +
          '  var object = ' + object + ';' +
          '  var size = math.size(object).valueOf();' +
          '  return access(object, ' + index + ');' +
          '})()';
    }
    else {
      return 'access(' + object + ', ' + index + ')';
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  AccessorNode.prototype.forEach = function (callback) {
    callback(this.object, 'object', this);
    callback(this.index, 'index', this);
  };

  /**
   * Create a new AccessorNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {AccessorNode} Returns a transformed copy of the node
   */
  AccessorNode.prototype.map = function (callback) {
    return new AccessorNode(
        this._ifNode(callback(this.object, 'object', this)),
        this._ifNode(callback(this.index, 'index', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {AccessorNode}
   */
  AccessorNode.prototype.clone = function () {
    return new AccessorNode(this.object, this.index);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string}
   */
  AccessorNode.prototype._toString = function (options) {
    var object = this.object.toString(options);
    if (needParenthesis(this.object)) {
      object = '(' + object + ')';
    }

    return object + this.index.toString(options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string}
   */
  AccessorNode.prototype._toTex = function (options) {
    var object = this.object.toTex(options);
    if (needParenthesis(this.object)) {
      object = '\\left(' + object + '\\right)';
    }

    return object + this.index.toTex(options);
  };

  /**
   * Are parenthesis needed?
   * @private
   */
  function needParenthesis(node) {
    // TODO: maybe make a method on the nodes which tells whether they need parenthesis?
    return !(node.isAccessorNode || node.isArrayNode || node.isConstantNode
        || node.isFunctionNode || node.isObjectNode || node.isParenthesisNode
        || node.isSymbolNode);
  }

  return AccessorNode;
}

exports.name = 'AccessorNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"./Node":217,"./utils/access":225}],209:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor ArrayNode
   * @extends {Node}
   * Holds an 1-dimensional array with items
   * @param {Node[]} [items]   1 dimensional array with items
   */
  function ArrayNode(items) {
    if (!(this instanceof ArrayNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.items = items || [];

    // validate input
    if (!Array.isArray(this.items)
        || !this.items.every(function (item) {return item && item.isNode;})) {
      throw new TypeError('Array containing Nodes expected');
    }

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');
    };
    Object.defineProperty(this, 'nodes', { get: deprecated, set: deprecated });
  }

  ArrayNode.prototype = new Node();

  ArrayNode.prototype.type = 'ArrayNode';

  ArrayNode.prototype.isArrayNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @private
   */
  ArrayNode.prototype._compile = function (defs, args) {
    var asMatrix = (defs.math.config().matrix !== 'Array');

    var items = this.items.map(function (node) {
      return node._compile(defs, args);
    });

    return (asMatrix ? 'math.matrix([' : '[') +
        items.join(',') +
        (asMatrix ? '])' : ']');
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ArrayNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.items.length; i++) {
      var node = this.items[i];
      callback(node, 'items[' + i + ']', this);
    }
  };

  /**
   * Create a new ArrayNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ArrayNode} Returns a transformed copy of the node
   */
  ArrayNode.prototype.map = function (callback) {
    var items = [];
    for (var i = 0; i < this.items.length; i++) {
      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));
    }
    return new ArrayNode(items);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ArrayNode}
   */
  ArrayNode.prototype.clone = function() {
    return new ArrayNode(this.items.slice(0));
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ArrayNode.prototype._toString = function(options) {
    var items = this.items.map(function (node) {
      return node.toString(options);
    });
    return '[' + items.join(', ') + ']';
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ArrayNode.prototype._toTex = function(options) {
    var s = '\\begin{bmatrix}';

    this.items.forEach(function(node) {
      if (node.items) {
        s += node.items.map(function(childNode) {
          return childNode.toTex(options);
        }).join('&');
      }
      else {
        s += node.toTex(options);
      }

      // new line
      s += '\\\\';
    });
    s += '\\end{bmatrix}';
    return s;
  };

  return ArrayNode;
}

exports.name = 'ArrayNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"./Node":217}],210:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var ArrayNode = load(require('./ArrayNode'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var assign = load(require('./utils/assign'));
  var access = load(require('./utils/access'));

  var keywords = require('../keywords');
  var operators = require('../operators');

  /**
   * @constructor AssignmentNode
   * @extends {Node}
   *
   * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
   * replace a subset of a matrix like `A[2,2]=42`.
   *
   * Syntax:
   *
   *     new AssignmentNode(symbol, value)
   *     new AssignmentNode(object, index, value)
   *
   * Usage:
   *
   *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2));                      // a=2
   *    new AssignmentNode(new SymbolNode('a'), new IndexNode('b'), new ConstantNode(2))   // a.b=2
   *    new AssignmentNode(new SymbolNode('a'), new IndexNode(1, 2), new ConstantNode(3))  // a[1,2]=3
   *
   * @param {SymbolNode | AccessorNode} object  Object on which to assign a value
   * @param {IndexNode} [index=null]            Index, property name or matrix
   *                                            index. Optional. If not provided
   *                                            and `object` is a SymbolNode,
   *                                            the property is assigned to the
   *                                            global scope.
   * @param {Node} value                        The value to be assigned
   */
  function AssignmentNode(object, index, value) {
    if (!(this instanceof AssignmentNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.object = object;
    this.index = value ? index : null;
    this.value = value ? value : index;

    // validate input
    if (!object || !(object.isSymbolNode || object.isAccessorNode)) {
      throw new TypeError('SymbolNode or AccessorNode expected as "object"');
    }
    if (object && object.isSymbolNode && object.name === 'end') {
      throw new Error('Cannot assign to symbol "end"');
    }
    if (this.index && !this.index.isIndexNode) {
      throw new TypeError('IndexNode expected as "index"');
    }
    if (!this.value || !this.value.isNode) {
      throw new TypeError('Node expected as "value"');
    }

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        if (this.index) {
          return (this.index.isObjectProperty())
              ? this.index.getObjectProperty()
              : '';
        }
        else {
          return this.object.name || '';
        }
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });
  }

  AssignmentNode.prototype = new Node();

  AssignmentNode.prototype.type = 'AssignmentNode';

  AssignmentNode.prototype.isAssignmentNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @private
   */
  AssignmentNode.prototype._compile = function (defs, args) {
    defs.assign = assign;
    defs.access = access;

    var size;
    var object = this.object._compile(defs, args);
    var index = this.index ? this.index._compile(defs, args) : null;
    var value = this.value._compile(defs, args);

    if (!this.index) {
      // apply a variable to the scope, for example `a=2`
      if (!this.object.isSymbolNode) {
        throw new TypeError('SymbolNode expected as object');
      }

      return 'scope["' + this.object.name + '"] = ' + value;
    }
    else if (this.index.isObjectProperty()) {
      // apply an object property for example `a.b=2`
      return object + '["' + this.index.getObjectProperty() + '"] = ' + value;
    }
    else if (this.object.isSymbolNode) {
      // update a matrix subset, for example `a[2]=3`
      size = this.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';

      // apply updated object to scope
      return '(function () {' +
          '  var object = ' + object + ';' +
          '  var value = ' + value + ';' +
          '  ' + size +
          '  scope["' + this.object.name + '"] = assign(object, ' + index + ', value);' +
          '  return value;' +
          '})()';
    }
    else { // this.object.isAccessorNode === true
      // update a matrix subset, for example `a.b[2]=3`
      size = this.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';

      // we will not use the _compile of the AccessorNode, but compile it
      // ourselves here as we need the parent object of the AccessorNode:
      // wee need to apply the updated object to parent object
      var parentObject = this.object.object._compile(defs, args);

      if (this.object.index.isObjectProperty()) {
        var parentProperty = '["' + this.object.index.getObjectProperty() + '"]';
        return '(function () {' +
            '  var parent = ' + parentObject + ';' +
            '  var object = parent' + parentProperty + ';' + // parentIndex is a property
            '  var value = ' + value + ';' +
            size +
            '  parent' + parentProperty + ' = assign(object, ' + index + ', value);' +
            '  return value;' +
            '})()';
      }
      else {
        // if some parameters use the 'end' parameter, we need to calculate the size
        var parentSize = this.object.index.needsSize() ? 'var size = math.size(parent).valueOf();' : '';
        var parentIndex = this.object.index._compile(defs, args);

        return '(function () {' +
            '  var parent = ' + parentObject + ';' +
            '  ' + parentSize +
            '  var parentIndex = ' + parentIndex + ';' +
            '  var object = access(parent, parentIndex);' +
            '  var value = ' + value + ';' +
            '  ' + size +
            '  assign(parent, parentIndex, assign(object, ' + index + ', value));' +
            '  return value;' +
            '})()';
      }
    }
  };


  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  AssignmentNode.prototype.forEach = function (callback) {
    callback(this.object, 'object', this);
    if (this.index) {
      callback(this.index, 'index', this);
    }
    callback(this.value, 'value', this);
  };

  /**
   * Create a new AssignmentNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {AssignmentNode} Returns a transformed copy of the node
   */
  AssignmentNode.prototype.map = function (callback) {
    var object = this._ifNode(callback(this.object, 'object', this));
    var index = this.index
        ? this._ifNode(callback(this.index, 'index', this))
        : null;
    var value = this._ifNode(callback(this.value, 'value', this));

    return new AssignmentNode(object, index, value);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {AssignmentNode}
   */
  AssignmentNode.prototype.clone = function() {
    return new AssignmentNode(this.object, this.index, this.value);
  };

  /*
   * Is parenthesis needed?
   * @param {node} node
   * @param {string} [parenthesis='keep']
   * @private
   */
  function needParenthesis(node, parenthesis) {
    if (!parenthesis) {
      parenthesis = 'keep';
    }

    var precedence = operators.getPrecedence(node, parenthesis);
    var exprPrecedence = operators.getPrecedence(node.value, parenthesis);
    return (parenthesis === 'all')
      || ((exprPrecedence !== null) && (exprPrecedence <= precedence));
  }

  /**
   * Get string representation
   * @param {Object} options
   * @return {string}
   */
  AssignmentNode.prototype._toString = function(options) {
    var object = this.object.toString(options);
    var index = this.index ? this.index.toString(options) : '';
    var value = this.value.toString(options);
    if (needParenthesis(this, options && options.parenthesis)) {
      value = '(' + value + ')';
    }

    return object + index + ' = ' + value;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string}
   */
  AssignmentNode.prototype._toTex = function(options) {
    var object = this.object.toTex(options);
    var index = this.index ? this.index.toTex(options) : '';
    var value = this.value.toTex(options);
    if (needParenthesis(this, options && options.parenthesis)) {
      value = '\\left(' + value + '\\right)';
    }

    return object + index + ':=' + value;
  };

  return AssignmentNode;
}

exports.name = 'AssignmentNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/latex":360,"../keywords":207,"../operators":227,"./ArrayNode":209,"./Node":217,"./utils/access":225,"./utils/assign":226}],211:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var ResultSet = load(require('../../type/resultset/ResultSet'));

  /**
   * @constructor BlockNode
   * @extends {Node}
   * Holds a set with blocks
   * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
   *            An array with blocks, where a block is constructed as an Object
   *            with properties block, which is a Node, and visible, which is
   *            a boolean. The property visible is optional and is true by default
   */
  function BlockNode(blocks) {
    if (!(this instanceof BlockNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input, copy blocks
    if (!Array.isArray(blocks)) throw new Error('Array expected');
    this.blocks = blocks.map(function (block) {
      var node = block && block.node;
      var visible = block && block.visible !== undefined ? block.visible : true;

      if (!(node && node.isNode))      throw new TypeError('Property "node" must be a Node');
      if (typeof visible !== 'boolean') throw new TypeError('Property "visible" must be a boolean');

      return {
        node: node,
        visible: visible
      }
    });
  }

  BlockNode.prototype = new Node();

  BlockNode.prototype.type = 'BlockNode';

  BlockNode.prototype.isBlockNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  BlockNode.prototype._compile = function (defs, args) {
    defs.ResultSet = ResultSet;
    var blocks = this.blocks.map(function (param) {
      var js = param.node._compile(defs, args);
      if (param.visible) {
        return 'results.push(' + js + ');';
      }
      else {
        return js + ';';
      }
    });

    return '(function () {' +
        'var results = [];' +
        blocks.join('') +
        'return new ResultSet(results);' +
        '})()';
  };

  /**
   * Execute a callback for each of the child blocks of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  BlockNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.blocks.length; i++) {
      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);
    }
  };

  /**
   * Create a new BlockNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {BlockNode} Returns a transformed copy of the node
   */
  BlockNode.prototype.map = function (callback) {
    var blocks = [];
    for (var i = 0; i < this.blocks.length; i++) {
      var block = this.blocks[i];
      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));
      blocks[i] = {
        node: node,
        visible: block.visible
      };
    }
    return new BlockNode(blocks);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {BlockNode}
   */
  BlockNode.prototype.clone = function () {
    var blocks = this.blocks.map(function (block) {
      return {
        node: block.node,
        visible: block.visible
      };
    });

    return new BlockNode(blocks);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  BlockNode.prototype._toString = function (options) {
    return this.blocks.map(function (param) {
      return param.node.toString(options) + (param.visible ? '' : ';');
    }).join('\n');
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  BlockNode.prototype._toTex = function (options) {
    return this.blocks.map(function (param) {
      return param.node.toTex(options) + (param.visible ? '' : ';');
    }).join('\\;\\;\n');
  };

  return BlockNode;
}

exports.name = 'BlockNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../type/resultset/ResultSet":343,"./Node":217}],212:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');
var operators = require('../operators');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
   *
   * @param {Node} condition   Condition, must result in a boolean
   * @param {Node} trueExpr    Expression evaluated when condition is true
   * @param {Node} falseExpr   Expression evaluated when condition is true
   *
   * @constructor ConditionalNode
   * @extends {Node}
   */
  function ConditionalNode(condition, trueExpr, falseExpr) {
    if (!(this instanceof ConditionalNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
    if (!(condition && condition.isNode)) throw new TypeError('Parameter condition must be a Node');
    if (!(trueExpr && trueExpr.isNode))  throw new TypeError('Parameter trueExpr must be a Node');
    if (!(falseExpr && falseExpr.isNode)) throw new TypeError('Parameter falseExpr must be a Node');

    this.condition = condition;
    this.trueExpr = trueExpr;
    this.falseExpr = falseExpr;
  }

  ConditionalNode.prototype = new Node();

  ConditionalNode.prototype.type = 'ConditionalNode';

  ConditionalNode.prototype.isConditionalNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ConditionalNode.prototype._compile = function (defs, args) {
    /**
     * Test whether a condition is met
     * @param {*} condition
     * @returns {boolean} true if condition is true or non-zero, else false
     */
    defs.testCondition = function (condition) {
      if (typeof condition === 'number'
          || typeof condition === 'boolean'
          || typeof condition === 'string') {
        return condition ? true : false;
      }

      if (condition) {
        if (condition.isBigNumber === true) {
          return condition.isZero() ? false : true;
        }

        if (condition.isComplex === true) {
          return (condition.re || condition.im) ? true : false;
        }

        if (condition.isUnit === true) {
          return condition.value ? true : false;
        }
      }

      if (condition === null || condition === undefined) {
        return false;
      }

      throw new TypeError('Unsupported type of condition "' + defs.math['typeof'](condition) + '"');
    };

    return (
      'testCondition(' + this.condition._compile(defs, args) + ') ? ' +
      '( ' + this.trueExpr._compile(defs, args) + ') : ' +
      '( ' + this.falseExpr._compile(defs, args) + ')'
    );
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ConditionalNode.prototype.forEach = function (callback) {
    callback(this.condition, 'condition', this);
    callback(this.trueExpr, 'trueExpr', this);
    callback(this.falseExpr, 'falseExpr', this);
  };

  /**
   * Create a new ConditionalNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ConditionalNode} Returns a transformed copy of the node
   */
  ConditionalNode.prototype.map = function (callback) {
    return new ConditionalNode(
        this._ifNode(callback(this.condition, 'condition', this)),
        this._ifNode(callback(this.trueExpr, 'trueExpr', this)),
        this._ifNode(callback(this.falseExpr, 'falseExpr', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ConditionalNode}
   */
  ConditionalNode.prototype.clone = function () {
    return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  ConditionalNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var precedence = operators.getPrecedence(this, parenthesis);

    //Enclose Arguments in parentheses if they are an OperatorNode
    //or have lower or equal precedence
    //NOTE: enclosing all OperatorNodes in parentheses is a decision
    //purely based on aesthetics and readability
    var condition = this.condition.toString(options);
    var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);
    if ((parenthesis === 'all')
        || (this.condition.type === 'OperatorNode')
        || ((conditionPrecedence !== null) && (conditionPrecedence <= precedence))) {
      condition = '(' + condition + ')';
    }

    var trueExpr = this.trueExpr.toString(options);
    var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);
    if ((parenthesis === 'all')
        || (this.trueExpr.type === 'OperatorNode')
        || ((truePrecedence !== null) && (truePrecedence <= precedence))) {
      trueExpr = '(' + trueExpr + ')';
    }

    var falseExpr = this.falseExpr.toString(options);
    var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);
    if ((parenthesis === 'all')
        || (this.falseExpr.type === 'OperatorNode')
        || ((falsePrecedence !== null) && (falsePrecedence <= precedence))) {
      falseExpr = '(' + falseExpr + ')';
    }
    return condition + ' ? ' + trueExpr + ' : ' + falseExpr;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ConditionalNode.prototype._toTex = function (options) {
    return '\\begin{cases} {'
        + this.trueExpr.toTex(options) + '}, &\\quad{\\text{if }\\;'
        + this.condition.toTex(options)
        + '}\\\\{' + this.falseExpr.toTex(options)
        + '}, &\\quad{\\text{otherwise}}\\end{cases}';
  };

  return ConditionalNode;
}

exports.name = 'ConditionalNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/latex":360,"../operators":227,"./Node":217}],213:[function(require,module,exports){
'use strict';

var getType = require('../../utils/types').type;

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * A ConstantNode holds a constant value like a number or string. A ConstantNode
   * stores a stringified version of the value and uses this to compile to
   * JavaScript.
   *
   * In case of a stringified number as input, this may be compiled to a BigNumber
   * when the math instance is configured for BigNumbers.
   *
   * Usage:
   *
   *     // stringified values with type
   *     new ConstantNode('2.3', 'number');
   *     new ConstantNode('true', 'boolean');
   *     new ConstantNode('hello', 'string');
   *
   *     // non-stringified values, type will be automatically detected
   *     new ConstantNode(2.3);
   *     new ConstantNode('hello');
   *
   * @param {string | number | boolean | null | undefined} value
   *                            When valueType is provided, value must contain
   *                            an uninterpreted string representing the value.
   *                            When valueType is undefined, value can be a
   *                            number, string, boolean, null, or undefined, and
   *                            the type will be determined automatically.
   * @param {string} [valueType]  The type of value. Choose from 'number', 'string',
   *                              'boolean', 'undefined', 'null'
   * @constructor ConstantNode
   * @extends {Node}
   */
  function ConstantNode(value, valueType) {
    if (!(this instanceof ConstantNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (valueType) {
      if (typeof valueType !== 'string') {
        throw new TypeError('String expected for parameter "valueType"');
      }
      if (typeof value !== 'string') {
        throw new TypeError('String expected for parameter "value"');
      }

      this.value = value;
      this.valueType = valueType;
    }
    else {
      // stringify the value and determine the type
      this.value = value + '';
      this.valueType = getType(value);
    }

    if (!SUPPORTED_TYPES[this.valueType]) {
      throw new TypeError('Unsupported type of value "' + this.valueType + '"');
    }
  }

  var SUPPORTED_TYPES = {
    'number': true,
    'string': true,
    'boolean': true,
    'undefined': true,
    'null': true
  };

  ConstantNode.prototype = new Node();

  ConstantNode.prototype.type = 'ConstantNode';

  ConstantNode.prototype.isConstantNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ConstantNode.prototype._compile = function (defs, args) {
    switch (this.valueType) {
      case 'number':
        // TODO: replace this with using config.number
        var numConfig = defs.math.config().number;
        if (numConfig === 'BigNumber') {
          return 'math.bignumber("' + this.value + '")';
        }
        else if (numConfig === 'Fraction') {
          return 'math.fraction("' + this.value + '")';
        }
        else {
          // remove leading zeros like '003.2' which are not allowed by JavaScript
          return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
            return match.substring(zeros.length);
          });
        }

      case 'string':
        return '"' + this.value + '"';

      case 'boolean':
        return this.value;

      case 'undefined':
        return this.value;

      case 'null':
        return this.value;

      default:
        // TODO: move this error to the constructor?
        throw new TypeError('Unsupported type of constant "' + this.valueType + '"');
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ConstantNode.prototype.forEach = function (callback) {
    // nothing to do, we don't have childs
  };


  /**
   * Create a new ConstantNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {ConstantNode} Returns a clone of the node
   */
  ConstantNode.prototype.map = function (callback) {
    return this.clone();
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ConstantNode}
   */
  ConstantNode.prototype.clone = function () {
    return new ConstantNode(this.value, this.valueType);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  ConstantNode.prototype._toString = function (options) {
    switch (this.valueType) {
      case 'string':
        return '"' + this.value + '"';

      default:
        return this.value;
    }
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ConstantNode.prototype._toTex = function (options) {
    var value = this.value,
        index;
    switch (this.valueType) {
      case 'string':
        return '\\mathtt{"' + value + '"}';

      case 'number':
        index = value.toLowerCase().indexOf('e');
        if (index !== -1) {
          return value.substring(0, index) + '\\cdot10^{' +
              value.substring(index + 1) + '}';
        }
        return value;

      default:
        return value;
    }
  };

  return ConstantNode;
}

exports.name = 'ConstantNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/types":364,"./Node":217}],214:[function(require,module,exports){
'use strict';

var keywords = require('../keywords');
var latex = require('../../utils/latex');
var operators = require('../operators');

function isString (x) {
  return typeof x === 'string';
}

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor FunctionAssignmentNode
   * @extends {Node}
   * Function assignment
   *
   * @param {string} name           Function name
   * @param {string[] | Array.<{name: string, type: string}>} params
   *                                Array with function parameter names, or an
   *                                array with objects containing the name
   *                                and type of the parameter
   * @param {Node} expr             The function expression
   */
  function FunctionAssignmentNode(name, params, expr) {
    if (!(this instanceof FunctionAssignmentNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
    if (!Array.isArray(params))  throw new TypeError('Array containing strings or objects expected for parameter "params"');
    if (!(expr && expr.isNode)) throw new TypeError('Node expected for parameter "expr"');
    if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');

    this.name = name;
    this.params = params.map(function (param) {
      return param && param.name || param;
    });
    this.types = params.map(function (param) {
      return param && param.type || 'any'
    });
    this.expr = expr;
  }

  FunctionAssignmentNode.prototype = new Node();

  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';

  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  FunctionAssignmentNode.prototype._compile = function (defs, args) {
    defs.typed = typed;

    // we extend the original args and add the args to the child object
    var childArgs = Object.create(args);
    this.params.forEach(function (variable) {
      childArgs[variable] = true;
    });

    // compile the function expression with the child args
    var jsExpr = this.expr._compile(defs, childArgs);

    return 'scope["' + this.name + '"] = ' +
        '  (function () {' +
        '    var fn = typed("' + this.name + '", {' +
        '      "' + this.types.join(',') + '": function (' + this.params.join(',') + ') {' +
        '        return ' + jsExpr + '' +
        '      }' +
        '    });' +
        '    fn.syntax = "' + this.name + '(' + this.params.join(', ') + ')";' +
        '    return fn;' +
        '  })()';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  FunctionAssignmentNode.prototype.forEach = function (callback) {
    callback(this.expr, 'expr', this);
  };

  /**
   * Create a new FunctionAssignmentNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
   */
  FunctionAssignmentNode.prototype.map = function (callback) {
    var expr = this._ifNode(callback(this.expr, 'expr', this));

    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {FunctionAssignmentNode}
   */
  FunctionAssignmentNode.prototype.clone = function () {
    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
  };

  /**
   * Is parenthesis needed?
   * @param {Node} node
   * @param {Object} parenthesis
   * @private
   */
  function needParenthesis(node, parenthesis) {
    var precedence = operators.getPrecedence(node, parenthesis);
    var exprPrecedence = operators.getPrecedence(node.expr, parenthesis);

    return (parenthesis === 'all')
      || ((exprPrecedence !== null) && (exprPrecedence <= precedence));
  }

  /**
   * get string representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionAssignmentNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var expr = this.expr.toString(options);
    if (needParenthesis(this, parenthesis)) {
      expr = '(' + expr + ')';
    }
    return this.name + '(' + this.params.join(', ') + ') = ' + expr;
  };

  /**
   * get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionAssignmentNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var expr = this.expr.toTex(options);
    if (needParenthesis(this, parenthesis)) {
      expr = '\\left(' + expr + '\\right)';
    }

    return '\\mathrm{' + this.name
        + '}\\left(' + this.params.map(latex.toSymbol).join(',') + '\\right):=' + expr;
  };

  return FunctionAssignmentNode;
}
exports.name = 'FunctionAssignmentNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/latex":360,"../keywords":207,"../operators":227,"./Node":217}],215:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');

function factory (type, config, load, typed, math) {
  var Node = load(require('./Node'));
  var SymbolNode = load(require('./SymbolNode'));

  /**
   * @constructor FunctionNode
   * @extends {./Node}
   * invoke a list with arguments on a node
   * @param {./Node | string} fn Node resolving with a function on which to invoke
   *                             the arguments, typically a SymboNode or AccessorNode
   * @param {./Node[]} args
   */
  function FunctionNode(fn, args) {
    if (!(this instanceof FunctionNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (typeof fn === 'string') {
      fn = new SymbolNode(fn);
    }

    // validate input
    if (!fn || !fn.isNode) throw new TypeError('Node expected as parameter "fn"');
    if (!Array.isArray(args)
        || !args.every(function (arg) {return arg && arg.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "args"');
    }

    this.fn = fn;
    this.args = args || [];

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        return this.fn.name || '';
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');
    };
    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
  }

  FunctionNode.prototype = new Node();

  FunctionNode.prototype.type = 'FunctionNode';

  FunctionNode.prototype.isFunctionNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  FunctionNode.prototype._compile = function (defs, args) {
    // compile fn and arguments
    var jsFn = this.fn._compile(defs, args);
    var jsArgs = this.args.map(function (arg) {
      return arg._compile(defs, args);
    });
    var argsName;

    if (this.fn.isSymbolNode) {
      // we can statically determine whether the function has an rawArgs property
      var name = this.fn.name;
      var fn = defs.math[name];
      var isRaw = (typeof fn === 'function') && (fn.rawArgs == true);

      if (isRaw) {
        // pass unevaluated parameters (nodes) to the function
        argsName = this._getUniqueArgumentsName(defs);
        defs[argsName] = this.args;

        return jsFn + '(' + argsName + ', math, scope)';
      }
      else {
        // "regular" evaluation
        return jsFn + '(' + jsArgs.join(', ') + ')';
      }
    }
    else if (this.fn.isAccessorNode && this.fn.index.isObjectProperty()) {
      // execute the function with the right context: the object of the AccessorNode
      argsName = this._getUniqueArgumentsName(defs);
      defs[argsName] = this.args;

      var jsObject = this.fn.object._compile(defs, args);
      var prop = this.fn.index.getObjectProperty();

      return '(function () {' +
          'var object = ' + jsObject + ';' +
          'return (object["' + prop + '"] && object["' + prop + '"].rawArgs) ' +
          ' ? object["' + prop + '"](' + argsName + ', math, scope)' +
          ' : object["' + prop + '"](' + jsArgs.join(', ') + ')' +
          '})()';
    }
    else { // this.fn.isAccessorNode && !this.fn.index.isObjectProperty()
      // we have to dynamically determine whether the function has a rawArgs property
      argsName = this._getUniqueArgumentsName(defs);
      defs[argsName] = this.args;

      return '(function () {' +
          'var fn = ' + jsFn + ';' +
          'return (fn && fn.rawArgs) ' +
          ' ? fn(' + argsName + ', math, scope)' +
          ' : fn(' + jsArgs.join(', ') + ')' +
          '})()';
    }
  };

  /**
   * Get a unique name for a arguments to store in defs
   * @param {Object} defs
   * @return {string} A string like 'args1', 'args2', ...
   * @private
   */
  FunctionNode.prototype._getUniqueArgumentsName = function (defs) {
    var argsName;
    var i = 0;

    do {
      argsName = 'args' + i;
      i++;
    }
    while (argsName in defs);

    return argsName;
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  FunctionNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.args.length; i++) {
      callback(this.args[i], 'args[' + i + ']', this);
    }
  };

  /**
   * Create a new FunctionNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {FunctionNode} Returns a transformed copy of the node
   */
  FunctionNode.prototype.map = function (callback) {
    var fn = this.fn.map(callback);
    var args = [];
    for (var i = 0; i < this.args.length; i++) {
      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
    }
    return new FunctionNode(fn, args);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {FunctionNode}
   */
  FunctionNode.prototype.clone = function () {
    return new FunctionNode(this.fn, this.args.slice(0));
  };

  //backup Node's toString function
  //@private
  var nodeToString = FunctionNode.prototype.toString;

  /**
   * Get string representation. (wrapper function)
   * This overrides parts of Node's toString function.
   * If callback is an object containing callbacks, it
   * calls the correct callback for the current node,
   * otherwise it falls back to calling Node's toString
   * function.
   *
   * @param {Object} options
   * @return {string} str
   * @override
   */
  FunctionNode.prototype.toString = function (options) {
    var customString;
    var name = this.fn.toString(options);
    if (options && (typeof options.handler === 'object') && options.handler.hasOwnProperty(name)) {
      //callback is a map of callback functions
      customString = options.handler[name](this, options);
    }

    if (typeof customString !== 'undefined') {
      return customString;
    }

    //fall back to Node's toString
    return nodeToString.call(this, options);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionNode.prototype._toString = function (options) {
    var args = this.args.map(function (arg) {
      return arg.toString(options);
    });

    // format the arguments like "add(2, 4.2)"
    return this.fn.toString(options) + '(' + args.join(', ') + ')';
  };

  /*
   * Expand a LaTeX template
   *
   * @param {string} template
   * @param {Node} node
   * @param {Object} options
   * @private
   **/
  function expandTemplate(template, node, options) {
    var latex = '';

    // Match everything of the form ${identifier} or ${identifier[2]} or $$
    // while submatching identifier and 2 (in the second case)
    var regex = new RegExp('\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)', 'ig');

    var inputPos = 0;   //position in the input string
    var match;
    while ((match = regex.exec(template)) !== null) {   //go through all matches
      // add everything in front of the match to the LaTeX string
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;

      if (match[0] === '$$') { // escaped dollar sign
        latex += '$';
        inputPos++;
      }
      else { // template parameter
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError('Template: Property ' + match[1] + ' does not exist.');
        }
        if (match[2] === undefined) { //no square brackets
          switch (typeof property) {
            case 'string':
              latex += property;
              break;
            case 'object':
              if (property.isNode) {
                latex += property.toTex(options);
              }
              else if (Array.isArray(property)) {
                //make array of Nodes into comma separated list
                latex += property.map(function (arg, index) {
                  if (arg && arg.isNode) {
                    return arg.toTex(options);
                  }
                  throw new TypeError('Template: ' + match[1] + '[' + index + '] is not a Node.');
                }).join(',');
              }
              else {
                throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
              }
              break;
            default:
              throw new TypeError('Template: ' + match[1] + ' has to be a Node, String or array of Nodes');
          }
        }
        else { //with square brackets
          if (property[match[2]] && property[match[2]].isNode) {
            latex += property[match[2]].toTex(options);
          }
          else {
            throw new TypeError('Template: ' + match[1] + '[' + match[2] + '] is not a Node.');
          }
        }
      }
    }
    latex += template.slice(inputPos);  //append rest of the template

    return latex;
  }

  //backup Node's toTex function
  //@private
  var nodeToTex = FunctionNode.prototype.toTex;

  /**
   * Get LaTeX representation. (wrapper function)
   * This overrides parts of Node's toTex function.
   * If callback is an object containing callbacks, it
   * calls the correct callback for the current node,
   * otherwise it falls back to calling Node's toTex
   * function.
   *
   * @param {Object} options
   * @return {string}
   */
  FunctionNode.prototype.toTex = function (options) {
    var customTex;
    if (options && (typeof options.handler === 'object') && options.handler.hasOwnProperty(this.name)) {
      //callback is a map of callback functions
      customTex = options.handler[this.name](this, options);
    }

    if (typeof customTex !== 'undefined') {
      return customTex;
    }

    //fall back to Node's toTex
    return nodeToTex.call(this, options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  FunctionNode.prototype._toTex = function (options) {
    var args = this.args.map(function (arg) { //get LaTeX of the arguments
      return arg.toTex(options);
    });

    var latexConverter;

    if (math[this.name] && ((typeof math[this.name].toTex === 'function') || (typeof math[this.name].toTex === 'object') || (typeof math[this.name].toTex === 'string'))) {
      //.toTex is a callback function
      latexConverter = math[this.name].toTex;
    }

    var customToTex;
    switch (typeof latexConverter) {
      case 'function': //a callback function
        customToTex = latexConverter(this, options);
        break;
      case 'string': //a template string
        customToTex = expandTemplate(latexConverter, this, options);
        break;
      case 'object': //an object with different "converters" for different numbers of arguments
        switch (typeof latexConverter[args.length]) {
          case 'function':
            customToTex = latexConverter[args.length](this, options);
            break;
          case 'string':
            customToTex = expandTemplate(latexConverter[args.length], this, options);
            break;
        }
    }

    if (typeof customToTex !== 'undefined') {
      return customToTex;
    }

    return expandTemplate(latex.defaultTemplate, this, options);
  };

  /**
   * Get identifier.
   * @return {string}
   */
  FunctionNode.prototype.getIdentifier = function () {
    return this.type + ':' + this.name;
  };

  return FunctionNode;
}

exports.name = 'FunctionNode';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../utils/latex":360,"./Node":217,"./SymbolNode":222}],216:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));
  var RangeNode = load(require('./RangeNode'));
  var SymbolNode = load(require('./SymbolNode'));

  var Range = load(require('../../type/matrix/Range'));

  var isArray = Array.isArray;

  /**
   * @constructor IndexNode
   * @extends Node
   *
   * Describes a subset of a matrix or an object property.
   * Cannot be used on its own, needs to be used within an AccessorNode or
   * AssignmentNode.
   *
   * @param {Node[]} dimensions
   * @param {boolean} [dotNotation=false]  Optional property describing whether
   *                                       this index was written using dot
   *                                       notation like `a.b`, or using bracket
   *                                       notation like `a["b"]` (default).
   *                                       Used to stringify an IndexNode.
   */
  function IndexNode(dimensions, dotNotation) {
    if (!(this instanceof IndexNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.dimensions = dimensions;
    this.dotNotation = dotNotation || false;

    // validate input
    if (!isArray(dimensions)
        || !dimensions.every(function (range) {return range && range.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
    }
    if (this.dotNotation && !this.isObjectProperty()) {
      throw new Error('dotNotation only applicable for object properties');
    }

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');
    };
    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
  }

  IndexNode.prototype = new Node();

  IndexNode.prototype.type = 'IndexNode';

  IndexNode.prototype.isIndexNode = true;

  /**
   * Compile all range nodes
   *
   * When some of the dimensions has `end` defined, the IndexNode requires
   * a variable `size` to be defined in the current closure, and must contain
   * the size of the matrix that's being handled. To check whether the `size`
   * variable is needed, call IndexNode.needsSize().
   *
   * @param {Object} defs           Object which can be used to define functions
   *                                or constants globally available for the
   *                                compiled expression
   * @param {Object} args           Object with local function arguments, the key is
   *                                the name of the argument, and the value is `true`.
   *                                The object may not be mutated, but must be
   *                                extended instead.
   * @return {string} code
   */
  IndexNode.prototype._compile = function (defs, args) {
    // args can be mutated by IndexNode, when dimensions use `end`
    var childArgs = Object.create(args);

    // helper function to create a Range from start, step and end
    defs.range = function (start, end, step) {
      return new Range(
          (start && start.isBigNumber === true) ? start.toNumber() : start,
          (end   && end.isBigNumber === true)   ? end.toNumber()   : end,
          (step  && step.isBigNumber === true)  ? step.toNumber()  : step
      );
    };

    // TODO: implement support for bignumber (currently bignumbers are silently
    //       reduced to numbers when changing the value to zero-based)

    // TODO: Optimization: when the range values are ConstantNodes,
    //       we can beforehand resolve the zero-based value

    // optimization for a simple object property
    var dimensions = this.dimensions.map(function (range, i) {
      if (range && range.isRangeNode) {
        if (range.needsEnd()) {
          childArgs.end = true;

          // resolve end and create range
          return '(function () {' +
              'var end = size[' + i + ']; ' +
              'return range(' +
              range.start._compile(defs, childArgs) + ', ' +
              range.end._compile(defs, childArgs) + ', ' +
              (range.step ? range.step._compile(defs, childArgs) : '1') +
              '); ' +
              '})()';
        }
        else {
          // create range
          return 'range(' +
              range.start._compile(defs, childArgs) + ', ' +
              range.end._compile(defs, childArgs) + ', ' +
              (range.step ? range.step._compile(defs, childArgs) : '1') +
              ')';
        }
      }
      if (range.isSymbolNode && range.name === 'end') {
        childArgs.end = true;

        // resolve the parameter 'end'
        return '(function () {' +
            'var end = size[' + i + ']; ' +
            'return ' + range._compile(defs, childArgs) + '; ' +
            '})()'
      }
      else { // ConstantNode
        return range._compile(defs, childArgs);
      }
    });

    return 'math.index(' + dimensions.join(', ') + ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  IndexNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.dimensions.length; i++) {
      callback(this.dimensions[i], 'dimensions[' + i + ']', this);
    }
  };

  /**
   * Create a new IndexNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {IndexNode} Returns a transformed copy of the node
   */
  IndexNode.prototype.map = function (callback) {
    var dimensions = [];
    for (var i = 0; i < this.dimensions.length; i++) {
      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));
    }

    return new IndexNode(dimensions);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {IndexNode}
   */
  IndexNode.prototype.clone = function () {
    return new IndexNode(this.dimensions.slice(0));
  };

  /**
   * Test whether this IndexNode contains a single property name
   * @return {boolean}
   */
  IndexNode.prototype.isObjectProperty = function () {
    return this.dimensions.length === 1 &&
        this.dimensions[0].isConstantNode &&
        this.dimensions[0].valueType === 'string';
  };

  /**
   * Returns the property name if IndexNode contains a property.
   * If not, returns null.
   * @return {string | null}
   */
  IndexNode.prototype.getObjectProperty = function () {
    return this.isObjectProperty() ? this.dimensions[0].value : null;
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  IndexNode.prototype._toString = function (options) {
    // format the parameters like "[1, 0:5]"
    return this.dotNotation
        ? ('.' + this.getObjectProperty())
        : ('[' + this.dimensions.join(', ') + ']');
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  IndexNode.prototype._toTex = function (options) {
    var dimensions = this.dimensions.map(function (range) {
      return range.toTex(options);
    });

    return this.dotNotation
        ? ('.' + this.getObjectProperty() + '')
        : ('_{' + dimensions.join(',') + '}');
  };

  /**
   * Test whether this IndexNode needs the object size, size of the Matrix
   * @return {boolean}
   */
  IndexNode.prototype.needsSize = function () {
    return this.dimensions.some(function (range) {
      return (range.isRangeNode && range.needsEnd()) ||
          (range.isSymbolNode && range.name === 'end');
    });
  };

  return IndexNode;
}

exports.name = 'IndexNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../type/matrix/Range":327,"./Node":217,"./RangeNode":221,"./SymbolNode":222}],217:[function(require,module,exports){
'use strict';

var keywords = require('../keywords');
var extend = require('../../utils/object').extend;
var deepEqual= require('../../utils/object').deepEqual;

function factory (type, config, load, typed, math) {
  /**
   * Node
   */
  function Node() {
    if (!(this instanceof Node)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
  }

  /**
   * Evaluate the node
   * @param {Object} [scope]  Scope to read/write variables
   * @return {*}              Returns the result
   */
  Node.prototype.eval = function(scope) {
    return this.compile().eval(scope);
  };

  Node.prototype.type = 'Node';

  Node.prototype.isNode = true;

  Node.prototype.comment = '';

  /**
   * Compile the node to javascript code
   * @return {{eval: function}} expr  Returns an object with a function 'eval',
   *                                  which can be invoked as expr.eval([scope]),
   *                                  where scope is an optional object with
   *                                  variables.
   */
  Node.prototype.compile = function () {
    // TODO: calling compile(math) is deprecated since version 2.0.0. Remove this warning some day
    if (arguments.length > 0) {
      throw new Error('Calling compile(math) is deprecated. Call the function as compile() instead.');
    }

    // definitions globally available inside the closure of the compiled expressions
    var defs = {
      math: math.expression.transform,
      args: {}, // can be filled with names of FunctionAssignment arguments
      _validateScope: _validateScope
    };

    // will be used to put local function arguments
    var args = {};

    var code = this._compile(defs, args);

    var defsCode = Object.keys(defs).map(function (name) {
      return '    var ' + name + ' = defs["' + name + '"];';
    });

    var factoryCode =
        defsCode.join(' ') +
        'return {' +
        '  "eval": function (scope) {' +
        '    if (scope) _validateScope(scope);' +
        '    scope = scope || {};' +
        '    return ' + code + ';' +
        '  }' +
        '};';

    var factory = new Function('defs', factoryCode);
    return factory(defs);
  };

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          and constants globally available inside the closure
   *                          of the compiled expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  Node.prototype._compile = function (defs, args) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot compile a Node interface');
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  Node.prototype.forEach = function (callback) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot run forEach on a Node interface');
  };

  /**
   * Create a new Node having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {OperatorNode} Returns a transformed copy of the node
   */
  Node.prototype.map = function (callback) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot run map on a Node interface');
  };

  /**
   * Validate whether an object is a Node, for use with map
   * @param {Node} node
   * @returns {Node} Returns the input if it's a node, else throws an Error
   * @protected
   */
  Node.prototype._ifNode = function (node) {
    if (!(node && node.isNode)) {
      throw new TypeError('Callback function must return a Node');
    }

    return node;
  };

  /**
   * Recursively traverse all nodes in a node tree. Executes given callback for
   * this node and each of its child nodes.
   * @param {function(node: Node, path: string, parent: Node)} callback
   *          A callback called for every node in the node tree.
   */
  Node.prototype.traverse = function (callback) {
    // execute callback for itself
    callback(this, null, null);

    // recursively traverse over all childs of a node
    function _traverse(node, callback) {
      node.forEach(function (child, path, parent) {
        callback(child, path, parent);
        _traverse(child, callback);
      });
    }

    _traverse(this, callback);
  };

  /**
   * Recursively transform a node tree via a transform function.
   *
   * For example, to replace all nodes of type SymbolNode having name 'x' with a
   * ConstantNode with value 2:
   *
   *     var res = Node.transform(function (node, path, parent) {
   *       if (node && node.isSymbolNode) && (node.name == 'x')) {
   *         return new ConstantNode(2);
   *       }
   *       else {
   *         return node;
   *       }
   *     });
   *
   * @param {function(node: Node, path: string, parent: Node) : Node} callback
   *          A mapping function accepting a node, and returning
   *          a replacement for the node or the original node.
   *          Signature: callback(node: Node, index: string, parent: Node) : Node
   * @return {Node} Returns the original node or its replacement
   */
  Node.prototype.transform = function (callback) {
    // traverse over all childs
    function _transform (node, callback) {
      return node.map(function(child, path, parent) {
        var replacement = callback(child, path, parent);
        return _transform(replacement, callback);
      });
    }

    var replacement = callback(this, null, null);
    return _transform(replacement, callback);
  };

  /**
   * Find any node in the node tree matching given filter function. For example, to
   * find all nodes of type SymbolNode having name 'x':
   *
   *     var results = Node.filter(function (node) {
   *       return (node && node.isSymbolNode) && (node.name == 'x');
   *     });
   *
   * @param {function(node: Node, path: string, parent: Node) : Node} callback
   *            A test function returning true when a node matches, and false
   *            otherwise. Function signature:
   *            callback(node: Node, index: string, parent: Node) : boolean
   * @return {Node[]} nodes       An array with nodes matching given filter criteria
   */
  Node.prototype.filter = function (callback) {
    var nodes = [];

    this.traverse(function (node, path, parent) {
      if (callback(node, path, parent)) {
        nodes.push(node);
      }
    });

    return nodes;
  };

  // TODO: deprecated since version 1.1.0, remove this some day
  Node.prototype.find = function () {
    throw new Error('Function Node.find is deprecated. Use Node.filter instead.');
  };

  // TODO: deprecated since version 1.1.0, remove this some day
  Node.prototype.match = function () {
    throw new Error('Function Node.match is deprecated. See functions Node.filter, Node.transform, Node.traverse.');
  };

  /**
   * Create a shallow clone of this node
   * @return {Node}
   */
  Node.prototype.clone = function () {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot clone a Node interface');
  };

  /**
   * Create a deep clone of this node
   * @return {Node}
   */
  Node.prototype.cloneDeep = function () {
    return this.map(function (node) {
      return node.cloneDeep();
    });
  };

  /**
   * Deep compare this node with another node.
   * @param {Node} other
   * @return {boolean} Returns true when both nodes are of the same type and
   *                   contain the same values (as do their childs)
   */
  Node.prototype.equals = function (other) {
    return other
        ? deepEqual(this, other)
        : false
  };

  /**
   * Get string representation. (wrapper function)
   *
   * This function can get an object of the following form:
   * {
   *    handler: //This can be a callback function of the form
   *             // "function callback(node, options)"or
   *             // a map that maps function names (used in FunctionNodes)
   *             // to callbacks
   *    parenthesis: "keep" //the parenthesis option (This is optional)
   * }
   *
   * @param {Object} [options]
   * @return {string}
   */
  Node.prototype.toString = function (options) {
    var customString;
    if (options && typeof options == "object") {
        switch (typeof options.handler) {
          case 'object':
          case 'undefined':
            break;
          case 'function':
            customString = options.handler(this, options);
            break;
          default:
            throw new TypeError('Object or function expected as callback');
        }
    }

    if (typeof customString !== 'undefined') {
      return customString;
    }

    return this._toString(options);
  };

  /**
   * Internal function to generate the string output.
   * This has to be implemented by every Node
   *
   * @throws {Error}
   */
  Node.prototype._toString = function () {
    //must be implemented by each of the Node implementations
    throw new Error('_toString not implemented for ' + this.type);
  };

  /**
   * Get LaTeX representation. (wrapper function)
   *
   * This function can get an object of the following form:
   * {
   *    handler: //This can be a callback function of the form
   *             // "function callback(node, options)"or
   *             // a map that maps function names (used in FunctionNodes)
   *             // to callbacks
   *    parenthesis: "keep" //the parenthesis option (This is optional)
   * }
   *
   * @param {Object} [options]
   * @return {string}
   */
  Node.prototype.toTex = function (options) {
    var customTex;
    if (options && typeof options == 'object') {
      switch (typeof options.handler) {
        case 'object':
        case 'undefined':
          break;
        case 'function':
          customTex = options.handler(this, options);
          break;
        default:
          throw new TypeError('Object or function expected as callback');
      }
    }

    if (typeof customTex !== 'undefined') {
      return customTex;
    }

    return this._toTex(options);
  };

  /**
   * Internal function to generate the LaTeX output.
   * This has to be implemented by every Node
   *
   * @param {Object} [options]
   * @throws {Error}
   */
  Node.prototype._toTex = function (options) {
    //must be implemented by each of the Node implementations
    throw new Error('_toTex not implemented for ' + this.type);
  };

  /**
   * Get identifier.
   * @return {string}
   */
  Node.prototype.getIdentifier = function () {
    return this.type;
  };

  /**
   * Get the content of the current Node.
   * @return {Node} node
   **/
  Node.prototype.getContent = function () {
    return this;
  };

  /**
   * Validate the symbol names of a scope.
   * Throws an error when the scope contains an illegal symbol.
   * @param {Object} scope
   */
  function _validateScope(scope) {
    for (var symbol in scope) {
      if (scope.hasOwnProperty(symbol)) {
        if (symbol in keywords) {
          throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
        }
      }
    }
  }

  return Node;
}

exports.name = 'Node';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../utils/object":362,"../keywords":207}],218:[function(require,module,exports){
'use strict';

var string = require('../../utils/string');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor ObjectNode
   * @extends {Node}
   * Holds an object with keys/values
   * @param {Object.<string, Node>} [properties]   array with key/value pairs
   */
  function ObjectNode(properties) {
    if (!(this instanceof ObjectNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.properties = properties || {};

    // validate input
    if (properties) {
      if (!(typeof properties === 'object') || Object.keys(properties).some(function (key) {
            return !properties[key] || !properties[key].isNode;
          })) {
        throw new TypeError('Object containing Nodes expected');
      }
    }
  }

  ObjectNode.prototype = new Node();

  ObjectNode.prototype.type = 'ObjectNode';

  ObjectNode.prototype.isObjectNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} code
   * @private
   */
  ObjectNode.prototype._compile = function (defs, args) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push('"' + key + '": ' + this.properties[key]._compile(defs, args));
      }
    }
    return '{' + entries.join(', ') + '}';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ObjectNode.prototype.forEach = function (callback) {
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        callback(this.properties[key], 'properties["' + key + '"]', this);
      }
    }
  };

  /**
   * Create a new ObjectNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ObjectNode} Returns a transformed copy of the node
   */
  ObjectNode.prototype.map = function (callback) {
    var properties = {};
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        properties[key] = this._ifNode(callback(this.properties[key], 'properties["' + key + '"]', this));
      }
    }
    return new ObjectNode(properties);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ObjectNode}
   */
  ObjectNode.prototype.clone = function() {
    var properties = {};
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        properties[key] = this.properties[key];
      }
    }
    return new ObjectNode(properties);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ObjectNode.prototype._toString = function(options) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push('"' + key + '": ' + this.properties[key].toString(options));
      }
    }
    return '{' + entries.join(', ') + '}';
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ObjectNode.prototype._toTex = function(options) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push("\\mathbf{" + key + ':} & ' + this.properties[key].toTex(options) + "\\\\");
      }
    }
    return '\\left\\{\\begin{array}{ll}' + entries.join('\n') + '\\end{array}\\right\\}';
  };

  return ObjectNode;
}

exports.name = 'ObjectNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../../utils/string":363,"./Node":217}],219:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');
var operators = require('../operators');

function factory (type, config, load, typed, math) {
  var Node         = load(require('./Node'));
  var ConstantNode = load(require('./ConstantNode'));
  var SymbolNode   = load(require('./SymbolNode'));
  var FunctionNode = load(require('./FunctionNode'));

  /**
   * @constructor OperatorNode
   * @extends {Node}
   * An operator with two arguments, like 2+3
   *
   * @param {string} op           Operator name, for example '+'
   * @param {string} fn           Function name, for example 'add'
   * @param {Node[]} args         Operator arguments
   * @param {boolean} [implicit]  Is this an implicit multiplication?
   */
  function OperatorNode(op, fn, args, implicit) {
    if (!(this instanceof OperatorNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    //validate input
    if (typeof op !== 'string') {
      throw new TypeError('string expected for parameter "op"');
    }
    if (typeof fn !== 'string') {
      throw new TypeError('string expected for parameter "fn"');
    }
    if (!Array.isArray(args)
        || !args.every(function (node) {return node && node.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "args"');
    }

    this.implicit = (implicit === true);
    this.op = op;
    this.fn = fn;
    this.args = args || [];
  }

  OperatorNode.prototype = new Node();

  OperatorNode.prototype.type = 'OperatorNode';

  OperatorNode.prototype.isOperatorNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  OperatorNode.prototype._compile = function (defs, args) {
    if (!defs.math[this.fn]) {
      throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
    }

    var jsArgs = this.args.map(function (arg) {
      return arg._compile(defs, args);
    });

    return 'math.' + this.fn + '(' + jsArgs.join(', ') + ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  OperatorNode.prototype.forEach = function (callback) {
    for (var i = 0; i < this.args.length; i++) {
      callback(this.args[i], 'args[' + i + ']', this);
    }
  };

  /**
   * Create a new OperatorNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {OperatorNode} Returns a transformed copy of the node
   */
  OperatorNode.prototype.map = function (callback) {
    var args = [];
    for (var i = 0; i < this.args.length; i++) {
      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
    }
    return new OperatorNode(this.op, this.fn, args);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {OperatorNode}
   */
  OperatorNode.prototype.clone = function () {
    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);
  };

  /**
   * Calculate which parentheses are necessary. Gets an OperatorNode
   * (which is the root of the tree) and an Array of Nodes
   * (this.args) and returns an array where 'true' means that an argument
   * has to be enclosed in parentheses whereas 'false' means the opposite.
   *
   * @param {OperatorNode} root
   * @param {string} parenthesis
   * @param {Node[]} args
   * @param {boolean} latex
   * @return {boolean[]}
   * @private
   */
  function calculateNecessaryParentheses(root, parenthesis, args, latex) {
    //precedence of the root OperatorNode
    var precedence = operators.getPrecedence(root, parenthesis);
    var associativity = operators.getAssociativity(root, parenthesis);

    if ((parenthesis === 'all') || ((args.length > 2) && (root.getIdentifier() !== 'OperatorNode:add') && (root.getIdentifier() !== 'OperatorNode:multiply'))) {
      var parens = args.map(function (arg) {
        switch (arg.getContent().type) { //Nodes that don't need extra parentheses
          case 'ArrayNode':
          case 'ConstantNode':
          case 'SymbolNode':
          case 'ParenthesisNode':
            return false;
            break;
          default:
            return true;
        }
      });
      return parens;
    }

    if (args.length === 0) {
      return [];
    } else if (args.length === 1) { //unary operators
      //precedence of the operand
      var operandPrecedence = operators.getPrecedence(args[0], parenthesis);

      //handle special cases for LaTeX, where some of the parentheses aren't needed
      if (latex && (operandPrecedence !== null)) {
        var operandIdentifier;
        var rootIdentifier;
        if (parenthesis === 'keep') {
          operandIdentifier = args[0].getIdentifier();
          rootIdentifier = root.getIdentifier();
        }
        else {
          //Ignore Parenthesis Nodes when not in 'keep' mode
          operandIdentifier = args[0].getContent().getIdentifier();
          rootIdentifier = root.getContent().getIdentifier();
        }
        if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {
          return [false];
        }

        if (operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {
          return [false];
        }
      }

      if (operandPrecedence === null) {
        //if the operand has no defined precedence, no parens are needed
        return [false];
      }

      if (operandPrecedence <= precedence) {
        //if the operands precedence is lower, parens are needed
        return [true];
      }

      //otherwise, no parens needed
      return [false];
    } else if (args.length === 2) { //binary operators
      var lhsParens; //left hand side needs parenthesis?
      //precedence of the left hand side
      var lhsPrecedence = operators.getPrecedence(args[0], parenthesis);
      //is the root node associative with the left hand side
      var assocWithLhs = operators.isAssociativeWith(root, args[0], parenthesis);

      if (lhsPrecedence === null) {
        //if the left hand side has no defined precedence, no parens are needed
        //FunctionNode for example
        lhsParens = false;
      }
      else if ((lhsPrecedence === precedence) && (associativity === 'right') && !assocWithLhs) {
        //In case of equal precedence, if the root node is left associative
        // parens are **never** necessary for the left hand side.
        //If it is right associative however, parens are necessary
        //if the root node isn't associative with the left hand side
        lhsParens = true;
      }
      else if (lhsPrecedence < precedence) {
        lhsParens = true;
      }
      else {
        lhsParens = false;
      }

      var rhsParens; //right hand side needs parenthesis?
      //precedence of the right hand side
      var rhsPrecedence = operators.getPrecedence(args[1], parenthesis);
      //is the root node associative with the right hand side?
      var assocWithRhs = operators.isAssociativeWith(root, args[1], parenthesis);

      if (rhsPrecedence === null) {
        //if the right hand side has no defined precedence, no parens are needed
        //FunctionNode for example
        rhsParens = false;
      }
      else if ((rhsPrecedence === precedence) && (associativity === 'left') && !assocWithRhs) {
        //In case of equal precedence, if the root node is right associative
        // parens are **never** necessary for the right hand side.
        //If it is left associative however, parens are necessary
        //if the root node isn't associative with the right hand side
        rhsParens = true;
      }
      else if (rhsPrecedence < precedence) {
        rhsParens = true;
      }
      else {
        rhsParens = false;
      }

      //handle special cases for LaTeX, where some of the parentheses aren't needed
      if (latex) {
        var rootIdentifier;
        var lhsIdentifier;
        var rhsIdentifier;
        if (parenthesis === 'keep') {
          rootIdentifier = root.getIdentifier();
          lhsIdentifier = root.args[0].getIdentifier();
          rhsIdentifier = root.args[1].getIdentifier();
        }
        else {
          //Ignore ParenthesisNodes when not in 'keep' mode
          rootIdentifier = root.getContent().getIdentifier();
          lhsIdentifier = root.args[0].getContent().getIdentifier();
          rhsIdentifier = root.args[1].getContent().getIdentifier();
        }

        if (lhsPrecedence !== null) {
          if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {
            lhsParens = false;
          }

          if (operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
            lhsParens = false;
          }
        }

        if (rhsPrecedence !== null) {
          if (operators.properties[precedence][rootIdentifier].latexRightParens === false) {
            rhsParens = false;
          }

          if (operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
            rhsParens = false;
          }
        }
      }

      return [lhsParens, rhsParens];
    } else if ((args.length > 2) && ((root.getIdentifier() === 'OperatorNode:add') || (root.getIdentifier() === 'OperatorNode:multiply'))) {
      var parensArray = args.map(function (arg) {
        var argPrecedence = operators.getPrecedence(arg, parenthesis);
        var assocWithArg = operators.isAssociativeWith(root, arg, parenthesis);
        var argAssociativity = operators.getAssociativity(arg, parenthesis);
        if (argPrecedence === null) {
          //if the argument has no defined precedence, no parens are needed
          return false;
        } else if ((precedence === argPrecedence) && (associativity === argAssociativity) && !assocWithArg) {
          return true;
        } else if (argPrecedence < precedence) {
          return true;
        }

        return false;
      });
      return parensArray;
    }
  }

  /**
   * Get string representation.
   * @param {Object} options
   * @return {string} str
   */
  OperatorNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var implicit = (options && options.implicit) ? options.implicit : 'hide';
    var args = this.args;
    var parens = calculateNecessaryParentheses(this, parenthesis, args, false);

    if (args.length === 1) { //unary operators
      var assoc = operators.getAssociativity(this, parenthesis);

      var operand = args[0].toString(options);
      if (parens[0]) {
        operand = '(' + operand + ')';
      }

      if (assoc === 'right') { //prefix operator
        return this.op + operand;
      }
      else if (assoc === 'left') { //postfix
        return operand + this.op;
      }

      //fall back to postfix
      return operand + this.op;
    } else if (args.length == 2) {
      var lhs = args[0].toString(options); //left hand side
      var rhs = args[1].toString(options); //right hand side
      if (parens[0]) { //left hand side in parenthesis?
        lhs = '(' + lhs + ')';
      }
      if (parens[1]) { //right hand side in parenthesis?
        rhs = '(' + rhs + ')';
      }

      if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit == 'hide')) {
        return lhs + ' ' + rhs;
      }

      return lhs + ' ' + this.op + ' ' + rhs;
    } else if ((args.length > 2) && ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply'))) {
      var stringifiedArgs = args.map(function (arg, index) {
        arg = arg.toString(options);
        if (parens[index]) { //put in parenthesis?
          arg = '(' + arg + ')';
        }

        return arg;
      });

      if (this.implicit && (this.getIdentifier() === 'OperatorNode:multiply') && (implicit === 'hide')) {
        return stringifiedArgs.join(' ');
      }

      return stringifiedArgs.join(' ' + this.op + ' ');
    } else {
      //fallback to formatting as a function call
      return this.fn + '(' + this.args.join(', ') + ')';
    }
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  OperatorNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var implicit = (options && options.implicit) ? options.implicit : 'hide';
    var args = this.args;
    var parens = calculateNecessaryParentheses(this, parenthesis, args, true);
    var op = latex.operators[this.fn];
    op = typeof op === 'undefined' ? this.op : op; //fall back to using this.op

    if (args.length === 1) { //unary operators
      var assoc = operators.getAssociativity(this, parenthesis);

      var operand = args[0].toTex(options);
      if (parens[0]) {
        operand = '\\left(' + operand + '\\right)';
      }

      if (assoc === 'right') { //prefix operator
        return op + operand;
      }
      else if (assoc === 'left') { //postfix operator
        return operand + op;
      }

      //fall back to postfix
      return operand + op;
    } else if (args.length === 2) { //binary operators
      var lhs = args[0]; //left hand side
      var lhsTex = lhs.toTex(options);
      if (parens[0]) {
        lhsTex = '\\left(' + lhsTex + '\\right)';
      }

      var rhs = args[1]; //right hand side
      var rhsTex = rhs.toTex(options);
      if (parens[1]) {
        rhsTex = '\\left(' + rhsTex + '\\right)';
      }

      //handle some exceptions (due to the way LaTeX works)
      var lhsIdentifier;
      if (parenthesis === 'keep') {
        lhsIdentifier = lhs.getIdentifier();
      }
      else {
        //Ignore ParenthesisNodes if in 'keep' mode
        lhsIdentifier = lhs.getContent().getIdentifier();
      }
      switch (this.getIdentifier()) {
        case 'OperatorNode:divide':
          //op contains '\\frac' at this point
          return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';
        case 'OperatorNode:pow':
          lhsTex = '{' + lhsTex + '}';
          rhsTex = '{' + rhsTex + '}';
          switch (lhsIdentifier) {
            case 'ConditionalNode': //
            case 'OperatorNode:divide':
              lhsTex = '\\left(' + lhsTex + '\\right)';
          }
        case 'OperatorNode:multiply':
          if (this.implicit && (implicit === 'hide')) {
            return lhsTex + '~' + rhsTex;
          }
      }
      return lhsTex + op + rhsTex;
    } else if ((args.length > 2) && ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply'))) {
      var texifiedArgs = args.map(function (arg, index) {
        arg = arg.toTex(options);
        if (parens[index]) {
          arg = '\\left(' + arg + '\\right)';
        }
        return arg;
      });

      if ((this.getIdentifier() === 'OperatorNode:multiply') && this.implicit) {
        return texifiedArgs.join('~');
      }

      return texifiedArgs.join(op)
    } else {
      //fall back to formatting as a function call
      //as this is a fallback, it doesn't use
      //fancy function names
      return '\\mathrm{' + this.fn + '}\\left('
          + args.map(function (arg) {
            return arg.toTex(options);
          }).join(',') + '\\right)';
    }
  };

  /**
   * Get identifier.
   * @return {string}
   */
  OperatorNode.prototype.getIdentifier = function () {
    return this.type + ':' + this.fn;
  };

  return OperatorNode;
}

exports.name = 'OperatorNode';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../utils/latex":360,"../operators":227,"./ConstantNode":213,"./FunctionNode":215,"./Node":217,"./SymbolNode":222}],220:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor ParenthesisNode
   * @extends {Node}
   * A parenthesis node describes manual parenthesis from the user input
   * @param {Node} content
   * @extends {Node}
   */
  function ParenthesisNode(content) {
    if (!(this instanceof ParenthesisNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (!(content && content.isNode)) {
      throw new TypeError('Node expected for parameter "content"');
    }

    this.content = content;
  }

  ParenthesisNode.prototype = new Node();

  ParenthesisNode.prototype.type = 'ParenthesisNode';

  ParenthesisNode.prototype.isParenthesisNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ParenthesisNode.prototype._compile = function (defs, args) {
    return this.content._compile(defs, args);
  };

  /**
   * Get the content of the current Node.
   * @return {Node} content
   * @override
   **/
  ParenthesisNode.prototype.getContent = function () {
    return this.content.getContent();
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ParenthesisNode.prototype.forEach = function (callback) {
    callback(this.content, 'content', this);
  };

  /**
   * Create a new ParenthesisNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {ParenthesisNode} Returns a clone of the node
   */
  ParenthesisNode.prototype.map = function (callback) {
    var content = callback(this.content, 'content', this);
    return new ParenthesisNode(content);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ParenthesisNode}
   */
  ParenthesisNode.prototype.clone = function() {
    return new ParenthesisNode(this.content);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ParenthesisNode.prototype._toString = function(options) {
    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {
      return '(' + this.content.toString(options) + ')';
    }
    return this.content.toString(options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ParenthesisNode.prototype._toTex = function(options) {
    if ((!options) || (options && !options.parenthesis) || (options && options.parenthesis === 'keep')) {
      return '\\left(' + this.content.toTex(options) + '\\right)';
    }
    return this.content.toTex(options);
  };

  return ParenthesisNode;
}

exports.name = 'ParenthesisNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"./Node":217}],221:[function(require,module,exports){
'use strict';

var operators = require('../operators');

function factory (type, config, load, typed) {
  var Node = load(require('./Node'));

  /**
   * @constructor RangeNode
   * @extends {Node}
   * create a range
   * @param {Node} start  included lower-bound
   * @param {Node} end    included upper-bound
   * @param {Node} [step] optional step
   */
  function RangeNode(start, end, step) {
    if (!(this instanceof RangeNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate inputs
    if (!(start && start.isNode)) throw new TypeError('Node expected');
    if (!(end && end.isNode)) throw new TypeError('Node expected');
    if (step && !(step && step.isNode)) throw new TypeError('Node expected');
    if (arguments.length > 3) throw new Error('Too many arguments');

    this.start = start;         // included lower-bound
    this.end = end;           // included upper-bound
    this.step = step || null;  // optional step
  }

  RangeNode.prototype = new Node();

  RangeNode.prototype.type = 'RangeNode';

  RangeNode.prototype.isRangeNode = true;

  /**
   * Check whether the RangeNode needs the `end` symbol to be defined.
   * This end is the size of the Matrix in current dimension.
   * @return {boolean}
   */
  RangeNode.prototype.needsEnd = function () {
    // find all `end` symbols in this RangeNode
    var endSymbols = this.filter(function (node) {
      return (node && node.isSymbolNode) && (node.name == 'end');
    });

    return endSymbols.length > 0;
  };

  /**
   * Compile the node to javascript code
   *
   * When the range has a symbol `end` defined, the RangeNode requires
   * a variable `end` to be defined in the current closure, which must contain
   * the length of the of the matrix that's being handled in the range's
   * dimension. To check whether the `end` variable is needed, call
   * RangeNode.needsEnd().
   *
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  RangeNode.prototype._compile = function (defs, args) {
    return 'math.range(' +
        this.start._compile(defs, args) + ', ' +
        this.end._compile(defs, args) +
        (this.step ? (', ' + this.step._compile(defs, args)) : '') +
        ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  RangeNode.prototype.forEach = function (callback) {
    callback(this.start, 'start', this);
    callback(this.end, 'end', this);
    if (this.step) {
      callback(this.step, 'step', this);
    }
  };

  /**
   * Create a new RangeNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {RangeNode} Returns a transformed copy of the node
   */
  RangeNode.prototype.map = function (callback) {
    return new RangeNode(
        this._ifNode(callback(this.start, 'start', this)),
        this._ifNode(callback(this.end, 'end', this)),
        this.step && this._ifNode(callback(this.step, 'step', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {RangeNode}
   */
  RangeNode.prototype.clone = function () {
    return new RangeNode(this.start, this.end, this.step && this.step);
  };

  /**
   * Calculate the necessary parentheses
   * @param {Node} node
   * @param {string} parenthesis
   * @return {Object} parentheses
   * @private
   */
  function calculateNecessaryParentheses(node, parenthesis) {
    var precedence = operators.getPrecedence(node, parenthesis);
    var parens = {};

    var startPrecedence = operators.getPrecedence(node.start, parenthesis);
    parens.start = ((startPrecedence !== null) && (startPrecedence <= precedence))
      || (parenthesis === 'all');

    if (node.step) {
      var stepPrecedence = operators.getPrecedence(node.step, parenthesis);
      parens.step = ((stepPrecedence !== null) && (stepPrecedence <= precedence))
        || (parenthesis === 'all');
    }

    var endPrecedence = operators.getPrecedence(node.end, parenthesis);
    parens.end = ((endPrecedence !== null) && (endPrecedence <= precedence))
      || (parenthesis === 'all');

    return parens;
  }

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   */
  RangeNode.prototype._toString = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var parens = calculateNecessaryParentheses(this, parenthesis);

    //format string as start:step:stop
    var str;

    var start = this.start.toString(options);
    if (parens.start) {
      start = '(' + start + ')';
    }
    str = start;

    if (this.step) {
      var step = this.step.toString(options);
      if (parens.step) {
        step = '(' + step + ')';
      }
      str += ':' + step;
    }

    var end = this.end.toString(options);
    if (parens.end) {
      end = '(' + end + ')';
    }
    str += ':' + end;

    return str;
  };

  /**
   * Get LaTeX representation
   * @params {Object} options
   * @return {string} str
   */
  RangeNode.prototype._toTex = function (options) {
    var parenthesis = (options && options.parenthesis) ? options.parenthesis : 'keep';
    var parens = calculateNecessaryParentheses(this, parenthesis);

    var str = this.start.toTex(options);
    if (parens.start) {
      str = '\\left(' + str + '\\right)';
    }

    if (this.step) {
      var step = this.step.toTex(options);
      if (parens.step) {
        step = '\\left(' + step + '\\right)';
      }
      str += ':' + step;
    }

    var end = this.end.toTex(options);
    if (parens.end) {
      end = '\\left(' + end + '\\right)';
    }
    str += ':' + end;

    return str;
  };

  return RangeNode;
}

exports.name = 'RangeNode';
exports.path = 'expression.node';
exports.factory = factory;

},{"../operators":227,"./Node":217}],222:[function(require,module,exports){
'use strict';

var latex = require('../../utils/latex');

function factory (type, config, load, typed, math) {
  var Node = load(require('./Node'));

  var Unit = load(require('../../type/unit/Unit'));

  /**
   * @constructor SymbolNode
   * @extends {Node}
   * A symbol node can hold and resolve a symbol
   * @param {string} name
   * @extends {Node}
   */
  function SymbolNode(name) {
    if (!(this instanceof SymbolNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (typeof name !== 'string')  throw new TypeError('String expected for parameter "name"');

    this.name = name;
  }

  SymbolNode.prototype = new Node();

  SymbolNode.prototype.type = 'SymbolNode';

  SymbolNode.prototype.isSymbolNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  SymbolNode.prototype._compile = function (defs, args) {
    // add a function to the definitions
    defs['undef'] = undef;
    defs['Unit'] = Unit;

    if (args[this.name]) {
      // this is a FunctionAssignment argument
      // (like an x when inside the expression of a function assignment `f(x) = ...`)
      return this.name;
    }
    else if (this.name in defs.math) {
      return '("' + this.name + '" in scope ? scope["' + this.name + '"] : math["' + this.name + '"])';
    }
    else {
      return '(' +
          '"' + this.name + '" in scope ? scope["' + this.name + '"] : ' +
          (Unit.isValuelessUnit(this.name) ?
          'new Unit(null, "' + this.name + '")' :
          'undef("' + this.name + '")') +
          ')';
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  SymbolNode.prototype.forEach = function (callback) {
    // nothing to do, we don't have childs
  };

  /**
   * Create a new SymbolNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {SymbolNode} Returns a clone of the node
   */
  SymbolNode.prototype.map = function (callback) {
    return this.clone();
  };

  /**
   * Throws an error 'Undefined symbol {name}'
   * @param {string} name
   */
  function undef (name) {
    throw new Error('Undefined symbol ' + name);
  }

  /**
   * Create a clone of this node, a shallow copy
   * @return {SymbolNode}
   */
  SymbolNode.prototype.clone = function() {
    return new SymbolNode(this.name);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  SymbolNode.prototype._toString = function(options) {
    return this.name;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  SymbolNode.prototype._toTex = function(options) {
    var isUnit = false;
    if ((typeof math[this.name] === 'undefined') && Unit.isValuelessUnit(this.name)) {
      isUnit = true;
    }
    var symbol = latex.toSymbol(this.name, isUnit);
    if (symbol[0] === '\\') {
      //no space needed if the symbol starts with '\'
      return symbol;
    }
    //the space prevents symbols from breaking stuff like '\cdot' if it's written right before the symbol
    return ' ' + symbol;
  };

  return SymbolNode;
}

exports.name = 'SymbolNode';
exports.path = 'expression.node';
exports.math = true; // request access to the math namespace as 5th argument of the factory function
exports.factory = factory;

},{"../../type/unit/Unit":344,"../../utils/latex":360,"./Node":217}],223:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * @constructor UpdateNode
   */
  function UpdateNode() {
    // TODO: deprecated since v3. Cleanup some day
    throw new Error('UpdateNode is deprecated. Use AssignmentNode instead.');
  }

  return UpdateNode;
}

exports.name = 'UpdateNode';
exports.path = 'expression.node';
exports.factory = factory;

},{}],224:[function(require,module,exports){
module.exports = [
  require('./AccessorNode'),
  require('./ArrayNode'),
  require('./AssignmentNode'),
  require('./BlockNode'),
  require('./ConditionalNode'),
  require('./ConstantNode'),
  require('./IndexNode'),
  require('./FunctionAssignmentNode'),
  require('./FunctionNode'),
  require('./Node'),
  require('./ObjectNode'),
  require('./OperatorNode'),
  require('./ParenthesisNode'),
  require('./RangeNode'),
  require('./SymbolNode'),
  require('./UpdateNode')
];

},{"./AccessorNode":208,"./ArrayNode":209,"./AssignmentNode":210,"./BlockNode":211,"./ConditionalNode":212,"./ConstantNode":213,"./FunctionAssignmentNode":214,"./FunctionNode":215,"./IndexNode":216,"./Node":217,"./ObjectNode":218,"./OperatorNode":219,"./ParenthesisNode":220,"./RangeNode":221,"./SymbolNode":222,"./UpdateNode":223}],225:[function(require,module,exports){
'use strict';

var errorTransform = require('../../transform/error.transform').transform;

function factory (type, config, load, typed) {
  var subset = load(require('../../../function/matrix/subset'));
  var matrix = load(require('../../../type/matrix/function/matrix'));

  /**
   * Retrieve part of an object:
   *
   * - Retrieve a property from an object
   * - Retrieve a part of a string
   * - Retrieve a matrix subset
   *
   * @param {Object | Array | Matrix | string} object
   * @param {Index} index
   * @return {Object | Array | Matrix | string} Returns the subset
   */
  return function access(object, index) {
    try {
      if (Array.isArray(object)) {
        return matrix(object).subset(index).valueOf();
      }
      else if (object && typeof object.subset === 'function') { // Matrix
        return object.subset(index);
      }
      else if (typeof object === 'string') {
        // TODO: move getStringSubset into a separate util file, use that
        return subset(object, index);
      }
      else if (typeof object === 'object') {
        if (!index.isObjectProperty()) {
          throw TypeError('Cannot apply a numeric index as object property');
        }
        return object[index.getObjectProperty()];
      }
      else {
        throw new TypeError('Cannot apply index: unsupported type of object');
      }
    }
    catch (err) {
      throw errorTransform(err);
    }
  }
}

exports.factory = factory;

},{"../../../function/matrix/subset":283,"../../../type/matrix/function/matrix":328,"../../transform/error.transform":230}],226:[function(require,module,exports){
'use strict';

var errorTransform = require('../../transform/error.transform').transform;

function factory (type, config, load, typed) {
  var subset = load(require('../../../function/matrix/subset'));
  var matrix = load(require('../../../type/matrix/function/matrix'));

  /**
   * Replace part of an object:
   *
   * - Assign a property to an object
   * - Replace a part of a string
   * - Replace a matrix subset
   *
   * @param {Object | Array | Matrix | string} object
   * @param {Index} index
   * @param {*} value
   * @return {Object | Array | Matrix | string} Returns the original object
   *                                            except in case of a string
   */
  return function assign(object, index, value) {
    try {
      if (Array.isArray(object)) {
        return matrix(object).subset(index, value).valueOf();
      }
      else if (object && typeof object.subset === 'function') { // Matrix
        return object.subset(index, value);
      }
      else if (typeof object === 'string') {
        // TODO: move setStringSubset into a separate util file, use that
        return subset(object, index, value);
      }
      else if (typeof object === 'object') {
        if (!index.isObjectProperty()) {
          throw TypeError('Cannot apply a numeric index as object property');
        }
        object[index.getObjectProperty()] = value;
        return object;
      }
      else {
        throw new TypeError('Cannot apply index: unsupported type of object');
      }
    }
    catch (err) {
        throw errorTransform(err);
    }
  }
}

exports.factory = factory;

},{"../../../function/matrix/subset":283,"../../../type/matrix/function/matrix":328,"../../transform/error.transform":230}],227:[function(require,module,exports){
'use strict'

//list of identifiers of nodes in order of their precedence
//also contains information about left/right associativity
//and which other operator the operator is associative with
//Example:
// addition is associative with addition and subtraction, because:
// (a+b)+c=a+(b+c)
// (a+b)-c=a+(b-c)
//
// postfix operators are left associative, prefix operators 
// are right associative
//
//It's also possible to set the following properties:
// latexParens: if set to false, this node doesn't need to be enclosed
//              in parentheses when using LaTeX
// latexLeftParens: if set to false, this !OperatorNode's! 
//                  left argument doesn't need to be enclosed
//                  in parentheses
// latexRightParens: the same for the right argument
var properties = [
  { //assignment
    'AssignmentNode': {},
    'FunctionAssignmentNode': {}
  },
  { //conditional expression
    'ConditionalNode': {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      //conditionals don't need parentheses in LaTeX because
      //they are 2 dimensional
    }
  },
  { //logical or
    'OperatorNode:or': {
      associativity: 'left',
      associativeWith: []
    }

  },
  { //logical xor
    'OperatorNode:xor': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //logical and
    'OperatorNode:and': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitwise or
    'OperatorNode:bitOr': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitwise xor
    'OperatorNode:bitXor': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitwise and
    'OperatorNode:bitAnd': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //relational operators
    'OperatorNode:equal': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:unequal': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:smaller': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:larger': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:smallerEq': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:largerEq': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //bitshift operators
    'OperatorNode:leftShift': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:rightArithShift': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:rightLogShift': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //unit conversion
    'OperatorNode:to': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //range
    'RangeNode': {}
  },
  { //addition, subtraction
    'OperatorNode:add': {
      associativity: 'left',
      associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']
    },
    'OperatorNode:subtract': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //multiply, divide, modulus
    'OperatorNode:multiply': {
      associativity: 'left',
      associativeWith: [
        'OperatorNode:multiply',
        'OperatorNode:divide',
        'Operator:dotMultiply',
        'Operator:dotDivide'
      ]
    },
    'OperatorNode:divide': {
      associativity: 'left',
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      //fractions don't require parentheses because
      //they're 2 dimensional, so parens aren't needed
      //in LaTeX
    },
    'OperatorNode:dotMultiply': {
      associativity: 'left',
      associativeWith: [
        'OperatorNode:multiply',
        'OperatorNode:divide',
        'OperatorNode:dotMultiply',
        'OperatorNode:doDivide'
      ]
    },
    'OperatorNode:dotDivide': {
      associativity: 'left',
      associativeWith: []
    },
    'OperatorNode:mod': {
      associativity: 'left',
      associativeWith: []
    }
  },
  { //unary prefix operators
    'OperatorNode:unaryPlus': {
      associativity: 'right'
    },
    'OperatorNode:unaryMinus': {
      associativity: 'right'
    },
    'OperatorNode:bitNot': {
      associativity: 'right'
    },
    'OperatorNode:not': {
      associativity: 'right'
    }
  },
  { //exponentiation
    'OperatorNode:pow': {
      associativity: 'right',
      associativeWith: [],
      latexRightParens: false
      //the exponent doesn't need parentheses in
      //LaTeX because it's 2 dimensional
      //(it's on top)
    },
    'OperatorNode:dotPow': {
      associativity: 'right',
      associativeWith: []
    }
  },
  { //factorial
    'OperatorNode:factorial': {
      associativity: 'left'
    }
  },
  { //matrix transpose
    'OperatorNode:transpose': {
      associativity: 'left'
    }
  }
];

/**
 * Get the precedence of a Node.
 * Higher number for higher precedence, starting with 0.
 * Returns null if the precedence is undefined.
 *
 * @param {Node}
 * @param {string} parenthesis
 * @return {number|null}
 */
function getPrecedence (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  for (var i = 0; i < properties.length; i++) {
    if (identifier in properties[i]) {
      return i;
    }
  }
  return null;
}

/**
 * Get the associativity of an operator (left or right).
 * Returns a string containing 'left' or 'right' or null if
 * the associativity is not defined.
 *
 * @param {Node}
 * @param {string} parenthesis
 * @return {string|null}
 * @throws {Error}
 */
function getAssociativity (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index = getPrecedence(node, parenthesis);
  if (index === null) {
    //node isn't in the list
    return null;
  }
  var property = properties[index][identifier];

  if (property.hasOwnProperty('associativity')) {
    if (property.associativity === 'left') {
      return 'left';
    }
    if (property.associativity === 'right') {
      return 'right';
    }
    //associativity is invalid
    throw Error('\'' + identifier + '\' has the invalid associativity \''
                + property.associativity + '\'.');
  }

  //associativity is undefined
  return null;
}

/**
 * Check if an operator is associative with another operator.
 * Returns either true or false or null if not defined.
 *
 * @param {Node} nodeA
 * @param {Node} nodeB
 * @param {string} parenthesis
 * @return {bool|null}
 */
function isAssociativeWith (nodeA, nodeB, parenthesis) {
  var a = nodeA;
  var b = nodeB;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    var a = nodeA.getContent();
    var b = nodeB.getContent();
  }
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index = getPrecedence(a, parenthesis);
  if (index === null) {
    //node isn't in the list
    return null;
  }
  var property = properties[index][identifierA];

  if (property.hasOwnProperty('associativeWith')
      && (property.associativeWith instanceof Array)) {
    for (var i = 0; i < property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }

  //associativeWith is not defined
  return null;
}

module.exports.properties = properties;
module.exports.getPrecedence = getPrecedence;
module.exports.getAssociativity = getAssociativity;
module.exports.isAssociativeWith = isAssociativeWith;

},{}],228:[function(require,module,exports){
'use strict';

var ArgumentsError = require('../error/ArgumentsError');
var deepMap = require('../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var AccessorNode            = load(require('./node/AccessorNode'));
  var ArrayNode               = load(require('./node/ArrayNode'));
  var AssignmentNode          = load(require('./node/AssignmentNode'));
  var BlockNode               = load(require('./node/BlockNode'));
  var ConditionalNode         = load(require('./node/ConditionalNode'));
  var ConstantNode            = load(require('./node/ConstantNode'));
  var FunctionAssignmentNode  = load(require('./node/FunctionAssignmentNode'));
  var IndexNode               = load(require('./node/IndexNode'));
  var ObjectNode              = load(require('./node/ObjectNode'));
  var OperatorNode            = load(require('./node/OperatorNode'));
  var ParenthesisNode         = load(require('./node/ParenthesisNode'));
  var FunctionNode            = load(require('./node/FunctionNode'));
  var RangeNode               = load(require('./node/RangeNode'));
  var SymbolNode              = load(require('./node/SymbolNode'));


  /**
   * Parse an expression. Returns a node tree, which can be evaluated by
   * invoking node.eval();
   *
   * Syntax:
   *
   *     parse(expr)
   *     parse(expr, options)
   *     parse([expr1, expr2, expr3, ...])
   *     parse([expr1, expr2, expr3, ...], options)
   *
   * Example:
   *
   *     var node = parse('sqrt(3^2 + 4^2)');
   *     node.compile(math).eval(); // 5
   *
   *     var scope = {a:3, b:4}
   *     var node = parse('a * b'); // 12
   *     var code = node.compile(math);
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].compile(math).eval(); // 12
   *
   * @param {string | string[] | Matrix} expr
   * @param {{nodes: Object<string, Node>}} [options]  Available options:
   *                                                   - `nodes` a set of custom nodes
   * @return {Node | Node[]} node
   * @throws {Error}
   */
  function parse (expr, options) {
    if (arguments.length != 1 && arguments.length != 2) {
      throw new ArgumentsError('parse', arguments.length, 1, 2);
    }

    // pass extra nodes
    extra_nodes = (options && options.nodes) ? options.nodes : {};

    if (typeof expr === 'string') {
      // parse a single expression
      expression = expr;
      return parseStart();
    }
    else if (Array.isArray(expr) || expr instanceof type.Matrix) {
      // parse an array or matrix with expressions
      return deepMap(expr, function (elem) {
        if (typeof elem !== 'string') throw new TypeError('String expected');

        expression = elem;
        return parseStart();
      });
    }
    else {
      // oops
      throw new TypeError('String or matrix expected');
    }
  }

  // token types enumeration
  var TOKENTYPE = {
    NULL : 0,
    DELIMITER : 1,
    NUMBER : 2,
    SYMBOL : 3,
    UNKNOWN : 4
  };

  // map with all delimiters
  var DELIMITERS = {
    ',': true,
    '(': true,
    ')': true,
    '[': true,
    ']': true,
    '{': true,
    '}': true,
    '\"': true,
    ';': true,

    '+': true,
    '-': true,
    '*': true,
    '.*': true,
    '/': true,
    './': true,
    '%': true,
    '^': true,
    '.^': true,
    '~': true,
    '!': true,
    '&': true,
    '|': true,
    '^|': true,
    '\'': true,
    '=': true,
    ':': true,
    '?': true,

    '==': true,
    '!=': true,
    '<': true,
    '>': true,
    '<=': true,
    '>=': true,

    '<<': true,
    '>>': true,
    '>>>': true
  };

  // map with all named delimiters
  var NAMED_DELIMITERS = {
    'mod': true,
    'to': true,
    'in': true,
    'and': true,
    'xor': true,
    'or': true,
    'not': true
  };

  var extra_nodes = {};             // current extra nodes
  var expression = '';              // current expression
  var comment = '';                 // last parsed comment
  var index = 0;                    // current index in expr
  var c = '';                       // current token character in expr
  var token = '';                   // current token
  var token_type = TOKENTYPE.NULL;  // type of the token
  var nesting_level = 0;            // level of nesting inside parameters, used to ignore newline characters
  var conditional_level = null;     // when a conditional is being parsed, the level of the conditional is stored here

  /**
   * Get the first character from the expression.
   * The character is stored into the char c. If the end of the expression is
   * reached, the function puts an empty string in c.
   * @private
   */
  function first() {
    index = 0;
    c = expression.charAt(0);
    nesting_level = 0;
    conditional_level = null;
  }

  /**
   * Get the next character from the expression.
   * The character is stored into the char c. If the end of the expression is
   * reached, the function puts an empty string in c.
   * @private
   */
  function next() {
    index++;
    c = expression.charAt(index);
  }

  /**
   * Preview the previous character from the expression.
   * @return {string} cNext
   * @private
   */
  function prevPreview() {
    return expression.charAt(index - 1);
  }

  /**
   * Preview the next character from the expression.
   * @return {string} cNext
   * @private
   */
  function nextPreview() {
    return expression.charAt(index + 1);
  }

  /**
   * Preview the second next character from the expression.
   * @return {string} cNext
   * @private
   */
  function nextNextPreview() {
    return expression.charAt(index + 2);
  }

  /**
   * Get next token in the current string expr.
   * The token and token type are available as token and token_type
   * @private
   */
  function getToken() {
    token_type = TOKENTYPE.NULL;
    token = '';
    comment = '';

    // skip over whitespaces
    // space, tab, and newline when inside parameters
    while (parse.isWhitespace(c, nesting_level)) {
      next();
    }

    // skip comment
    if (c == '#') {
      while (c != '\n' && c != '') {
        comment += c;
        next();
      }
    }

    // check for end of expression
    if (c == '') {
      // token is still empty
      token_type = TOKENTYPE.DELIMITER;
      return;
    }

    // check for new line character
    if (c == '\n' && !nesting_level) {
      token_type = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for delimiters consisting of 3 characters
    var c2 = c + nextPreview();
    var c3 = c2 + nextNextPreview();
    if (c3.length == 3 && DELIMITERS[c3]) {
      token_type = TOKENTYPE.DELIMITER;
      token = c3;
      next();
      next();
      next();
      return;
    }

    // check for delimiters consisting of 2 characters
    if (c2.length == 2 && DELIMITERS[c2]) {
      token_type = TOKENTYPE.DELIMITER;
      token = c2;
      next();
      next();
      return;
    }

    // check for delimiters consisting of 1 character
    if (DELIMITERS[c]) {
      token_type = TOKENTYPE.DELIMITER;
      token = c;
      next();
      return;
    }

    // check for a number
    if (parse.isDigitDot(c)) {
      token_type = TOKENTYPE.NUMBER;

      // get number, can have a single dot
      if (c == '.') {
        token += c;
        next();

        if (!parse.isDigit(c)) {
          // this is no number, it is just a dot (can be dot notation)
          token_type = TOKENTYPE.DELIMITER;
        }
      }
      else {
        while (parse.isDigit(c)) {
          token += c;
          next();
        }
        if (parse.isDecimalMark(c, nextPreview())) {
          token += c;
          next();
        }
      }
      while (parse.isDigit(c)) {
        token += c;
        next();
      }

      // check for exponential notation like "2.3e-4", "1.23e50" or "2e+4"
      c2 = nextPreview();
      if (c == 'E' || c == 'e') {
        if (parse.isDigit(c2) || c2 == '-' || c2 == '+') {
          token += c;
          next();

          if (c == '+' || c == '-') {
            token += c;
            next();
          }

          // Scientific notation MUST be followed by an exponent
          if (!parse.isDigit(c)) {
            throw createSyntaxError('Digit expected, got "' + c + '"');
          }

          while (parse.isDigit(c)) {
            token += c;
            next();
          }

          if (parse.isDecimalMark(c, nextPreview())) {
            throw createSyntaxError('Digit expected, got "' + c + '"');
          }
        }
        else if (c2 == '.') {
          next();
          throw createSyntaxError('Digit expected, got "' + c + '"');
        }
      }

      return;
    }

    // check for variables, functions, named operators
    if (parse.isAlpha(c, prevPreview(), nextPreview())) {
      while (parse.isAlpha(c, prevPreview(), nextPreview()) || parse.isDigit(c)) {
        token += c;
        next();
      }

      if (NAMED_DELIMITERS.hasOwnProperty(token)) {
        token_type = TOKENTYPE.DELIMITER;
      }
      else {
        token_type = TOKENTYPE.SYMBOL;
      }

      return;
    }

    // something unknown is found, wrong characters -> a syntax error
    token_type = TOKENTYPE.UNKNOWN;
    while (c != '') {
      token += c;
      next();
    }
    throw createSyntaxError('Syntax error in part "' + token + '"');
  }

  /**
   * Get next token and skip newline tokens
   */
  function getTokenSkipNewline () {
    do {
      getToken();
    }
    while (token == '\n');
  }

  /**
   * Open parameters.
   * New line characters will be ignored until closeParams() is called
   */
  function openParams() {
    nesting_level++;
  }

  /**
   * Close parameters.
   * New line characters will no longer be ignored
   */
  function closeParams() {
    nesting_level--;
  }

  /**
   * Checks whether the current character `c` is a valid alpha character:
   *
   * - A latin letter (upper or lower case) Ascii: a-z, A-Z
   * - An underscore                         Ascii: _
   * - A latin letter with accents          Unicode: \u00C0 - \u02AF
   * - A greek letter                       Unicode: \u0370 - \u03FF
   * - A mathematical alphanumeric symbol   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
   *
   * The previous and next characters are needed to determine whether
   * this character is part of a unicode surrogate pair.
   *
   * @param {string} c      Current character in the expression
   * @param {string} cPrev  Previous character
   * @param {string} cNext  Next character
   * @return {boolean}
   */
  parse.isAlpha = function isAlpha (c, cPrev, cNext) {
    return parse.isValidLatinOrGreek(c)
        || parse.isValidMathSymbol(c, cNext)
        || parse.isValidMathSymbol(cPrev, c);
  };

  /**
   * Test whether a character is a valid latin, greek, or letter-like character
   * @param {string} c
   * @return {boolean}
   */
  parse.isValidLatinOrGreek = function isValidLatinOrGreek (c) {
    return /^[a-zA-Z_\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
  };

  /**
   * Test whether two given 16 bit characters form a surrogate pair of a
   * unicode math symbol.
   *
   * http://unicode-table.com/en/
   * http://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode
   *
   * Note: In ES6 will be unicode aware:
   * http://stackoverflow.com/questions/280712/javascript-unicode-regexes
   * https://mathiasbynens.be/notes/es6-unicode-regex
   *
   * @param {string} high
   * @param {string} low
   * @return {boolean}
   */
  parse.isValidMathSymbol = function isValidMathSymbol (high, low) {
    return /^[\uD835]$/.test(high) &&
        /^[\uDC00-\uDFFF]$/.test(low) &&
        /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };

  /**
   * Check whether given character c is a white space character: space, tab, or enter
   * @param {string} c
   * @param {number} nestingLevel
   * @return {boolean}
   */
  parse.isWhitespace = function isWhitespace (c, nestingLevel) {
    // TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
    return c == ' ' || c == '\t' || (c == '\n' && nestingLevel > 0);
  };

  /**
   * Test whether the character c is a decimal mark (dot).
   * This is the case when it's not the start of a delimiter '.*', './', or '.^'
   * @param {string} c
   * @param {string} cNext
   * @return {boolean}
   */
  parse.isDecimalMark = function isDecimalMark (c, cNext) {
    return c == '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';
  };

  /**
   * checks if the given char c is a digit or dot
   * @param {string} c   a string with one character
   * @return {boolean}
   */
  parse.isDigitDot = function isDigitDot (c) {
    return ((c >= '0' && c <= '9') || c == '.');
  };

  /**
   * checks if the given char c is a digit
   * @param {string} c   a string with one character
   * @return {boolean}
   */
  parse.isDigit = function isDigit (c) {
    return (c >= '0' && c <= '9');
  };

  /**
   * Start of the parse levels below, in order of precedence
   * @return {Node} node
   * @private
   */
  function parseStart () {
    // get the first character in expression
    first();

    getToken();

    var node = parseBlock();

    // check for garbage at the end of the expression
    // an expression ends with a empty character '' and token_type DELIMITER
    if (token != '') {
      if (token_type == TOKENTYPE.DELIMITER) {
        // user entered a not existing operator like "//"

        // TODO: give hints for aliases, for example with "<>" give as hint " did you mean != ?"
        throw createError('Unexpected operator ' + token);
      }
      else {
        throw createSyntaxError('Unexpected part "' + token + '"');
      }
    }

    return node;
  }

  /**
   * Parse a block with expressions. Expressions can be separated by a newline
   * character '\n', or by a semicolon ';'. In case of a semicolon, no output
   * of the preceding line is returned.
   * @return {Node} node
   * @private
   */
  function parseBlock () {
    var node;
    var blocks = [];
    var visible;

    if (token == '') {
      // empty expression
      node = new ConstantNode('undefined', 'undefined');
      node.comment = comment;
      return node
    }

    if (token != '\n' && token != ';') {
      node = parseAssignment();
      node.comment = comment;
    }

    // TODO: simplify this loop
    while (token == '\n' || token == ';') {
      if (blocks.length == 0 && node) {
        visible = (token != ';');
        blocks.push({
          node: node,
          visible: visible
        });
      }

      getToken();
      if (token != '\n' && token != ';' && token != '') {
        node = parseAssignment();
        node.comment = comment;

        visible = (token != ';');
        blocks.push({
          node: node,
          visible: visible
        });
      }
    }

    if (blocks.length > 0) {
      return new BlockNode(blocks);
    }
    else {
      return node;
    }
  }

  /**
   * Assignment of a function or variable,
   * - can be a variable like 'a=2.3'
   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'
   * - defining a function like 'f(x) = x^2'
   * @return {Node} node
   * @private
   */
  function parseAssignment () {
    var name, args, value, valid;

    var node = parseConditional();

    if (token == '=') {
      if (node && node.isSymbolNode) {
        // parse a variable assignment like 'a = 2/3'
        name = node.name;
        getTokenSkipNewline();
        value = parseAssignment();
        return new AssignmentNode(new SymbolNode(name), value);
      }
      else if (node && node.isAccessorNode) {
        // parse a matrix subset assignment like 'A[1,2] = 4'
        getTokenSkipNewline();
        value = parseAssignment();
        return new AssignmentNode(node.object, node.index, value);
      }
      else if (node && node.isFunctionNode) {
        // parse function assignment like 'f(x) = x^2'
        valid = true;
        args = [];

        name = node.name;
        node.args.forEach(function (arg, index) {
          if (arg && arg.isSymbolNode) {
            args[index] = arg.name;
          }
          else {
            valid = false;
          }
        });

        if (valid) {
          getTokenSkipNewline();
          value = parseAssignment();
          return new FunctionAssignmentNode(name, args, value);
        }
      }

      throw createSyntaxError('Invalid left hand side of assignment operator =');
    }

    return node;
  }

  /**
   * conditional operation
   *
   *     condition ? truePart : falsePart
   *
   * Note: conditional operator is right-associative
   *
   * @return {Node} node
   * @private
   */
  function parseConditional () {
    var node = parseLogicalOr();

    while (token == '?') {
      // set a conditional level, the range operator will be ignored as long
      // as conditional_level == nesting_level.
      var prev = conditional_level;
      conditional_level = nesting_level;
      getTokenSkipNewline();

      var condition = node;
      var trueExpr = parseAssignment();

      if (token != ':') throw createSyntaxError('False part of conditional expression expected');

      conditional_level = null;
      getTokenSkipNewline();

      var falseExpr = parseAssignment(); // Note: check for conditional operator again, right associativity

      node = new ConditionalNode(condition, trueExpr, falseExpr);

      // restore the previous conditional level
      conditional_level = prev;
    }

    return node;
  }

  /**
   * logical or, 'x or y'
   * @return {Node} node
   * @private
   */
  function parseLogicalOr() {
    var node = parseLogicalXor();

    while (token == 'or') {
      getTokenSkipNewline();
      node = new OperatorNode('or', 'or', [node, parseLogicalXor()]);
    }

    return node;
  }

  /**
   * logical exclusive or, 'x xor y'
   * @return {Node} node
   * @private
   */
  function parseLogicalXor() {
    var node = parseLogicalAnd();

    while (token == 'xor') {
      getTokenSkipNewline();
      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd()]);
    }

    return node;
  }

  /**
   * logical and, 'x and y'
   * @return {Node} node
   * @private
   */
  function parseLogicalAnd() {
    var node = parseBitwiseOr();

    while (token == 'and') {
      getTokenSkipNewline();
      node = new OperatorNode('and', 'and', [node, parseBitwiseOr()]);
    }

    return node;
  }

  /**
   * bitwise or, 'x | y'
   * @return {Node} node
   * @private
   */
  function parseBitwiseOr() {
    var node = parseBitwiseXor();

    while (token == '|') {
      getTokenSkipNewline();
      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor()]);
    }

    return node;
  }

  /**
   * bitwise exclusive or (xor), 'x ^| y'
   * @return {Node} node
   * @private
   */
  function parseBitwiseXor() {
    var node = parseBitwiseAnd();

    while (token == '^|') {
      getTokenSkipNewline();
      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd()]);
    }

    return node;
  }

  /**
   * bitwise and, 'x & y'
   * @return {Node} node
   * @private
   */
  function parseBitwiseAnd () {
    var node = parseRelational();

    while (token == '&') {
      getTokenSkipNewline();
      node = new OperatorNode('&', 'bitAnd', [node, parseRelational()]);
    }

    return node;
  }

  /**
   * relational operators
   * @return {Node} node
   * @private
   */
  function parseRelational () {
    var node, operators, name, fn, params;

    node = parseShift();

    operators = {
      '==': 'equal',
      '!=': 'unequal',
      '<': 'smaller',
      '>': 'larger',
      '<=': 'smallerEq',
      '>=': 'largerEq'
    };
    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseShift()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
   * @return {Node} node
   * @private
   */
  function parseShift () {
    var node, operators, name, fn, params;

    node = parseConversion();

    operators = {
      '<<' : 'leftShift',
      '>>' : 'rightArithShift',
      '>>>' : 'rightLogShift'
    };

    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseConversion()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * conversion operators 'to' and 'in'
   * @return {Node} node
   * @private
   */
  function parseConversion () {
    var node, operators, name, fn, params;

    node = parseRange();

    operators = {
      'to' : 'to',
      'in' : 'to'   // alias of 'to'
    };

    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      
      if (name === 'in' && token === '') {
        // end of expression -> this is the unit 'in' ('inch')
        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);
      }
      else {
        // operator 'a to b' or 'a in b'
        params = [node, parseRange()];
        node = new OperatorNode(name, fn, params);
      }
    }

    return node;
  }

  /**
   * parse range, "start:end", "start:step:end", ":", "start:", ":end", etc
   * @return {Node} node
   * @private
   */
  function parseRange () {
    var node, params = [];

    if (token == ':') {
      // implicit start=1 (one-based)
      node = new ConstantNode('1', 'number');
    }
    else {
      // explicit start
      node = parseAddSubtract();
    }

    if (token == ':' && (conditional_level !== nesting_level)) {
      // we ignore the range operator when a conditional operator is being processed on the same level
      params.push(node);

      // parse step and end
      while (token == ':' && params.length < 3) {
        getTokenSkipNewline();

        if (token == ')' || token == ']' || token == ',' || token == '') {
          // implicit end
          params.push(new SymbolNode('end'));
        }
        else {
          // explicit end
          params.push(parseAddSubtract());
        }
      }

      if (params.length == 3) {
        // params = [start, step, end]
        node = new RangeNode(params[0], params[2], params[1]); // start, end, step
      }
      else { // length == 2
        // params = [start, end]
        node = new RangeNode(params[0], params[1]); // start, end
      }
    }

    return node;
  }

  /**
   * add or subtract
   * @return {Node} node
   * @private
   */
  function parseAddSubtract ()  {
    var node, operators, name, fn, params;

    node = parseMultiplyDivide();

    operators = {
      '+': 'add',
      '-': 'subtract'
    };
    while (token in operators) {
      name = token;
      fn = operators[name];

      getTokenSkipNewline();
      params = [node, parseMultiplyDivide()];
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * multiply, divide, modulus
   * @return {Node} node
   * @private
   */
  function parseMultiplyDivide () {
    var node, last, operators, name, fn;

    node = parseUnary();
    last = node;

    operators = {
      '*': 'multiply',
      '.*': 'dotMultiply',
      '/': 'divide',
      './': 'dotDivide',
      '%': 'mod',
      'mod': 'mod'
    };

    while (true) {
      if (token in operators) {
        // explicit operators
        name = token;
        fn = operators[name];

        getTokenSkipNewline();

        last = parseUnary();
        node = new OperatorNode(name, fn, [node, last]);
      }
      else if ((token_type == TOKENTYPE.SYMBOL) ||
          (token == 'in' && (node && node.isConstantNode)) ||
          (token_type == TOKENTYPE.NUMBER &&
              !last.isConstantNode &&
              (!last.isOperatorNode || last.op === '!')) ||
          (token == '(')) {
        // parse implicit multiplication
        //
        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'
        // number:      implicit multiplication like '(2+3)2'
        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'
        last = parseUnary();
        node = new OperatorNode('*', 'multiply', [node, last], true /*implicit*/);
      }
      else {
        break;
      }
    }

    return node;
  }

  /**
   * Unary plus and minus, and logical and bitwise not
   * @return {Node} node
   * @private
   */
  function parseUnary () {
    var name, params;
    var fn = {
      '-': 'unaryMinus',
      '+': 'unaryPlus',
      '~': 'bitNot',
      'not': 'not'
    }[token];

    if (fn) {
      name = token;

      getTokenSkipNewline();
      params = [parseUnary()];

      return new OperatorNode(name, fn, params);
    }

    return parsePow();
  }

  /**
   * power
   * Note: power operator is right associative
   * @return {Node} node
   * @private
   */
  function parsePow () {
    var node, name, fn, params;

    node = parseLeftHandOperators();

    if (token == '^' || token == '.^') {
      name = token;
      fn = (name == '^') ? 'pow' : 'dotPow';

      getTokenSkipNewline();
      params = [node, parseUnary()]; // Go back to unary, we can have '2^-3'
      node = new OperatorNode(name, fn, params);
    }

    return node;
  }

  /**
   * Left hand operators: factorial x!, transpose x'
   * @return {Node} node
   * @private
   */
  function parseLeftHandOperators ()  {
    var node, operators, name, fn, params;

    node = parseCustomNodes();

    operators = {
      '!': 'factorial',
      '\'': 'transpose'
    };

    while (token in operators) {
      name = token;
      fn = operators[name];

      getToken();
      params = [node];

      node = new OperatorNode(name, fn, params);
      node = parseAccessors(node);
    }

    return node;
  }

  /**
   * Parse a custom node handler. A node handler can be used to process
   * nodes in a custom way, for example for handling a plot.
   *
   * A handler must be passed as second argument of the parse function.
   * - must extend math.expression.node.Node
   * - must contain a function _compile(defs: Object) : string
   * - must contain a function find(filter: Object) : Node[]
   * - must contain a function toString() : string
   * - the constructor is called with a single argument containing all parameters
   *
   * For example:
   *
   *     nodes = {
   *       'plot': PlotHandler
   *     };
   *
   * The constructor of the handler is called as:
   *
   *     node = new PlotHandler(params);
   *
   * The handler will be invoked when evaluating an expression like:
   *
   *     node = math.parse('plot(sin(x), x)', nodes);
   *
   * @return {Node} node
   * @private
   */
  function parseCustomNodes () {
    var params = [], handler;

    if (token_type == TOKENTYPE.SYMBOL && extra_nodes[token]) {
      handler = extra_nodes[token];

      getToken();

      // parse parameters
      if (token == '(') {
        params = [];

        openParams();
        getToken();

        if (token != ')') {
          params.push(parseAssignment());

          // parse a list with parameters
          while (token == ',') {
            getToken();
            params.push(parseAssignment());
          }
        }

        if (token != ')') {
          throw createSyntaxError('Parenthesis ) expected');
        }
        closeParams();
        getToken();
      }

      // create a new node handler
      //noinspection JSValidateTypes
      return new handler(params);
    }

    return parseSymbol();
  }

  /**
   * parse symbols: functions, variables, constants, units
   * @return {Node} node
   * @private
   */
  function parseSymbol () {
    var node, name;

    if (token_type == TOKENTYPE.SYMBOL ||
        (token_type == TOKENTYPE.DELIMITER && token in NAMED_DELIMITERS)) {
      name = token;

      getToken();

      // parse function parameters and matrix index
      node = new SymbolNode(name);
      node = parseAccessors(node);
      return node;
    }

    return parseString();
  }

  /**
   * parse accessors:
   * - function invocation in round brackets (...), for example sqrt(2)
   * - index enclosed in square brackets [...], for example A[2,3]
   * - dot notation for properties, like foo.bar
   * @param {Node} node    Node on which to apply the parameters. If there
   *                       are no parameters in the expression, the node
   *                       itself is returned
   * @param {string[]} [types]  Filter the types of notations
   *                            can be ['(', '[', '.']
   * @return {Node} node
   * @private
   */
  function parseAccessors (node, types) {
    var params;

    while ((token == '(' || token == '[' || token == '.') &&
        (!types || types.indexOf(token) !== -1)) {
      params = [];

      if (token == '(') {
        if (node.isSymbolNode || node.isAccessorNode || node.isFunctionNode) {
          // function invocation like fn(2, 3)
          openParams();
          getToken();

          if (token != ')') {
            params.push(parseAssignment());

            // parse a list with parameters
            while (token == ',') {
              getToken();
              params.push(parseAssignment());
            }
          }

          if (token != ')') {
            throw createSyntaxError('Parenthesis ) expected');
          }
          closeParams();
          getToken();

          node = new FunctionNode(node, params);
        }
        else {
          // implicit multiplication like (2+3)(4+5)
          // don't parse it here but let it be handled by parseMultiplyDivide
          // with correct precedence
          return node;
        }
      }
      else if (token == '[') {
        // index notation like variable[2, 3]
        openParams();
        getToken();

        if (token != ']') {
          params.push(parseAssignment());

          // parse a list with parameters
          while (token == ',') {
            getToken();
            params.push(parseAssignment());
          }
        }

        if (token != ']') {
          throw createSyntaxError('Parenthesis ] expected');
        }
        closeParams();
        getToken();

        node = new AccessorNode(node, new IndexNode(params));
      }
      else {
        // dot notation like variable.prop
        getToken();

        if (token_type != TOKENTYPE.SYMBOL) {
          throw createSyntaxError('Property name expected after dot');
        }
        params.push(new ConstantNode(token));
        getToken();

        var dotNotation = true;
        node = new AccessorNode(node, new IndexNode(params, dotNotation));
      }
    }

    return node;
  }

  /**
   * parse a string.
   * A string is enclosed by double quotes
   * @return {Node} node
   * @private
   */
  function parseString () {
    var node, str;

    if (token == '"') {
      str = parseStringToken();

      // create constant
      node = new ConstantNode(str, 'string');

      // parse index parameters
      node = parseAccessors(node);

      return node;
    }

    return parseMatrix();
  }

  /**
   * Parse a string surrounded by double quotes "..."
   * @return {string}
   */
  function parseStringToken () {
    var str = '';

    while (c != '' && c != '\"') {
      if (c == '\\') {
        // escape character
        str += c;
        next();
      }

      str += c;
      next();
    }

    getToken();
    if (token != '"') {
      throw createSyntaxError('End of string " expected');
    }
    getToken();

    return str;
  }

  /**
   * parse the matrix
   * @return {Node} node
   * @private
   */
  function parseMatrix () {
    var array, params, rows, cols;

    if (token == '[') {
      // matrix [...]
      openParams();
      getToken();

      if (token != ']') {
        // this is a non-empty matrix
        var row = parseRow();

        if (token == ';') {
          // 2 dimensional array
          rows = 1;
          params = [row];

          // the rows of the matrix are separated by dot-comma's
          while (token == ';') {
            getToken();

            params[rows] = parseRow();
            rows++;
          }

          if (token != ']') {
            throw createSyntaxError('End of matrix ] expected');
          }
          closeParams();
          getToken();

          // check if the number of columns matches in all rows
          cols = params[0].items.length;
          for (var r = 1; r < rows; r++) {
            if (params[r].items.length != cols) {
              throw createError('Column dimensions mismatch ' +
                  '(' + params[r].items.length + ' != ' + cols + ')');
            }
          }

          array = new ArrayNode(params);
        }
        else {
          // 1 dimensional vector
          if (token != ']') {
            throw createSyntaxError('End of matrix ] expected');
          }
          closeParams();
          getToken();

          array = row;
        }
      }
      else {
        // this is an empty matrix "[ ]"
        closeParams();
        getToken();
        array = new ArrayNode([]);
      }

      return parseAccessors(array);
    }

    return parseObject();
  }

  /**
   * Parse a single comma-separated row from a matrix, like 'a, b, c'
   * @return {ArrayNode} node
   */
  function parseRow () {
    var params = [parseAssignment()];
    var len = 1;

    while (token == ',') {
      getToken();

      // parse expression
      params[len] = parseAssignment();
      len++;
    }

    return new ArrayNode(params);
  }

  /**
   * parse an object, enclosed in angle brackets{...}, for example {value: 2}
   * @return {Node} node
   * @private
   */
  function parseObject () {
    if (token == '{') {
      var key;

      var properties = {};
      do {
        getToken();

        if (token != '}') {
          // parse key
          if (token == '"') {
            key = parseStringToken();
          }
          else if (token_type == TOKENTYPE.SYMBOL) {
            key = token;
            getToken();
          }
          else {
            throw createSyntaxError('Symbol or string expected as object key');
          }

          // parse key/value separator
          if (token != ':') {
            throw createSyntaxError('Colon : expected after object key');
          }
          getToken();

          // parse key
          properties[key] = parseAssignment();
        }
      }
      while (token == ',');

      if (token != '}') {
        throw createSyntaxError('Comma , or bracket } expected after object value');
      }
      getToken();

      var node = new ObjectNode(properties);

      // parse index parameters
      node = parseAccessors(node);

      return node;
    }

    return parseNumber();
  }

  /**
   * parse a number
   * @return {Node} node
   * @private
   */
  function parseNumber () {
    var number;

    if (token_type == TOKENTYPE.NUMBER) {
      // this is a number
      number = token;
      getToken();

      return new ConstantNode(number, 'number');
    }

    return parseParentheses();
  }

  /**
   * parentheses
   * @return {Node} node
   * @private
   */
  function parseParentheses () {
    var node;

    // check if it is a parenthesized expression
    if (token == '(') {
      // parentheses (...)
      openParams();
      getToken();

      node = parseAssignment(); // start again

      if (token != ')') {
        throw createSyntaxError('Parenthesis ) expected');
      }
      closeParams();
      getToken();

      node = new ParenthesisNode(node);
      node = parseAccessors(node);
      return node;
    }

    return parseEnd();
  }

  /**
   * Evaluated when the expression is not yet ended but expected to end
   * @return {Node} res
   * @private
   */
  function parseEnd () {
    if (token == '') {
      // syntax error or unexpected end of expression
      throw createSyntaxError('Unexpected end of expression');
    } else {
      throw createSyntaxError('Value expected');
    }
  }

  /**
   * Shortcut for getting the current row value (one based)
   * Returns the line of the currently handled expression
   * @private
   */
  /* TODO: implement keeping track on the row number
  function row () {
    return null;
  }
  */

  /**
   * Shortcut for getting the current col value (one based)
   * Returns the column (position) where the last token starts
   * @private
   */
  function col () {
    return index - token.length + 1;
  }

  /**
   * Create an error
   * @param {string} message
   * @return {SyntaxError} instantiated error
   * @private
   */
  function createSyntaxError (message) {
    var c = col();
    var error = new SyntaxError(message + ' (char ' + c + ')');
    error['char'] = c;

    return error;
  }

  /**
   * Create an error
   * @param {string} message
   * @return {Error} instantiated error
   * @private
   */
  function createError (message) {
    var c = col();
    var error = new SyntaxError(message + ' (char ' + c + ')');
    error['char'] = c;

    return error;
  }

  return parse;
}

exports.name = 'parse';
exports.path = 'expression';
exports.factory = factory;

},{"../error/ArgumentsError":14,"../utils/collection/deepMap":353,"./node/AccessorNode":208,"./node/ArrayNode":209,"./node/AssignmentNode":210,"./node/BlockNode":211,"./node/ConditionalNode":212,"./node/ConstantNode":213,"./node/FunctionAssignmentNode":214,"./node/FunctionNode":215,"./node/IndexNode":216,"./node/ObjectNode":218,"./node/OperatorNode":219,"./node/ParenthesisNode":220,"./node/RangeNode":221,"./node/SymbolNode":222}],229:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;

/**
 * Attach a transform function to math.range
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function concat
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var concat = load(require('../../function/matrix/concat'));

  // @see: comment of concat itself
 return typed('concat', {
    '...any': function (args) {
      // change last argument from one-based to zero-based
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last === 'number') {
        args[lastIndex] = last - 1;
      }
      else if (last && last.isBigNumber === true) {
        args[lastIndex] = last.minus(1);
      }

      try {
        return concat.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'concat';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/concat":275,"./error.transform":230}],230:[function(require,module,exports){
var IndexError = require('../../error/IndexError');

/**
 * Transform zero-based indices to one-based indices in errors
 * @param {Error} err
 * @returns {Error} Returns the transformed error
 */
exports.transform = function (err) {
  if (err && err.isIndexError) {
    return new IndexError(
        err.index + 1,
        err.min + 1,
        err.max !== undefined ? err.max + 1 : undefined);
  }

  return err;
};

},{"../../error/IndexError":16}],231:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.filter
 * Adds a property transform containing the transform function.
 *
 * This transform adds support for equations as test function for math.filter,
 * so you can do something like 'filter([3, -2, 5], x > 0)'.
 */
function factory (type, config, load, typed) {
  var filter = load(require('../../function/matrix/filter'));
  var SymbolNode = load(require('../node/SymbolNode'));

  function filterTransform(args, math, scope) {
    var x, test;

    if (args[0]) {
      x = args[0].compile().eval(scope);
    }

    if (args[1]) {
      if (args[1] && args[1].isSymbolNode) {
        // a function pointer, like filter([3, -2, 5], myTestFunction);
        test = args[1].compile().eval(scope);
      }
      else {
        // an equation like filter([3, -2, 5], x > 0)

        // find an undefined symbol
        var _scope = scope || {};
        var symbol = args[1]
            .filter(function (node) {
              return (node && node.isSymbolNode) &&
                  !(node.name in math) &&
                  !(node.name in _scope);
            })[0];

        // create a test function for this equation
        var sub = Object.create(_scope);
        var eq = args[1].compile();
        if (symbol) {
          var name = symbol.name;
          test = function (x) {
            sub[name] = x;
            return eq.eval(sub);
          }
        }
        else {
          throw new Error('No undefined variable found in filter equation');
        }
      }
    }

    return filter(x, test);
  }

  filterTransform.rawArgs = true;

  return filterTransform;
}

exports.name = 'filter';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/filter":278,"../node/SymbolNode":222}],232:[function(require,module,exports){
'use strict';

var maxArgumentCount = require('../../utils/function').maxArgumentCount;

/**
 * Attach a transform function to math.forEach
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 */
function factory (type, config, load, typed) {
  var forEach = load(require('../../function/matrix/forEach'));

  return typed('forEach', {
    'Array | Matrix, function': function (array, callback) {
      // figure out what number of arguments the callback function expects
      var args = maxArgumentCount(callback);

      var recurse = function (value, index) {
        if (Array.isArray(value)) {
          value.forEach(function (child, i) {
            // we create a copy of the index array and append the new index value
            recurse(child, index.concat(i + 1)); // one based index, hence i+1
          });
        }
        else {
          // invoke the callback function with the right number of arguments
          if (args === 1) {
            callback(value);
          }
          else if (args === 2) {
            callback(value, index);
          }
          else { // 3 or -1
            callback(value, index, array);
          }
        }
      };
      recurse(array.valueOf(), []); // pass Array
    }
  });
}

exports.name = 'forEach';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/forEach":279,"../../utils/function":358}],233:[function(require,module,exports){
module.exports = [
  require('./concat.transform'),
  require('./filter.transform'),
  require('./forEach.transform'),
  require('./index.transform'),
  require('./map.transform'),
  require('./max.transform'),
  require('./mean.transform'),
  require('./min.transform'),
  require('./range.transform'),
  require('./subset.transform')
];

},{"./concat.transform":229,"./filter.transform":231,"./forEach.transform":232,"./index.transform":234,"./map.transform":235,"./max.transform":236,"./mean.transform":237,"./min.transform":238,"./range.transform":239,"./subset.transform":240}],234:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.index
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 */
function factory (type, config, load) {

  return function indexTransform() {
    var args = [];
    for (var i = 0, ii = arguments.length; i < ii; i++) {
      var arg = arguments[i];

      // change from one-based to zero based, and convert BigNumber to number
      if (arg && arg.isRange === true) {
        arg.start--;
        arg.end -= (arg.step > 0 ? 0 : 2);
      }
      else if (arg && arg.isSet === true) {
        arg = arg.map(function (v) { return v - 1; });
      }
      else if (arg && (arg.isArray === true || arg.isMatrix)) {
        arg = arg.map(function (v) { return v - 1; });
      }
      else if (typeof arg === 'number') {
        arg--;
      }
      else if (arg && arg.isBigNumber === true) {
        arg = arg.toNumber() - 1;
      }
      else if (typeof arg === 'string') {
        // leave as is
      }
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }

      args[i] = arg;
    }

    var res = new type.Index();
    type.Index.apply(res, args);
    return res;
  };
}

exports.name = 'index';
exports.path = 'expression.transform';
exports.factory = factory;

},{}],235:[function(require,module,exports){
'use strict';

var maxArgumentCount = require('../../utils/function').maxArgumentCount;

/**
 * Attach a transform function to math.map
 * Adds a property transform containing the transform function.
 *
 * This transform creates a one-based index instead of a zero-based index
 */
function factory (type, config, load, typed) {
  var map = load(require('../../function/matrix/map'));
  var matrix = load(require('../../type/matrix/function/matrix'));

  return typed('max', {
    'Array, function': function (x, callback) {
      return _map(x, callback, x);
    },

    'Matrix, function': function (x, callback) {
      return matrix(_map(x.valueOf(), callback, x));
    }
  });
}

/**
 * Map for a multi dimensional array. One-based indexes
 * @param {Array} array
 * @param {function} callback
 * @param {Array} orig
 * @return {Array}
 * @private
 */
function _map (array, callback, orig) {
  // figure out what number of arguments the callback function expects
  var args = maxArgumentCount(callback);

  function recurse(value, index) {
    if (Array.isArray(value)) {
      return value.map(function (child, i) {
        // we create a copy of the index array and append the new index value
        return recurse(child, index.concat(i + 1)); // one based index, hence i + 1
      });
    }
    else {
      // invoke the callback function with the right number of arguments
      if (args === 1) {
        return callback(value);
      }
      else if (args === 2) {
        return callback(value, index);
      }
      else { // 3 or -1
        return callback(value, index, orig);
      }
    }
  }

  return recurse(array, []);
}

exports.name = 'map';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/map":281,"../../type/matrix/function/matrix":328,"../../utils/function":358}],236:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isCollection = require('../../utils/collection/isCollection');

/**
 * Attach a transform function to math.max
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function max
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var max = load(require('../../function/statistics/max'));

  return typed('max', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 && isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim && dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return max.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'max';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/statistics/max":291,"../../utils/collection/isCollection":354,"./error.transform":230}],237:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isCollection = require('../../utils/collection/isCollection');

/**
 * Attach a transform function to math.mean
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function mean
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var mean = load(require('../../function/statistics/mean'));

  return typed('mean', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 && isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim && dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return mean.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'mean';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/statistics/mean":292,"../../utils/collection/isCollection":354,"./error.transform":230}],238:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;
var isCollection = require('../../utils/collection/isCollection');

/**
 * Attach a transform function to math.min
 * Adds a property transform containing the transform function.
 *
 * This transform changed the last `dim` parameter of function min
 * from one-based to zero based
 */
function factory (type, config, load, typed) {
  var min = load(require('../../function/statistics/min'));

  return typed('min', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 && isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim && dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return min.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'min';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/statistics/min":293,"../../utils/collection/isCollection":354,"./error.transform":230}],239:[function(require,module,exports){
'use strict';

/**
 * Attach a transform function to math.range
 * Adds a property transform containing the transform function.
 *
 * This transform creates a range which includes the end value
 */
function factory (type, config, load, typed) {
  var range = load(require('../../function/matrix/range'));

  return typed('range', {
    '...any': function (args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== 'boolean') {
        // append a parameter includeEnd=true
        args.push(true);
      }

      return range.apply(null, args);
    }
  });
}

exports.name = 'range';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/range":282}],240:[function(require,module,exports){
'use strict';

var errorTransform = require('./error.transform').transform;

/**
 * Attach a transform function to math.subset
 * Adds a property transform containing the transform function.
 *
 * This transform creates a range which includes the end value
 */
function factory (type, config, load, typed) {
  var subset = load(require('../../function/matrix/subset'));

  return typed('subset', {
    '...any': function (args) {
      try {
        return subset.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}

exports.name = 'subset';
exports.path = 'expression.transform';
exports.factory = factory;

},{"../../function/matrix/subset":283,"./error.transform":230}],241:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5);                // returns number 3.5
   *    math.abs(-4.2);               // returns number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            A number or matrix for which to get the absolute value
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Absolute value of `x`
   */
  var abs = typed('abs', {
    'number': Math.abs,

    'Complex': function (x) {
      return x.abs();
    },

    'BigNumber': function (x) {
      return x.abs();
    },

    'Fraction': function (x) {
      return x.abs();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since abs(0) = 0
      return deepMap(x, abs, true);
    },

    'Unit': function(x) {
      return x.abs();
    }
  });

  abs.toTex = {1: '\\left|${args[0]}\\right|'};

  return abs;
}

exports.name = 'abs';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],242:[function(require,module,exports){
'use strict';

var extend = require('../../utils/object').extend;

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var latex = require('../../utils/latex.js');
  
  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Add two or more values, `x + y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.add(x, y)
   *    math.add(x, y, z, ...)
   *
   * Examples:
   *
   *    math.add(2, 3);               // returns number 5
   *    math.add(2, 3, 4);            // returns number 9
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(-4, 1);
   *    math.add(a, b);               // returns Complex -2 + 4i
   *
   *    math.add([1, 2, 3], 4);       // returns Array [5, 6, 7]
   *
   *    var c = math.unit('5 cm');
   *    var d = math.unit('2.1 mm');
   *    math.add(c, d);               // returns Unit 52.1 mm
   *
   *    math.add("2.3", "4");         // returns number 6.3
   *
   * See also:
   *
   *    subtract, sum
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
   */
  var add = typed('add', extend({
    // we extend the signatures of addScalar with signatures dealing with matrices

    'Matrix, Matrix': function (x, y) {
      // result
      var c;
      
      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, addScalar);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, addScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, addScalar, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, addScalar);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return add(matrix(x), matrix(y)).valueOf();
    },
    
    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return add(matrix(x), y);
    },
    
    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return add(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, addScalar, false);
          break;
        default:
          c = algorithm14(x, y, addScalar, false);
          break;
      }
      return c;
    },
    
    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, addScalar, true);
          break;
        default:
          c = algorithm14(y, x, addScalar, true);
          break;
      }
      return c;
    },
    
    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, addScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, addScalar, true).valueOf();
    },

    'any, any': addScalar,

    'any, any, ...any': function (x, y, rest) {
      var result = add(x, y);

      for (var i = 0; i < rest.length; i++) {
        result = add(result, rest[i]);
      }

      return result;
    }
  }, addScalar.signatures));

  add.toTex = {
    2: '\\left(${args[0]}' + latex.operators['add'] + '${args[1]}\\right)'
  };
  
  return add;
}

exports.name = 'add';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm01":329,"../../type/matrix/utils/algorithm04":332,"../../type/matrix/utils/algorithm10":337,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex.js":360,"../../utils/object":362,"./addScalar":243}],243:[function(require,module,exports){
'use strict';

function factory(type, config, load, typed) {

  /**
   * Add two scalar values, `x + y`.
   * This function is meant for internal use: it is used by the public function
   * `add`
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Sum of `x` and `y`
   * @private
   */
  var add = typed('add', {

    'number, number': function (x, y) {
      return x + y;
    },

    'Complex, Complex': function (x, y) {
      return x.add(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.plus(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.add(y);
    },

    'Unit, Unit': function (x, y) {
      if (x.value == null) throw new Error('Parameter x contains a unit with undefined value');
      if (y.value == null) throw new Error('Parameter y contains a unit with undefined value');
      if (!x.equalBase(y)) throw new Error('Units do not match');

      var res = x.clone();
      res.value = add(res.value, y.value);
      res.fixPrefix = false;
      return res;
    }
  });

  return add;
}

exports.factory = factory;

},{}],244:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var unaryMinus = load(require('./unaryMinus'));
  var isNegative = load(require('../utils/isNegative'));
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Calculate the cubic root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cbrt(x)
   *    math.cbrt(x, allRoots)
   *
   * Examples:
   *
   *    math.cbrt(27);                  // returns 3
   *    math.cube(3);                   // returns 27
   *    math.cbrt(-64);                 // returns -4
   *    math.cbrt(math.unit('27 m^3')); // returns Unit 3 m
   *    math.cbrt([27, 64, 125]);       // returns [3, 4, 5]
   *
   *    var x = math.complex('8i');
   *    math.cbrt(x);                   // returns Complex 1.7320508075689 + i
   *    math.cbrt(x, true);             // returns Matrix [
   *                                    //    1.7320508075689 + i
   *                                    //   -1.7320508075689 + i
   *                                    //   -2i
   *                                    // ]
   *
   * See also:
   *
   *    square, sqrt, cube
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x
   *            Value for which to calculate the cubic root.
   * @param {boolean} [allRoots]  Optional, false by default. Only applicable
   *            when `x` is a number or complex number. If true, all complex
   *            roots are returned, if false (default) the principal root is
   *            returned.
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}
   *            Returns the cubic root of `x`
   */
  var cbrt = typed('cbrt', {
    'number': _cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex

    'Complex': _cbrtComplex,

    'Complex, boolean': _cbrtComplex,

    'BigNumber': function (x) {
      return x.cbrt();
    },

    'Unit': _cbrtUnit,

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since cbrt(0) = 0
      return deepMap(x, cbrt, true);
    }
  });

  /**
   * Calculate the cubic root for a complex number
   * @param {Complex} x
   * @param {boolean} [allRoots]   If true, the function will return an array
   *                               with all three roots. If false or undefined,
   *                               the principal root is returned.
   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
    // https://www.wikiwand.com/en/Cube_root#/Complex_numbers

    var arg_3 = x.arg() / 3;
    var abs = x.abs();

    // principal root:
    var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3).exp());

    if (allRoots) {
      var all = [
          principal,
          new type.Complex(_cbrtNumber(abs), 0).mul(
            new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
          new type.Complex(_cbrtNumber(abs), 0).mul(
            new type.Complex(0, arg_3 - Math.PI * 2 / 3).exp())
      ];

      return (config.matrix === 'Array') ? all : matrix(all);
    }
    else {
      return principal;
    }
  }

  /**
   * Calculate the cubic root for a Unit
   * @param {Unit} x
   * @return {Unit} Returns the cubic root of x
   * @private
   */
  function _cbrtUnit(x) {
    if(x.value && x.value.isComplex) {
      var result = x.clone();
      result.value = 1.0;
      result = result.pow(1.0/3);           // Compute the units
      result.value = _cbrtComplex(x.value); // Compute the value
      return result;
    }
    else {
      var negate = isNegative(x.value);
      if (negate) {
        x.value = unaryMinus(x.value);
      }

      // TODO: create a helper function for this
      var third;
      if (x.value && x.value.isBigNumber) {
        third = new type.BigNumber(1).div(3);
      }
      else if (x.value && x.value.isFraction) {
        third = new type.Fraction(1, 3);
      }
      else {
        third = 1/3;
      }

      var result = x.pow(third);

      if (negate) {
        result.value = unaryMinus(result.value);
      }

      return result;
    }
  }

  cbrt.toTex = {1: '\\sqrt[3]{${args[0]}}'};

  return cbrt;
}

/**
 * Calculate cbrt for a number
 *
 * Code from es6-shim.js:
 *   https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1564-L1577
 *
 * @param {number} x
 * @returns {number | Complex} Returns the cubic root of x
 * @private
 */
var _cbrtNumber = Math.cbrt || function (x) {
  if (x === 0) {
    return x;
  }

  var negate = x < 0;
  var result;
  if (negate) {
    x = -x;
  }

  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
    result = (x / (result * result) + (2 * result)) / 3;
  } else {
    result = x;
  }

  return negate ? -result : result;
};

exports.name = 'cbrt';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/collection/deepMap":353,"../utils/isNegative":321,"./unaryMinus":272}],245:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *
   * Examples:
   *
   *    math.ceil(3.2);               // returns number 4
   *    math.ceil(3.8);               // returns number 4
   *    math.ceil(-4.2);              // returns number -4
   *    math.ceil(-4.7);              // returns number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.ceil(c);                 // returns Complex 4 - 2i
   *
   *    math.ceil([3.2, 3.8, -4.7]);  // returns Array [4, 4, -4]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
  var ceil = typed('ceil', {
    'number': Math.ceil,

    'Complex': function (x) {
      return x.ceil();
    },

    'BigNumber': function (x) {
      return x.ceil();
    },

    'Fraction': function (x) {
      return x.ceil();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since ceil(0) = 0
      return deepMap(x, ceil, true);
    }
  });

  ceil.toTex = {1: '\\left\\lceil${args[0]}\\right\\rceil'};

  return ceil;
}

exports.name = 'ceil';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],246:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Compute the cube of a value, `x * x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2);            // returns number 8
   *    math.pow(2, 3);          // returns number 8
   *    math.cube(4);            // returns number 64
   *    4 * 4 * 4;               // returns number 64
   *
   *    math.cube([1, 2, 3, 4]); // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow, cbrt
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x  Number for which to calculate the cube
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} Cube of x
   */
  var cube = typed('cube', {
    'number': function (x) {
      return x * x * x;
    },

    'Complex': function (x) {
      return x.mul(x).mul(x); // Is faster than pow(x, 3)
    },

    'BigNumber': function (x) {
      return x.times(x).times(x);
    },

    'Fraction': function (x) {
      return x.pow(3); // Is faster than mul()mul()mul()
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since cube(0) = 0
      return deepMap(x, cube, true);
    },

    'Unit': function(x) {
      return x.pow(3);
    }
  });

  cube.toTex = {1: '\\left(${args[0]}\\right)^3'};

  return cube;
}

exports.name = 'cube';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],247:[function(require,module,exports){
'use strict';

var extend = require('../../utils/object').extend;

function factory (type, config, load, typed) {

  var divideScalar = load(require('./divideScalar'));
  var multiply     = load(require('./multiply'));
  var inv          = load(require('../matrix/inv'));
  var matrix       = load(require('../../type/matrix/function/matrix'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3);            // returns number 0.6666666666666666
   *
   *    var a = math.complex(5, 14);
   *    var b = math.complex(4, 1);
   *    math.divide(a, b);            // returns Complex 2 + 3i
   *
   *    var c = [[7, -6], [13, -4]];
   *    var d = [[1, 2], [4, 3]];
   *    math.divide(c, d);            // returns Array [[-9, 4], [-11, 6]]
   *
   *    var e = math.unit('18 km');
   *    math.divide(e, 4.5);          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */
  var divide = typed('divide', extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices

    'Array | Matrix, Array | Matrix': function (x, y) {
      // TODO: implement matrix right division using pseudo inverse
      // http://www.mathworks.nl/help/matlab/ref/mrdivide.html
      // http://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
      // http://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
      return multiply(x, inv(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;

      // process storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, divideScalar, false);
          break;
        case 'dense':
          c = algorithm14(x, y, divideScalar, false);
          break;
      }
      return c;
    },
    
    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
    },

    'any, Array | Matrix': function (x, y) {
      return multiply(x, inv(y));
    }
  }, divideScalar.signatures));

  divide.toTex = {2: '\\frac{${args[0]}}{${args[1]}}'};

  return divide;
}

exports.name = 'divide';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm14":341,"../../utils/object":362,"../matrix/inv":280,"./divideScalar":248,"./multiply":262}],248:[function(require,module,exports){
'use strict';

function factory(type, config, load, typed) {
  var multiplyScalar = load(require('./multiplyScalar'));

  /**
   * Divide two scalar values, `x / y`.
   * This function is meant for internal use: it is used by the public functions
   * `divide` and `inv`.
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Quotient, `x / y`
   * @private
   */
  var divideScalar = typed('divide', {
    'number, number': function (x, y) {
      return x / y;
    },

    'Complex, Complex': function (x, y) {
      return x.div(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.div(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.div(y);
    },

    'Unit, number | Fraction | BigNumber': function (x, y) {
      var res = x.clone();
      // TODO: move the divide function to Unit.js, it uses internals of Unit
      res.value = divideScalar(((res.value === null) ? res._normalize(1) : res.value), y);
      return res;
    },

    'number | Fraction | BigNumber, Unit': function (x, y) {
      var res = y.pow(-1);
      // TODO: move the divide function to Unit.js, it uses internals of Unit
      res.value = multiplyScalar(((res.value === null) ? res._normalize(1) : res.value), x);
      return res;
    },

    'Unit, Unit': function (x, y) {
      return x.divide(y);
    }

  });

  return divideScalar;
}

exports.factory = factory;

},{"./multiplyScalar":263}],249:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var divideScalar = load(require('./divideScalar'));
  var latex = require('../../utils/latex');
  
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4);   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotDivide(a, b);   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b);      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */
  var dotDivide = typed('dotDivide', {
    
    'any, any': divideScalar,
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse ./ sparse
              c = algorithm07(x, y, divideScalar, false);
              break;
            default:
              // sparse ./ dense
              c = algorithm02(y, x, divideScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense ./ sparse
              c = algorithm03(x, y, divideScalar, false);
              break;
            default:
              // dense ./ dense
              c = algorithm13(x, y, divideScalar);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotDivide(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotDivide(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotDivide(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, divideScalar, false);
          break;
        default:
          c = algorithm14(x, y, divideScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, divideScalar, true);
          break;
        default:
          c = algorithm14(y, x, divideScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, divideScalar, true).valueOf();
    }
  });

  dotDivide.toTex = {
    2: '\\left(${args[0]}' + latex.operators['dotDivide'] + '${args[1]}\\right)'
  };
  
  return dotDivide;
}

exports.name = 'dotDivide';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm02":330,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm07":335,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex":360,"./divideScalar":248}],250:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var multiplyScalar = load(require('./multiplyScalar'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4); // returns 8
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotMultiply(a, b); // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b);    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */
  var dotMultiply = typed('dotMultiply', {
    
    'any, any': multiplyScalar,
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .* sparse
              c = algorithm09(x, y, multiplyScalar, false);
              break;
            default:
              // sparse .* dense
              c = algorithm02(y, x, multiplyScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .* sparse
              c = algorithm02(x, y, multiplyScalar, false);
              break;
            default:
              // dense .* dense
              c = algorithm13(x, y, multiplyScalar);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotMultiply(matrix(x), matrix(y)).valueOf();
    },
    
    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotMultiply(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotMultiply(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, multiplyScalar, false);
          break;
        default:
          c = algorithm14(x, y, multiplyScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, multiplyScalar, true);
          break;
        default:
          c = algorithm14(y, x, multiplyScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
    }
  });

  dotMultiply.toTex = {
    2: '\\left(${args[0]}' + latex.operators['dotMultiply'] + '${args[1]}\\right)'
  };
  
  return dotMultiply;
}

exports.name = 'dotMultiply';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm02":330,"../../type/matrix/utils/algorithm09":336,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex":360,"./multiplyScalar":263}],251:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var pow = load(require('./pow'));
  var latex = require('../../utils/latex');

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3);            // returns number 8
   *
   *    var a = [[1, 2], [4, 3]];
   *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */
  var dotPow = typed('dotPow', {
    
    'any, any': pow,
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .^ sparse
              c = algorithm07(x, y, pow, false);
              break;
            default:
              // sparse .^ dense
              c = algorithm03(y, x, pow, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .^ sparse
              c = algorithm03(x, y, pow, false);
              break;
            default:
              // dense .^ dense
              c = algorithm13(x, y, pow);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotPow(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotPow(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotPow(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, dotPow, false);
          break;
        default:
          c = algorithm14(x, y, dotPow, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, dotPow, true);
          break;
        default:
          c = algorithm14(y, x, dotPow, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, dotPow, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, dotPow, true).valueOf();
    }
  });

  dotPow.toTex = {
    2: '\\left(${args[0]}' + latex.operators['dotPow'] + '${args[1]}\\right)'
  };
  
  return dotPow;
}

exports.name = 'dotPow';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm07":335,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex":360,"./pow":266}],252:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the exponent of a value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2);                  // returns number 7.3890560989306495
   *    math.pow(math.e, 2);          // returns number 7.3890560989306495
   *    math.log(math.exp(2));        // returns number 2
   *
   *    math.exp([1, 2, 3]);
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    log, pow
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x  A number or matrix to exponentiate
   * @return {number | BigNumber | Complex | Array | Matrix} Exponent of `x`
   */
  var exp = typed('exp', {
    'number': Math.exp,

    'Complex': function (x) {
      return x.exp();
    },

    'BigNumber': function (x) {
      return x.exp();
    },

    'Array | Matrix': function (x) {
      // TODO: exp(sparse) should return a dense matrix since exp(0)==1
      return deepMap(x, exp);
    }
  });

  exp.toTex = {1: '\\exp\\left(${args[0]}\\right)'};

  return exp;
}

exports.name = 'exp';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],253:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *
   * Examples:
   *
   *    math.fix(3.2);                // returns number 3
   *    math.fix(3.8);                // returns number 3
   *    math.fix(-4.2);               // returns number -4
   *    math.fix(-4.7);               // returns number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.fix(c);                  // returns Complex 3 - 2i
   *
   *    math.fix([3.2, 3.8, -4.7]);   // returns Array [3, 3, -4]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
    'number': function (x) {
      return (x > 0) ? Math.floor(x) : Math.ceil(x);
    },

    'Complex': function (x) {
      return new type.Complex(
          (x.re > 0) ? Math.floor(x.re) : Math.ceil(x.re),
          (x.im > 0) ? Math.floor(x.im) : Math.ceil(x.im)
      );
    },

    'BigNumber': function (x) {
      return x.isNegative() ? x.ceil() : x.floor();
    },

    'Fraction': function (x) {
      return x.s < 0 ? x.ceil() : x.floor();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since fix(0) = 0
      return deepMap(x, fix, true);
    }
  });

  fix.toTex = {1: '\\mathrm{${name}}\\left(${args[0]}\\right)'};

  return fix;
}

exports.name = 'fix';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],254:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *
   * Examples:
   *
   *    math.floor(3.2);              // returns number 3
   *    math.floor(3.8);              // returns number 3
   *    math.floor(-4.2);             // returns number -5
   *    math.floor(-4.7);             // returns number -5
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.floor(c);                // returns Complex 3 - 3i
   *
   *    math.floor([3.2, 3.8, -4.7]); // returns Array [3, 3, -5]
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
  var floor = typed('floor', {
    'number': Math.floor,

    'Complex': function (x) {
      return x.floor();
    },

    'BigNumber': function (x) {
      return x.floor();
    },

    'Fraction': function (x) {
      return x.floor();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since floor(0) = 0
      return deepMap(x, floor, true);
    }
  });

  floor.toTex = {1: '\\left\\lfloor${args[0]}\\right\\rfloor'};

  return floor;
}

exports.name = 'floor';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],255:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12);              // returns 4
   *    math.gcd(-4, 6);              // returns 2
   *    math.gcd(25, 15, -10);        // returns 5
   *
   *    math.gcd([8, -4], [12, 6]);   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
   */
  var gcd = typed('gcd', {

    'number, number': _gcd,

    'BigNumber, BigNumber': _gcdBigNumber,

    'Fraction, Fraction': function (x, y) {
      return x.gcd(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, gcd);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, gcd, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, gcd, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, gcd);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return gcd(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return gcd(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return gcd(x, matrix(y));
    },
    
    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, gcd, false);
          break;
        default:
          c = algorithm14(x, y, gcd, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, gcd, true);
          break;
        default:
          c = algorithm14(y, x, gcd, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, gcd, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, gcd, true).valueOf();
    },

    // TODO: need a smarter notation here
    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function (a, b, args) {
      var res = gcd(a, b);
      for (var i = 0; i < args.length; i++) {
        res = gcd(res, args[i]);
      }
      return res;
    }
  });

  gcd.toTex = '\\gcd\\left(${args}\\right)';

  return gcd;

  /**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denominator of a and b
   * @private
   */
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.mod(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}

/**
 * Calculate gcd for numbers
 * @param {number} a
 * @param {number} b
 * @returns {number} Returns the greatest common denominator of a and b
 * @private
 */
function _gcd(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error('Parameters in function gcd must be integer numbers');
  }

  // http://en.wikipedia.org/wiki/Euclidean_algorithm
  var r;
  while (b != 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return (a < 0) ? -a : a;
}

exports.name = 'gcd';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm01":329,"../../type/matrix/utils/algorithm04":332,"../../type/matrix/utils/algorithm10":337,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/number":361}],256:[function(require,module,exports){
'use strict';

var flatten = require('../../utils/array').flatten;

function factory (type, config, load, typed) {
  var abs = load(require('./abs'));
  var add = load(require('./addScalar'));
  var divide = load(require('./divideScalar'));
  var multiply = load(require('./multiplyScalar'));
  var sqrt = load(require('./sqrt'));
  var smaller = load(require('../relational/smaller'));
  var isPositive = load(require('../utils/isPositive'));

  /**
   * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:
   *
   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
   *
   * For matrix input, the hypotenusa is calculated for all values in the matrix.
   *
   * Syntax:
   *
   *     math.hypot(a, b, ...)
   *     math.hypot([a, b, c, ...])
   *
   * Examples:
   *
   *     math.hypot(3, 4);      // 5
   *     math.hypot(3, 4, 5);   // 7.0710678118654755
   *     math.hypot([3, 4, 5]); // 7.0710678118654755
   *     math.hypot(-2);        // 2
   *
   * See also:
   *
   *     abs, norm
   *
   * @param {... number | BigNumber} args
   * @return {number | BigNumber} Returns the hypothenusa of the input values.
   */
  var hypot = typed('hypot', {
    '... number | BigNumber': _hypot,

    'Array': function (x) {
      return hypot.apply(hypot, flatten(x));
    },

    'Matrix': function (x) {
      return hypot.apply(hypot, flatten(x.toArray()));
    }
  });

  /**
   * Calculate the hypotenusa for an Array with values
   * @param {Array.<number | BigNumber>} args
   * @return {number | BigNumber} Returns the result
   * @private
   */
  function _hypot (args) {
    // code based on `hypot` from es6-shim:
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
    var result = 0;
    var largest = 0;

    for (var i = 0; i < args.length; i++) {
      var value = abs(args[i]);
      if (smaller(largest, value)) {
        result = multiply(result, multiply(divide(largest, value), divide(largest, value)));
        result = add(result, 1);
        largest = value;
      } else {
        result = add(result, isPositive(value) ? multiply(divide(value, largest), divide(value, largest)) : value);
      }
    }

    return multiply(largest, sqrt(result));
  }

  hypot.toTex = '\\hypot\\left(${args}\\right)';

  return hypot;
}

exports.name = 'hypot';
exports.factory = factory;

},{"../../utils/array":346,"../relational/smaller":290,"../utils/isPositive":323,"./abs":241,"./addScalar":243,"./divideScalar":248,"./multiplyScalar":263,"./sqrt":269}],257:[function(require,module,exports){
module.exports = [
  require('./abs'),
  require('./add'),
  require('./addScalar'),
  require('./cbrt'),
  require('./ceil'),
  require('./cube'),
  require('./divide'),
  require('./dotDivide'),
  require('./dotMultiply'),
  require('./dotPow'),
  require('./exp'),
  require('./fix'),
  require('./floor'),
  require('./gcd'),
  require('./hypot'),
  require('./lcm'),
  require('./log'),
  require('./log10'),
  require('./mod'),
  require('./multiply'),
  require('./norm'),
  require('./nthRoot'),
  require('./pow'),
  require('./round'),
  require('./sign'),
  require('./sqrt'),
  require('./square'),
  require('./subtract'),
  require('./unaryMinus'),
  require('./unaryPlus'),
  require('./xgcd')
];

},{"./abs":241,"./add":242,"./addScalar":243,"./cbrt":244,"./ceil":245,"./cube":246,"./divide":247,"./dotDivide":249,"./dotMultiply":250,"./dotPow":251,"./exp":252,"./fix":253,"./floor":254,"./gcd":255,"./hypot":256,"./lcm":258,"./log":259,"./log10":260,"./mod":261,"./multiply":262,"./norm":264,"./nthRoot":265,"./pow":266,"./round":267,"./sign":268,"./sqrt":269,"./square":270,"./subtract":271,"./unaryMinus":272,"./unaryPlus":273,"./xgcd":274}],258:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6);               // returns 12
   *    math.lcm(6, 21);              // returns 42
   *    math.lcm(6, 21, 5);           // returns 210
   *
   *    math.lcm([4, 6], [6, 21]);    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Array | Matrix}                           The least common multiple
   */
  var lcm = typed('lcm', {
    'number, number': _lcm,

    'BigNumber, BigNumber': _lcmBigNumber,

    'Fraction, Fraction': function (x, y) {

      return x.lcm(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm06(x, y, lcm);
              break;
            default:
              // sparse + dense
              c = algorithm02(y, x, lcm, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm02(x, y, lcm, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, lcm);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return lcm(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return lcm(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return lcm(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, lcm, false);
          break;
        default:
          c = algorithm14(x, y, lcm, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, lcm, true);
          break;
        default:
          c = algorithm14(y, x, lcm, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, lcm, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, lcm, true).valueOf();
    },

    // TODO: need a smarter notation here
    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function (a, b, args) {
      var res = lcm(a, b);
      for (var i = 0; i < args.length; i++) {
        res = lcm(res, args[i]);
      }
      return res;
    }
  });

  lcm.toTex = undefined;  // use default template

  return lcm;

  /**
   * Calculate lcm for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns the least common multiple of a and b
   * @private
   */
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function lcm must be integer numbers');
    }

    if (a.isZero() || b.isZero()) {
      return new type.BigNumber(0);
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    // evaluate lcm here inline to reduce overhead
    var prod = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod.div(a).abs();
  }
}

/**
 * Calculate lcm for two numbers
 * @param {number} a
 * @param {number} b
 * @returns {number} Returns the least common multiple of a and b
 * @private
 */
function _lcm (a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error('Parameters in function lcm must be integer numbers');
  }

  if (a == 0 || b == 0) {
    return 0;
  }

  // http://en.wikipedia.org/wiki/Euclidean_algorithm
  // evaluate lcm here inline to reduce overhead
  var t;
  var prod = a * b;
  while (b != 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod / a);
}

exports.name = 'lcm';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm02":330,"../../type/matrix/utils/algorithm06":334,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/number":361}],259:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var divideScalar = load(require('./divideScalar'));

  /**
   * Calculate the logarithm of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log(x)
   *    math.log(x, base)
   *
   * Examples:
   *
   *    math.log(3.5);                  // returns 1.252762968495368
   *    math.exp(math.log(2.4));        // returns 2.4
   *
   *    math.pow(10, 4);                // returns 10000
   *    math.log(10000, 10);            // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *
   *    math.log(1024, 2);              // returns 10
   *    math.pow(2, 10);                // returns 1024
   *
   * See also:
   *
   *    exp, log10
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @param {number | BigNumber | Complex} [base=e]
   *            Optional base for the logarithm. If not provided, the natural
   *            logarithm of `x` is calculated.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the logarithm of `x`
   */
  var log = typed('log', {
    'number': function (x) {
      if (x >= 0 || config.predictable) {
        return Math.log(x);
      }
      else {
        // negative value -> complex value computation
        return new type.Complex(x, 0).log();
      }
    },

    'Complex': function (x) {
      return x.log();
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.ln();
      }
      else {
        // downgrade to number, return Complex valued result
        return new type.Complex(x.toNumber(), 0).log();
      }
    },

    'Array | Matrix': function (x) {
      return deepMap(x, log);
    },

    'any, any': function (x, base) {
      // calculate logarithm for a specified base, log(x, base)
      return divideScalar(log(x), log(base));
    }
  });

  log.toTex = {
    1: '\\ln\\left(${args[0]}\\right)',
    2: '\\log_{${args[1]}}\\left(${args[0]}\\right)'
  };

  return log;
}

exports.name = 'log';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"./divideScalar":248}],260:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001);            // returns -5
   *    math.log10(10000);              // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *    math.pow(10, 4);                // returns 10000
   *
   * See also:
   *
   *    exp, log
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */
  var log10 = typed('log10', {
    'number': function (x) {
      if (x >= 0 || config.predictable) {
        return _log10(x);
      }
      else {
        // negative value -> complex value computation
        return new type.Complex(x, 0).log().div(Math.LN10);
      }
    },

    'Complex': function (x) {
      return new type.Complex(x).log().div(Math.LN10);
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.log();
      }
      else {
        // downgrade to number, return Complex valued result
        return new type.Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },

    'Array | Matrix': function (x) {
      return deepMap(x, log10);
    }
  });

  log10.toTex = {1: '\\log_{10}\\left(${args[0]}\\right)'};

  return log10;
}

/**
 * Calculate the 10-base logarithm of a number
 * @param {number} x
 * @return {number}
 * @private
 */
var _log10 = Math.log10 || function (x) {
  return Math.log(x) / Math.LN10;
};

exports.name = 'log10';
exports.factory = factory;


},{"../../utils/collection/deepMap":353}],261:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See http://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3);                // returns 2
   *    math.mod(11, 2);               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0;
   *    }
   *
   *    isOdd(2);                      // returns false
   *    isOdd(3);                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend
   * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */
  var mod = typed('mod', {

    'number, number': _mod,

    'BigNumber, BigNumber': function (x, y) {
      return y.isZero() ? x : x.mod(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.mod(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // mod(sparse, sparse)
              c = algorithm05(x, y, mod, false);
              break;
            default:
              // mod(sparse, dense)
              c = algorithm02(y, x, mod, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // mod(dense, sparse)
              c = algorithm03(x, y, mod, false);
              break;
            default:
              // mod(dense, dense)
              c = algorithm13(x, y, mod);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return mod(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return mod(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return mod(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, mod, false);
          break;
        default:
          c = algorithm14(x, y, mod, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, mod, true);
          break;
        default:
          c = algorithm14(y, x, mod, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, mod, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, mod, true).valueOf();
    }
  });

  mod.toTex = {
    2: '\\left(${args[0]}' + latex.operators['mod'] + '${args[1]}\\right)'
  };

  return mod;

  /**
   * Calculate the modulus of two numbers
   * @param {number} x
   * @param {number} y
   * @returns {number} res
   * @private
   */
  function _mod(x, y) {
    if (y > 0) {
      // We don't use JavaScript's % operator here as this doesn't work
      // correctly for x < 0 and x == 0
      // see http://en.wikipedia.org/wiki/Modulo_operation
      return x - y * Math.floor(x / y);
    }
    else if (y === 0) {
      return x;
    }
    else { // y < 0
      // TODO: implement mod for a negative divisor
      throw new Error('Cannot calculate mod for a negative divisor');
    }
  }
}

exports.name = 'mod';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm02":330,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm05":333,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex":360}],262:[function(require,module,exports){
'use strict';

var extend = require('../../utils/object').extend;
var array = require('../../utils/array');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var multiplyScalar = load(require('./multiplyScalar'));
  var equalScalar = load(require('../relational/equalScalar'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  var DenseMatrix = type.DenseMatrix;
  var SparseMatrix = type.SparseMatrix;

  /**
   * Multiply two or more values, `x * y`.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *    math.multiply(x, y, z, ...)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2);        // returns number 20.8
   *    math.multiply(2, 3, 4);       // returns number 24
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.multiply(a, b);          // returns Complex 5 + 14i
   *
   *    var c = [[1, 2], [4, 3]];
   *    var d = [[1, 2, 3], [3, -4, 7]];
   *    math.multiply(c, d);          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    var e = math.unit('2.1 km');
   *    math.multiply(3, e);          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide, prod, cross, dot
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */
  var multiply = typed('multiply', extend({
    // we extend the signatures of multiplyScalar with signatures dealing with matrices

    'Array, Array': function (x, y) {
      // check dimensions
      _validateMatrixDimensions(array.size(x), array.size(y));

      // use dense matrix implementation
      var m = multiply(matrix(x), matrix(y));
      // return array or scalar
      return (m && m.isMatrix === true) ? m.valueOf() : m;
    },

    'Matrix, Matrix': function (x, y) {
      // dimensions
      var xsize = x.size();
      var ysize = y.size();

      // check dimensions
      _validateMatrixDimensions(xsize, ysize);

      // process dimensions
      if (xsize.length === 1) {
        // process y dimensions
        if (ysize.length === 1) {
          // Vector * Vector
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        // Vector * Matrix
        return _multiplyVectorMatrix(x, y);
      }
      // process y dimensions
      if (ysize.length === 1) {
        // Matrix * Vector
        return _multiplyMatrixVector(x, y);
      }
      // Matrix * Matrix
      return _multiplyMatrixMatrix(x, y);
    },

    'Matrix, Array': function (x, y) {
      // use Matrix * Matrix implementation
      return multiply(x, matrix(y));
    },

    'Array, Matrix': function (x, y) {
      // use Matrix * Matrix implementation
      return multiply(matrix(x, y.storage()), y);
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      
      // process storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, multiplyScalar, false);
          break;
        case 'dense':
          c = algorithm14(x, y, multiplyScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, multiplyScalar, true);
          break;
        case 'dense':
          c = algorithm14(y, x, multiplyScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
    },

    'any, any': multiplyScalar,

    'any, any, ...any': function (x, y, rest) {
      var result = multiply(x, y);

      for (var i = 0; i < rest.length; i++) {
        result = multiply(result, rest[i]);
      }

      return result;
    }
  }, multiplyScalar.signatures));

  var _validateMatrixDimensions = function (size1, size2) {
    // check left operand dimensions
    switch (size1.length) {
      case 1:
        // check size2
        switch (size2.length) {
          case 1:
            // Vector x Vector
            if (size1[0] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
            }
            break;
          case 2:
            // Vector x Matrix
            if (size1[0] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
            }
            break;
          default:
            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
        }
        break;
      case 2:
        // check size2
        switch (size2.length) {
          case 1:
            // Matrix x Vector
            if (size1[1] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
            }
            break;
          case 2:
            // Matrix x Matrix
            if (size1[1] !== size2[0]) {
              // throw error
              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
            }
            break;
          default:
            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
        }
        break;
      default:
        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
    }
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (N)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {number}             Scalar value
   */
  var _multiplyVectorVector = function (a, b, n) {
    // check empty vector
    if (n === 0)
      throw new Error('Cannot multiply two empty vectors');

    // a dense
    var adata = a._data;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    
    // result (do not initialize it with zero)
    var c = mf(adata[0], bdata[0]);
    // loop data
    for (var i = 1; i < n; i++) {
      // multiply and accumulate
      c = af(c, mf(adata[i], bdata[i]));
    }
    return c;
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Matrix         (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */
  var _multiplyVectorMatrix = function (a, b) {
    // process storage
    switch (b.storage()) {
      case 'dense':
        return _multiplyVectorDenseMatrix(a, b);
    }
    throw new Error('Not implemented');
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Dense Vector   (M)
   * @param {Matrix} b            Dense Matrix   (MxN)
   *
   * @return {Matrix}             Dense Vector   (N)
   */
  var _multiplyVectorDenseMatrix = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    // rows & columns
    var alength = asize[0];
    var bcolumns = bsize[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }

    // result
    var c = [];

    // loop matrix columns
    for (var j = 0; j < bcolumns; j++) {
      // sum (do not initialize it with zero)
      var sum = mf(adata[0], bdata[0][j]);      
      // loop vector
      for (var i = 1; i < alength; i++) {
        // multiply & accumulate
        sum = af(sum, mf(adata[i], bdata[i][j]));
      }
      c[j] = sum;
    }

    // return matrix
    return new DenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Dense Vector   (N)
   *
   * @return {Matrix}             Dense Vector   (M)
   */
  var _multiplyMatrixVector = function (a, b) {
    // process storage
    switch (a.storage()) {
      case 'dense':
        return _multiplyDenseMatrixVector(a, b);
      case 'sparse':
        return _multiplySparseMatrixVector(a, b);
    }
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            Matrix         (MxN)
   * @param {Matrix} b            Matrix         (NxC)
   *
   * @return {Matrix}             Matrix         (MxC)
   */
  var _multiplyMatrixMatrix = function (a, b) {
    // process storage
    switch (a.storage()) {
      case 'dense':
        // process storage
        switch (b.storage()) {
          case 'dense':
            return _multiplyDenseMatrixDenseMatrix(a, b);
          case 'sparse':
            return _multiplyDenseMatrixSparseMatrix(a, b);
        }
        break;
      case 'sparse':
        // process storage
        switch (b.storage()) {
          case 'dense':
            return _multiplySparseMatrixDenseMatrix(a, b);
          case 'sparse':
            return _multiplySparseMatrixSparseMatrix(a, b);
        }
        break;
    }
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix  (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             Dense Vector (M) 
   */ 
  var _multiplyDenseMatrixVector = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;
    // rows & columns
    var arows = asize[0];
    var acolumns = asize[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }

    // result
    var c = [];

    // loop matrix a rows
    for (var i = 0; i < arows; i++) {
      // current row
      var row = adata[i];
      // sum (do not initialize it with zero)
      var sum = mf(row[0], bdata[0]);
      // loop matrix a columns
      for (var j = 1; j < acolumns; j++) {
        // multiply & accumulate
        sum = af(sum, mf(row[j], bdata[j]));
      }
      c[i] = sum;
    }

    // return matrix
    return new DenseMatrix({
      data: c,
      size: [arows],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            DenseMatrix    (NxC)
   *
   * @return {Matrix}             DenseMatrix    (MxC)
   */
  var _multiplyDenseMatrixDenseMatrix = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b dense
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    // rows & columns
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    
    // result
    var c = [];

    // loop matrix a rows
    for (var i = 0; i < arows; i++) {
      // current row
      var row = adata[i];
      // initialize row array
      c[i] = [];
      // loop matrix b columns
      for (var j = 0; j < bcolumns; j++) {
        // sum (avoid initializing sum to zero)
        var sum = mf(row[0], bdata[0][j]);
        // loop matrix a columns
        for (var x = 1; x < acolumns; x++) {
          // multiply & accumulate
          sum = af(sum, mf(row[x], bdata[x][j]));
        }
        c[i][j] = sum;
      }
    }

    // return matrix
    return new DenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            DenseMatrix    (MxN)
   * @param {Matrix} b            SparseMatrix   (NxC)
   *
   * @return {Matrix}             SparseMatrix   (MxC)
   */
  var _multiplyDenseMatrixSparseMatrix = function (a, b) {
    // a dense
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b sparse
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    // validate b matrix
    if (!bvalues)
      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
    // rows & columns
    var arows = asize[0];
    var bcolumns = bsize[1];
    
    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;
    // equalScalar signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
    }

    // result
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // c matrix
    var c = new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });

    // loop b columns
    for (var jb = 0; jb < bcolumns; jb++) {
      // update ptr
      cptr[jb] = cindex.length;
      // indeces in column jb
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      // do not process column jb if no data exists
      if (kb1 > kb0) {
        // last row mark processed
        var last = 0;
        // loop a rows
        for (var i = 0; i < arows; i++) {
          // column mark
          var mark = i + 1;
          // C[i, jb]
          var cij;
          // values in b column j
          for (var kb = kb0; kb < kb1; kb++) {
            // row
            var ib = bindex[kb];
            // check value has been initialized
            if (last !== mark) {
              // first value in column jb
              cij = mf(adata[i][ib], bvalues[kb]);
              // update mark
              last = mark;
            }
            else {
              // accumulate value
              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
            }
          }
          // check column has been processed and value != 0
          if (last === mark && !eq(cij, zero)) {
            // push row & value
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
    }
    // update ptr
    cptr[bcolumns] = cindex.length;

    // return sparse matrix
    return c;
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix    (MxN)
   * @param {Matrix} b            Dense Vector (N)
   *
   * @return {Matrix}             SparseMatrix    (M, 1) 
   */
  var _multiplySparseMatrixVector = function (a, b) {
    // a sparse
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    // validate a matrix
    if (!avalues)
      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;
    // rows & columns
    var arows = a._size[0];
    var brows = b._size[0];
    // result
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    
    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;
    // equalScalar signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
    }

    // workspace
    var x = [];
    // vector with marks indicating a value x[i] exists in a given column
    var w = [];

    // update ptr
    cptr[0] = 0;
    // rows in b
    for (var ib = 0; ib < brows; ib++) {
      // b[ib]
      var vbi = bdata[ib];
      // check b[ib] != 0, avoid loops
      if (!eq(vbi, zero)) {
        // A values & index in ib column
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          // a row
          var ia = aindex[ka];
          // check value exists in current j
          if (!w[ia]) {
            // ia is new entry in j
            w[ia] = true;
            // add i to pattern of C
            cindex.push(ia);
            // x(ia) = A
            x[ia] = mf(vbi, avalues[ka]);
          }
          else {
            // i exists in C already
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    // copy values from x to column jb of c
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      // row
      var ic = cindex[p];
      // copy value
      cvalues[p] = x[ic];
    }
    // update ptr
    cptr[1] = cindex.length;

    // return sparse matrix
    return new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            DenseMatrix       (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */
  var _multiplySparseMatrixDenseMatrix = function (a, b) {
    // a sparse
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    // validate a matrix
    if (!avalues)
      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
    // b dense
    var bdata = b._data;
    var bdt = b._datatype;
    // rows & columns
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;
    // equalScalar signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
    }

    // result
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // c matrix
    var c = new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });

    // workspace
    var x = [];
    // vector with marks indicating a value x[i] exists in a given column
    var w = [];

    // loop b columns
    for (var jb = 0; jb < bcolumns; jb++) {
      // update ptr
      cptr[jb] = cindex.length;
      // mark in workspace for current column
      var mark = jb + 1;
      // rows in jb
      for (var ib = 0; ib < brows; ib++) {
        // b[ib, jb]
        var vbij = bdata[ib][jb];
        // check b[ib, jb] != 0, avoid loops
        if (!eq(vbij, zero)) {
          // A values & index in ib column
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // a row
            var ia = aindex[ka];
            // check value exists in current j
            if (w[ia] !== mark) {
              // ia is new entry in j
              w[ia] = mark;
              // add i to pattern of C
              cindex.push(ia);
              // x(ia) = A
              x[ia] = mf(vbij, avalues[ka]);
            }
            else {
              // i exists in C already
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      // copy values from x to column jb of c
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        // row
        var ic = cindex[p];
        // copy value
        cvalues[p] = x[ic];
      }
    }
    // update ptr
    cptr[bcolumns] = cindex.length;

    // return sparse matrix
    return c;
  };

  /**
   * C = A * B
   *
   * @param {Matrix} a            SparseMatrix      (MxN)
   * @param {Matrix} b            SparseMatrix      (NxC)
   *
   * @return {Matrix}             SparseMatrix      (MxC)
   */
  var _multiplySparseMatrixSparseMatrix = function (a, b) {
    // a sparse
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    // b sparse
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    
    // rows & columns
    var arows = a._size[0];
    var bcolumns = b._size[1];
    // flag indicating both matrices (a & b) contain data
    var values = avalues && bvalues;

    // datatype
    var dt;
    // addScalar signature to use
    var af = addScalar;
    // multiplyScalar signature to use
    var mf = multiplyScalar;

    // process data types
    if (adt && bdt && adt === bdt && typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signatures that matches (dt, dt)
      af = typed.find(addScalar, [dt, dt]);
      mf = typed.find(multiplyScalar, [dt, dt]);
    }
    
    // result
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // c matrix
    var c = new SparseMatrix({
      values : cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });

    // workspace
    var x = values ? [] : undefined;
    // vector with marks indicating a value x[i] exists in a given column
    var w = [];
    // variables
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    // loop b columns
    for (var jb = 0; jb < bcolumns; jb++) {
      // update ptr
      cptr[jb] = cindex.length;
      // mark in workspace for current column
      var mark = jb + 1;
      // B values & index in j
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        // b row
        ib = bindex[kb];
        // check we need to process values
        if (values) {
          // loop values in a[:,ib]
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // row
            ia = aindex[ka];
            // check value exists in current j
            if (w[ia] !== mark) {
              // ia is new entry in j
              w[ia] = mark;
              // add i to pattern of C
              cindex.push(ia);
              // x(ia) = A
              x[ia] = mf(bvalues[kb], avalues[ka]);
            }
            else {
              // i exists in C already
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        }
        else {
          // loop values in a[:,ib]
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // row
            ia = aindex[ka];
            // check value exists in current j
            if (w[ia] !== mark) {
              // ia is new entry in j
              w[ia] = mark;
              // add i to pattern of C
              cindex.push(ia);
            }
          }
        }
      }
      // check we need to process matrix values (pattern matrix)
      if (values) {
        // copy values from x to column jb of c
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          // row
          var ic = cindex[p];
          // copy value
          cvalues[p] = x[ic];
        }
      }
    }
    // update ptr
    cptr[bcolumns] = cindex.length;

    // return sparse matrix
    return c;
  };

  multiply.toTex = {
    2: '\\left(${args[0]}' + latex.operators['multiply'] + '${args[1]}\\right)'
  };

  return multiply;
}

exports.name = 'multiply';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm14":341,"../../utils/array":346,"../../utils/latex":360,"../../utils/object":362,"../relational/equalScalar":288,"./addScalar":243,"./multiplyScalar":263}],263:[function(require,module,exports){
'use strict';

function factory(type, config, load, typed) {
  
  /**
   * Multiply two scalar values, `x * y`.
   * This function is meant for internal use: it is used by the public function
   * `multiply`
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Multiplication of `x` and `y`
   * @private
   */
  var multiplyScalar = typed('multiplyScalar', {

    'number, number': function (x, y) {
      return x * y;
    },

    'Complex, Complex': function (x, y) {
      return x.mul(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.times(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.mul(y);
    },

    'number | Fraction | BigNumber | Complex, Unit': function (x, y) {
      var res = y.clone();
      res.value = (res.value === null) ? res._normalize(x) : multiplyScalar(res.value, x);
      return res;
    },

    'Unit, number | Fraction | BigNumber | Complex': function (x, y) {
      var res = x.clone();
      res.value = (res.value === null) ? res._normalize(y) : multiplyScalar(res.value, y);
      return res;
    },

    'Unit, Unit': function (x, y) {
      return x.multiply(y);
    }

  });

  return multiplyScalar;
}

exports.factory = factory;

},{}],264:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  
  var abs         = load(require('../arithmetic/abs'));
  var add         = load(require('../arithmetic/add'));
  var pow         = load(require('../arithmetic/pow'));
  var sqrt        = load(require('../arithmetic/sqrt'));
  var multiply    = load(require('../arithmetic/multiply'));
  var equalScalar = load(require('../relational/equalScalar'));
  var larger      = load(require('../relational/larger'));
  var smaller     = load(require('../relational/smaller'));
  var matrix      = load(require('../../type/matrix/function/matrix'));
  var trace       = load(require('../matrix/trace'));
  var transpose   = load(require('../matrix/transpose'));


  /**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5);                         // returns 3.5
   *    math.norm(-3.5);                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4));         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity);        // returns 3
   *    math.norm([1, 2, -3], -Infinity);       // returns 1
   *
   *    math.norm([3, 4], 2);                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf');     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro');     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs, hypot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the norm
   * @param  {number | BigNumber | string} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {number | BigNumber} the p-norm
   */
  var norm = typed('norm', {
    'number': Math.abs,

    'Complex': function (x) {
      return x.abs();
    },

    'BigNumber': function (x) {
      // norm(x) = abs(x)
      return x.abs();
    },
    
    'boolean | null' : function (x) {
      // norm(x) = abs(x)
      return Math.abs(x);
    },

    'Array': function (x) {
      return _norm(matrix(x), 2);
    },
    
    'Matrix': function (x) {
      return _norm(x, 2);
    },

    'number | Complex | BigNumber | boolean | null, number | BigNumber | string': function (x) {
      // ignore second parameter, TODO: remove the option of second parameter for these types
      return norm(x);
    },

    'Array, number | BigNumber | string': function (x, p) {
      return _norm(matrix(x), p);
    },
    
    'Matrix, number | BigNumber | string': function (x, p) {
      return _norm(x, p);
    }
  });

  /**
   * Calculate the norm for an array
   * @param {Array} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */
  function _norm (x, p) {
    // size
    var sizeX = x.size();
    
    // check if it is a vector
    if (sizeX.length == 1) {
      // check p
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        // norm(x, Infinity) = max(abs(x))
        var pinf = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value) {
            var v = abs(value);
            if (larger(v, pinf))
              pinf = v;
          },
          true);
        return pinf;
      }
      if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
        // norm(x, -Infinity) = min(abs(x))
        var ninf;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value) {
            var v = abs(value);
            if (!ninf || smaller(v, ninf))
              ninf = v;
          },
          true);
        return ninf || 0;
      }
      if (p === 'fro') {
        return _norm(x, 2);
      }
      if (typeof p === 'number' && !isNaN(p)) {
        // check p != 0
        if (!equalScalar(p, 0)) {
          // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
          var n = 0;
          // skip zeros since abs(0) == 0
          x.forEach(
            function (value) {
              n = add(pow(abs(value), p), n);
            },
            true);
          return pow(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      // invalid parameter value
      throw new Error('Unsupported parameter value');
    }
    // MxN matrix
    if (sizeX.length == 2) {
      // check p
      if (p === 1) {
        // norm(x) = the largest column sum
        var c = [];
        // result
        var maxc = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value, index) {
            var j = index[1];
            var cj = add(c[j] || 0, abs(value));
            if (larger(cj, maxc))
              maxc = cj;
            c[j] = cj;
          },
          true);
        return maxc;
      }
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        // norm(x) = the largest row sum
        var r = [];
        // result
        var maxr = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value, index) {
            var i = index[0];
            var ri = add(r[i] || 0, abs(value));
            if (larger(ri, maxr))
              maxr = ri;
            r[i] = ri;
          },
          true);
        return maxr;
      }
      if (p === 'fro') {
        // norm(x) = sqrt(sum(diag(x'x)))
        return sqrt(trace(multiply(transpose(x), x)));
      }
      if (p === 2) {
        // not implemented
        throw new Error('Unsupported parameter value, missing implementation of matrix singular value decomposition');
      }
      // invalid parameter value
      throw new Error('Unsupported parameter value');
    }
  }

  norm.toTex = {
    1: '\\left\\|${args[0]}\\right\\|',
    2: undefined  // use default template
  };

  return norm;
}

exports.name = 'norm';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../arithmetic/abs":241,"../arithmetic/add":242,"../arithmetic/multiply":262,"../arithmetic/pow":266,"../arithmetic/sqrt":269,"../matrix/trace":284,"../matrix/transpose":285,"../relational/equalScalar":288,"../relational/larger":289,"../relational/smaller":290}],265:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the nth root of a value.
   * The principal nth root of a positive real number A, is the positive real
   * solution of the equation
   *
   *     x^root = A
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *     math.nthRoot(a)
   *     math.nthRoot(a, root)
   *
   * Examples:
   *
   *     math.nthRoot(9, 2);    // returns 3, as 3^2 == 9
   *     math.sqrt(9);          // returns 3, as 3^2 == 9
   *     math.nthRoot(64, 3);   // returns 4, as 4^3 == 64
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param {number | BigNumber | Array | Matrix | Complex} a
   *              Value for which to calculate the nth root
   * @param {number | BigNumber} [root=2]    The root.
   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
   */
  var nthRoot = typed('nthRoot', {
    
    'number': function (x) {
      return _nthRoot(x, 2);
    },
    'number, number': _nthRoot,

    'BigNumber': function (x) {
      return _bigNthRoot(x, new type.BigNumber(2));
    },
    'Complex' : function(x) {
      return _nthComplexRoot(x, 2);
    }, 
    'Complex, number' : _nthComplexRoot,
    'BigNumber, BigNumber': _bigNthRoot,

    'Array | Matrix': function (x) {
      return nthRoot(x, 2);
    },
    
    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // density must be one (no zeros in matrix)
              if (y.density() === 1) {
                // sparse + sparse
                c = algorithm06(x, y, nthRoot);
              }
              else {
                // throw exception
                throw new Error('Root must be non-zero');
              }
              break;
            default:
              // sparse + dense
              c = algorithm02(y, x, nthRoot, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // density must be one (no zeros in matrix)
              if (y.density() === 1) {
                // dense + sparse
                c = algorithm01(x, y, nthRoot, false);
              }
              else {
                // throw exception
                throw new Error('Root must be non-zero');
              }
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, nthRoot);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(x, matrix(y));
    },
    
    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, nthRoot, false);
          break;
        default:
          c = algorithm14(x, y, nthRoot, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          // density must be one (no zeros in matrix)
          if (y.density() === 1) {
            // sparse - scalar
            c = algorithm11(y, x, nthRoot, true);
          }
          else {
            // throw exception
            throw new Error('Root must be non-zero');
          }
          break;
        default:
          c = algorithm14(y, x, nthRoot, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), y).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(x, matrix(y)).valueOf();
    }
  });

  nthRoot.toTex = {2: '\\sqrt[${args[1]}]{${args[0]}}'};

  return nthRoot;

  /**
   * Calculate the nth root of a for BigNumbers, solve x^root == a
   * http://rosettacode.org/wiki/Nth_root#JavaScript
   * @param {BigNumber} a
   * @param {BigNumber} root
   * @private
   */
  function _bigNthRoot(a, root) {
    var precision = type.BigNumber.precision;
    var Big = type.BigNumber.clone({precision: precision + 2});
    var zero = new type.BigNumber(0);

    var one = new Big(1);
    var inv = root.isNegative();
    if (inv) {
      root = root.neg();
    }

    if (root.isZero()) {
      throw new Error('Root must be non-zero');
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error('Root must be odd when a is negative.');
    }

    // edge cases zero and infinity
    if (a.isZero()) {
      return inv ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv ? zero : a;
    }

    var x = a.abs().pow(one.div(root));
    // If a < 0, we require that root is an odd integer,
    // so (-1) ^ (1/root) = -1
    x = a.isNeg() ? x.neg() : x;
    return new type.BigNumber((inv ? one.div(x) : x).toPrecision(precision));
  }
}

/**
 * Calculate the nth root of a, solve x^root == a
 * http://rosettacode.org/wiki/Nth_root#JavaScript
 * @param {number} a
 * @param {number} root
 * @private
 */
function _nthRoot(a, root) {
  var inv = root < 0;
  if (inv) {
    root = -root;
  }

  if (root === 0) {
    throw new Error('Root must be non-zero');
  }
  if (a < 0 && (Math.abs(root) % 2 != 1)) {
    throw new Error('Root must be odd when a is negative.');
  }

  // edge cases zero and infinity
  if (a == 0) {
    return inv ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv ? 0 : a;
  }

  var x = Math.pow(Math.abs(a), 1/root);
  // If a < 0, we require that root is an odd integer,
  // so (-1) ^ (1/root) = -1
  x = a < 0 ? -x : x;
  return inv ? 1 / x : x;

  // Very nice algorithm, but fails with nthRoot(-2, 3).
  // Newton's method has some well-known problems at times:
  // https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis
  /*
  var x = 1; // Initial guess
  var xPrev = 1;
  var i = 0;
  var iMax = 10000;
  do {
    var delta = (a / Math.pow(x, root - 1) - x) / root;
    xPrev = x;
    x = x + delta;
    i++;
  }
  while (xPrev !== x && i < iMax);

  if (xPrev !== x) {
    throw new Error('Function nthRoot failed to converge');
  }

  return inv ? 1 / x : x;
  */
}

/**
 * Calculate the nth root of a Complex Number a using De Moviers Theorem.
 * @param  {Complex} a
 * @param  {number} root
 * @return {Array} array or n Complex Roots in Polar Form.
 */
function _nthComplexRoot(a, root) {
  if (root < 0) throw new Error('Root must be greater than zero');
  if (root === 0) throw new Error('Root must be non-zero');
  if (root % 1 !== 0) throw new Error('Root must be an integer');  
  var arg = a.arg();
  var abs = a.abs();
  var roots = [];
  var r = Math.pow(abs, 1/root);
  for(var k = 0; k < root; k++) {
    roots.push({r: r, phi: (arg + 2 * Math.PI * k)/root});
  }
  return roots;
}

exports.name = 'nthRoot';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm01":329,"../../type/matrix/utils/algorithm02":330,"../../type/matrix/utils/algorithm06":334,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341}],266:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var size = require('../../utils/array').size;

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');
  var eye = load(require('../matrix/eye'));
  var multiply = load(require('./multiply'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var fraction = load(require('../../type/fraction/function/fraction'));
  var number = load(require('../../type/number'));

  /**
   * Calculates the power of x to y, `x ^ y`.
   * Matrix exponentiation is supported for square matrices `x`, and positive
   * integer exponents `y`.
   *
   * For cubic roots of negative numbers, the function returns the principal
   * root by default. In order to let the function return the real root,
   * math.js can be configured with `math.config({predictable: true})`.
   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3);               // returns number 8
   *
   *    var a = math.complex(2, 3);
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    var b = [[1, 2], [4, 3]];
   *    math.pow(b, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    multiply, sqrt, cbrt, nthRoot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex} y                   The exponent
   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
   */
  var pow = typed('pow', {
    'number, number': _pow,

    'Complex, Complex': function (x, y) {
      return x.pow(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      if (y.isInteger() || x >= 0 || config.predictable) {
        return x.pow(y);
      }
      else {
        return new type.Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },

    'Fraction, Fraction': function (x, y) {
      if (y.d !== 1) {
        if (config.predictable) {
          throw new Error('Function pow does not support non-integer exponents for fractions.');
        }
        else {
          return _pow(x.valueOf(), y.valueOf());
        }
      }
      else {
        return x.pow(y);
     }
    },

    'Array, number': _powArray,

    'Array, BigNumber': function (x, y) {
      return _powArray(x, y.toNumber());
    },

    'Matrix, number': _powMatrix,

    'Matrix, BigNumber': function (x, y) {
      return _powMatrix(x, y.toNumber());
    },

    'Unit, number': function (x, y) {
      return x.pow(y);
    }

  });

  /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number | Complex} res
   * @private
   */
  function _pow(x, y) {

    // Alternatively could define a 'realmode' config option or something, but
    // 'predictable' will work for now
    if (config.predictable && !isInteger(y) && x < 0) {
      // Check to see if y can be represented as a fraction
      try {
        var yFrac = fraction(y);
        var yNum = number(yFrac);
        if(y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if(yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      }
      catch (ex) {
        // fraction() throws an error if y is Infinity, etc.
      }

      // Unable to express y as a fraction, so continue on
    }

    if (isInteger(y) || x >= 0 || config.predictable) {
      return Math.pow(x, y);
    }
    else {
      return new type.Complex(x, 0).pow(y, 0);
    }
  }

  /**
   * Calculate the power of a 2d array
   * @param {Array} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Array}
   * @private
   */
  function _powArray(x, y) {
    if (!isInteger(y) || y < 0) {
      throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');
    }
    // verify that A is a 2 dimensional square matrix
    var s = size(x);
    if (s.length != 2) {
      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
    }
    if (s[0] != s[1]) {
      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
    }

    var res = eye(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) == 1) {
        res = multiply(px, res);
      }
      y >>= 1;
      px = multiply(px, px);
    }
    return res;
  }

  /**
   * Calculate the power of a 2d matrix
   * @param {Matrix} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Matrix}
   * @private
   */
  function _powMatrix (x, y) {
    return matrix(_powArray(x.valueOf(), y));
  }



  pow.toTex = {
    2: '\\left(${args[0]}\\right)' + latex.operators['pow'] + '{${args[1]}}'
  };

  return pow;
}

exports.name = 'pow';
exports.factory = factory;

},{"../../type/fraction/function/fraction":326,"../../type/matrix/function/matrix":328,"../../type/number":342,"../../utils/array":346,"../../utils/latex":360,"../../utils/number":361,"../matrix/eye":277,"./multiply":262}],267:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var toFixed = require('../../utils/number').toFixed;
var deepMap = require('../../utils/collection/deepMap');

var NO_INT = 'Number of decimals in function round must be an integer';

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));
  
  /**
   * Round a value towards the nearest integer.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *
   * Examples:
   *
   *    math.round(3.2);              // returns number 3
   *    math.round(3.8);              // returns number 4
   *    math.round(-4.2);             // returns number -4
   *    math.round(-4.7);             // returns number -5
   *    math.round(math.pi, 3);       // returns number 3.142
   *    math.round(123.45678, 2);     // returns number 123.46
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.round(c);                // returns Complex 3 - 3i
   *
   *    math.round([3.2, 3.8, -4.7]); // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
  var round = typed('round', {

    'number': Math.round,

    'number, number': function (x, n) {
      if (!isInteger(n))   {throw new TypeError(NO_INT);}
      if (n < 0 || n > 15) {throw new Error('Number of decimals in function round must be in te range of 0-15');}

      return _round(x, n);
    },

    'Complex': function (x) {
      return x.round();
    },

    'Complex, number': function (x, n) {
      if (n % 1) {throw new TypeError(NO_INT);}
      
      return x.round(n);
    },

    'Complex, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      var _n = n.toNumber();
      return x.round(_n);
    },

    'number, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      return new type.BigNumber(x).toDecimalPlaces(n.toNumber());
    },

    'BigNumber': function (x) {
      return x.toDecimalPlaces(0);
    },

    'BigNumber, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      return x.toDecimalPlaces(n.toNumber());
    },

    'Fraction': function (x) {
      return x.round();
    },

    'Fraction, number': function (x, n) {
      if (n % 1) {throw new TypeError(NO_INT);}
      return x.round(n);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since round(0) = 0
      return deepMap(x, round, true);
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, round, false);
          break;
        default:
          c = algorithm14(x, y, round, false);
          break;
      }
      return c;
    },

    'number | Complex | BigNumber, Matrix': function (x, y) {
      // check scalar is zero
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm12(y, x, round, true);
            break;
          default:
            c = algorithm14(y, x, round, true);
            break;
        }
        return c;
      }
      // do not execute algorithm, result will be a zero matrix
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, round, false).valueOf();
    },

    'number | Complex | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, round, true).valueOf();
    }
  });

  round.toTex = {
    1: '\\left\\lfloor${args[0]}\\right\\rceil',
    2: undefined  // use default template
  };

  return round;
}

/**
 * round a number to the given number of decimals, or to zero if decimals is
 * not provided
 * @param {number} value
 * @param {number} decimals       number of decimals, between 0 and 15 (0 by default)
 * @return {number} roundedValue
 * @private
 */
function _round (value, decimals) {
  return parseFloat(toFixed(value, decimals));
}

exports.name = 'round';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm14":341,"../../utils/collection/deepMap":353,"../../utils/number":361,"../matrix/zeros":286,"../relational/equalScalar":288}],268:[function(require,module,exports){
'use strict';

var number = require('../../utils/number');
var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x > 1
   * - -1 when x < 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5);               // returns 1
   *    math.sign(-4.2);              // returns -1
   *    math.sign(0);                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2]);  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            The number for which to determine the sign
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
   *            The sign of `x`
   */
  var sign = typed('sign', {
    'number': number.sign,

    'Complex': function (x) {
      return x.sign();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(x.cmp(0));
    },

    'Fraction': function (x) {
      return new type.Fraction(x.s, 1);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sign(0) = 0
      return deepMap(x, sign, true);
    },

    'Unit': function(x) {
      return sign(x.value);
    }
  });

  sign.toTex = {1: '\\mathrm{${name}}\\left(${args[0]}\\right)'};

  return sign;
}

exports.name = 'sign';
exports.factory = factory;


},{"../../utils/collection/deepMap":353,"../../utils/number":361}],269:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the square root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25);                // returns 5
   *    math.square(5);               // returns 25
   *    math.sqrt(-4);                // returns Complex 2i
   *
   * See also:
   *
   *    square, multiply, cube, cbrt
   *
   * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
   *            Value for which to calculate the square root.
   * @return {number | BigNumber | Complex | Array | Matrix | Unit}
   *            Returns the square root of `x`
   */
  var sqrt = typed('sqrt', {
    'number': _sqrtNumber,

    'Complex': function (x) {
        return x.sqrt();
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.sqrt();
      }
      else {
        // negative value -> downgrade to number to do complex value computation
        return _sqrtNumber(x.toNumber());
      }
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sqrt(0) = 0
      return deepMap(x, sqrt, true);
    },

    'Unit': function (x) {
      // Someday will work for complex units when they are implemented
      return x.pow(0.5);
    }

  });

  /**
   * Calculate sqrt for a number
   * @param {number} x
   * @returns {number | Complex} Returns the square root of x
   * @private
   */
  function _sqrtNumber(x) {
    if (x >= 0 || config.predictable) {
      return Math.sqrt(x);
    }
    else {
      return new type.Complex(x, 0).sqrt();
    }
  }

  sqrt.toTex = {1: '\\sqrt{${args[0]}}'};

  return sqrt;
}

exports.name = 'sqrt';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],270:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Compute the square of a value, `x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2);           // returns number 4
   *    math.square(3);           // returns number 9
   *    math.pow(3, 2);           // returns number 9
   *    math.multiply(3, 3);      // returns number 9
   *
   *    math.square([1, 2, 3, 4]);  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            Number for which to calculate the square
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Squared value
   */
  var square = typed('square', {
    'number': function (x) {
      return x * x;
    },

    'Complex': function (x) {
      return x.mul(x);
    },

    'BigNumber': function (x) {
      return x.times(x);
    },

    'Fraction': function (x) {
      return x.mul(x);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since square(0) = 0
      return deepMap(x, square, true);
    },

    'Unit': function(x) {
      return x.pow(2);
    }
  });

  square.toTex = {1: '\\left(${args[0]}\\right)^2'};

  return square;
}

exports.name = 'square';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],271:[function(require,module,exports){
'use strict';

var DimensionError = require('../../error/DimensionError');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var unaryMinus = load(require('./unaryMinus'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  // TODO: split function subtract in two: subtract and subtractScalar

  /**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2);        // returns number 3.3
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.subtract(a, b);          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4);  // returns Array [1, 3, 0]
   *
   *    var c = math.unit('2.1 km');
   *    var d = math.unit('500m');
   *    math.subtract(c, d);          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
   *            Initial value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
   *            Value to subtract from `x`
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Subtraction of `x` and `y`
   */
  var subtract = typed('subtract', {

    'number, number': function (x, y) {
      return x - y;
    },

    'Complex, Complex': function (x, y) {
      return x.sub(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.minus(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.sub(y);
    },

    'Unit, Unit': function (x, y) {
      if (x.value == null) {
        throw new Error('Parameter x contains a unit with undefined value');
      }

      if (y.value == null) {
        throw new Error('Parameter y contains a unit with undefined value');
      }

      if (!x.equalBase(y)) {
        throw new Error('Units do not match');
      }

      var res = x.clone();
      res.value = subtract(res.value, y.value);
      res.fixPrefix = false;

      return res;
    },
    
    'Matrix, Matrix': function (x, y) {
      // matrix sizes
      var xsize = x.size();
      var ysize = y.size();

      // check dimensions
      if (xsize.length !== ysize.length)
        throw new DimensionError(xsize.length, ysize.length);

      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse - sparse
              c = algorithm05(x, y, subtract);
              break;
            default:
              // sparse - dense
              c = algorithm03(y, x, subtract, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense - sparse
              c = algorithm01(x, y, subtract, false);
              break;
            default:
              // dense - dense
              c = algorithm13(x, y, subtract);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return subtract(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return subtract(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return subtract(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          // algorithm 7 is faster than 9 since it calls f() for nonzero items only!
          c = algorithm10(x, unaryMinus(y), addScalar);
          break;
        default:
          c = algorithm14(x, y, subtract);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, subtract, true);
          break;
        default:
          c = algorithm14(y, x, subtract, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, subtract, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, subtract, true).valueOf();
    }
  });

  subtract.toTex = {
    2: '\\left(${args[0]}' + latex.operators['subtract'] + '${args[1]}\\right)'
  };

  return subtract;
}

exports.name = 'subtract';
exports.factory = factory;

},{"../../error/DimensionError":15,"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm01":329,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm05":333,"../../type/matrix/utils/algorithm10":337,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex":360,"./addScalar":243,"./unaryMinus":272}],272:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  /**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5);      // returns -3.5
   *    math.unaryMinus(-4.2);     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */
  var unaryMinus = typed('unaryMinus', {
    'number': function (x) {
      return -x;
    },

    'Complex': function (x) {
      return x.neg();
    },

    'BigNumber': function (x) {
      return x.neg();
    },

    'Fraction': function (x) {
      return x.neg();
    },

    'Unit': function (x) {
      var res = x.clone();
      res.value = unaryMinus(x.value);
      return res;
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since unaryMinus(0) = 0
      return deepMap(x, unaryMinus, true);
    }

    // TODO: add support for string
  });

  unaryMinus.toTex = {
    1: latex.operators['unaryMinus'] + '\\left(${args[0]}\\right)'
  };

  return unaryMinus;
}

exports.name = 'unaryMinus';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../../utils/latex":360}],273:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  /**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5);      // returns 3.5
   *    math.unaryPlus(1);     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {number | BigNumber | Fraction | string | Complex | Unit | Array | Matrix} x
   *            Input value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */
  var unaryPlus = typed('unaryPlus', {
    'number': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x; // complex numbers are immutable
    },

    'BigNumber': function (x) {
      return x; // bignumbers are immutable
    },

    'Fraction': function (x) {
      return x; // fractions are immutable
    },

    'Unit': function (x) {
      return x.clone();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since unaryPlus(0) = 0
      return deepMap(x, unaryPlus, true);
    },

    'boolean | string | null': function (x) {
      // convert to a number or bignumber
      return (config.number == 'BigNumber') ? new type.BigNumber(+x): +x;
    }
  });

  unaryPlus.toTex = {
    1: latex.operators['unaryPlus'] + '\\left(${args[0]}\\right)'
  };

  return unaryPlus;
}

exports.name = 'unaryPlus';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../../utils/latex":360}],274:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Calculate the extended greatest common divisor for two values.
   * See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12);             // returns [4, -1, 1]
   *    math.gcd(8, 12);              // returns 4
   *    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */
  var xgcd = typed('xgcd', {
    'number, number': _xgcd,
    'BigNumber, BigNumber': _xgcdBigNumber
    // TODO: implement support for Fraction
  });

  xgcd.toTex = undefined; // use default template

  return xgcd;

  /**
   * Calculate xgcd for two numbers
   * @param {number} a
   * @param {number} b
   * @return {number} result
   * @private
   */
  function _xgcd (a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        x = 0, lastx = 1,
        y = 1, lasty = 0;

    if (!isInteger(a) || !isInteger(b)) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    while (b) {
      q = Math.floor(a / b);
      r = a % b;

      t = x;
      x = lastx - q * x;
      lastx = t;

      t = y;
      y = lasty - q * y;
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    }
    else {
      res = [a, a ? lastx : 0, lasty];
    }
    return (config.matrix === 'Array') ? res : matrix(res);
  }

  /**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */
  function _xgcdBigNumber(a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        zero = new type.BigNumber(0),
        one = new type.BigNumber(1),
        x = zero,
        lastx = one,
        y = one,
        lasty = zero;

    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);

      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;

      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    }
    else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return (config.matrix === 'Array') ? res : matrix(res);
  }
}

exports.name = 'xgcd';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/number":361}],275:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var isInteger = require('../../utils/number').isInteger;
var array = require('../../utils/array');
var IndexError = require('../../error/IndexError');
var DimensionError = require('../../error/DimensionError');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Concatenate two or more matrices.
   *
   * Syntax:
   *
   *     math.concat(A, B, C, ...)
   *     math.concat(A, B, C, ..., dim)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *   By default the last dimension of the matrices.
   *
   * Examples:
   *
   *    var A = [[1, 2], [5, 6]];
   *    var B = [[3, 4], [7, 8]];
   *
   *    math.concat(A, B);                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
   *    math.concat(A, B, 0);               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
   *    math.concat('hello', ' ', 'world'); // returns 'hello world'
   *
   * See also:
   *
   *    size, squeeze, subset, transpose
   *
   * @param {... Array | Matrix} args     Two or more matrices
   * @return {Array | Matrix} Concatenated matrix
   */
  var concat = typed('concat', {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    '...Array | Matrix | number | BigNumber': function (args) {
      var i;
      var len = args.length;
      var dim = -1;  // zero-based dimension
      var prevDim;
      var asMatrix = false;
      var matrices = [];  // contains multi dimensional arrays

      for (i = 0; i < len; i++) {
        var arg = args[i];

        // test whether we need to return a Matrix (if not we return an Array)
        if (arg && arg.isMatrix === true) {
          asMatrix = true;
        }

        if (typeof arg === 'number' || (arg && arg.isBigNumber === true)) {
          if (i !== len - 1) {
            throw new Error('Dimension must be specified as last argument');
          }

          // last argument contains the dimension on which to concatenate
          prevDim = dim;
          dim = arg.valueOf(); // change BigNumber to number

          if (!isInteger(dim)) {
            throw new TypeError('Integer number expected for dimension');
          }

          if (dim < 0 || (i > 0 && dim > prevDim)) {
            // TODO: would be more clear when throwing a DimensionError here
            throw new IndexError(dim, prevDim + 1);
          }
        }
        else {
          // this is a matrix or array
          var m = clone(arg).valueOf();
          var size = array.size(m);
          matrices[i] = m;
          prevDim = dim;
          dim = size.length - 1;

          // verify whether each of the matrices has the same number of dimensions
          if (i > 0 && dim != prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }

      if (matrices.length == 0) {
        throw new SyntaxError('At least one matrix expected');
      }

      var res = matrices.shift();
      while (matrices.length) {
        res = _concat(res, matrices.shift(), dim, 0);
      }

      return asMatrix ? matrix(res) : res;
    },

    '...string': function (args) {
      return args.join('');
    }
  });

  concat.toTex = undefined; // use default template

  return concat;
}

/**
 * Recursively concatenate two matrices.
 * The contents of the matrices is not cloned.
 * @param {Array} a             Multi dimensional array
 * @param {Array} b             Multi dimensional array
 * @param {number} concatDim    The dimension on which to concatenate (zero-based)
 * @param {number} dim          The current dim (zero-based)
 * @return {Array} c            The concatenated matrix
 * @private
 */
function _concat(a, b, concatDim, dim) {
  if (dim < concatDim) {
    // recurse into next dimension
    if (a.length != b.length) {
      throw new DimensionError(a.length, b.length);
    }

    var c = [];
    for (var i = 0; i < a.length; i++) {
      c[i] = _concat(a[i], b[i], concatDim, dim + 1);
    }
    return c;
  }
  else {
    // concatenate this dimension
    return a.concat(b);
  }
}

exports.name = 'concat';
exports.factory = factory;

},{"../../error/DimensionError":15,"../../error/IndexError":16,"../../type/matrix/function/matrix":328,"../../utils/array":346,"../../utils/number":361,"../../utils/object":362}],276:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');
var object = util.object;
var string = util.string;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var add = load(require('../arithmetic/add'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));
  var unaryMinus = load(require('../arithmetic/unaryMinus'));

  /**
   * Calculate the determinant of a matrix.
   *
   * Syntax:
   *
   *    math.det(x)
   *
   * Examples:
   *
   *    math.det([[1, 2], [3, 4]]); // returns -2
   *
   *    var A = [
   *      [-2, 2, 3],
   *      [-1, 1, 3],
   *      [2, 0, -1]
   *    ]
   *    math.det(A); // returns 6
   *
   * See also:
   *
   *    inv
   *
   * @param {Array | Matrix} x  A matrix
   * @return {number} The determinant of `x`
   */
  var det = typed('det', {
    'any': function (x) {
      return object.clone(x);
    },

    'Array | Matrix': function det (x) {
      var size;
      if (x && x.isMatrix === true) {
        size = x.size();
      }
      else if (Array.isArray(x)) {
        x = matrix(x);
        size = x.size();
      }
      else {
        // a scalar
        size = [];
      }

      switch (size.length) {
        case 0:
          // scalar
          return object.clone(x);

        case 1:
          // vector
          if (size[0] == 1) {
            return object.clone(x.valueOf()[0]);
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + string.format(size) + ')');
          }

        case 2:
          // two dimensional array
          var rows = size[0];
          var cols = size[1];
          if (rows == cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + string.format(size) + ')');
          }

        default:
          // multi dimensional array
          throw new RangeError('Matrix must be two dimensional ' +
          '(size: ' + string.format(size) + ')');
      }
    }
  });

  det.toTex = {1: '\\det\\left(${args[0]}\\right)'};

  return det;

  /**
   * Calculate the determinant of a matrix
   * @param {Array[]} matrix  A square, two dimensional matrix
   * @param {number} rows     Number of rows of the matrix (zero-based)
   * @param {number} cols     Number of columns of the matrix (zero-based)
   * @returns {number} det
   * @private
   */
  function _det (matrix, rows, cols) {
    if (rows == 1) {
      // this is a 1 x 1 matrix
      return object.clone(matrix[0][0]);
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
      return subtract(
          multiply(matrix[0][0], matrix[1][1]),
          multiply(matrix[1][0], matrix[0][1])
      );
    }
    else {
      // this is an n x n matrix
      var compute_mu = function (matrix) {
        var i, j;

        // Compute the matrix with zero lower triangle, same upper triangle,
        // and diagonals given by the negated sum of the below diagonal
        // elements.
        var mu = new Array(matrix.length);
        var sum = 0;
        for (i = 1; i < matrix.length; i++) {
          sum = add(sum, matrix[i][i]);
        }

        for (i = 0; i < matrix.length; i++) {
          mu[i] = new Array(matrix.length);
          mu[i][i] = unaryMinus(sum);

          for (j = 0; j < i; j++) {
            mu[i][j] = 0; // TODO: make bignumber 0 in case of bignumber computation
          }

          for (j = i + 1; j < matrix.length; j++) {
            mu[i][j] = matrix[i][j];
          }

          if (i+1 < matrix.length) {
            sum = subtract(sum, matrix[i + 1][i + 1]);
          }
        }

        return mu;
      };

      var fa = matrix;
      for (var i = 0; i < rows - 1; i++) {
        fa = multiply(compute_mu(fa), matrix);
      }

      if (rows % 2 == 0) {
        return unaryMinus(fa[0][0]);
      } else {
        return fa[0][0];
      }
    }
  }
}

exports.name = 'det';
exports.factory = factory;


},{"../../type/matrix/function/matrix":328,"../../utils/index":359,"../arithmetic/add":242,"../arithmetic/multiply":262,"../arithmetic/subtract":271,"../arithmetic/unaryMinus":272}],277:[function(require,module,exports){
'use strict';

var array = require('../../utils/array');
var isInteger = require('../../utils/number').isInteger;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  
  /**
   * Create a 2-dimensional identity matrix with size m x n or n x n.
   * The matrix has ones on the diagonal and zeros elsewhere.
   *
   * Syntax:
   *
   *    math.eye(n)
   *    math.eye(n, format)
   *    math.eye(m, n)
   *    math.eye(m, n, format)
   *    math.eye([m, n])
   *    math.eye([m, n], format)
   *
   * Examples:
   *
   *    math.eye(3);                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
   *    math.eye(3, 2);                 // returns [[1, 0], [0, 1], [0, 0]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.eye(math.size(A));         // returns [[1, 0, 0], [0, 1, 0]]
   *
   * See also:
   *
   *    diag, ones, zeros, size, range
   *
   * @param {...number | Matrix | Array} size   The size for the matrix
   * @param {string} [format]                   The Matrix storage format
   *
   * @return {Matrix | Array | number} A matrix with ones on the diagonal.
   */
  var eye = typed('eye', {
    '': function () {
      return (config.matrix === 'Matrix') ? matrix([]) : [];
    },

    'string': function (format) {
      return matrix(format);
    },

    'number | BigNumber': function (rows) {
      return _eye(rows, rows, config.matrix === 'Matrix' ? 'default' : undefined);
    },
    
    'number | BigNumber, string': function (rows, format) {
      return _eye(rows, rows, format);
    },

    'number | BigNumber, number | BigNumber': function (rows, cols) {
      return _eye(rows, cols, config.matrix === 'Matrix' ? 'default' : undefined);
    },
    
    'number | BigNumber, number | BigNumber, string': function (rows, cols, format) {
      return _eye(rows, cols, format);
    },

    'Array':  function (size) {
      return _eyeVector(size);
    },
    
    'Array, string':  function (size, format) {
      return _eyeVector(size, format);
    },

    'Matrix': function (size) {
      return _eyeVector(size.valueOf(), size.storage());
    },
    
    'Matrix, string': function (size, format) {
      return _eyeVector(size.valueOf(), format);
    }
  });

  eye.toTex = undefined; // use default template

  return eye;

  function _eyeVector (size, format) {
    switch (size.length) {
      case 0: return format ? matrix(format) : [];
      case 1: return _eye(size[0], size[0], format);
      case 2: return _eye(size[0], size[1], format);
      default: throw new Error('Vector containing two values expected');
    }
  }

  /**
   * Create an identity matrix
   * @param {number | BigNumber} rows
   * @param {number | BigNumber} cols
   * @param {string} [format]
   * @returns {Matrix}
   * @private
   */
  function _eye (rows, cols, format) {
    // BigNumber constructor with the right precision
    var Big = (rows && rows.isBigNumber === true)
        ? type.BigNumber
        : (cols && cols.isBigNumber === true)
            ? type.BigNumber
            : null;

    if (rows && rows.isBigNumber === true) rows = rows.toNumber();
    if (cols && cols.isBigNumber === true) cols = cols.toNumber();

    if (!isInteger(rows) || rows < 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }
    
    var one = Big ? new type.BigNumber(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size = [rows, cols];
    
    // check we need to return a matrix
    if (format) {
      // get matrix storage constructor
      var F = type.Matrix.storage(format);
      // create diagonal matrix (use optimized implementation for storage format)
      return F.diagonal(size, one, 0, defaultValue);
    }
    
    // create and resize array
    var res = array.resize([], size, defaultValue);
    // fill in ones on the diagonal
    var minimum = rows < cols ? rows : cols;
    // fill diagonal
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
}

exports.name = 'eye';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/array":346,"../../utils/number":361}],278:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;
var maxArgumentCount = require('../../utils/function').maxArgumentCount;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  
  /**
   * Filter the items in an array or one dimensional matrix.
   *
   * Syntax:
   *
   *    math.filter(x, test)
   *
   * Examples:
   *
   *    function isPositive (x) {
   *      return x > 0;
   *    }
   *    math.filter([6, -2, -1, 4, 3], isPositive); // returns [6, 4, 3]
   *
   *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/); // returns ["23", "100", "55"]
   *
   * See also:
   *
   *    forEach, map, sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to filter
   * @param {Function | RegExp} test
   *        A function or regular expression to test items.
   *        All entries for which `test` returns true are returned.
   *        When `test` is a function, it is invoked with three parameters:
   *        the value of the element, the index of the element, and the
   *        matrix/array being traversed. The function must return a boolean.
   * @return {Matrix | Array} Returns the filtered matrix.
   */
  var filter = typed('filter', {
    'Array, function': _filterCallback,

    'Array, RegExp': _filterRegExp,

    'Matrix, function': function (x, test) {
      return matrix(_filterCallback(x.toArray(), test));
    },

    'Matrix, RegExp': function (x, test) {
      return matrix(_filterRegExp(x.toArray(), test));
    }
  });

  filter.toTex = undefined; // use default template

  return filter;
}

/**
 * Filter values in a callback given a callback function
 * @param {Array} x
 * @param {Function} callback
 * @return {Array} Returns the filtered array
 * @private
 */
function _filterCallback (x, callback) {
  if (size(x).length !== 1) {
    throw new Error('Only one dimensional matrices supported');
  }

  // figure out what number of arguments the callback function expects
  var args = maxArgumentCount(callback);

  return x.filter(function (value, index, array) {
    // invoke the callback function with the right number of arguments
    if (args === 1) {
      return callback(value);
    }
    else if (args === 2) {
      return callback(value, [index]);
    }
    else { // 3 or -1
      return callback(value, [index], array);
    }
  });
}

/**
 * Filter values in a callback given a regular expression
 * @param {Array} x
 * @param {Function} regexp
 * @return {Array} Returns the filtered array
 * @private
 */
function _filterRegExp (x, regexp) {
  if (size(x).length !== 1) {
    throw new Error('Only one dimensional matrices supported');
  }

  return x.filter(function (entry) {
    return regexp.test(entry);
  });
}

exports.name = 'filter';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/array":346,"../../utils/function":358}],279:[function(require,module,exports){
'use strict';

var maxArgumentCount = require('../../utils/function').maxArgumentCount;

function factory (type, config, load, typed) {
  /**
   * Iterate over all elements of a matrix/array, and executes the given callback function.
   *
   * Syntax:
   *
   *    math.forEach(x, callback)
   *
   * Examples:
   *
   *    math.forEach([1, 2, 3], function(value) {
   *      console.log(value);
   *    });
   *    // outputs 1, 2, 3
   *
   * See also:
   *
   *    filter, map, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix/array being traversed.
   */
  var forEach = typed('forEach', {
    'Array, function': _forEach,

    'Matrix, function': function (x, callback) {
      return x.forEach(callback);
    }
  });

  forEach.toTex = undefined; // use default template

  return forEach;
}

/**
 * forEach for a multi dimensional array
 * @param {Array} array
 * @param {Function} callback
 * @private
 */
function _forEach (array, callback) {
  // figure out what number of arguments the callback function expects
  var args = maxArgumentCount(callback);

  var recurse = function (value, index) {
    if (Array.isArray(value)) {
      value.forEach(function (child, i) {
        // we create a copy of the index array and append the new index value
        recurse(child, index.concat(i));
      });
    }
    else {
      // invoke the callback function with the right number of arguments
      if (args === 1) {
        callback(value);
      }
      else if (args === 2) {
        callback(value, index);
      }
      else { // 3 or -1
        callback(value, index, array);
      }
    }
  };
  recurse(array, []);
}

exports.name = 'forEach';
exports.factory = factory;

},{"../../utils/function":358}],280:[function(require,module,exports){
'use strict';

var util = require('../../utils/index');

function factory (type, config, load, typed) {
  var matrix       = load(require('../../type/matrix/function/matrix'));
  var divideScalar = load(require('../arithmetic/divideScalar'));
  var addScalar    = load(require('../arithmetic/addScalar'));
  var multiply     = load(require('../arithmetic/multiply'));
  var unaryMinus   = load(require('../arithmetic/unaryMinus'));
  var det          = load(require('../matrix/det'));
  var eye          = load(require('./eye'));

  /**
   * Calculate the inverse of a square matrix.
   *
   * Syntax:
   *
   *     math.inv(x)
   *
   * Examples:
   *
   *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
   *     math.inv(4);                 // returns 0.25
   *     1 / 4;                       // returns 0.25
   *
   * See also:
   *
   *     det, transpose
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */
  var inv = typed('inv', {
    'Array | Matrix': function (x) {
      var size = (x.isMatrix === true) ? x.size() : util.array.size(x);
      switch (size.length) {
        case 1:
          // vector
          if (size[0] == 1) {
            if (x.isMatrix === true) {
              return matrix([
                divideScalar(1, x.valueOf()[0])
              ]);
            }
            else {
              return [
                divideScalar(1, x[0])
              ];
            }
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + util.string.format(size) + ')');
          }

        case 2:
          // two dimensional array
          var rows = size[0];
          var cols = size[1];
          if (rows == cols) {
            if (x.isMatrix === true) {
              return matrix(
                  _inv(x.valueOf(), rows, cols),
                  x.storage()
              );
            }
            else {
              // return an Array
              return _inv(x, rows, cols);
            }
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + util.string.format(size) + ')');
          }

        default:
          // multi dimensional array
          throw new RangeError('Matrix must be two dimensional ' +
          '(size: ' + util.string.format(size) + ')');
      }
    },

    'any': function (x) {
      // scalar
      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
    }
  });

  /**
   * Calculate the inverse of a square matrix
   * @param {Array[]} mat     A square matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns, must equal rows
   * @return {Array[]} inv    Inverse matrix
   * @private
   */
  function _inv (mat, rows, cols){
    var r, s, f, value, temp;

    if (rows == 1) {
      // this is a 1 x 1 matrix
      value = mat[0][0];
      if (value == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [[
        divideScalar(1, value)
      ]];
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      var d = det(mat);
      if (d == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [
        [
          divideScalar(mat[1][1], d),
          divideScalar(unaryMinus(mat[0][1]), d)
        ],
        [
          divideScalar(unaryMinus(mat[1][0]), d),
          divideScalar(mat[0][0], d)
        ]
      ];
    }
    else {
      // this is a matrix of 3 x 3 or larger
      // calculate inverse using gauss-jordan elimination
      //      http://en.wikipedia.org/wiki/Gaussian_elimination
      //      http://mathworld.wolfram.com/MatrixInverse.html
      //      http://math.uww.edu/~mcfarlat/inverse.htm

      // make a copy of the matrix (only the arrays, not of the elements)
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }

      // create an identity matrix which in the end will contain the
      // matrix inverse
      var B = eye(rows).valueOf();

      // loop over all columns, and perform row reductions
      for (var c = 0; c < cols; c++) {
        // element Acc should be non zero. if not, swap content
        // with one of the lower rows
        r = c;
        while (r < rows && A[r][c] == 0) {
          r++;
        }
        if (r == rows || A[r][c] == 0) {
          // TODO: in case of zero det, just return a matrix wih Infinity values? (like octave)
          throw Error('Cannot calculate inverse, determinant is zero');
        }
        if (r != c) {
          temp = A[c]; A[c] = A[r]; A[r] = temp;
          temp = B[c]; B[c] = B[r]; B[r] = temp;
        }

        // eliminate non-zero values on the other rows at column c
        var Ac = A[c],
            Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r],
              Br = B[r];
          if(r != c) {
            // eliminate value at column c and row r
            if (Ar[c] != 0) {
              f = divideScalar(unaryMinus(Ar[c]), Ac[c]);

              // add (f * row c) to row r to eliminate the value
              // at column c
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar(Br[s],  multiply(f, Bc[s]));
              }
            }
          }
          else {
            // normalize value at Acc to 1,
            // divide each value on row r with the value at Acc
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }

  inv.toTex = {1: '\\left(${args[0]}\\right)^{-1}'};

  return inv;
}

exports.name = 'inv';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/index":359,"../arithmetic/addScalar":243,"../arithmetic/divideScalar":248,"../arithmetic/multiply":262,"../arithmetic/unaryMinus":272,"../matrix/det":276,"./eye":277}],281:[function(require,module,exports){
'use strict';

var maxArgumentCount = require('../../utils/function').maxArgumentCount;

function factory (type, config, load, typed) {
  /**
   * Create a new matrix or array with the results of the callback function executed on
   * each entry of the matrix/array.
   *
   * Syntax:
   *
   *    math.map(x, callback)
   *
   * Examples:
   *
   *    math.map([1, 2, 3], function(value) {
   *      return value * value;
   *    });  // returns [1, 4, 9]
   *
   * See also:
   *
   *    filter, forEach, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the matrix being traversed.
   * @return {Matrix | array}     Transformed map of x
   */
  var map = typed('map', {
    'Array, function': _map,

    'Matrix, function': function (x, callback) {
      return x.map(callback);
    }
  });

  map.toTex = undefined; // use default template

  return map;
}

/**
 * Map for a multi dimensional array
 * @param {Array} array
 * @param {Function} callback
 * @return {Array}
 * @private
 */
function _map (array, callback) {
  // figure out what number of arguments the callback function expects
  var args = maxArgumentCount(callback);

  var recurse = function (value, index) {
    if (Array.isArray(value)) {
      return value.map(function (child, i) {
        // we create a copy of the index array and append the new index value
        return recurse(child, index.concat(i));
      });
    }
    else {
      // invoke the callback function with the right number of arguments
      if (args === 1) {
        return callback(value);
      }
      else if (args === 2) {
        return callback(value, index);
      }
      else { // 3 or -1
        return callback(value, index, array);
      }
    }
  };

  return recurse(array, []);
}

exports.name = 'map';
exports.factory = factory;

},{"../../utils/function":358}],282:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  var ZERO = new type.BigNumber(0);
  var ONE = new type.BigNumber(1);

  /**
   * Create an array from a range.
   * By default, the range end is excluded. This can be customized by providing
   * an extra parameter `includeEnd`.
   *
   * Syntax:
   *
   *     math.range(str [, includeEnd])               // Create a range from a string,
   *                                                  // where the string contains the
   *                                                  // start, optional step, and end,
   *                                                  // separated by a colon.
   *     math.range(start, end [, includeEnd])        // Create a range with start and
   *                                                  // end and a step size of 1.
   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
   *                                                  // and end.
   *
   * Where:
   *
   * - `str: string`
   *   A string 'start:end' or 'start:step:end'
   * - `start: {number | BigNumber}`
   *   Start of the range
   * - `end: number | BigNumber`
   *   End of the range, excluded by default, included when parameter includeEnd=true
   * - `step: number | BigNumber`
   *   Step size. Default value is 1.
   * - `includeEnd: boolean`
   *   Option to specify whether to include the end or not. False by default.
   *
   * Examples:
   *
   *     math.range(2, 6);        // [2, 3, 4, 5]
   *     math.range(2, -3, -1);   // [2, 1, 0, -1, -2]
   *     math.range('2:1:6');     // [2, 3, 4, 5]
   *     math.range(2, 6, true);  // [2, 3, 4, 5, 6]
   *
   * See also:
   *
   *     ones, zeros, size, subset
   *
   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
   * @return {Array | Matrix} range
   */
  var range = typed('range', {
    // TODO: simplify signatures when typed-function supports default values and optional arguments

    // TODO: a number or boolean should not be converted to string here
    'string': _strRange,
    'string, boolean': _strRange,

    'number, number':  function (start, end) {
      return _out(_rangeEx(start, end, 1));
    },
    'number, number, number': function (start, end, step) {
      return _out(_rangeEx(start, end, step));
    },
    'number, number, boolean': function (start, end, includeEnd) {
      return includeEnd
          ? _out(_rangeInc(start, end, 1))
          : _out(_rangeEx(start, end, 1));
    },
    'number, number, number, boolean': function (start, end, step, includeEnd) {
      return includeEnd
          ? _out(_rangeInc(start, end, step))
          : _out(_rangeEx(start, end, step));
    },

    'BigNumber, BigNumber':  function (start, end) {
      return _out(_bigRangeEx(start, end, ONE));
    },
    'BigNumber, BigNumber, BigNumber': function (start, end, step) {
      return _out(_bigRangeEx(start, end, step));
    },
    'BigNumber, BigNumber, boolean': function (start, end, includeEnd) {
      return includeEnd
          ? _out(_bigRangeInc(start, end, ONE))
          : _out(_bigRangeEx(start, end, ONE));
    },
    'BigNumber, BigNumber, BigNumber, boolean': function (start, end, step, includeEnd) {
      return includeEnd
          ? _out(_bigRangeInc(start, end, step))
          : _out(_bigRangeEx(start, end, step));
    }

  });

  range.toTex = undefined; // use default template

  return range;

  function _out(arr) {
    return config.matrix === 'Array' ? arr : matrix(arr);
  }

  function _strRange (str, includeEnd) {
    var r = _parse(str);
    if (!r){
      throw new SyntaxError('String "' + str + '" is no valid range');
    }

    var fn;
    if (config.number === 'BigNumber') {
      fn = includeEnd ? _bigRangeInc : _bigRangeEx;
      return _out(fn(
          new type.BigNumber(r.start),
          new type.BigNumber(r.end),
          new type.BigNumber(r.step)));
    }
    else {
      fn = includeEnd ? _rangeInc : _rangeEx;
      return _out(fn(r.start, r.end, r.step));
    }
  }

  /**
   * Create a range with numbers. End is excluded
   * @param {number} start
   * @param {number} end
   * @param {number} step
   * @returns {Array} range
   * @private
   */
  function _rangeEx (start, end, step) {
    var array = [],
        x = start;
    if (step > 0) {
      while (x < end) {
        array.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x > end) {
        array.push(x);
        x += step;
      }
    }

    return array;
  }

  /**
   * Create a range with numbers. End is included
   * @param {number} start
   * @param {number} end
   * @param {number} step
   * @returns {Array} range
   * @private
   */
  function _rangeInc (start, end, step) {
    var array = [],
        x = start;
    if (step > 0) {
      while (x <= end) {
        array.push(x);
        x += step;
      }
    }
    else if (step < 0) {
      while (x >= end) {
        array.push(x);
        x += step;
      }
    }

    return array;
  }

  /**
   * Create a range with big numbers. End is excluded
   * @param {BigNumber} start
   * @param {BigNumber} end
   * @param {BigNumber} step
   * @returns {Array} range
   * @private
   */
  function _bigRangeEx (start, end, step) {
    var array = [],
        x = start;
    if (step.gt(ZERO)) {
      while (x.lt(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    else if (step.lt(ZERO)) {
      while (x.gt(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }

    return array;
  }

  /**
   * Create a range with big numbers. End is included
   * @param {BigNumber} start
   * @param {BigNumber} end
   * @param {BigNumber} step
   * @returns {Array} range
   * @private
   */
  function _bigRangeInc (start, end, step) {
    var array = [],
        x = start;
    if (step.gt(ZERO)) {
      while (x.lte(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    else if (step.lt(ZERO)) {
      while (x.gte(end)) {
        array.push(x);
        x = x.plus(step);
      }
    }

    return array;
  }

  /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @param {string} str
   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
   * @private
   */
  function _parse (str) {
    var args = str.split(':');

    // number
    var nums = args.map(function (arg) {
      // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
      return Number(arg);
    });

    var invalid = nums.some(function (num) {
      return isNaN(num);
    });
    if(invalid) {
      return null;
    }

    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };

      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };

      default:
        return null;
    }
  }

}

exports.name = 'range';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328}],283:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var validateIndex = require('../../utils/array').validateIndex;
var DimensionError = require('../../error/DimensionError');

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Get or set a subset of a matrix or string.
   *
   * Syntax:
   *     math.subset(value, index)                                // retrieve a subset
   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
   *
   * Examples:
   *
   *     // get a subset
   *     var d = [[1, 2], [3, 4]];
   *     math.subset(d, math.index(1, 0));        // returns 3
   *     math.subset(d, math.index([0, 2], 1));   // returns [[2], [4]]
   *
   *     // replace a subset
   *     var e = [];
   *     var f = math.subset(e, math.index(0, [0, 2]), [5, 6]);  // f = [[5, 6]]
   *     var g = math.subset(f, math.index(1, 1), 7, 0);         // g = [[5, 6], [0, 7]]
   *
   * See also:
   *
   *     size, resize, squeeze, index
   *
   * @param {Array | Matrix | string} matrix  An array, matrix, or string
   * @param {Index} index                     An index containing ranges for each
   *                                          dimension
   * @param {*} [replacement]                 An array, matrix, or scalar.
   *                                          If provided, the subset is replaced with replacement.
   *                                          If not provided, the subset is returned
   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
   *                                          the matrix is resized. If not provided,
   *                                          math.matrix elements will be left undefined.
   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
   */
  var subset = typed('subset', {
    // get subset
    'Array, Index': function (value, index) {
      var m = matrix(value);
      var subset = m.subset(index);       // returns a Matrix
      return subset && subset.valueOf();  // return an Array (like the input)
    },

    'Matrix, Index': function (value, index) {
      return value.subset(index);
    },

    'Object, Index': _getObjectProperty,

    'string, Index': _getSubstring,

    // set subset
    'Array, Index, any': function (value, index, replacement) {
      return matrix(clone(value))
          .subset(index, replacement, undefined)
          .valueOf();
    },

    'Array, Index, any, any': function (value, index, replacement, defaultValue) {
      return matrix(clone(value))
          .subset(index, replacement, defaultValue)
          .valueOf();
    },

    'Matrix, Index, any': function (value, index, replacement) {
      return value.clone().subset(index, replacement);
    },

    'Matrix, Index, any, any': function (value, index, replacement, defaultValue) {
      return value.clone().subset(index, replacement, defaultValue);
    },

    'string, Index, string': _setSubstring,
    'string, Index, string, string': _setSubstring,
    'Object, Index, any': _setObjectProperty
  });

  subset.toTex = undefined; // use default template

  return subset;

  /**
   * Retrieve a subset of a string
   * @param {string} str            string from which to get a substring
   * @param {Index} index           An index containing ranges for each dimension
   * @returns {string} substring
   * @private
   */
  function _getSubstring(str, index) {
    if (!index || index.isIndex !== true) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new DimensionError(index.size().length, 1);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    validateIndex(index.min()[0], strLen);
    validateIndex(index.max()[0], strLen);

    var range = index.dimension(0);

    var substr = '';
    range.forEach(function (v) {
      substr += str.charAt(v);
    });

    return substr;
  }

  /**
   * Replace a substring in a string
   * @param {string} str            string to be replaced
   * @param {Index} index           An index containing ranges for each dimension
   * @param {string} replacement    Replacement string
   * @param {string} [defaultValue] Default value to be uses when resizing
   *                                the string. is ' ' by default
   * @returns {string} result
   * @private
   */
  function _setSubstring(str, index, replacement, defaultValue) {
    if (!index || index.isIndex !== true) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new DimensionError(index.size().length, 1);
    }
    if (defaultValue !== undefined) {
      if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    }
    else {
      defaultValue = ' ';
    }

    var range = index.dimension(0);
    var len = range.size()[0];

    if (len != replacement.length) {
      throw new DimensionError(range.size()[0], replacement.length);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    validateIndex(index.min()[0]);
    validateIndex(index.max()[0]);

    // copy the string into an array with characters
    var chars = [];
    for (var i = 0; i < strLen; i++) {
      chars[i] = str.charAt(i);
    }

    range.forEach(function (v, i) {
      chars[v] = replacement.charAt(i[0]);
    });

    // initialize undefined characters with a space
    if (chars.length > strLen) {
      for (i = strLen - 1, len = chars.length; i < len; i++) {
        if (!chars[i]) {
          chars[i] = defaultValue;
        }
      }
    }

    return chars.join('');
  }
}

/**
 * Retrieve a property from an object
 * @param {Object} object
 * @param {Index} index
 * @return {*} Returns the value of the property
 * @private
 */
function _getObjectProperty (object, index) {
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }

  var key = index.dimension(0);
  if (typeof key !== 'string') {
    throw new TypeError('String expected as index to retrieve an object property');
  }

  return object[key];
}

/**
 * Set a property on an object
 * @param {Object} object
 * @param {Index} index
 * @param {*} replacement
 * @return {*} Returns the updated object
 * @private
 */
function _setObjectProperty (object, index, replacement) {
  if (index.size().length !== 1) {
    throw new DimensionError(index.size(), 1);
  }

  var key = index.dimension(0);
  if (typeof key !== 'string') {
    throw new TypeError('String expected as index to retrieve an object property');
  }

  // clone the object, and apply the property to the clone
  var updated = clone(object);
  updated[key] = replacement;

  return updated;
}

exports.name = 'subset';
exports.factory = factory;

},{"../../error/DimensionError":15,"../../type/matrix/function/matrix":328,"../../utils/array":346,"../../utils/object":362}],284:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var format = require('../../utils/string').format;

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  var add = load(require('../arithmetic/add'));

  /**
   * Calculate the trace of a matrix: the sum of the elements on the main
   * diagonal of a square matrix.
   *
   * Syntax:
   *
   *    math.trace(x)
   *
   * Examples:
   *
   *    math.trace([[1, 2], [3, 4]]); // returns 5
   *
   *    var A = [
   *      [1, 2, 3],
   *      [-1, 2, 3],
   *      [2, 0, 3]
   *    ]
   *    math.trace(A); // returns 6
   *
   * See also:
   *
   *    diag
   *
   * @param {Array | Matrix} x  A matrix
   *
   * @return {number} The trace of `x`
   */
  var trace = typed('trace', {
    
    'Array': function (x) {
      // use dense matrix implementation
      return trace(matrix(x));
    },

    'Matrix': function (x) {
      // result
      var c;
      // process storage format
      switch (x.storage()) {
        case 'dense':
          c = _denseTrace(x);
          break;
        case 'sparse':
          c = _sparseTrace(x);
          break;
      }
      return c;
    },
    
    'any': clone
  });
  
  var _denseTrace = function (m) {
    // matrix size & data
    var size = m._size;
    var data = m._data;
    
    // process dimensions
    switch (size.length) {
      case 1:
        // vector
        if (size[0] == 1) {
          // return data[0]
          return clone(data[0]);
        }
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
      case 2:
        // two dimensional
        var rows = size[0];
        var cols = size[1];
        if (rows === cols) {
          // calulate sum
          var sum = 0;
          // loop diagonal
          for (var i = 0; i < rows; i++)
            sum = add(sum, data[i][i]);
          // return trace
          return sum;
        }
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');        
      default:
        // multi dimensional
        throw new RangeError('Matrix must be two dimensional (size: ' + format(size) + ')');
    }
  };
  
  var _sparseTrace = function (m) {
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var size = m._size;
    // check dimensions
    var rows = size[0];
    var columns = size[1];
    // matrix must be square
    if (rows === columns) {
      // calulate sum
      var sum = 0;
      // check we have data (avoid looping columns)
      if (values.length > 0) {
        // loop columns
        for (var j = 0; j < columns; j++) {
          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          // loop k within [k0, k1[
          for (var k = k0; k < k1; k++) {
            // row index
            var i = index[k];
            // check row
            if (i === j) {
              // accumulate value
              sum = add(sum, values[k]);
              // exit loop
              break;
            }
            if (i > j) {
              // exit loop, no value on the diagonal for column j
              break;
            }
          }
        }
      }
      // return trace
      return sum;
    }
    throw new RangeError('Matrix must be square (size: ' + format(size) + ')');   
  };

  trace.toTex = {1: '\\mathrm{tr}\\left(${args[0]}\\right)'};
  
  return trace;
}

exports.name = 'trace';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/object":362,"../../utils/string":363,"../arithmetic/add":242}],285:[function(require,module,exports){
'use strict';

var clone = require('../../utils/object').clone;
var format = require('../../utils/string').format;

function factory (type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var DenseMatrix = type.DenseMatrix,
      SparseMatrix = type.SparseMatrix;

  /**
   * Transpose a matrix. All values of the matrix are reflected over its
   * main diagonal. Only applicable to two dimensional matrices containing
   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
   * vectors and scalars return the input unchanged.
   *
   * Syntax:
   *
   *     math.transpose(x)
   *
   * Examples:
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
   *
   * See also:
   *
   *     diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be transposed
   * @return {Array | Matrix}   The transposed matrix
   */
  var transpose = typed('transpose', {

    'Array': function (x) {
      // use dense matrix implementation
      return transpose(matrix(x)).valueOf();
    },

    'Matrix': function (x) {
      // matrix size
      var size = x.size();

      // result
      var c;
      
      // process dimensions
      switch (size.length) {
        case 1:
          // vector
          c = x.clone();
          break;

        case 2:
          // rows and columns
          var rows = size[0];
          var columns = size[1];

          // check columns
          if (columns === 0) {
            // throw exception
            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');
          }

          // process storage format
          switch (x.storage()) {
            case 'dense':
              c = _denseTranspose(x, rows, columns);
              break;
            case 'sparse':
              c = _sparseTranspose(x, rows, columns);
              break;
          }
          break;
          
        default:
          // multi dimensional
          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');
      }
      return c;
    },

    // scalars
    'any': function (x) {
      return clone(x);
    }
  });

  var _denseTranspose = function (m, rows, columns) {
    // matrix array
    var data = m._data;
    // transposed matrix data
    var transposed = [];
    var transposedRow;
    // loop columns
    for (var j = 0; j < columns; j++) {
      // initialize row
      transposedRow = transposed[j] = [];
      // loop rows
      for (var i = 0; i < rows; i++) {
        // set data
        transposedRow[i] = clone(data[i][j]);
      }
    }
    // return matrix
    return new DenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  };

  var _sparseTranspose = function (m, rows, columns) {
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // result matrices
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // row counts
    var w = [];
    for (var x = 0; x < rows; x++)
      w[x] = 0;
    // vars
    var p, l, j;
    // loop values in matrix
    for (p = 0, l = index.length; p < l; p++) {
      // number of values in row
      w[index[p]]++;
    }
    // cumulative sum
    var sum = 0;
    // initialize cptr with the cummulative sum of row counts
    for (var i = 0; i < rows; i++) {
      // update cptr
      cptr.push(sum);
      // update sum
      sum += w[i];
      // update w
      w[i] = cptr[i];
    }
    // update cptr
    cptr.push(sum);
    // loop columns
    for (j = 0; j < columns; j++) {
      // values & index in column
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        // C values & index
        var q = w[index[k]]++;
        // C[j, i] = A[i, j]
        cindex[q] = j;
        // check we need to process values (pattern matrix)
        if (values)
          cvalues[q] = clone(values[k]);
      }
    }
    // return matrix
    return new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  };

  transpose.toTex = {1: '\\left(${args[0]}\\right)' + latex.operators['transpose']};

  return transpose;
}

exports.name = 'transpose';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/latex":360,"../../utils/object":362,"../../utils/string":363}],286:[function(require,module,exports){
'use strict';

var isInteger = require('../../utils/number').isInteger;
var resize = require('../../utils/array').resize;

function factory (type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  /**
   * Create a matrix filled with zeros. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.zeros(m)
   *    math.zeros(m, format)
   *    math.zeros(m, n)
   *    math.zeros(m, n, format)
   *    math.zeros([m, n])
   *    math.zeros([m, n], format)
   *
   * Examples:
   *
   *    math.zeros(3);                  // returns [0, 0, 0]
   *    math.zeros(3, 2);               // returns [[0, 0], [0, 0], [0, 0]]
   *    math.zeros(3, 'dense');         // returns [0, 0, 0]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.zeros(math.size(A));       // returns [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *
   *    ones, eye, size, range
   *
   * @param {...number | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix}           A matrix filled with zeros
   */
  var zeros = typed('zeros', {
    '': function () {
      return (config.matrix === 'Array')
          ? _zeros([])
          : _zeros([], 'default');
    },

    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    '...number | BigNumber | string': function (size) {
      var last = size[size.length - 1];
      if (typeof last === 'string') {
        var format = size.pop();
        return _zeros(size, format);
      }
      else if (config.matrix === 'Array') {
        return _zeros(size);
      }
      else {
        return _zeros(size, 'default');
      }
    },

    'Array': _zeros,

    'Matrix': function (size) {
      var format = size.storage();
      return _zeros(size.valueOf(), format);
    },

    'Array | Matrix, string': function (size, format) {
      return _zeros (size.valueOf(), format);
    }
  });

  zeros.toTex = undefined; // use default template

  return zeros;

  /**
   * Create an Array or Matrix with zeros
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */
  function _zeros(size, format) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new type.BigNumber(0) : 0;
    _validate(size);

    if (format) {
      // return a matrix
      var m = matrix(format);
      if (size.length > 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    }
    else {
      // return an Array
      var arr = [];
      if (size.length > 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }

  // replace BigNumbers with numbers, returns true if size contained BigNumbers
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function (value, index, arr) {
      if (value && value.isBigNumber === true) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }

  // validate arguments
  function _validate (size) {
    size.forEach(function (value) {
      if (typeof value !== 'number' || !isInteger(value) || value < 0) {
        throw new Error('Parameters in function zeros must be positive integers');
      }
    });
  }
}

// TODO: zeros contains almost the same code as ones. Reuse this?

exports.name = 'zeros';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../utils/array":346,"../../utils/number":361}],287:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('./equalScalar'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether two values are equal.
   *
   * The function tests whether the relative difference between x and y is
   * smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is only
   * equal to `null` and nothing else, and `undefined` is only equal to
   * `undefined` and nothing else.
   *
   * Syntax:
   *
   *    math.equal(x, y)
   *
   * Examples:
   *
   *    math.equal(2 + 2, 3);         // returns false
   *    math.equal(2 + 2, 4);         // returns true
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.equal(a, b);             // returns true
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.equal(c, d);             // returns [true, false, true]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.equal(0, null);          // returns false
   *
   * See also:
   *
   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual
   *
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
   */
  var equal = typed('equal', {
    
    'any, any': function (x, y) {
      // strict equality for null and undefined?
      if (x === null) { return y === null; }
      if (y === null) { return x === null; }
      if (x === undefined) { return y === undefined; }
      if (y === undefined) { return x === undefined; }

      return equalScalar(x, y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, equalScalar);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, equalScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, equalScalar, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, equalScalar);
              break;
          }
          break;
      }
      return c;
    },
    
    'Array, Array': function (x, y) {
      // use matrix implementation
      return equal(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return equal(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return equal(x, matrix(y));
    },
    
    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, equalScalar, false);
          break;
        default:
          c = algorithm14(x, y, equalScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, equalScalar, true);
          break;
        default:
          c = algorithm14(y, x, equalScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, equalScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, equalScalar, true).valueOf();
    }
  });

  equal.toTex = {
    2: '\\left(${args[0]}' + latex.operators['equal'] + '${args[1]}\\right)'
  };

  return equal;
}

exports.name = 'equal';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm07":335,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/latex":360,"./equalScalar":288}],288:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {
  
  /**
   * Test whether two values are equal.
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
   * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
   * @private
   */
  var equalScalar = typed('equalScalar', {

    'boolean, boolean': function (x, y) {
      return x === y;
    },

    'number, number': function (x, y) {
      return x === y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.eq(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.equals(y);
    },

    'Complex, Complex': function (x, y) {
      return x.equals(y);
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return equalScalar(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x === y;
    }
  });
  
  return equalScalar;
}

exports.factory = factory;

},{"../../utils/bignumber/nearlyEqual":349,"../../utils/number":361}],289:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {
  
  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether value x is larger than y.
   *
   * The function returns true when x is larger than y and the relative
   * difference between x and y is larger than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.larger(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 3);             // returns false
   *    math.larger(5, 2 + 2);         // returns true
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.larger(a, b);             // returns false
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
   */
  var larger = typed('larger', {

    'boolean, boolean': function (x, y) {
      return x > y;
    },

    'number, number': function (x, y) {
      return x > y && !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.gt(y) && !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) === 1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return larger(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x > y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, larger);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, larger, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, larger, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, larger);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return larger(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return larger(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return larger(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, larger, false);
          break;
        default:
          c = algorithm14(x, y, larger, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, larger, true);
          break;
        default:
          c = algorithm14(y, x, larger, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, larger, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, larger, true).valueOf();
    }
  });

  larger.toTex = {
    2: '\\left(${args[0]}' + latex.operators['larger'] + '${args[1]}\\right)'
  };

  return larger;
}

exports.name = 'larger';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm07":335,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/bignumber/nearlyEqual":349,"../../utils/latex":360,"../../utils/number":361}],290:[function(require,module,exports){
'use strict';

var nearlyEqual = require('../../utils/number').nearlyEqual;
var bigNearlyEqual = require('../../utils/bignumber/nearlyEqual');

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

  /**
   * Test whether value x is smaller than y.
   *
   * The function returns true when x is smaller than y and the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smaller(x, y)
   *
   * Examples:
   *
   *    math.smaller(2, 3);            // returns true
   *    math.smaller(5, 2 * 2);        // returns false
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.smaller(a, b);            // returns true
   *
   * See also:
   *
   *    equal, unequal, smallerEq, smaller, smallerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
  var smaller = typed('smaller', {

    'boolean, boolean': function (x, y) {
      return x < y;
    },

    'number, number': function (x, y) {
      return x < y && !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.lt(y) && !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) === -1;
    },

    'Complex, Complex': function (x, y) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return smaller(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x < y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, smaller);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, smaller, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, smaller, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, smaller);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return smaller(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return smaller(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return smaller(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, smaller, false);
          break;
        default:
          c = algorithm14(x, y, smaller, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, smaller, true);
          break;
        default:
          c = algorithm14(y, x, smaller, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, smaller, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, smaller, true).valueOf();
    }
  });

  smaller.toTex = {
    2: '\\left(${args[0]}' + latex.operators['smaller'] + '${args[1]}\\right)'
  };

  return smaller;
}

exports.name = 'smaller';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm07":335,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341,"../../utils/bignumber/nearlyEqual":349,"../../utils/latex":360,"../../utils/number":361}],291:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var larger = load(require('../relational/larger'));

  /**
   * Compute the maximum value of a matrix or a  list with values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.max(a, b, c, ...)
   *     math.max(A)
   *     math.max(A, dim)
   *
   * Examples:
   *
   *     math.max(2, 1, 4, 3);                  // returns 4
   *     math.max([2, 1, 4, 3]);                // returns 4
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.max([[2, 5], [4, 3], [1, 7]], 0); // returns [4, 7]
   *     math.max([[2, 5], [4, 3]], [1, 7], 1); // returns [5, 4, 7]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, min, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The maximum value
   */
  var max = typed('max', {
    // max([a, b, c, d, ...])
    'Array | Matrix': _max,

    // max([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      return reduce(array, dim.valueOf(), _largest);
    },

    // max(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function max');
      }

      return _max(args);
    }
  });

  max.toTex = '\\max\\left(${args}\\right)';

  return max;

  /**
   * Return the largest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is largest, or y when y is largest
   * @private
   */
  function _largest(x, y){
    return larger(x, y) ? x : y;
  }

  /**
   * Recursively calculate the maximum value in an n-dimensional array
   * @param {Array} array
   * @return {number} max
   * @private
   */
  function _max(array) {
    var max = undefined;

    deepForEach(array, function (value) {
      if (max === undefined || larger(value, max)) {
        max = value;
      }
    });

    if (max === undefined) {
      throw new Error('Cannot calculate max of an empty array');
    }

    return max;
  }
}

exports.name = 'max';
exports.factory = factory;

},{"../../utils/collection/containsCollections":351,"../../utils/collection/deepForEach":352,"../../utils/collection/reduce":355,"../relational/larger":289}],292:[function(require,module,exports){
'use strict';

var size = require('../../utils/array').size;
var deepForEach = require('../../utils/collection/deepForEach');
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var divide = load(require('../arithmetic/divide'));

  /**
   * Compute the mean value of matrix or a list with values.
   * In case of a multi dimensional array, the mean of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.mean(a, b, c, ...)
   *     math.mean(A)
   *     math.mean(A, dim)
   *
   * Examples:
   *
   *     math.mean(2, 1, 4, 3);                     // returns 2.5
   *     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
   *
   *     math.mean([[2, 5], [6, 3], [1, 7]], 0);    // returns [3, 5]
   *     math.mean([[2, 5], [6, 3], [1, 7]], 1);    // returns [3.5, 4.5, 4]
   *
   * See also:
   *
   *     median, min, max, sum, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The mean of all values
   */
  var mean = typed('mean', {
      // mean([a, b, c, d, ...])
    'Array | Matrix': _mean,

      // mean([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': _nmean,

    // mean(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function mean');
      }

      return _mean(args);
    }
  });

  mean.toTex = undefined; // use default template

  return mean;

  /**
   * Calculate the mean value in an n-dimensional array, returning a
   * n-1 dimensional array
   * @param {Array} array
   * @param {number} dim
   * @return {number} mean
   * @private
   */
  function _nmean(array, dim){
    var sum = reduce(array, dim, add);
    var s = Array.isArray(array) ? size(array) : array.size();
    return divide(sum, s[dim]);
  }

  /**
   * Recursively calculate the mean value in an n-dimensional array
   * @param {Array} array
   * @return {number} mean
   * @private
   */
  function _mean(array) {
    var sum = 0;
    var num = 0;

    deepForEach(array, function (value) {
      sum = add(sum, value);
      num++;
    });

    if (num === 0) {
      throw new Error('Cannot calculate mean of an empty array');
    }

    return divide(sum, num);
  }
}

exports.name = 'mean';
exports.factory = factory;

},{"../../utils/array":346,"../../utils/collection/containsCollections":351,"../../utils/collection/deepForEach":352,"../../utils/collection/reduce":355,"../arithmetic/add":242,"../arithmetic/divide":247}],293:[function(require,module,exports){
'use strict';

var deepForEach = require('../../utils/collection/deepForEach');
var reduce = require('../../utils/collection/reduce');
var containsCollections = require('../../utils/collection/containsCollections');

function factory (type, config, load, typed) {
  var smaller = load(require('../relational/smaller'));
  
  /**
   * Compute the maximum value of a matrix or a  list of values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.min(a, b, c, ...)
   *     math.min(A)
   *     math.min(A, dim)
   *
   * Examples:
   *
   *     math.min(2, 1, 4, 3);                  // returns 1
   *     math.min([2, 1, 4, 3]);                // returns 1
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.min([[2, 5], [4, 3], [1, 7]], 0); // returns [1, 3]
   *     math.min([[2, 5], [4, 3], [1, 7]], 1); // returns [2, 3, 1]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, max, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The minimum value
   */
  var min = typed('min', {
    // min([a, b, c, d, ...])
    'Array | Matrix': _min,

    // min([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      return reduce(array, dim.valueOf(), _smallest);
    },

    // min(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function min');
      }

      return _min(args);
    }
  });

  min.toTex = '\\min\\left(${args}\\right)';

  return min;

  /**
   * Return the smallest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is smallest, or y when y is smallest
   * @private
   */
  function _smallest(x, y) {
    return smaller(x, y) ? x : y;
  }

  /**
   * Recursively calculate the minimum value in an n-dimensional array
   * @param {Array} array
   * @return {number} min
   * @private
   */
  function _min(array) {
    var min = undefined;

    deepForEach(array, function (value) {
      if (min === undefined || smaller(value, min)) {
        min = value;
      }
    });

    if (min === undefined) {
      throw new Error('Cannot calculate min of an empty array');
    }

    return min;
  }
}

exports.name = 'min';
exports.factory = factory;

},{"../../utils/collection/containsCollections":351,"../../utils/collection/deepForEach":352,"../../utils/collection/reduce":355,"../relational/smaller":290}],294:[function(require,module,exports){
'use strict';

var string = require('../../utils/string');

function factory (type, config, load, typed) {
  /**
   * Format a value of any type into a string.
   *
   * Syntax:
   *
   *    math.format(value)
   *    math.format(value, options)
   *    math.format(value, precision)
   *    math.format(value, callback)
   *
   * Where:
   *
   *  - `value: *`
   *    The value to be formatted
   *  - `options: Object`
   *    An object with formatting options. Available options:
   *    - `notation: string`
   *      Number notation. Choose from:
   *      - 'fixed'
   *        Always use regular number notation.
   *        For example '123.40' and '14000000'
   *      - 'exponential'
   *        Always use exponential notation.
   *        For example '1.234e+2' and '1.4e+7'
   *      - 'engineering'
   *        Always use engineering notation.
   *        For example '123.4e+0' and '14.0e+6'
   *      - 'auto' (default)
   *        Regular number notation for numbers having an absolute value between
   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
   *        Lower bound is included, upper bound is excluded.
   *        For example '123.4' and '1.4e7'.
   *    - `precision: number`
   *      A number between 0 and 16 to round the digits of the number. In case
   *      of notations 'exponential' and 'auto', `precision` defines the total
   *      number of significant digits returned and is undefined by default.
   *      In case of notation 'fixed', `precision` defines the number of
   *      significant digits after the decimal point, and is 0 by default.
   *    - `exponential: Object`
   *      An object containing two parameters, {number} lower and {number} upper,
   *      used by notation 'auto' to determine when to return exponential
   *      notation. Default values are `lower=1e-3` and `upper=1e5`. Only
   *      applicable for notation `auto`.
   *    - `fraction: string`. Available values: 'ratio' (default) or 'decimal'.
   *      For example `format(fraction(1, 3))` will output '1/3' when 'ratio' is
   *      configured, and will output `0.(3)` when 'decimal' is configured.
   * - `callback: function`
   *   A custom formatting function, invoked for all numeric elements in `value`,
   *   for example all elements of a matrix, or the real and imaginary
   *   parts of a complex number. This callback can be used to override the
   *   built-in numeric notation with any type of formatting. Function `callback`
   *   is called with `value` as parameter and must return a string.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this function
   *   is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * Examples:
   *
   *    math.format(6.4);                                        // returns '6.4'
   *    math.format(1240000);                                    // returns '1.24e6'
   *    math.format(1/3);                                        // returns '0.3333333333333333'
   *    math.format(1/3, 3);                                     // returns '0.333'
   *    math.format(21385, 2);                                   // returns '21000'
   *    math.format(12.071, {notation: 'fixed'});                // returns '12'
   *    math.format(2.3,    {notation: 'fixed', precision: 2});  // returns '2.30'
   *    math.format(52.8,   {notation: 'exponential'});          // returns '5.28e+1'
   *    math.format(12400,  {notation: 'engineering'});         // returns '12.400e+3'
   *
   *    function formatCurrency(value) {
   *      // return currency notation with two digits:
   *      return '$' + value.toFixed(2);
   *
   *      // you could also use math.format inside the callback:
   *      // return '$' + math.format(value, {notation: 'fixed', precision: 2});
   *    }
   *    math.format([2.1, 3, 0.016], formatCurrency};            // returns '[$2.10, $3.00, $0.02]'
   *
   * See also:
   *
   *    print
   *
   * @param {*} value                               Value to be stringified
   * @param {Object | Function | number} [options]  Formatting options
   * @return {string} The formatted value
   */
  var format = typed('format', {
    'any': string.format,
    'any, Object | function | number': string.format
  });

  format.toTex = undefined; // use default template

  return format;
}

exports.name = 'format';
exports.factory = factory;

},{"../../utils/string":363}],295:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acos(x)
   *
   * Examples:
   *
   *    math.acos(0.5);           // returns number 1.0471975511965979
   *    math.acos(math.cos(1.5)); // returns number 1.5
   *
   *    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    cos, atan, asin
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc cosine of x
   */
  var acos = typed('acos', {
    'number': function (x) {
      if ((x >= -1 && x <= 1) || config.predictable) {
        return Math.acos(x);
      }
      else {
        return new type.Complex(x, 0).acos();
      }
    },

    'Complex': function (x) {
      return x.acos();
    },

    'BigNumber': function (x) {
      return x.acos();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acos);
    }
  });

  acos.toTex = {1: '\\cos^{-1}\\left(${args[0]}\\right)'};

  return acos;
}

exports.name = 'acos';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],296:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arccos of a value,
   * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acosh(x)
   *
   * Examples:
   *
   *    math.acosh(1.5);       // returns 0.9624236501192069
   *
   * See also:
   *
   *    cosh, asinh, atanh
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccosine of x
   */
  var acosh = typed('acosh', {
    'number': function (x) {
      if (x >= 1 || config.predictable) {
        return _acosh(x);
      }
      if (x <= -1) {
        return new type.Complex(Math.log(Math.sqrt(x*x - 1) - x), Math.PI);
      }
      return new type.Complex(x, 0).acosh();
    },

    'Complex': function (x) {
      return x.acosh();
    },

    'BigNumber': function (x) {
      return x.acosh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acosh);
    }
  });

  acosh.toTex = {1: '\\cosh^{-1}\\left(${args[0]}\\right)'};

  return acosh;
}

/**
 * Calculate the hyperbolic arccos of a number
 * @param {number} x
 * @return {number}
 * @private
 */
var _acosh = Math.acosh || function (x) {
  return Math.log(Math.sqrt(x*x - 1) + x)
};

exports.name = 'acosh';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],297:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acot(x)
   *
   * Examples:
   *
   *    math.acot(0.5);           // returns number 0.4636476090008061
   *    math.acot(math.cot(1.5)); // returns number 1.5
   *
   *    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
    'number': function (x) {
      return Math.atan(1 / x);
    },

    'Complex': function (x) {
      return x.acot();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).atan();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acot);
    }
  });

  acot.toTex = {1: '\\cot^{-1}\\left(${args[0]}\\right)'};

  return acot;
}

exports.name = 'acot';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],298:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arccotangent of a value,
   * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acoth(x)
   *
   * Examples:
   *
   *    math.acoth(0.5);       // returns 0.8047189562170503
   *
   * See also:
   *
   *    acsch, asech
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccotangent of x
   */
  var acoth = typed('acoth', {
    'number': function (x) {
      if (x >= 1 || x <= -1 || config.predictable) {
        return isFinite(x) ? (Math.log((x+1)/x) + Math.log(x/(x-1))) / 2 : 0;
      }
      return new type.Complex(x, 0).acoth();
    },

    'Complex': function (x) {
      return x.acoth();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).atanh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acoth);
    }
  });

  acoth.toTex = {1: '\\coth^{-1}\\left(${args[0]}\\right)'};

  return acoth;
}

exports.name = 'acoth';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],299:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');


function factory (type, config, load, typed) {

  /**
   * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acsc(x)
   *
   * Examples:
   *
   *    math.acsc(0.5);           // returns number 0.5235987755982989
   *    math.acsc(math.csc(1.5)); // returns number ~1.5
   *
   *    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    csc, asin, asec
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
    'number': function (x) {
      if (x <= -1 || x >= 1 || config.predictable) {
        return Math.asin(1 / x);
      }
      return new type.Complex(x, 0).acsc();
    },

    'Complex': function (x) {
      return x.acsc();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).asin();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acsc);
    }
  });

  acsc.toTex = {1: '\\csc^{-1}\\left(${args[0]}\\right)'};

  return acsc;
}

exports.name = 'acsc';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],300:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arccosecant of a value,
   * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acsch(x)
   *
   * Examples:
   *
   *    math.acsch(0.5);       // returns 1.4436354751788103
   *
   * See also:
   *
   *    asech, acoth
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccosecant of x
   */
  var acsch = typed('acsch', {
    'number': function (x) {
      x = 1 / x;
      return Math.log(x + Math.sqrt(x*x + 1));
    },

    'Complex': function (x) {
      return x.acsch();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).asinh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acsch);
    }
  });

  acsch.toTex = {1: '\\mathrm{csch}^{-1}\\left(${args[0]}\\right)'};

  return acsch;
}

exports.name = 'acsch';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],301:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asec(x)
   *
   * Examples:
   *
   *    math.asec(0.5);           // returns 1.0471975511965979
   *    math.asec(math.sec(1.5)); // returns 1.5
   *
   *    math.asec(2);             // returns 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    acos, acot, acsc
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} The arc secant of x
   */
  var asec = typed('asec', {
    'number': function (x) {
      if (x <= -1 || x >= 1 || config.predictable) {
        return Math.acos(1 / x);
      }
      return new type.Complex(x, 0).asec();
    },

    'Complex': function (x) {
      return x.asec();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).acos();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, asec);
    }
  });

  asec.toTex = {1: '\\sec^{-1}\\left(${args[0]}\\right)'};

  return asec;
}

exports.name = 'asec';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],302:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  var acosh = typed.find(load(require('./acosh')), ['Complex']);

  /**
   * Calculate the hyperbolic arcsecant of a value,
   * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asech(x)
   *
   * Examples:
   *
   *    math.asech(0.5);       // returns 1.3169578969248166
   *
   * See also:
   *
   *    acsch, acoth
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arcsecant of x
   */
  var asech = typed('asech', {
    'number': function (x) {
      if ((x <= 1 && x >= -1) || config.predictable) {
        x = 1 / x;

        var ret = Math.sqrt(x*x - 1);
        if (x > 0 || config.predictable) {
          return Math.log(ret + x);
        }

        return new type.Complex(Math.log(ret - x), Math.PI);
      }

      return new type.Complex(x, 0).asech();
    },

    'Complex': function (x) {
      return x.asech()
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).acosh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, asech);
    }
  });

  asech.toTex = {1: '\\mathrm{sech}^{-1}\\left(${args[0]}\\right)'};

  return asech;
}

exports.name = 'asech';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"./acosh":296}],303:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asin(x)
   *
   * Examples:
   *
   *    math.asin(0.5);           // returns number 0.5235987755982989
   *    math.asin(math.sin(1.5)); // returns number ~1.5
   *
   *    math.asin(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    sin, atan, acos
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc sine of x
   */
  var asin = typed('asin', {
    'number': function (x) {
      if ((x >= -1 && x <= 1) || config.predictable) {
        return Math.asin(x);
      }
      else {
        return new type.Complex(x, 0).asin();
      }
    },

    'Complex': function (x) {
      return x.asin();
    },

    'BigNumber': function (x) {
      return x.asin();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since asin(0) = 0
      return deepMap(x, asin, true);
    }
  });

  asin.toTex = {1: '\\sin^{-1}\\left(${args[0]}\\right)'};

  return asin;
}

exports.name = 'asin';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],304:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the hyperbolic arcsine of a value,
   * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asinh(x)
   *
   * Examples:
   *
   *    math.asinh(0.5);       // returns 0.48121182505960347
   *
   * See also:
   *
   *    acosh, atanh
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arcsine of x
   */
  var asinh = typed('asinh', {
    'number': Math.asinh || function (x) {
      return Math.log(Math.sqrt(x*x + 1) + x);
    },

    'Complex': function (x) {
        return x.asinh();
    },

    'BigNumber': function (x) {
      return x.asinh();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since asinh(0) = 0
      return deepMap(x, asinh, true);
    }
  });

  asinh.toTex = {1: '\\sinh^{-1}\\left(${args[0]}\\right)'};

  return asinh;
}

exports.name = 'asinh';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],305:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the inverse tangent of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan(x)
   *
   * Examples:
   *
   *    math.atan(0.5);           // returns number 0.4636476090008061
   *    math.atan(math.tan(1.5)); // returns number 1.5
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, asin, acos
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
   */
  var atan = typed('atan', {
    'number': function (x) {
      return Math.atan(x);
    },

    'Complex': function (x) {
      return x.atan();
    },

    'BigNumber': function (x) {
      return x.atan();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since atan(0) = 0
      return deepMap(x, atan, true);
    }
  });

  atan.toTex = {1: '\\tan^{-1}\\left(${args[0]}\\right)'};

  return atan;
}

exports.name = 'atan';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],306:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  /**
   * Calculate the inverse tangent function with two arguments, y/x.
   * By providing two arguments, the right quadrant of the computed angle can be
   * determined.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan2(y, x)
   *
   * Examples:
   *
   *    math.atan2(2, 2) / math.pi;       // returns number 0.25
   *
   *    var angle = math.unit(60, 'deg'); // returns Unit 60 deg
   *    var x = math.cos(angle);
   *    var y = math.sin(angle);
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, atan, sin, cos
   *
   * @param {number | Array | Matrix} y  Second dimension
   * @param {number | Array | Matrix} x  First dimension
   * @return {number | Array | Matrix} Four-quadrant inverse tangent
   */
  var atan2 = typed('atan2', {

    'number, number': Math.atan2,

    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored the imaginary.

    'BigNumber, BigNumber': function (y, x) {
      return type.BigNumber.atan2(y, x);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .* sparse
              c = algorithm09(x, y, atan2, false);
              break;
            default:
              // sparse .* dense
              c = algorithm02(y, x, atan2, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .* sparse
              c = algorithm03(x, y, atan2, false);
              break;
            default:
              // dense .* dense
              c = algorithm13(x, y, atan2);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return atan2(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return atan2(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return atan2(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, atan2, false);
          break;
        default:
          c = algorithm14(x, y, atan2, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, atan2, true);
          break;
        default:
          c = algorithm14(y, x, atan2, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, atan2, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, atan2, true).valueOf();
    }
  });

  atan2.toTex = {2: '\\mathrm{atan2}\\left(${args}\\right)'};

  return atan2;
}

exports.name = 'atan2';
exports.factory = factory;

},{"../../type/matrix/function/matrix":328,"../../type/matrix/utils/algorithm02":330,"../../type/matrix/utils/algorithm03":331,"../../type/matrix/utils/algorithm09":336,"../../type/matrix/utils/algorithm11":338,"../../type/matrix/utils/algorithm12":339,"../../type/matrix/utils/algorithm13":340,"../../type/matrix/utils/algorithm14":341}],307:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic arctangent of a value,
   * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atanh(x)
   *
   * Examples:
   *
   *    math.atanh(0.5);       // returns 0.5493061443340549
   *
   * See also:
   *
   *    acosh, asinh
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arctangent of x
   */
  var atanh = typed('atanh', {
    'number': function (x) {
      if ((x <= 1 && x >= -1) || config.predictable) {
        return _atanh(x);
      }
      return new type.Complex(x, 0).atanh();
    },

    'Complex': function (x) {
      return x.atanh();
    },

    'BigNumber': function (x) {
      return x.atanh();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since atanh(0) = 0
      return deepMap(x, atanh, true);
    }
  });

  atanh.toTex = {1: '\\tanh^{-1}\\left(${args[0]}\\right)'};

  return atanh;
}

/**
 * Calculate the hyperbolic arctangent of a number
 * @param {number} x
 * @return {number}
 * @private
 */
var _atanh = Math.atanh || function (x) {
  return Math.log((1 + x)/(1 - x)) / 2
};

exports.name = 'atanh';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],308:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cos(x)
   *
   * Examples:
   *
   *    math.cos(2);                      // returns number -0.4161468365471422
   *    math.cos(math.pi / 4);            // returns number  0.7071067811865475
   *    math.cos(math.unit(180, 'deg'));  // returns number -1
   *    math.cos(math.unit(60, 'deg'));   // returns number  0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
   */
  var cos = typed('cos', {
    'number': Math.cos,

    'Complex': function (x) {
      return x.cos();
    },

    'BigNumber': function (x) {
      return x.cos();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cos is no angle');
      }
      return cos(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cos);
    }
  });

  cos.toTex = {1: '\\cos\\left(${args[0]}\\right)'};

  return cos;
}

exports.name = 'cos';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],309:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic cosine of a value,
   * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cosh(x)
   *
   * Examples:
   *
   *    math.cosh(0.5);       // returns number 1.1276259652063807
   *
   * See also:
   *
   *    sinh, tanh
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic cosine of x
   */
  var cosh = typed('cosh', {
    'number': _cosh,

    'Complex': function (x) {
      return x.cosh();
    },

    'BigNumber': function (x) {
      return x.cosh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cosh is no angle');
      }
      return cosh(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cosh);
    }
  });

  cosh.toTex = {1: '\\cosh\\left(${args[0]}\\right)'};

  return cosh;
}

/**
 * Calculate the hyperbolic cosine of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
var _cosh = Math.cosh || function (x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};

exports.name = 'cosh';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],310:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cot(x)
   *
   * Examples:
   *
   *    math.cot(2);      // returns number -0.45765755436028577
   *    1 / math.tan(2);  // returns number -0.45765755436028577
   *
   * See also:
   *
   *    tan, sec, csc
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cotangent of x
   */
  var cot = typed('cot', {
    'number': function (x) {
      return 1 / Math.tan(x);
    },

    'Complex': function (x) {
      return x.cot();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.tan());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cot is no angle');
      }
      return cot(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cot);
    }
  });

  cot.toTex = {1: '\\cot\\left(${args[0]}\\right)'};

  return cot;
}

exports.name = 'cot';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],311:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic cotangent of a value,
   * defined as `coth(x) = 1 / tanh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.coth(x)
   *
   * Examples:
   *
   *    // coth(x) = 1 / tanh(x)
   *    math.coth(2);         // returns 1.0373147207275482
   *    1 / math.tanh(2);     // returns 1.0373147207275482
   *
   * See also:
   *
   *    sinh, tanh, cosh
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
   */
  var coth = typed('coth', {
    'number': _coth,

    'Complex': function (x) {
      return x.coth();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.tanh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function coth is no angle');
      }
      return coth(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, coth);
    }
  });

  coth.toTex = {1: '\\coth\\left(${args[0]}\\right)'};

  return coth;
}

/**
 * Calculate the hyperbolic cosine of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _coth(x) {
  var e = Math.exp(2 * x);
  return (e + 1) / (e - 1);
}

exports.name = 'coth';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],312:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csc(x)
   *
   * Examples:
   *
   *    math.csc(2);      // returns number 1.099750170294617
   *    1 / math.sin(2);  // returns number 1.099750170294617
   *
   * See also:
   *
   *    sin, sec, cot
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cosecant of x
   */
  var csc = typed('csc', {
    'number': function (x) {
      return 1 / Math.sin(x);
    },

    'Complex': function (x) {
      return x.csc();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.sin());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csc is no angle');
      }
      return csc(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, csc);
    }
  });

  csc.toTex = {1: '\\csc\\left(${args[0]}\\right)'};

  return csc;
}

exports.name = 'csc';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],313:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var sign = require('../../utils/number').sign;

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic cosecant of a value,
   * defined as `csch(x) = 1 / sinh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csch(x)
   *
   * Examples:
   *
   *    // csch(x) = 1/ sinh(x)
   *    math.csch(0.5);       // returns 1.9190347513349437
   *    1 / math.sinh(0.5);   // returns 1.9190347513349437
   *
   * See also:
   *
   *    sinh, sech, coth
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
   */
  var csch = typed('csch', {
    'number': _csch,

    'Complex': function (x) {
      return x.csch();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.sinh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csch is no angle');
      }
      return csch(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, csch);
    }
  });

  csch.toTex = {1: '\\mathrm{csch}\\left(${args[0]}\\right)'};

  return csch;
}

/**
 * Calculate the hyperbolic cosecant of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _csch(x) {
  // consider values close to zero (+/-)
  if (x == 0) {
    return Number.POSITIVE_INFINITY;
  }
  else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}

exports.name = 'csch';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../../utils/number":361}],314:[function(require,module,exports){
module.exports = [
  require('./acos'),
  require('./acosh'),
  require('./acot'),
  require('./acoth'),
  require('./acsc'),
  require('./acsch'),
  require('./asec'),
  require('./asech'),
  require('./asin'),
  require('./asinh'),
  require('./atan'),
  require('./atan2'),
  require('./atanh'),
  require('./cos'),
  require('./cosh'),
  require('./cot'),
  require('./coth'),
  require('./csc'),
  require('./csch'),
  require('./sec'),
  require('./sech'),
  require('./sin'),
  require('./sinh'),
  require('./tan'),
  require('./tanh')
];

},{"./acos":295,"./acosh":296,"./acot":297,"./acoth":298,"./acsc":299,"./acsch":300,"./asec":301,"./asech":302,"./asin":303,"./asinh":304,"./atan":305,"./atan2":306,"./atanh":307,"./cos":308,"./cosh":309,"./cot":310,"./coth":311,"./csc":312,"./csch":313,"./sec":315,"./sech":316,"./sin":317,"./sinh":318,"./tan":319,"./tanh":320}],315:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sec(x)
   *
   * Examples:
   *
   *    math.sec(2);      // returns number -2.4029979617223822
   *    1 / math.cos(2);  // returns number -2.4029979617223822
   *
   * See also:
   *
   *    cos, csc, cot
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Secant of x
   */
  var sec = typed('sec', {
    'number': function (x) {
      return 1 / Math.cos(x);
    },

    'Complex': function (x) {
      return x.sec();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.cos());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sec is no angle');
      }
      return sec(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, sec);
    }
  });

  sec.toTex = {1: '\\sec\\left(${args[0]}\\right)'};

  return sec;
}

exports.name = 'sec';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],316:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic secant of a value,
   * defined as `sech(x) = 1 / cosh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sech(x)
   *
   * Examples:
   *
   *    // sech(x) = 1/ cosh(x)
   *    math.sech(0.5);       // returns 0.886818883970074
   *    1 / math.cosh(0.5);   // returns 0.886818883970074
   *
   * See also:
   *
   *    cosh, csch, coth
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic secant of x
   */
  var sech = typed('sech', {
    'number': _sech,

    'Complex': function (x) {
      return x.sech();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.cosh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sech is no angle');
      }
      return sech(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, sech);
    }
  });

  sech.toTex = {1: '\\mathrm{sech}\\left(${args[0]}\\right)'};

  return sech;
}

/**
 * Calculate the hyperbolic secant of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
function _sech(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}

exports.name = 'sech';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],317:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {

  /**
   * Calculate the sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sin(x)
   *
   * Examples:
   *
   *    math.sin(2);                      // returns number 0.9092974268256813
   *    math.sin(math.pi / 4);            // returns number 0.7071067811865475
   *    math.sin(math.unit(90, 'deg'));   // returns number 1
   *    math.sin(math.unit(30, 'deg'));   // returns number 0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
   */
  var sin = typed('sin', {
    'number': Math.sin,

    'Complex': function (x) {
      return x.sin();
    },

    'BigNumber': function (x) {
      return x.sin();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sin is no angle');
      }
      return sin(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sin(0) = 0
      return deepMap(x, sin, true);
    }
  });

  sin.toTex = {1: '\\sin\\left(${args[0]}\\right)'};

  return sin;
}

exports.name = 'sin';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],318:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic sine of a value,
   * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sinh(x)
   *
   * Examples:
   *
   *    math.sinh(0.5);       // returns number 0.5210953054937474
   *
   * See also:
   *
   *    cosh, tanh
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic sine of x
   */
  var sinh = typed('sinh', {
    'number': _sinh,

    'Complex': function (x) {
      return x.sinh();
    },

    'BigNumber': function (x) {
      return x.sinh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sinh is no angle');
      }
      return sinh(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sinh(0) = 0
      return deepMap(x, sinh, true);
    }
  });

  sinh.toTex = {1: '\\sinh\\left(${args[0]}\\right)'};

  return sinh;
}

/**
 * Calculate the hyperbolic sine of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
var _sinh = Math.sinh || function (x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};

exports.name = 'sinh';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],319:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tan(x)
   *
   * Examples:
   *
   *    math.tan(0.5);                    // returns number 0.5463024898437905
   *    math.sin(0.5) / math.cos(0.5);    // returns number 0.5463024898437905
   *    math.tan(math.pi / 4);            // returns number 1
   *    math.tan(math.unit(45, 'deg'));   // returns number 1
   *
   * See also:
   *
   *    atan, sin, cos
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Tangent of x
   */
  var tan = typed('tan', {
    'number': Math.tan,

    'Complex': function (x) {
        return x.tan();
    },

    'BigNumber': function (x) {
      return x.tan();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tan is no angle');
      }
      return tan(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since tan(0) = 0
      return deepMap(x, tan, true);
    }
  });

  tan.toTex = {1: '\\tan\\left(${args[0]}\\right)'};

  return tan;
}

exports.name = 'tan';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],320:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Calculate the hyperbolic tangent of a value,
   * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tanh(x)
   *
   * Examples:
   *
   *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
   *    math.tanh(0.5);                   // returns 0.46211715726000974
   *    math.sinh(0.5) / math.cosh(0.5);  // returns 0.46211715726000974
   *    1 / math.coth(0.5);               // returns 0.46211715726000974
   *
   * See also:
   *
   *    sinh, cosh, coth
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic tangent of x
   */
  var tanh = typed('tanh', {
    'number': _tanh,

    'Complex': function (x) {
        return x.tanh();
    },

    'BigNumber': function (x) {
      return x.tanh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tanh is no angle');
      }
      return tanh(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since tanh(0) = 0
      return deepMap(x, tanh, true);
    }
  });

  tanh.toTex = {1: '\\tanh\\left(${args[0]}\\right)'};

  return tanh;
}

/**
 * Calculate the hyperbolic tangent of a number
 * @param {number} x
 * @returns {number}
 * @private
 */
var _tanh = Math.tanh || function (x) {
  var e = Math.exp(2 * x);
  return (e - 1) / (e + 1);
};

exports.name = 'tanh';
exports.factory = factory;

},{"../../utils/collection/deepMap":353}],321:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is negative: smaller than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNegative(x)
   *
   * Examples:
   *
   *    math.isNegative(3);                     // returns false
   *    math.isNegative(-2);                    // returns true
   *    math.isNegative(0);                     // returns false
   *    math.isNegative(-0);                    // returns false
   *    math.isNegative(math.bignumber(2));     // returns false
   *    math.isNegative(math.fraction(-2, 5));  // returns true
   *    math.isNegative('-2');                  // returns true
   *    math.isNegative([2, 0, -3]');           // returns [false, false, true]
   *
   * See also:
   *
   *    isNumeric, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
  var isNegative = typed('isNegative', {
    'number': function (x) {
      return x < 0;
    },

    'BigNumber': function (x) {
      return x.isNeg() && !x.isZero() && !x.isNaN();
    },

    'Fraction': function (x) {
      return x.s < 0; // It's enough to decide on the sign
    },

    'Unit': function (x) {
      return isNegative(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isNegative);
    }
  });

  return isNegative;
}

exports.name = 'isNegative';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../../utils/number":361}],322:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is an numeric value.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNumeric(x)
   *
   * Examples:
   *
   *    math.isNumeric(2);                     // returns true
   *    math.isNumeric(0);                     // returns true
   *    math.isNumeric(math.bignumber(500));   // returns true
   *    math.isNumeric(math.fraction(4));      // returns true
   *    math.isNumeric(math.complex('2-4i');   // returns false
   *    math.isNumeric('3');                   // returns false
   *    math.isNumeric([2.3, 'foo', false]);   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, or `boolean`. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */
  var isNumeric = typed('isNumeric', {
    'number | BigNumber | Fraction | boolean': function () {
      return true;
    },

    'Complex | Unit | string': function () {
      return false;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isNumeric);
    }
  });

  return isNumeric;
}

exports.name = 'isNumeric';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../../utils/number":361}],323:[function(require,module,exports){
'use strict';

var deepMap = require('../../utils/collection/deepMap');
var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Test whether a value is positive: larger than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPositive(x)
   *
   * Examples:
   *
   *    math.isPositive(3);                     // returns true
   *    math.isPositive(-2);                    // returns false
   *    math.isPositive(0);                     // returns false
   *    math.isPositive(-0);                    // returns false
   *    math.isPositive(0.5);                   // returns true
   *    math.isPositive(math.bignumber(2));     // returns true
   *    math.isPositive(math.fraction(-2, 5));  // returns false
   *    math.isPositive(math.fraction(1,3));    // returns false
   *    math.isPositive('2');                   // returns true
   *    math.isPositive([2, 0, -3]');           // returns [true, false, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
  var isPositive = typed('isPositive', {
    'number': function (x) {
      return x > 0;
    },

    'BigNumber': function (x) {
      return !x.isNeg() && !x.isZero() && !x.isNaN();
    },

    'Fraction': function (x) {
      return x.s > 0 && x.n > 0;
    },

    'Unit': function (x) {
      return isPositive(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isPositive);
    }
  });

  return isPositive;
}

exports.name = 'isPositive';
exports.factory = factory;

},{"../../utils/collection/deepMap":353,"../../utils/number":361}],324:[function(require,module,exports){
'use strict';

var types = require('../../utils/types');

function factory (type, config, load, typed) {
  /**
   * Determine the type of a variable.
   *
   * Function `typeof` recognizes the following types of objects:
   *
   * Object                 | Returns       | Example
   * ---------------------- | ------------- | ------------------------------------------
   * null                   | `'null'`      | `math.typeof(null)`
   * number                 | `'number'`    | `math.typeof(3.5)`
   * boolean                | `'boolean'`   | `math.typeof (true)`
   * string                 | `'string'`    | `math.typeof ('hello world')`
   * Array                  | `'Array'`     | `math.typeof ([1, 2, 3])`
   * Date                   | `'Date'`      | `math.typeof (new Date())`
   * Function               | `'Function'`  | `math.typeof (function () {})`
   * Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
   * RegExp                 | `'RegExp'`    | `math.typeof (/a regexp/)`
   * undefined              | `'undefined'` | `math.typeof(undefined)`
   * math.type.BigNumber    | `'BigNumber'` | `math.typeof (math.bignumber('2.3e500'))`
   * math.type.Chain        | `'Chain'`     | `math.typeof (math.chain(2))`
   * math.type.Complex      | `'Complex'`   | `math.typeof (math.complex(2, 3))`
   * math.type.Fraction     | `'Fraction'`  | `math.typeof (math.fraction(1, 3))`
   * math.type.Help         | `'Help'`      | `math.typeof (math.help('sqrt'))`
   * math.type.Index        | `'Index'`     | `math.typeof (math.index(1, 3))`
   * math.type.Matrix       | `'Matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
   * math.type.Range        | `'Range'`     | `math.typeof (math.range(0, 10))`
   * math.type.Unit         | `'Unit'`      | `math.typeof (math.unit('45 deg'))`
   *
   * Syntax:
   *
   *    math.typeof(x)
   *
   * Examples:
   *
   *    math.typeof(3.5);                     // returns 'number'
   *    math.typeof(math.complex('2-4i'));    // returns 'Complex'
   *    math.typeof(math.unit('45 deg'));     // returns 'Unit'
   *    math.typeof('hello world');           // returns 'string'
   *
   * @param {*} x     The variable for which to test the type.
   * @return {string} Returns the name of the type. Primitive types are lower case,
   *                  non-primitive types are upper-camel-case.
   *                  For example 'number', 'string', 'Array', 'Date'.
   */
  var _typeof = typed('_typeof', {
    'any': function (x) {
      // JavaScript types
      var t = types.type(x);

      // math.js types
      if (t === 'Object') {
        if (x.isBigNumber === true) return 'BigNumber';
        if (x.isComplex === true)   return 'Complex';
        if (x.isFraction === true)  return 'Fraction';
        if (x.isMatrix === true)    return 'Matrix';
        if (x.isUnit === true)      return 'Unit';
        if (x.isIndex === true)     return 'Index';
        if (x.isRange === true)     return 'Range';
        if (x.isChain === true)     return 'Chain';
        if (x.isHelp === true)      return 'Help';
      }

      return t;
    }
  });

  _typeof.toTex = undefined; // use default template

  return _typeof;
}

exports.name = 'typeof';
exports.factory = factory;

},{"../../utils/types":364}],325:[function(require,module,exports){
var Complex = require('complex.js');
var format = require('../../utils/number').format;
var isNumber = require('../../utils/number').isNumber;

function factory (type, config, load, typed, math) {

  /**
   * Attach type information
   */
  Complex.prototype.type = 'Complex';
  Complex.prototype.isComplex = true;


  /**
   * Get a JSON representation of the complex number
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
   */
  Complex.prototype.toJSON = function () {
    return {
      mathjs: 'Complex',
      re: this.re,
      im: this.im
    };
  };

  /*
   * Return the value of the complex number in polar notation
   * The angle phi will be set in the interval of [-pi, pi].
   * @return {{r: number, phi: number}} Returns and object with properties r and phi.
   */
  Complex.prototype.toPolar = function () {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };

  /**
   * Get a string representation of the complex number,
   * with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string} str
   */
  Complex.prototype.format = function (options) {
    var str = '';
    var im = this.im;
    var re = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);

    // round either re or im when smaller than the configured precision
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re / im) < epsilon) {
        re = 0;
      }
      if (Math.abs(im / re) < epsilon) {
        im = 0;
      }
    }

    if (im == 0) {
      // real value
      str = strRe;
    } else if (re == 0) {
      // purely complex value
      if (im == 1) {
        str = 'i';
      } else if (im == -1) {
        str = '-i';
      } else {
        str = strIm + 'i';
      }
    } else {
      // complex value
      if (im > 0) {
        if (im == 1) {
          str = strRe + ' + i';
        } else {
          str = strRe + ' + ' + strIm + 'i';
        }
      } else {
        if (im == -1) {
          str = strRe + ' - i';
        } else {
          str = strRe + ' - ' + strIm.substring(1) + 'i';
        }
      }
    }
    return str;
  };

  /**
   * Create a complex number from polar coordinates
   *
   * Usage:
   *
   *     Complex.fromPolar(r: number, phi: number) : Complex
   *     Complex.fromPolar({r: number, phi: number}) : Complex
   *
   * @param {*} args...
   * @return {Complex}
   */
  Complex.fromPolar = function (args) {
    switch (arguments.length) {
      case 1:
        var arg = arguments[0];
        if (typeof arg === 'object') {
          return Complex(arg);
        }
        throw new TypeError('Input has to be an object with r and phi keys.');

      case 2:
        var r = arguments[0],
            phi = arguments[1];
        if (isNumber(r)) {
          if (phi && phi.isUnit && phi.hasBase('ANGLE')) {
            // convert unit to a number in radians
            phi = phi.toNumber('rad');
          }

          if (isNumber(phi)) {
            return new Complex({r: r, phi: phi});
          }

          throw new TypeError('Phi is not a number nor an angle unit.');
        } else {
          throw new TypeError('Radius r is not a number.');
        }

      default:
        throw new SyntaxError('Wrong number of arguments in function fromPolar');
    }
  };


  Complex.prototype.valueOf = Complex.prototype.toString;

  /**
   * Create a Complex number from a JSON object
   * @param {Object} json  A JSON Object structured as
   *                       {"mathjs": "Complex", "re": 2, "im": 3}
   *                       All properties are optional, default values
   *                       for `re` and `im` are 0.
   * @return {Complex} Returns a new Complex number
   */
  Complex.fromJSON = function (json) {
    return new Complex(json);
  };

  // apply the current epsilon
  Complex.EPSILON = config.epsilon;

  // listen for changed in the configuration, automatically apply changed epsilon
  math.on('config', function (curr, prev) {
    if (curr.epsilon !== prev.epsilon) {
      Complex.EPSILON = curr.epsilon;
    }
  });

  return Complex;
}

exports.name = 'Complex';
exports.path = 'type';
exports.factory = factory;
exports.math = true; // request access to the math namespace

},{"../../utils/number":361,"complex.js":365}],326:[function(require,module,exports){
'use strict';

var deepMap = require('../../../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a fraction convert a value to a fraction.
   *
   * Syntax:
   *     math.fraction(numerator, denominator)
   *     math.fraction({n: numerator, d: denominator})
   *     math.fraction(matrix: Array | Matrix)         Turn all matrix entries
   *                                                   into fractions
   *
   * Examples:
   *
   *     math.fraction(1, 3);
   *     math.fraction('2/3');
   *     math.fraction({n: 2, d: 3});
   *     math.fraction([0.2, 0.25, 1.25]);
   *
   * See also:
   *
   *    bignumber, number, string, unit
   *
   * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]
   *            Arguments specifying the numerator and denominator of
   *            the fraction
   * @return {Fraction | Array | Matrix} Returns a fraction
   */
  var fraction = typed('fraction', {
    'number': function (x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + ' cannot be represented as a fraction');
      }

      return new type.Fraction(x);
    },

    'string': function (x) {
      return new type.Fraction(x);
    },

    'number, number': function (numerator, denominator) {
      return new type.Fraction(numerator, denominator);
    },

    'BigNumber': function (x) {
      return new type.Fraction(x.toString());
    },

    'Fraction': function (x) {
      return x; // fractions are immutable
    },

    'Object': function (x) {
      return new type.Fraction(x);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, fraction);
    }
  });

  return fraction;
}

exports.name = 'fraction';
exports.factory = factory;

},{"../../../utils/collection/deepMap":353}],327:[function(require,module,exports){
'use strict';

var number = require('../../utils/number');

function factory (type, config, load, typed) {
  /**
   * Create a range. A range has a start, step, and end, and contains functions
   * to iterate over the range.
   *
   * A range can be constructed as:
   *     var range = new Range(start, end);
   *     var range = new Range(start, end, step);
   *
   * To get the result of the range:
   *     range.forEach(function (x) {
   *         console.log(x);
   *     });
   *     range.map(function (x) {
   *         return math.sin(x);
   *     });
   *     range.toArray();
   *
   * Example usage:
   *     var c = new Range(2, 6);         // 2:1:5
   *     c.toArray();                     // [2, 3, 4, 5]
   *     var d = new Range(2, -3, -1);    // 2:-1:-2
   *     d.toArray();                     // [2, 1, 0, -1, -2]
   *
   * @class Range
   * @constructor Range
   * @param {number} start  included lower bound
   * @param {number} end    excluded upper bound
   * @param {number} [step] step size, default value is 1
   */
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (start != null) {
      if (start.isBigNumber === true)
        start = start.toNumber();
      else if (typeof start !== 'number')
        throw new TypeError('Parameter start must be a number');
    }
    if (end != null) {
      if (end.isBigNumber === true)
        end = end.toNumber();
      else if (typeof end !== 'number')
        throw new TypeError('Parameter end must be a number');
    }
    if (step != null) {
      if (step.isBigNumber === true)
        step = step.toNumber();
      else if (typeof step !== 'number')
        throw new TypeError('Parameter step must be a number');
    }

    this.start = (start != null) ? parseFloat(start) : 0;
    this.end   = (end != null)   ? parseFloat(end)   : 0;
    this.step  = (step != null)  ? parseFloat(step)  : 1;
  }

  /**
   * Attach type information
   */
  Range.prototype.type = 'Range';
  Range.prototype.isRange = true;

  /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @memberof Range
   * @param {string} str
   * @return {Range | null} range
   */
  Range.parse = function (str) {
    if (typeof str !== 'string') {
      return null;
    }

    var args = str.split(':');
    var nums = args.map(function (arg) {
      return parseFloat(arg);
    });

    var invalid = nums.some(function (num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }

    switch (nums.length) {
      case 2:
        return new Range(nums[0], nums[1]);
      case 3:
        return new Range(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };

  /**
   * Create a clone of the range
   * @return {Range} clone
   */
  Range.prototype.clone = function () {
    return new Range(this.start, this.end, this.step);
  };

  /**
   * Retrieve the size of the range.
   * Returns an array containing one number, the number of elements in the range.
   * @memberof Range
   * @returns {number[]} size
   */
  Range.prototype.size = function () {
    var len = 0,
        start = this.start,
        step = this.step,
        end = this.end,
        diff = end - start;

    if (number.sign(step) == number.sign(diff)) {
      len = Math.ceil((diff) / step);
    }
    else if (diff == 0) {
      len = 0;
    }

    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };

  /**
   * Calculate the minimum value in the range
   * @memberof Range
   * @return {number | undefined} min
   */
  Range.prototype.min = function () {
    var size = this.size()[0];

    if (size > 0) {
      if (this.step > 0) {
        // positive step
        return this.start;
      }
      else {
        // negative step
        return this.start + (size - 1) * this.step;
      }
    }
    else {
      return undefined;
    }
  };

  /**
   * Calculate the maximum value in the range
   * @memberof Range
   * @return {number | undefined} max
   */
  Range.prototype.max = function () {
    var size = this.size()[0];

    if (size > 0) {
      if (this.step > 0) {
        // positive step
        return this.start + (size - 1) * this.step;
      }
      else {
        // negative step
        return this.start;
      }
    }
    else {
      return undefined;
    }
  };


  /**
   * Execute a callback function for each value in the range.
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Range being traversed.
   */
  Range.prototype.forEach = function (callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i = 0;

    if (step > 0) {
      while (x < end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    }
    else if (step < 0) {
      while (x > end) {
        callback(x, [i], this);
        x += step;
        i++;
      }
    }
  };

  /**
   * Execute a callback function for each value in the Range, and return the
   * results as an array
   * @memberof Range
   * @param {function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix being traversed.
   * @returns {Array} array
   */
  Range.prototype.map = function (callback) {
    var array = [];
    this.forEach(function (value, index, obj) {
      array[index[0]] = callback(value, index, obj);
    });
    return array;
  };

  /**
   * Create an Array with a copy of the Ranges data
   * @memberof Range
   * @returns {Array} array
   */
  Range.prototype.toArray = function () {
    var array = [];
    this.forEach(function (value, index) {
      array[index[0]] = value;
    });
    return array;
  };

  /**
   * Get the primitive value of the Range, a one dimensional array
   * @memberof Range
   * @returns {Array} array
   */
  Range.prototype.valueOf = function () {
    // TODO: implement a caching mechanism for range.valueOf()
    return this.toArray();
  };

  /**
   * Get a string representation of the range, with optional formatting options.
   * Output is formatted as 'start:step:end', for example '2:6' or '0:0.2:11'
   * @memberof Range
   * @param {Object | number | function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */
  Range.prototype.format = function (options) {
    var str = number.format(this.start, options);

    if (this.step != 1) {
      str += ':' + number.format(this.step, options);
    }
    str += ':' + number.format(this.end, options);
    return str;
  };

  /**
   * Get a string representation of the range.
   * @memberof Range
   * @returns {string}
   */
  Range.prototype.toString = function () {
    return this.format();
  };

  /**
   * Get a JSON representation of the range
   * @memberof Range
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   */
  Range.prototype.toJSON = function () {
    return {
      mathjs: 'Range',
      start: this.start,
      end: this.end,
      step: this.step
    };
  };

  /**
   * Instantiate a Range from a JSON object
   * @memberof Range
   * @param {Object} json A JSON object structured as:
   *                      `{"mathjs": "Range", "start": 2, "end": 4, "step": 1}`
   * @return {Range}
   */
  Range.fromJSON = function (json) {
    return new Range(json.start, json.end, json.step);
  };

  return Range;
}

exports.name = 'Range';
exports.path = 'type';
exports.factory = factory;

},{"../../utils/number":361}],328:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * Create a Matrix. The function creates a new `math.type.Matrix` object from
   * an `Array`. A Matrix has utility functions to manipulate the data in the
   * matrix, like getting the size and getting or setting values in the matrix.
   * Supported storage formats are 'dense' and 'sparse'.
   *
   * Syntax:
   *
   *    math.matrix()                         // creates an empty matrix using default storage format (dense).
   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
   *
   * Examples:
   *
   *    var m = math.matrix([[1, 2], [3, 4]]);
   *    m.size();                        // Array [2, 2]
   *    m.resize([3, 2], 5);
   *    m.valueOf();                     // Array [[1, 2], [3, 4], [5, 5]]
   *    m.get([1, 0])                    // number 3
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, number, string, unit, sparse
   *
   * @param {Array | Matrix} [data]    A multi dimensional array
   * @param {string} [format]          The Matrix storage format
   *
   * @return {Matrix} The created matrix
   */
  var matrix = typed('matrix', {
    '': function () {
      return _create([]);
    },

    'string': function (format) {
      return _create([], format);
    },
    
    'string, string': function (format, datatype) {
      return _create([], format, datatype);
    },

    'Array': function (data) {
      return _create(data);
    },
      
    'Matrix': function (data) {
      return _create(data, data.storage());
    },
    
    'Array | Matrix, string': _create,
    
    'Array | Matrix, string, string': _create
  });

  matrix.toTex = {
    0: '\\begin{bmatrix}\\end{bmatrix}',
    1: '\\left(${args[0]}\\right)',
    2: '\\left(${args[0]}\\right)'
  };

  return matrix;

  /**
   * Create a new Matrix with given storage format
   * @param {Array} data
   * @param {string} [format]
   * @param {string} [datatype]
   * @returns {Matrix} Returns a new Matrix
   * @private
   */
  function _create(data, format, datatype) {
    // get storage format constructor
    var M = type.Matrix.storage(format || 'default');

    // create instance
    return new M(data, datatype);
  }
}

exports.name = 'matrix';
exports.factory = factory;

},{}],329:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij). 
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *            f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = 
   *            Dij          ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */
  var algorithm01 = function (denseMatrix, sparseMatrix, callback, inverse) {
    // dense matrix arrays
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    // sparse matrix arrays
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!bvalues)
      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // process data types
    var dt = typeof adt === 'string' && adt === bdt ? adt : undefined;
    // callback function
    var cf = dt ? typed.find(callback, [dt, dt]) : callback;

    // vars
    var i, j;
    
    // result (DenseMatrix)
    var cdata = [];
    // initialize c
    for (i = 0; i < rows; i++)
      cdata[i] = [];      
    
    // workspace
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns in b
    for (j = 0; j < columns; j++) {
      // column mark
      var mark = j + 1;
      // values in column j
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = bindex[k];
        // update workspace
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        // mark i as updated
        w[i] = mark;
      }
      // loop rows
      for (i = 0; i < rows; i++) {
        // check row is in workspace
        if (w[i] === mark) {
          // c[i][j] was already calculated
          cdata[i][j] = x[i];
        }
        else {
          // item does not exist in S
          cdata[i][j] = adata[i][j];
        }
      }
    }

    // return dense matrix
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  
  return algorithm01;
}

exports.name = 'algorithm01';
exports.factory = factory;

},{"../../../error/DimensionError":15}],330:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij). 
   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
   *
   *
   *            f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = 
   *            0            ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */
  var algorithm02 = function (denseMatrix, sparseMatrix, callback, inverse) {
    // dense matrix arrays
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    // sparse matrix arrays
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!bvalues)
      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];
    
    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result (SparseMatrix)
    var cvalues = [];
    var cindex = [];
    var cptr = [];

    // loop columns in b
    for (var j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // values in column j
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        var i = bindex[k];
        // update C(i,j)
        var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        // check for nonzero
        if (!eq(cij, zero)) {
          // push i & v
          cindex.push(i);
          cvalues.push(cij);
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
  
  return algorithm02;
}

exports.name = 'algorithm02';
exports.factory = factory;

},{"../../../error/DimensionError":15,"../../../function/relational/equalScalar":288}],331:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
   * Callback function invoked M*N times.
   *
   *
   *            f(Dij, Sij)  ; S(i,j) !== 0
   * C(i,j) = 
   *            f(Dij, 0)    ; otherwise
   *
   *
   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
   */
  var algorithm03 = function (denseMatrix, sparseMatrix, callback, inverse) {
    // dense matrix arrays
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    // sparse matrix arrays
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // sparse matrix cannot be a Pattern matrix
    if (!bvalues)
      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result (DenseMatrix)
    var cdata = [];

    // initialize dense matrix
    for (var z = 0; z < rows; z++) {
      // initialize row
      cdata[z] = [];
    }

    // workspace
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns in b
    for (var j = 0; j < columns; j++) {
      // column mark
      var mark = j + 1;
      // values in column j
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        var i = bindex[k];
        // update workspace
        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
        w[i] = mark;
      }
      // process workspace
      for (var y = 0; y < rows; y++) {
        // check we have a calculated value for current row
        if (w[y] === mark) {
          // use calculated value
          cdata[y][j] = x[y];
        }
        else {
          // calculate value
          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
        }
      }
    }

    // return dense matrix
    return new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  
  return algorithm03;
}

exports.name = 'algorithm03';
exports.factory = factory;

},{"../../../error/DimensionError":15}],332:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) =   A(i,j)       ; A(i,j) !== 0
   *            B(i,j)       ; B(i,j) !== 0
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm04 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspace
    var xa = avalues && bvalues ? [] : undefined;
    var xb = avalues && bvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var wa = [];
    var wb = [];

    // vars 
    var i, j, k, k0, k1;
    
    // loop columns
    for (j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // loop A(:,j)
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k];
        // update c
        cindex.push(i);
        // update workspace
        wa[i] = mark;
        // check we need to process values
        if (xa)
          xa[i] = avalues[k];
      }
      // loop B(:,j)
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = bindex[k];
        // check row exists in A
        if (wa[i] === mark) {
          // update record in xa @ i
          if (xa) {
            // invoke callback
            var v = cf(xa[i], bvalues[k]);
            // check for zero
            if (!eq(v, zero)) {
              // update workspace
              xa[i] = v;              
            }
            else {
              // remove mark (index will be removed later)
              wa[i] = null;
            }
          }
        }
        else {
          // update c
          cindex.push(i);
          // update workspace
          wb[i] = mark;
          // check we need to process values
          if (xb)
            xb[i] = bvalues[k];
        }
      }
      // check we need to process values (non pattern matrix)
      if (xa && xb) {
        // initialize first index in j
        k = cptr[j];
        // loop index in j
        while (k < cindex.length) {
          // row
          i = cindex[k];
          // check workspace has value @ i
          if (wa[i] === mark) {
            // push value (Aij != 0 || (Aij != 0 && Bij != 0))
            cvalues[k] = xa[i];
            // increment pointer
            k++;
          }
          else if (wb[i] === mark) {
            // push value (bij != 0)
            cvalues[k] = xb[i];
            // increment pointer
            k++;
          }
          else {
            // remove index @ k
            cindex.splice(k, 1);
          }
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };
  
  return algorithm04;
}

exports.name = 'algorithm04';
exports.factory = factory;

},{"../../../error/DimensionError":15,"../../../function/relational/equalScalar":288}],333:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));
  
  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MAX(NNZA, NNZB) times
   *
   *
   *            f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
   * C(i,j) =   
   *            0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm05 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var xa = cvalues ? [] : undefined;
    var xb = cvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var wa = [];
    var wb = [];

    // vars
    var i, j, k, k1;
    
    // loop columns
    for (j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // loop values A(:,j)
      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
        // row
        i = aindex[k];
        // push index
        cindex.push(i);
        // update workspace
        wa[i] = mark;
        // check we need to process values
        if (xa)
          xa[i] = avalues[k];
      }
      // loop values B(:,j)
      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
        // row
        i = bindex[k];
        // check row existed in A
        if (wa[i] !== mark) {
          // push index
          cindex.push(i);
        }
        // update workspace
        wb[i] = mark;
        // check we need to process values
        if (xb)
          xb[i] = bvalues[k];
      }
      // check we need to process values (non pattern matrix)
      if (cvalues) {
        // initialize first index in j
        k = cptr[j];
        // loop index in j
        while (k < cindex.length) {
          // row
          i = cindex[k];
          // marks
          var wai = wa[i];
          var wbi = wb[i];
          // check Aij or Bij are nonzero
          if (wai === mark || wbi === mark) {
            // matrix values @ i,j
            var va = wai === mark ? xa[i] : zero;
            var vb = wbi === mark ? xb[i] : zero;
            // Cij
            var vc = cf(va, vb);
            // check for zero
            if (!eq(vc, zero)) {
              // push value
              cvalues.push(vc);
              // increment pointer
              k++;
            }
            else {
              // remove value @ i, do not increment pointer
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm05;
}

exports.name = 'algorithm05';
exports.factory = factory;

},{"../../../error/DimensionError":15,"../../../function/relational/equalScalar":288}],334:[function(require,module,exports){
'use strict';

var scatter = require('./../../../utils/collection/scatter');
var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij). 
   * Callback function invoked (Anz U Bnz) times, where Anz and Bnz are the nonzero elements in both matrices.
   *
   *
   *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
   * C(i,j) =   
   *            0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm06 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = cvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var w = [];
    // marks indicating value in a given row has been updated
    var u = [];

    // loop columns
    for (var j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // columns mark
      var mark = j + 1;
      // scatter the values of A(:,j) into workspace
      scatter(a, j, w, x, u, mark, c, cf);
      // scatter the values of B(:,j) into workspace
      scatter(b, j, w, x, u, mark, c, cf);
      // check we need to process values (non pattern matrix)
      if (x) {
        // initialize first index in j
        var k = cptr[j];
        // loop index in j
        while (k < cindex.length) {
          // row
          var i = cindex[k];
          // check function was invoked on current row (Aij !=0 && Bij != 0)
          if (u[i] === mark) {
            // value @ i
            var v = x[i];
            // check for zero value
            if (!eq(v, zero)) {
              // push value
              cvalues.push(v);
              // increment pointer
              k++;
            }
            else {
              // remove value @ i, do not increment pointer
              cindex.splice(k, 1);
            }
          }
          else {
            // remove value @ i, do not increment pointer
            cindex.splice(k, 1);
          }
        }
      }
      else {
        // initialize first index in j
        var p = cptr[j];
        // loop index in j
        while (p < cindex.length) {
          // row
          var r = cindex[p];
          // check function was invoked on current row (Aij !=0 && Bij != 0)
          if (u[r] !== mark) {
            // remove value @ i, do not increment pointer
            cindex.splice(p, 1);
          }
          else {
            // increment pointer
            p++;
          }
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };
  
  return algorithm06;
}

exports.name = 'algorithm06';
exports.factory = factory;

},{"../../../error/DimensionError":15,"../../../function/relational/equalScalar":288,"./../../../utils/collection/scatter":356}],335:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij). 
   * Callback function invoked MxN times.
   *
   * C(i,j) = f(Aij, Bij)
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm07 = function (a, b, callback) {
    // sparse matrix arrays
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // vars
    var i, j;
    
    // result arrays
    var cdata = [];
    // initialize c
    for (i = 0; i < rows; i++)
      cdata[i] = [];

    // matrix
    var c = new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var xa = [];
    var xb = [];
    // marks indicating we have a value in x for a given column
    var wa = [];
    var wb = [];

    // loop columns
    for (j = 0; j < columns; j++) {
      // columns mark
      var mark = j + 1;
      // scatter the values of A(:,j) into workspace
      _scatter(a, j, wa, xa, mark);
      // scatter the values of B(:,j) into workspace
      _scatter(b, j, wb, xb, mark);
      // loop rows
      for (i = 0; i < rows; i++) {
        // matrix values @ i,j
        var va = wa[i] === mark ? xa[i] : zero;
        var vb = wb[i] === mark ? xb[i] : zero;
        // invoke callback
        cdata[i][j] = cf(va, vb);
      }          
    }

    // return sparse matrix
    return c;
  };
  
  var _scatter = function (m, j, w, x, mark) {
    // a arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // loop values in column j
    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
      // row
      var i = index[k];
      // update workspace
      w[i] = mark;
      x[i] = values[k];
    }
  };
  
  return algorithm07;
}

exports.name = 'algorithm07';
exports.factory = factory;

},{"../../../error/DimensionError":15}],336:[function(require,module,exports){
'use strict';

var DimensionError = require('../../../error/DimensionError');

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix A and invokes the callback function f(Aij, Bij). 
   * Callback function invoked NZA times, number of nonzero elements in A.
   *
   *
   *            f(Aij, Bij)  ; A(i,j) !== 0
   * C(i,j) =   
   *            0            ; otherwise
   *
   *
   * @param {Matrix}   a                 The SparseMatrix instance (A)
   * @param {Matrix}   b                 The SparseMatrix instance (B)
   * @param {Function} callback          The f(Aij,Bij) operation to invoke
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
   */
  var algorithm09 = function (a, b, callback) {
    // sparse matrix arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // sparse matrix arrays
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // check rows & columns
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1])
      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = avalues && bvalues ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = cvalues ? [] : undefined;
    // marks indicating we have a value in x for a given column
    var w = [];

    // vars
    var i, j, k, k0, k1;
    
    // loop columns
    for (j = 0; j < columns; j++) {
      // update cptr
      cptr[j] = cindex.length;
      // column mark
      var mark = j + 1;
      // check we need to process values
      if (x) {
        // loop B(:,j)
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k];
          // update workspace
          w[i] = mark;
          x[i] = bvalues[k];
        }
      }
      // loop A(:,j)
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        i = aindex[k];
        // check we need to process values
        if (x) {
          // b value @ i,j
          var vb = w[i] === mark ? x[i] : zero;
          // invoke f
          var vc = cf(avalues[k], vb);
          // check zero value
          if (!eq(vc, zero)) {
            // push index
            cindex.push(i);
            // push value
            cvalues.push(vc);
          }
        }
        else {
          // push index
          cindex.push(i);
        }
      }
    }
    // update cptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm09;
}

exports.name = 'algorithm09';
exports.factory = factory;

},{"../../../error/DimensionError":15,"../../../function/relational/equalScalar":288}],337:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b). 
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *            f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) =   
   *            b          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */
  var algorithm10 = function (s, b, callback, inverse) {
    // sparse matrix arrays
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;

    // sparse matrix cannot be a Pattern matrix
    if (!avalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cdata = [];
    // matrix
    var c = new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns
    for (var j = 0; j < columns; j++) {
      // columns mark
      var mark = j + 1;
      // values in j
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        var r = aindex[k];
        // update workspace
        x[r] = avalues[k];
        w[r] = mark;
      }
      // loop rows
      for (var i = 0; i < rows; i++) {
        // initialize C on first column
        if (j === 0) {
          // create row array
          cdata[i] = [];
        }
        // check sparse matrix has a value @ i,j
        if (w[i] === mark) {
          // invoke callback, update C
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        }
        else {
          // dense matrix value @ i, j
          cdata[i][j] = b;
        }
      }
    }

    // return sparse matrix
    return c;
  };

  return algorithm10;
}

exports.name = 'algorithm10';
exports.factory = factory;

},{}],338:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var equalScalar = load(require('../../../function/relational/equalScalar'));

  var SparseMatrix = type.SparseMatrix;

  /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b). 
   * Callback function invoked NZ times (number of nonzero items in S).
   *
   *
   *            f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) =   
   *            0          ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    SparseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */
  var algorithm11 = function (s, b, callback, inverse) {
    // sparse matrix arrays
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;

    // sparse matrix cannot be a Pattern matrix
    if (!avalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // find signature that matches (dt, dt)
      eq = typed.find(equalScalar, [dt, dt]);
      // convert 0 to the same datatype
      zero = typed.convert(0, dt);
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // result arrays
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    // matrix
    var c = new SparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });

    // loop columns
    for (var j = 0; j < columns; j++) {
      // initialize ptr
      cptr[j] = cindex.length;
      // values in j
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        var i = aindex[k];
        // invoke callback
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        // check value is zero
        if (!eq(v, zero)) {
          // push index & value
          cindex.push(i);
          cvalues.push(v);
        }
      }
    }
    // update ptr
    cptr[columns] = cindex.length;

    // return sparse matrix
    return c;
  };

  return algorithm11;
}

exports.name = 'algorithm11';
exports.factory = factory;

},{"../../../function/relational/equalScalar":288}],339:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b). 
   * Callback function invoked MxN times.
   *
   *
   *            f(Sij, b)  ; S(i,j) !== 0
   * C(i,j) =   
   *            f(0, b)    ; otherwise
   *
   *
   * @param {Matrix}   s                 The SparseMatrix instance (S)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
   */
  var algorithm12 = function (s, b, callback, inverse) {
    // sparse matrix arrays
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;

    // sparse matrix cannot be a Pattern matrix
    if (!avalues)
      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');

    // rows & columns
    var rows = asize[0];
    var columns = asize[1];

    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }
    
    // result arrays
    var cdata = [];
    // matrix
    var c = new DenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });

    // workspaces
    var x = [];
    // marks indicating we have a value in x for a given column
    var w = [];

    // loop columns
    for (var j = 0; j < columns; j++) {
      // columns mark
      var mark = j + 1;
      // values in j
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        // row
        var r = aindex[k];
        // update workspace
        x[r] = avalues[k];
        w[r] = mark;
      }
      // loop rows
      for (var i = 0; i < rows; i++) {
        // initialize C on first column
        if (j === 0) {
          // create row array
          cdata[i] = [];
        }
        // check sparse matrix has a value @ i,j
        if (w[i] === mark) {
          // invoke callback, update C
          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
        }
        else {
          // dense matrix value @ i, j
          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }

    // return sparse matrix
    return c;
  };
  
  return algorithm12;
}

exports.name = 'algorithm12';
exports.factory = factory;

},{}],340:[function(require,module,exports){
'use strict';

var util = require('../../../utils/index');
var DimensionError = require('../../../error/DimensionError');

var string = util.string,
    isString = string.isString;

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z). 
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, Bij..z)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Matrix}   b                 The DenseMatrix instance (B)
   * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
   */
  var algorithm13 = function (a, b, callback) {
    // a arrays
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    // b arrays
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    // c arrays
    var csize = [];

    // validate dimensions
    if (asize.length !== bsize.length)
      throw new DimensionError(asize.length, bsize.length);

    // validate each one of the dimension sizes
    for (var s = 0; s < asize.length; s++) {
      // must match
      if (asize[s] !== bsize[s])
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      // update dimension in c
      csize[s] = asize[s];
    }

    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string' && adt === bdt) {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }

    // populate cdata, iterate through dimensions
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    
    // c matrix
    return new DenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  
  // recursive function
  var _iterate = function (f, level, s, n, av, bv) {
    // initialize array for this level
    var cv = [];
    // check we reach the last level
    if (level === s.length - 1) {
      // loop arrays in last level
      for (var i = 0; i < n; i++) {
        // invoke callback and store value
        cv[i] = f(av[i], bv[i]);
      }
    }
    else {
      // iterate current level
      for (var j = 0; j < n; j++) {
        // iterate next level
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  };
  
  return algorithm13;
}

exports.name = 'algorithm13';
exports.factory = factory;

},{"../../../error/DimensionError":15,"../../../utils/index":359}],341:[function(require,module,exports){
'use strict';

var clone = require('../../../utils/object').clone;

function factory (type, config, load, typed) {

  var DenseMatrix = type.DenseMatrix;

  /**
   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b). 
   * Callback function invoked MxN times.
   *
   * C(i,j,...z) = f(Aij..z, b)
   *
   * @param {Matrix}   a                 The DenseMatrix instance (A)
   * @param {Scalar}   b                 The Scalar value
   * @param {Function} callback          The f(Aij..z,b) operation to invoke
   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
   *
   * @return {Matrix}                    DenseMatrix (C)
   *
   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
   */
  var algorithm14 = function (a, b, callback, inverse) {
    // a arrays
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    
    // datatype
    var dt;
    // callback signature to use
    var cf = callback;

    // process data types
    if (typeof adt === 'string') {
      // datatype
      dt = adt;
      // convert b to the same datatype
      b = typed.convert(b, dt);
      // callback
      cf = typed.find(callback, [dt, dt]);
    }
    
    // populate cdata, iterate through dimensions
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];

    // c matrix
    return new DenseMatrix({
      data: cdata,
      size: clone(asize),
      datatype: dt
    });
  };
  
  // recursive function
  var _iterate = function (f, level, s, n, av, bv, inverse) {
    // initialize array for this level
    var cv = [];
    // check we reach the last level
    if (level === s.length - 1) {
      // loop arrays in last level
      for (var i = 0; i < n; i++) {
        // invoke callback and store value
        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
      }
    }
    else {
      // iterate current level
      for (var j = 0; j < n; j++) {
        // iterate next level
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  };

  return algorithm14;
}

exports.name = 'algorithm14';
exports.factory = factory;

},{"../../../utils/object":362}],342:[function(require,module,exports){
'use strict';

var deepMap = require('./../utils/collection/deepMap');

function factory (type, config, load, typed) {
  /**
   * Create a number or convert a string, boolean, or unit to a number.
   * When value is a matrix, all elements will be converted to number.
   *
   * Syntax:
   *
   *    math.number(value)
   *    math.number(unit, valuelessUnit)
   *
   * Examples:
   *
   *    math.number(2);                         // returns number 2
   *    math.number('7.2');                     // returns number 7.2
   *    math.number(true);                      // returns number 1
   *    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
   *    math.number(math.unit('52cm'), 'm');    // returns 0.52
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, string, unit
   *
   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
   * @return {number | Array | Matrix} The created number
   */
  var number = typed('number', {
    '': function () {
      return 0;
    },

    'number': function (x) {
      return x;
    },

    'string': function (x) {
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is no valid number');
      }
      return num;
    },

    'BigNumber': function (x) {
      return x.toNumber();
    },

    'Fraction': function (x) {
      return x.valueOf();
    },

    'Unit': function (x) {
      throw new Error('Second argument with valueless unit expected');
    },

    'Unit, string | Unit': function (unit, valuelessUnit) {
      return unit.toNumber(valuelessUnit);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, number);
    }
  });

  number.toTex = {
    0: '0',
    1: '\\left(${args[0]}\\right)',
    2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
  };

  return number;
}

exports.name = 'number';
exports.factory = factory;

},{"./../utils/collection/deepMap":353}],343:[function(require,module,exports){
'use strict';

function factory (type, config, load, typed) {
  /**
   * A ResultSet contains a list or results
   * @class ResultSet
   * @param {Array} entries
   * @constructor ResultSet
   */
  function ResultSet(entries) {
    if (!(this instanceof ResultSet)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.entries = entries || [];
  }

  /**
   * Attach type information
   */
  ResultSet.prototype.type = 'ResultSet';
  ResultSet.prototype.isResultSet = true;

  /**
   * Returns the array with results hold by this ResultSet
   * @memberof ResultSet
   * @returns {Array} entries
   */
  ResultSet.prototype.valueOf = function () {
    return this.entries;
  };

  /**
   * Returns the stringified results of the ResultSet
   * @memberof ResultSet
   * @returns {string} string
   */
  ResultSet.prototype.toString = function () {
    return '[' + this.entries.join(', ') + ']';
  };

  /**
   * Get a JSON representation of the ResultSet
   * @memberof ResultSet
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "ResultSet", "entries": [...]}`
   */
  ResultSet.prototype.toJSON = function () {
    return {
      mathjs: 'ResultSet',
      entries: this.entries
    };
  };

  /**
   * Instantiate a ResultSet from a JSON object
   * @memberof ResultSet
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "ResultSet", "entries": [...]}`
   * @return {ResultSet}
   */
  ResultSet.fromJSON = function (json) {
    return new ResultSet(json.entries);
  };

  return ResultSet;
}

exports.name = 'ResultSet';
exports.path = 'type';
exports.factory = factory;

},{}],344:[function(require,module,exports){
'use strict';

var endsWith = require('../../utils/string').endsWith;
var clone = require('../../utils/object').clone;
var constants = require('../../utils/bignumber/constants');

function factory (type, config, load, typed, math) {
  var add       = load(require('../../function/arithmetic/addScalar'));
  var subtract  = load(require('../../function/arithmetic/subtract'));
  var multiply  = load(require('../../function/arithmetic/multiplyScalar'));
  var divide    = load(require('../../function/arithmetic/divideScalar'));
  var pow       = load(require('../../function/arithmetic/pow'));
  var abs       = load(require('../../function/arithmetic/abs'));
  var fix       = load(require('../../function/arithmetic/fix'));
  var equal     = load(require('../../function/relational/equal'));
  var isNumeric = load(require('../../function/utils/isNumeric'));
  var format    = load(require('../../function/string/format'));
  var getTypeOf = load(require('../../function/utils/typeof'));
  var toNumber  = load(require('../../type/number'));
  var Complex   = load(require('../../type/complex/Complex'));

  /**
   * A unit can be constructed in the following ways:
   *     var a = new Unit(value, name);
   *     var b = new Unit(null, name);
   *     var c = Unit.parse(str);
   *
   * Example usage:
   *     var a = new Unit(5, 'cm');               // 50 mm
   *     var b = Unit.parse('23 kg');             // 23 kg
   *     var c = math.in(a, new Unit(null, 'm');  // 0.05 m
   *     var d = new Unit(9.81, "m/s^2");         // 9.81 m/s^2
   *
   * @class Unit
   * @constructor Unit
   * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
   * @param {string} [name]   A unit name like "cm" or "inch", or a derived unit of the form: "u1[^ex1] [u2[^ex2] ...] [/ u3[^ex3] [u4[^ex4]]]", such as "kg m^2/s^2", where each unit appearing after the forward slash is taken to be in the denominator. "kg m^2 s^-2" is a synonym and is also acceptable. Any of the units can include a prefix.
   */
  function Unit(value, name) {
    if (!(this instanceof Unit)) {
      throw new Error('Constructor must be called with the new operator');
    }

    if (!(value === undefined || isNumeric(value) || value.isComplex)) {
      throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
    }
    if (name != undefined && (typeof name !== 'string' || name == '')) {
      throw new TypeError('Second parameter in Unit constructor must be a string');
    }

    if (name != undefined) {
      var u = Unit.parse(name);
      this.units = u.units;
      this.dimensions = u.dimensions;
    }
    else {
      this.units = [
        {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE,  // link to a list with supported prefixes
          power: 0
        }
      ];
      this.dimensions = []; 
      for(var i=0; i<BASE_DIMENSIONS.length; i++) {
        this.dimensions[i] = 0;
      }
    }

    this.value = (value != undefined) ? this._normalize(value) : null;

    this.fixPrefix = false; // if true, function format will not search for the
                            // best prefix but leave it as initially provided.
                            // fixPrefix is set true by the method Unit.to

    // The justification behind this is that if the constructor is explicitly called,
    // the caller wishes the units to be returned exactly as he supplied.
    this.isUnitListSimplified = true;

  }

  /**
   * Attach type information
   */
  Unit.prototype.type = 'Unit';
  Unit.prototype.isUnit = true;

  // private variables and functions for the Unit parser
  var text, index, c;

  function skipWhitespace() {
    while (c == ' ' || c == '\t') {
      next();
    }
  }

  function isDigitDot(c) {
    return ((c >= '0' && c <= '9') || c == '.');
  }

  function isDigit(c) {
    return ((c >= '0' && c <= '9'));
  }

  function next() {
    index++;
    c = text.charAt(index);
  }

  function revert(oldIndex) {
    index = oldIndex;
    c = text.charAt(index);
  }

  function parseNumber() {
    var number = '';
    var oldIndex;
    oldIndex = index;

    if (c == '+') {
      next();
    }
    else if (c == '-') {
      number += c;
      next();
    }

    if (!isDigitDot(c)) {
      // a + or - must be followed by a digit
      revert(oldIndex);
      return null;
    }

    // get number, can have a single dot
    if (c == '.') {
      number += c;
      next();
      if (!isDigit(c)) {
        // this is no legal number, it is just a dot
        revert(oldIndex);
        return null;
      }
    }
    else {
      while (isDigit(c)) {
        number += c;
        next();
      }
      if (c == '.') {
        number += c;
        next();
      }
    }
    while (isDigit(c)) {
      number += c;
      next();
    }

    // check for exponential notation like "2.3e-4" or "1.23e50"
    if (c == 'E' || c == 'e') {
      // The grammar branches here. This could either be part of an exponent or the start of a unit that begins with the letter e, such as "4exabytes"

      var tentativeNumber = '';
      var tentativeIndex = index;

      tentativeNumber += c;
      next();

      if (c == '+' || c == '-') {
        tentativeNumber += c;
        next();
      }

      // Scientific notation MUST be followed by an exponent (otherwise we assume it is not scientific notation)
      if (!isDigit(c)) {
        // The e or E must belong to something else, so return the number without the e or E.
        revert(tentativeIndex);
        return number;
      }
      
      // We can now safely say that this is scientific notation.
      number = number + tentativeNumber;
      while (isDigit(c)) {
        number += c;
        next();
      }
    }

    return number;
  }

  function parseUnit() {
    var unitName = '';

    // Alphanumeric characters only; matches [a-zA-Z0-9]
    var code = text.charCodeAt(index);
    while ( (code >= 48 && code <= 57) ||
            (code >= 65 && code <= 90) ||
            (code >= 97 && code <= 122)) {
      unitName += c;
      next();
      code = text.charCodeAt(index);
    }

    // Must begin with [a-zA-Z]
    code = unitName.charCodeAt(0);
    if ((code >= 65 && code <= 90) ||
        (code >= 97 && code <= 122)) {
        return unitName || null;
    } 
    else {
      return null;
    }
  }

  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    }
    else {
      return null;
    }
  }

  /**
   * Parse a string into a unit. The value of the unit is parsed as number,
   * BigNumber, or Fraction depending on the math.js config setting `number`.
   *
   * Throws an exception if the provided string does not contain a valid unit or
   * cannot be parsed.
   * @memberof Unit
   * @param {string} str        A string like "5.2 inch", "4e2 cm/s^2"
   * @return {Unit} unit
   */
  Unit.parse = function (str, options) {
    options = options || {};
    text = str;
    index = -1;
    c = '';

    if (typeof text !== 'string') {
      throw new TypeError('Invalid argument in Unit.parse, string expected');
    }

    var unit = new Unit();
    unit.units = [];

    // A unit should follow this pattern:
    // [number]unit[^number] [unit[^number]]...[/unit[^number] [unit[^number]]]

    // Rules:
    // number is any floating point number.
    // unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like the exponent of a floating point number!
    // The string may optionally begin with a number.
    // Each unit may optionally be followed by ^number.
    // Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
    //   2m^2kg/s^2
    // it is not good form. If a unit starts with e, then it could be confused as a floating point number:
    //   4erg

    next();
    skipWhitespace();
    // Optional number at the start of the string
    var valueStr = parseNumber();
    var value = null;
    if(valueStr) {
      if (config.number === 'BigNumber') {
        value = new type.BigNumber(valueStr);
      }
      else if (config.number === 'Fraction') {
        value = new type.Fraction(valueStr);
      }
      else { // number
        value = parseFloat(valueStr);
      }
    }
    skipWhitespace();    // Whitespace is not required here

    // Next, we read any number of unit[^number]
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;

    // Stack to keep track of powerMultipliers applied to each parentheses group
    var powerMultiplierStack = [];

    // Running product of all elements in powerMultiplierStack
    var powerMultiplierStackProduct = 1;

    while (true) {
      skipWhitespace();

      // Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
      // A '(' will always appear directly before a unit.
      while (c === '(') {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }

      // Is there something here?
      if(c) {
        var oldC = c;
        var uStr = parseUnit();
        if(uStr == null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
        }
      }
      else {
        // End of input.
        break;
      }

      // Verify the unit exists and get the prefix (if any)
      var res = _findUnit(uStr);
      if(res == null) {
        // Unit not found.
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }

      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      // Is there a "^ number"?
      skipWhitespace();
      if (parseCharacter('^')) {
        skipWhitespace();
        var p = parseNumber();
        if(p == null) {
          // No valid number found for the power!
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }

      // Add the unit to the list
      unit.units.push( {
        unit: res.unit,
        prefix: res.prefix,
        power: power
      });
      for(var i=0; i<BASE_DIMENSIONS.length; i++) {
        unit.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
      }

      // Check for and consume closing parentheses, popping from the stack.
      // A ')' will always follow a unit.
      skipWhitespace();
      while (c === ')') {
        if(powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }

      // "*" and "/" should mean we are expecting something to come next.
      // Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.
      expectingUnit = false;

      if (parseCharacter('*')) {
        // explicit multiplication
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      }
      else if (parseCharacter('/')) {
        // division
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
      else {
        // implicit multiplication
        powerMultiplierCurrent = 1;
      }

      // Replace the unit into the auto unit system
      if(res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    
    // Has the string been entirely consumed?
    skipWhitespace();
    if(c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }

    // Is there a trailing slash?
    if(expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }

    // Is the parentheses stack empty?
    if(powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }

    // Are there any units at all?
    if(unit.units.length == 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }

    unit.value = (value != undefined) ? unit._normalize(value) : null;
    return unit;
  };

  /**
   * create a copy of this unit
   * @memberof Unit
   * @return {Unit} Returns a cloned version of the unit
   */
  Unit.prototype.clone = function () {
    var unit = new Unit();

    unit.fixPrefix = this.fixPrefix;
    unit.isUnitListSimplified = this.isUnitListSimplified;

    unit.value = clone(this.value);
    unit.dimensions = this.dimensions.slice(0);
    unit.units = [];
    for(var i = 0; i < this.units.length; i++) {
      unit.units[i] = { };
      for (var p in this.units[i]) {
        if (this.units[i].hasOwnProperty(p)) {
          unit.units[i][p] = this.units[i][p];
        }
      }
    }

    return unit;
  };

  /**
   * Return whether the unit is derived (such as m/s, or cm^2, but not N)
   * @memberof Unit
   * @return {boolean} True if the unit is derived
   */
  Unit.prototype._isDerived = function() {
    if(this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1.0) > 1e-15;
  };

  /**
   * Normalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number | BigNumber | Fraction | boolean} value
   * @return {number | BigNumber | Fraction | boolean} normalized value
   * @private
   */
  Unit.prototype._normalize = function (value) {
    var unitValue, unitOffset, unitPower, unitPrefixValue;
    var convert;

    if (value == null || this.units.length === 0) {
      return value;
    }
    else if (this._isDerived()) {
      // This is a derived unit, so do not apply offsets.
      // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
      var res = value;
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      for(var i=0; i < this.units.length; i++) {
        unitValue       = convert(this.units[i].unit.value);
        unitPrefixValue = convert(this.units[i].prefix.value);
        unitPower       = convert(this.units[i].power);
        res = multiply(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
      }

      return res;
    }
    else {
      // This is a single unit of power 1, like kg or degC
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      unitValue       = convert(this.units[0].unit.value);
      unitOffset      = convert(this.units[0].unit.offset);
      unitPrefixValue = convert(this.units[0].prefix.value);

      return multiply(add(value, unitOffset), multiply(unitValue, unitPrefixValue));
    }
  };

  /**
   * Denormalize a value, based on its currently set unit(s)
   * @memberof Unit
   * @param {number} value
   * @param {number} [prefixValue]    Optional prefix value to be used (ignored if this is a derived unit)
   * @return {number} denormalized value
   * @private
   */
  Unit.prototype._denormalize = function (value, prefixValue) {
    var unitValue, unitOffset, unitPower, unitPrefixValue;
    var convert;

    if (value == null || this.units.length === 0) {
      return value;
    }
    else if (this._isDerived()) {
      // This is a derived unit, so do not apply offsets.
      // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
      // Also, prefixValue is ignored--but we will still use the prefix value stored in each unit, since kg is usually preferable to g unless the user decides otherwise.
      var res = value;
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      for (var i = 0; i < this.units.length; i++) {
        unitValue       = convert(this.units[i].unit.value);
        unitPrefixValue = convert(this.units[i].prefix.value);
        unitPower       = convert(this.units[i].power);
        res = divide(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
      }

      return res;
    }
    else {
      // This is a single unit of power 1, like kg or degC
      convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

      unitValue       = convert(this.units[0].unit.value);
      unitPrefixValue = convert(this.units[0].prefix.value);
      unitOffset      = convert(this.units[0].unit.offset);

      if (prefixValue == undefined) {
        return subtract(divide(divide(value, unitValue), unitPrefixValue), unitOffset);
      }
      else {
        return subtract(divide(divide(value, unitValue), prefixValue), unitOffset);
      }
    }
  };

  /**
   * Find a unit from a string
   * @memberof Unit
   * @param {string} str              A string like 'cm' or 'inch'
   * @returns {Object | null} result  When found, an object with fields unit and
   *                                  prefix is returned. Else, null is returned.
   * @private
   */
  function _findUnit(str) {
  
    // First, match units names exactly. For example, a user could define 'mm' as 10^-4 m, which is silly, but then we would want 'mm' to match the user-defined unit.
    if(UNITS.hasOwnProperty(str)) {
      var unit = UNITS[str];
      var prefix = unit.prefixes[''];
      return {
        unit: unit,
        prefix: prefix
      }
    }

    for (var name in UNITS) {
      if (UNITS.hasOwnProperty(name)) {
        if (endsWith(str, name)) {
          var unit = UNITS[name];
          var prefixLen = (str.length - name.length);
          var prefixName = str.substring(0, prefixLen);
          var prefix = unit.prefixes[prefixName];
          if (prefix !== undefined) {
            // store unit, prefix, and value
            return {
              unit: unit,
              prefix: prefix
            };
          }
        }
      }
    }

    return null;
  }

  /**
   * Test if the given expression is a unit.
   * The unit can have a prefix but cannot have a value.
   * @memberof Unit
   * @param {string} name   A string to be tested whether it is a value less unit.
   *                        The unit can have prefix, like "cm"
   * @return {boolean}      true if the given string is a unit
   */
  Unit.isValuelessUnit = function (name) {
    return (_findUnit(name) != null);
  };

  /**
   * check if this unit has given base unit
   * If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.
   * @memberof Unit
   * @param {BASE_UNITS | string | undefined} base
   */
  Unit.prototype.hasBase = function (base) {

    if(typeof(base) === "string") {
      base = BASE_UNITS[base];
    }

    if(!base)
      return false;


    // All dimensions must be the same
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;

  };

  /**
   * Check if this unit has a base or bases equal to another base or bases
   * For derived units, the exponent on each base also must match
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if equal base
   */
  Unit.prototype.equalBase = function (other) {
    // All dimensions must be the same
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };

  /**
   * Check if this unit equals another unit
   * @memberof Unit
   * @param {Unit} other
   * @return {boolean} true if both units are equal
   */
  Unit.prototype.equals = function (other) {
    return (this.equalBase(other) && equal(this.value, other.value));
  };

  /**
   * Multiply this unit with another one
   * @memberof Unit
   * @param {Unit} other
   * @return {Unit} product of this unit and the other unit
   */
  Unit.prototype.multiply = function (other) {
    var res = this.clone();
    
    for(var i = 0; i<BASE_DIMENSIONS.length; i++) {
      // Dimensions arrays may be of different lengths. Default to 0.
      res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
    }

    // Append other's units list onto res (simplify later in Unit.prototype.format)
    for(var i=0; i<other.units.length; i++) {
      // Make a deep copy
      var inverted = {};
      for(var key in other.units[i]) {
        inverted[key] = other.units[i][key];
      }
      res.units.push(inverted);
    }

    // If at least one operand has a value, then the result should also have a value
    if(this.value != null || other.value != null) {
      var valThis = this.value == null ? this._normalize(1) : this.value;
      var valOther = other.value == null ? other._normalize(1) : other.value;
      res.value = multiply(valThis, valOther);
    }
    else {
      res.value = null;
    }

    // Trigger simplification of the unit list at some future time
    res.isUnitListSimplified = false;

    return getNumericIfUnitless(res);
  };

  /**
   * Divide this unit by another one
   * @memberof Unit
   * @param {Unit} other
   * @return {Unit} result of dividing this unit by the other unit
   */
  Unit.prototype.divide = function (other) {
    var res = this.clone();
    
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      // Dimensions arrays may be of different lengths. Default to 0.
      res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
    }

    // Invert and append other's units list onto res (simplify later in Unit.prototype.format)
    for(var i=0; i<other.units.length; i++) {
      // Make a deep copy
      var inverted = {};
      for(var key in other.units[i]) {
        inverted[key] = other.units[i][key];
      }
      inverted.power = -inverted.power;
      res.units.push(inverted);
    }

    // If at least one operand has a value, the result should have a value
    if (this.value != null || other.value != null) {
      var valThis = this.value == null ? this._normalize(1) : this.value;
      var valOther = other.value == null ? other._normalize(1) : other.value;
      res.value = divide(valThis, valOther);
    }
    else {
      res.value = null;
    }

    // Trigger simplification of the unit list at some future time
    res.isUnitListSimplified = false;

    return getNumericIfUnitless(res);
  };

  /**
   * Calculate the power of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} p
   * @returns {Unit}      The result: this^p
   */
  Unit.prototype.pow = function (p) {
    var res = this.clone();
    
    for(var i=0; i<BASE_DIMENSIONS.length; i++) {
      // Dimensions arrays may be of different lengths. Default to 0.
      res.dimensions[i] = (this.dimensions[i] || 0) * p;
    }

    // Adjust the power of each unit in the list
    for(var i=0; i<res.units.length; i++) {
      res.units[i].power *= p;
    }

    if(res.value != null) {
      res.value = pow(res.value, p);

      // only allow numeric output, we don't want to return a Complex number
      //if (!isNumeric(res.value)) {
      //  res.value = NaN;
      //}
      // Update: Complex supported now
    }
    else {
      res.value = null;
    }

    // Trigger lazy evaluation of the unit list
    res.isUnitListSimplified = false;

    return getNumericIfUnitless(res);
  };

  /**
   * Return the numeric value of this unit if it is dimensionless, has a value, and config.predictable == false; or the original unit otherwise
   * @param {Unit} unit
   * @returns {number | Fraction | BigNumber | Unit}  The numeric value of the unit if conditions are met, or the original unit otherwise
   */
  var getNumericIfUnitless = function(unit) {
    if(unit.equalBase(BASE_UNITS.NONE) && unit.value !== null && !config.predictable) {
      return unit.value;
    }
    else {
      return unit;
    }
  }
    

  /**
   * Calculate the absolute value of a unit
   * @memberof Unit
   * @param {number | Fraction | BigNumber} x
   * @returns {Unit}      The result: |x|, absolute value of x
   */
  Unit.prototype.abs = function () {
    // This gives correct, but unexpected, results for units with an offset.
    // For example, abs(-283.15 degC) = -263.15 degC !!!
    var ret = this.clone();
    ret.value = abs(ret.value);

    for(var i in ret.units) {
      if(ret.units[i].unit.name === 'VA' || ret.units[i].unit.name === 'VAR') {
        ret.units[i].unit = UNITS["W"];
      }
    }

    return ret;
  };

  /**
   * Convert the unit to a specific unit name.
   * @memberof Unit
   * @param {string | Unit} valuelessUnit   A unit without value. Can have prefix, like "cm"
   * @returns {Unit} Returns a clone of the unit with a fixed prefix and unit.
   */
  Unit.prototype.to = function (valuelessUnit) {
    var other;
    var value = this.value == null ? this._normalize(1) : this.value;
    if (typeof valuelessUnit === 'string') {
      //other = new Unit(null, valuelessUnit);
      other = Unit.parse(valuelessUnit);
      if (!this.equalBase(other)) {
        throw new Error('Units do not match');
      }
      if (other.value !== null) {
        throw new Error('Cannot convert to a unit with a value');
      }

      other.value = clone(value);
      other.fixPrefix = true;
      other.isUnitListSimplified = true;
      return other;
    }
    else if (valuelessUnit && valuelessUnit.isUnit) {
      if (!this.equalBase(valuelessUnit)) {
        throw new Error('Units do not match');
      }
      if (valuelessUnit.value !== null) {
        throw new Error('Cannot convert to a unit with a value');
      }
      other = valuelessUnit.clone();
      other.value = clone(value);
      other.fixPrefix = true;
      other.isUnitListSimplified = true;
      return other;
    }
    else {
      throw new Error('String or Unit expected as parameter');
    }
  };

  /**
   * Return the value of the unit when represented with given valueless unit
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number} Returns the unit value as number.
   */
  // TODO: deprecate Unit.toNumber? It's always better to use toNumeric
  Unit.prototype.toNumber = function (valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };

  /**
   * Return the value of the unit in the original numeric type
   * @memberof Unit
   * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
   * @return {number | BigNumber | Fraction} Returns the unit value
   */
  Unit.prototype.toNumeric = function (valuelessUnit) {
    var other = this;
    if(valuelessUnit) {
      // Allow getting the numeric value without converting to a different unit
      other = this.to(valuelessUnit);
    }

    if(other._isDerived()) {
      return other._denormalize(other.value);
    }
    else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };

  /**
   * Get a string representation of the unit.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.toString = function () {
    return this.format();
  };

  /**
   * Get a JSON representation of the unit
   * @memberof Unit
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   */
  Unit.prototype.toJSON = function () {
    return {
      mathjs: 'Unit',
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };

  /**
   * Instantiate a Unit from a JSON object
   * @memberof Unit
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}`
   * @return {Unit}
   */
  Unit.fromJSON = function (json) {
    var unit = new Unit(json.value, json.unit);
    unit.fixPrefix = json.fixPrefix || false;
    return unit;
  };

  /**
   * Returns the string representation of the unit.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.valueOf = Unit.prototype.toString;

  /**
   * Attempt to simplify the list of units for this unit according to the dimensions array and the current unit system. After the call, this Unit will contain a list of the "best" units for formatting.
   * Intended to be evaluated lazily. You must set isUnitListSimplified = false before the call! After the call, isUnitListSimplified will be set to true.
   */
  Unit.prototype.simplifyUnitListLazy = function() {

    if (this.isUnitListSimplified || this.value == null) {
      return;
    }

    var proposedUnitList = [];

    // Search for a matching base
    var matchingBase;
    for(var key in currentUnitSystem) {
      if(this.hasBase(BASE_UNITS[key])) {
        matchingBase = key;
        break;
      }
    }

    if(matchingBase === 'NONE')
    {
      this.units = [];
    }
    else {
      var matchingUnit;
      if(matchingBase) {
        // Does the unit system have a matching unit?
        if(currentUnitSystem.hasOwnProperty(matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      var value;
      var str;
      if(matchingUnit) {
        this.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1.0
        }];
      }
      else {
        // Multiple units or units with powers are formatted like this:
        // 5 (kg m^2) / (s^3 mol)
        // Build an representation from the base units of the current unit system
        var missingBaseDim = false;
        for(var i=0; i<BASE_DIMENSIONS.length; i++) {
          var baseDim = BASE_DIMENSIONS[i];
          if(Math.abs(this.dimensions[i] || 0) > 1e-12) {
            if(currentUnitSystem.hasOwnProperty(baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: this.dimensions[i] || 0
              });
            }
            else {
              missingBaseDim = true;
            }
          }
        }
        var util = require('util');

        // Is the proposed unit list "simpler" than the existing one?
        if(proposedUnitList.length < this.units.length && !missingBaseDim) {
          // Replace this unit list with the proposed list
          this.units = proposedUnitList;
        }
      }
    }

    this.isUnitListSimplified = true;
  };

  /**
   * Get a string representation of the units of this Unit, without the value.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.formatUnits = function () {

    // Lazy evaluation of the unit list
    this.simplifyUnitListLazy();

    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;

    for(var i=0; i<this.units.length; i++) {
      if(this.units[i].power > 0) {
        nNum++;
        strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
        if(Math.abs(this.units[i].power - 1.0) > 1e-15) {
          strNum += "^" + this.units[i].power;
        }
      }
      else if(this.units[i].power < 0) {
        nDen++;
      }
    }

    if(nDen > 0) {
      for(var i=0; i<this.units.length; i++) {
        if(this.units[i].power < 0) {
          if(nNum > 0) {
            strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
            if(Math.abs(this.units[i].power + 1.0) > 1e-15) {
              strDen += "^" + (-this.units[i].power);
            }
          }
          else {
            strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
            strDen += "^" + (this.units[i].power);
          }
        }
      }
    }
    // Remove leading " "
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);

    // Add parans for better copy/paste back into the eval, for example, or for better pretty print formatting
    if(nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if(nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }

    var str = strNum;
    if(nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;

    return str;
  };

  /**
   * Get a string representation of the Unit, with optional formatting options.
   * @memberof Unit
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string}
   */
  Unit.prototype.format = function (options) {

    // Simplfy the unit list, if necessary
    this.simplifyUnitListLazy();

    // Apply some custom logic for handling VA and VAR. The goal is to express the value of the unit as a real value, if possible. Otherwise, use a real-valued unit instead of a complex-valued one.
    var isImaginary = false;
    var isReal = true;
    if(typeof(this.value) !== 'undefined' && this.value !== null && this.value.isComplex) {
      // TODO: Make this better, for example, use relative magnitude of re and im rather than absolute
      isImaginary = Math.abs(this.value.re) < 1e-14;
      isReal = Math.abs(this.value.im) < 1e-14;
    }
    
    for(var i in this.units) {
      if(this.units[i].unit) {
        if(this.units[i].unit.name === 'VA' && isImaginary) {
          this.units[i].unit = UNITS["VAR"];
        }
        else if(this.units[i].unit.name === 'VAR' && !isImaginary) {
          this.units[i].unit = UNITS["VA"];
        }
      }
    }


    // Now apply the best prefix
    // Units must have only one unit and not have the fixPrefix flag set
    if (this.units.length === 1 && !this.fixPrefix) {
      // Units must have integer powers, otherwise the prefix will change the
      // outputted value by not-an-integer-power-of-ten
      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) < 1e-14) {
        // Apply the best prefix
        this.units[0].prefix = this._bestPrefix();
      }
    }


    var value = this._denormalize(this.value);
    var str = (this.value !== null) ? format(value, options || {}) : '';
    var unitStr = this.formatUnits();
    if(this.value && this.value.isComplex) {
      str = "(" + str + ")";    // Surround complex values with ( ) to enable better parsing 
    }
    if(unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;

    return str;
  };

  /**
   * Calculate the best prefix using current value.
   * @memberof Unit
   * @returns {Object} prefix
   * @private
   */
  Unit.prototype._bestPrefix = function () {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }

    // find the best prefix value (resulting in the value of which
    // the absolute value of the log10 is closest to zero,
    // though with a little offset of 1.2 for nicer values: you get a
    // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...

    // Note: the units value can be any numeric type, but to find the best
    // prefix it's enough to work with limited precision of a regular number
    // Update: using mathjs abs since we also allow complex numbers
    var absValue = abs(this.value);
    var absUnitValue = abs(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if(bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix;    // Allow the original prefix
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (prefixes.hasOwnProperty(p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {

          var diff = Math.abs(
              Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);

          if (diff < bestDiff
              || (diff === bestDiff && prefix.name.length < bestPrefix.name.length)) {
                // choose the prefix with the smallest diff, or if equal, choose the one
                // with the shortest name (can happen with SHORTLONG for example)
                bestPrefix = prefix;
                bestDiff = diff;
          }
        }
      }
    }

    return bestPrefix;
  };

  /**
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units. 
   *
   *   Example:
   *
   *   var u = new Unit(1, 'm');
   *   u.splitUnit(['feet', 'inch']);
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */
  Unit.prototype.splitUnit = function(parts) {

    var x = this.clone();
    var ret = [];
    for(var i=0; i<parts.length; i++) {
      x = x.to(parts[i]);
      if(i==parts.length-1) break;
      // fix rounds a number towards 0
      var fixedVal = fix(x.toNumeric());
      var y = new Unit(fixedVal, parts[i].toString());
      ret.push(y);
      x = subtract(x, y);
    }
    ret.push(x);

    return ret;
  };

  var PREFIXES = {
    NONE: {
      '': {name: '', value: 1, scientific: true}
    },
    SHORT: {
      '': {name: '', value: 1, scientific: true},

      'da': {name: 'da', value: 1e1, scientific: false},
      'h': {name: 'h', value: 1e2, scientific: false},
      'k': {name: 'k', value: 1e3, scientific: true},
      'M': {name: 'M', value: 1e6, scientific: true},
      'G': {name: 'G', value: 1e9, scientific: true},
      'T': {name: 'T', value: 1e12, scientific: true},
      'P': {name: 'P', value: 1e15, scientific: true},
      'E': {name: 'E', value: 1e18, scientific: true},
      'Z': {name: 'Z', value: 1e21, scientific: true},
      'Y': {name: 'Y', value: 1e24, scientific: true},

      'd': {name: 'd', value: 1e-1, scientific: false},
      'c': {name: 'c', value: 1e-2, scientific: false},
      'm': {name: 'm', value: 1e-3, scientific: true},
      'u': {name: 'u', value: 1e-6, scientific: true},
      'n': {name: 'n', value: 1e-9, scientific: true},
      'p': {name: 'p', value: 1e-12, scientific: true},
      'f': {name: 'f', value: 1e-15, scientific: true},
      'a': {name: 'a', value: 1e-18, scientific: true},
      'z': {name: 'z', value: 1e-21, scientific: true},
      'y': {name: 'y', value: 1e-24, scientific: true}
    },
    LONG: {
      '': {name: '', value: 1, scientific: true},

      'deca': {name: 'deca', value: 1e1, scientific: false},
      'hecto': {name: 'hecto', value: 1e2, scientific: false},
      'kilo': {name: 'kilo', value: 1e3, scientific: true},
      'mega': {name: 'mega', value: 1e6, scientific: true},
      'giga': {name: 'giga', value: 1e9, scientific: true},
      'tera': {name: 'tera', value: 1e12, scientific: true},
      'peta': {name: 'peta', value: 1e15, scientific: true},
      'exa': {name: 'exa', value: 1e18, scientific: true},
      'zetta': {name: 'zetta', value: 1e21, scientific: true},
      'yotta': {name: 'yotta', value: 1e24, scientific: true},

      'deci': {name: 'deci', value: 1e-1, scientific: false},
      'centi': {name: 'centi', value: 1e-2, scientific: false},
      'milli': {name: 'milli', value: 1e-3, scientific: true},
      'micro': {name: 'micro', value: 1e-6, scientific: true},
      'nano': {name: 'nano', value: 1e-9, scientific: true},
      'pico': {name: 'pico', value: 1e-12, scientific: true},
      'femto': {name: 'femto', value: 1e-15, scientific: true},
      'atto': {name: 'atto', value: 1e-18, scientific: true},
      'zepto': {name: 'zepto', value: 1e-21, scientific: true},
      'yocto': {name: 'yocto', value: 1e-24, scientific: true}
    },
    SQUARED: {
      '': {name: '', value: 1, scientific: true},

      'da': {name: 'da', value: 1e2, scientific: false},
      'h': {name: 'h', value: 1e4, scientific: false},
      'k': {name: 'k', value: 1e6, scientific: true},
      'M': {name: 'M', value: 1e12, scientific: true},
      'G': {name: 'G', value: 1e18, scientific: true},
      'T': {name: 'T', value: 1e24, scientific: true},
      'P': {name: 'P', value: 1e30, scientific: true},
      'E': {name: 'E', value: 1e36, scientific: true},
      'Z': {name: 'Z', value: 1e42, scientific: true},
      'Y': {name: 'Y', value: 1e48, scientific: true},

      'd': {name: 'd', value: 1e-2, scientific: false},
      'c': {name: 'c', value: 1e-4, scientific: false},
      'm': {name: 'm', value: 1e-6, scientific: true},
      'u': {name: 'u', value: 1e-12, scientific: true},
      'n': {name: 'n', value: 1e-18, scientific: true},
      'p': {name: 'p', value: 1e-24, scientific: true},
      'f': {name: 'f', value: 1e-30, scientific: true},
      'a': {name: 'a', value: 1e-36, scientific: true},
      'z': {name: 'z', value: 1e-42, scientific: true},
      'y': {name: 'y', value: 1e-48, scientific: true}
    },
    CUBIC: {
      '': {name: '', value: 1, scientific: true},

      'da': {name: 'da', value: 1e3, scientific: false},
      'h': {name: 'h', value: 1e6, scientific: false},
      'k': {name: 'k', value: 1e9, scientific: true},
      'M': {name: 'M', value: 1e18, scientific: true},
      'G': {name: 'G', value: 1e27, scientific: true},
      'T': {name: 'T', value: 1e36, scientific: true},
      'P': {name: 'P', value: 1e45, scientific: true},
      'E': {name: 'E', value: 1e54, scientific: true},
      'Z': {name: 'Z', value: 1e63, scientific: true},
      'Y': {name: 'Y', value: 1e72, scientific: true},

      'd': {name: 'd', value: 1e-3, scientific: false},
      'c': {name: 'c', value: 1e-6, scientific: false},
      'm': {name: 'm', value: 1e-9, scientific: true},
      'u': {name: 'u', value: 1e-18, scientific: true},
      'n': {name: 'n', value: 1e-27, scientific: true},
      'p': {name: 'p', value: 1e-36, scientific: true},
      'f': {name: 'f', value: 1e-45, scientific: true},
      'a': {name: 'a', value: 1e-54, scientific: true},
      'z': {name: 'z', value: 1e-63, scientific: true},
      'y': {name: 'y', value: 1e-72, scientific: true}
    },
    BINARY_SHORT: {
      '': {name: '', value: 1, scientific: true},
      'k': {name: 'k', value: 1e3, scientific: true},
      'M': {name: 'M', value: 1e6, scientific: true},
      'G': {name: 'G', value: 1e9, scientific: true},
      'T': {name: 'T', value: 1e12, scientific: true},
      'P': {name: 'P', value: 1e15, scientific: true},
      'E': {name: 'E', value: 1e18, scientific: true},
      'Z': {name: 'Z', value: 1e21, scientific: true},
      'Y': {name: 'Y', value: 1e24, scientific: true},

      'Ki': {name: 'Ki', value: 1024, scientific: true},
      'Mi': {name: 'Mi', value: Math.pow(1024, 2), scientific: true},
      'Gi': {name: 'Gi', value: Math.pow(1024, 3), scientific: true},
      'Ti': {name: 'Ti', value: Math.pow(1024, 4), scientific: true},
      'Pi': {name: 'Pi', value: Math.pow(1024, 5), scientific: true},
      'Ei': {name: 'Ei', value: Math.pow(1024, 6), scientific: true},
      'Zi': {name: 'Zi', value: Math.pow(1024, 7), scientific: true},
      'Yi': {name: 'Yi', value: Math.pow(1024, 8), scientific: true}
    },
    BINARY_LONG: {
      '': {name: '', value: 1, scientific: true},
      'kilo': {name: 'kilo', value: 1e3, scientific: true},
      'mega': {name: 'mega', value: 1e6, scientific: true},
      'giga': {name: 'giga', value: 1e9, scientific: true},
      'tera': {name: 'tera', value: 1e12, scientific: true},
      'peta': {name: 'peta', value: 1e15, scientific: true},
      'exa': {name: 'exa', value: 1e18, scientific: true},
      'zetta': {name: 'zetta', value: 1e21, scientific: true},
      'yotta': {name: 'yotta', value: 1e24, scientific: true},

      'kibi': {name: 'kibi', value: 1024, scientific: true},
      'mebi': {name: 'mebi', value: Math.pow(1024, 2), scientific: true},
      'gibi': {name: 'gibi', value: Math.pow(1024, 3), scientific: true},
      'tebi': {name: 'tebi', value: Math.pow(1024, 4), scientific: true},
      'pebi': {name: 'pebi', value: Math.pow(1024, 5), scientific: true},
      'exi': {name: 'exi', value: Math.pow(1024, 6), scientific: true},
      'zebi': {name: 'zebi', value: Math.pow(1024, 7), scientific: true},
      'yobi': {name: 'yobi', value: Math.pow(1024, 8), scientific: true}
    },
    BTU: {
      '':   {name: '',   value: 1,   scientific: true},
      'MM': {name: 'MM', value: 1e6, scientific: true}
    }
  };

  // Add a prefix list for both short and long prefixes (for ohm in particular, since Mohm and megaohm are both acceptable):
  PREFIXES.SHORTLONG = {};
  for (var key in PREFIXES.SHORT) {
    if(PREFIXES.SHORT.hasOwnProperty(key)) {
      PREFIXES.SHORTLONG[key] = PREFIXES.SHORT[key];
    }
  }
  for (var key in PREFIXES.LONG) {
    if(PREFIXES.LONG.hasOwnProperty(key)) {
      PREFIXES.SHORTLONG[key] = PREFIXES.LONG[key];
    }
  }

  /* Internally, each unit is represented by a value and a dimension array. The elements of the dimensions array have the following meaning:
   * Index  Dimension
   * -----  ---------
   *   0    Length
   *   1    Mass
   *   2    Time
   *   3    Current
   *   4    Temperature
   *   5    Luminous intensity
   *   6    Amount of substance
   *   7    Angle
   *   8    Bit (digital)
   * For example, the unit "298.15 K" is a pure temperature and would have a value of 298.15 and a dimension array of [0, 0, 0, 0, 1, 0, 0, 0, 0]. The unit "1 cal / (gm C)" can be written in terms of the 9 fundamental dimensions as [length^2] / ([time^2] * [temperature]), and would a value of (after conversion to SI) 4184.0 and a dimensions array of [2, 0, -2, 0, -1, 0, 0, 0, 0].
   *
   */

  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];

  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },

    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },

    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },

    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };

  for(var key in BASE_UNITS) {
    BASE_UNITS[key].key = key;
  }

  var BASE_UNIT_NONE = {};

  var UNIT_NONE = {name: '', base: BASE_UNIT_NONE, value: 1, offset: 0, dimensions: [0,0,0,0,0,0,0,0,0]};

  var UNITS = {
    // length
    meter: {
      name: 'meter',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: 'inch',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: 'foot',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: 'yard',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: 'mile',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: 'link',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: 'rod',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.029210,
      offset: 0
    },
    chain: {
      name: 'chain',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: 'angstrom',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },

    m: {
      name: 'm',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    'in': {
      name: 'in',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: 'ft',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: 'yd',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: 'mi',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: 'li',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: 'rd',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.029210,
      offset: 0
    },
    ch: {
      name: 'ch',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: 'mil',
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0000254,
      offset: 0
    }, // 1/1000 inch

    // Surface
    m2: {
      name: 'm2',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: 'sqin',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.00064516,
      offset: 0
    }, // 645.16 mm2
    sqft: {
      name: 'sqft',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    }, // 0.09290304 m2
    sqyd: {
      name: 'sqyd',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    }, // 0.83612736 m2
    sqmi: {
      name: 'sqmi',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988.110336,
      offset: 0
    }, // 2.589988110336 km2
    sqrd: {
      name: 'sqrd',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    }, // 25.29295 m2
    sqch: {
      name: 'sqch',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    }, // 404.6873 m2
    sqmil: {
      name: 'sqmil',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 6.4516e-10,
      offset: 0
    }, // 6.4516 * 10^-10 m2
    acre: {
      name: 'acre',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    }, // 4046.86 m2
    hectare: {
      name: 'hectare',
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 10000,
      offset: 0
    }, // 10000 m2

    // Volume
    m3: {
      name: 'm3',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: 'L',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    }, // litre
    l: {
      name: 'l',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    }, // litre
    litre: {
      name: 'litre',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },
    cuin: {
      name: 'cuin',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1.6387064e-5,
      offset: 0
    }, // 1.6387064e-5 m3
    cuft: {
      name: 'cuft',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    }, // 28.316 846 592 L
    cuyd: {
      name: 'cuyd',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    }, // 764.554 857 984 L
    teaspoon: {
      name: 'teaspoon',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000005,
      offset: 0
    }, // 5 mL
    tablespoon: {
      name: 'tablespoon',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.000015,
      offset: 0
    }, // 15 mL
    //{name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: 'drop',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },  // 0.05 mL = 5e-8 m3
    gtt: {
      name: 'gtt',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },  // 0.05 mL = 5e-8 m3

    // Liquid volume
    minim: {
      name: 'minim',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00000006161152,
      offset: 0
    }, // 0.06161152 mL
    fluiddram: {
      name: 'fluiddram',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911,
      offset: 0
    },  // 3.696691 mL
    fluidounce: {
      name: 'fluidounce',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00002957353,
      offset: 0
    }, // 29.57353 mL
    gill: {
      name: 'gill',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0001182941,
      offset: 0
    }, // 118.2941 mL
    cc: {
      name: 'cc',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    }, // 1e-6 L
    cup: {
      name: 'cup',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882,
      offset: 0
    }, // 236.5882 mL
    pint: {
      name: 'pint',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0004731765,
      offset: 0
    }, // 473.1765 mL
    quart: {
      name: 'quart',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0009463529,
      offset: 0
    }, // 946.3529 mL
    gallon: {
      name: 'gallon',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785412,
      offset: 0
    }, // 3.785412 L
    beerbarrel: {
      name: 'beerbarrel',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    }, // 117.3478 L
    oilbarrel: {
      name: 'oilbarrel',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    }, // 158.9873 L
    hogshead: {
      name: 'hogshead',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.2384810,
      offset: 0
    }, // 238.4810 L

    //{name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: 'fldr',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0000036966911,
      offset: 0
    },  // 3.696691 mL
    floz: {
      name: 'floz',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.00002957353,
      offset: 0
    }, // 29.57353 mL
    gi: {
      name: 'gi',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0001182941,
      offset: 0
    }, // 118.2941 mL
    cp: {
      name: 'cp',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0002365882,
      offset: 0
    }, // 236.5882 mL
    pt: {
      name: 'pt',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0004731765,
      offset: 0
    }, // 473.1765 mL
    qt: {
      name: 'qt',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.0009463529,
      offset: 0
    }, // 946.3529 mL
    gal: {
      name: 'gal',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785412,
      offset: 0
    }, // 3.785412 L
    bbl: {
      name: 'bbl',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    }, // 117.3478 L
    obl: {
      name: 'obl',
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    }, // 158.9873 L
    //{name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?

    // Mass
    g: {
      name: 'g',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 0.001,
      offset: 0
    },
    gram: {
      name: 'gram',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 0.001,
      offset: 0
    },

    ton: {
      name: 'ton',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    tonne: {
      name: 'tonne',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1000,
      offset: 0
    },

    grain: {
      name: 'grain',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 64.79891e-6,
      offset: 0
    },
    dram: {
      name: 'dram',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 1.7718451953125e-3,
      offset: 0
    },
    ounce: {
      name: 'ounce',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 28.349523125e-3,
      offset: 0
    },
    poundmass: {
      name: 'poundmass',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 453.59237e-3,
      offset: 0
    },
    hundredweight: {
      name: 'hundredweight',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: 'stick',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 115e-3,
      offset: 0
    },
    stone: {
      name: 'stone',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },

    gr: {
      name: 'gr',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 64.79891e-6,
      offset: 0
    },
    dr: {
      name: 'dr',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 1.7718451953125e-3,
      offset: 0
    },
    oz: {
      name: 'oz',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 28.349523125e-3,
      offset: 0
    },
    lbm: {
      name: 'lbm',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 453.59237e-3,
      offset: 0
    },
    cwt: {
      name: 'cwt',
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },

    // Time
    s: {
      name: 's',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: 'min',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: 'h',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: 'second',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: 'sec',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: 'minute',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: 'hour',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: 'day',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: 'week',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7*86400,
      offset: 0
    },
    month: {
      name: 'month',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800, //1/12th of Julian year
      offset: 0
    },
    year: {
      name: 'year',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600, //Julian year
      offset: 0
    },
    decade: {
      name: 'year',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576000, //Julian decade
      offset: 0
    },
    century: {
      name: 'century',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3155760000, //Julian century
      offset: 0
    },
    millennium: {
      name: 'millennium',
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600000, //Julian millennium
      offset: 0
    },

    // Frequency
    hertz: {
      name: 'Hertz',
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: 'Hz',
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },

    // Angle
    rad: {
      name: 'rad',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: 'deg',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: 'grad',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: 'cycle',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: 'arcsec',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: 'arcmin',
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null, // will be filled in by calculateAngleValues()
      offset: 0
    },
    
    // Electric current
    A: {
      name: 'A',
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: 'ampere',
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },

    // Temperature
    // K(C) = C + 273.15
    // K(F) = (F + 459.67) / 1.8
    // K(R) = R / 1.8
    K: {
      name: 'K',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    degC: {
      name: 'degC',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: 'degF',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 459.67
    },
    degR: {
      name: 'degR',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 0
    },
    kelvin: {
      name: 'kelvin',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    celsius: {
      name: 'celsius',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: 'fahrenheit',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 459.67
    },
    rankine: {
      name: 'rankine',
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 0
    },

    // amount of substance
    mol: {
      name: 'mol',
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: 'mole',
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },

    // luminous intensity
    cd: {
      name: 'cd',
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    candela: {
      name: 'candela',
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    //{name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    //{name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},

    // Force
    N: {
      name: 'N',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: 'newton',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: 'dyn',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 0.00001,
      offset: 0
    },
    dyne: {
      name: 'dyne',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 0.00001,
      offset: 0
    },
    lbf: {
      name: 'lbf',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: 'poundforce',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: 'kip',
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
	
    // Energy
    J: {
      name: 'J',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: 'joule',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    erg: {
      name: 'erg',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.NONE,
      value: 1e-5,
      offset: 0
    },
    Wh: {
      name: 'Wh',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: 'BTU',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: 'eV',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1.602176565e-19,
      offset: 0
    },
    electronvolt: {
      name: 'electronvolt',
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1.602176565e-19,
      offset: 0
    },


    // Power
    W: {
      name: 'W',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: 'W',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: 'hp',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },

    // Electrical power units
    VAR: {
      name: 'VAR',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex.I,
      offset: 0
    },
    
    VA: {
      name: 'VA',
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },

    // Pressure
    Pa: {
      name: 'Pa',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: 'psi',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: 'atm',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: 'bar',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 100000,
      offset: 0
    },
    torr: {
      name: 'torr',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: 'mmHg',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: 'mmH2O',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: 'cmH2O',
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },

    // Electric charge
    coulomb: {
      name: 'coulomb',
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: 'C',
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: 'farad',
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: 'F',
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: 'volt',
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: 'V',
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: 'ohm',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,    // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    : {
      name: '',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: 'henry',
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: 'H',
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: 'siemens',
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: 'S',
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: 'weber',
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: 'Wb',
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: 'tesla',
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: 'T',
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },

    // Binary
    b: {
      name: 'b',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: 'bits',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: 'B',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: 'bytes',
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };

  // aliases (formerly plurals)
  var ALIASES = {
    meters: 'meter',
    inches: 'inch',
    feet: 'foot',
    yards: 'yard',
    miles: 'mile',
    links: 'link',
    rods: 'rod',
    chains: 'chain',
    angstroms: 'angstrom',

    lt: 'l',
    litres: 'litre',
    liter: 'litre',
    liters: 'litre',
    teaspoons: 'teaspoon',
    tablespoons: 'tablespoon',
    minims: 'minim',
    fluiddrams: 'fluiddram',
    fluidounces: 'fluidounce',
    gills: 'gill',
    cups: 'cup',
    pints: 'pint',
    quarts: 'quart',
    gallons: 'gallon',
    beerbarrels: 'beerbarrel',
    oilbarrels: 'oilbarrel',
    hogsheads: 'hogshead',
    gtts: 'gtt',

    grams: 'gram',
    tons: 'ton',
    tonnes: 'tonne',
    grains: 'grain',
    drams: 'dram',
    ounces: 'ounce',
    poundmasses: 'poundmass',
    hundredweights: 'hundredweight',
    sticks: 'stick',
    lb: 'lbm',
    lbs: 'lbm',
	
    kips: 'kip',

    acres: 'acre',
    hectares: 'hectare',
    sqfeet: 'sqft',
    sqyard: 'sqyd',
    sqmile: 'sqmi',
    sqmiles: 'sqmi',

    mmhg: 'mmHg',
    mmh2o: 'mmH2O',
    cmh2o: 'cmH2O',

    seconds: 'second',
    secs: 'second',
    minutes: 'minute',
    mins: 'minute',
    hours: 'hour',
    hr: 'hour',
    hrs: 'hour',
    days: 'day',
    weeks: 'week',
    months: 'month',
    years: 'year',

    hertz: 'hertz',

    radians: 'rad',
    degree: 'deg',
    degrees: 'deg',
    gradian: 'grad',
    gradians: 'grad',
    cycles: 'cycle',
    arcsecond: 'arcsec',
    arcseconds: 'arcsec',
    arcminute: 'arcmin',
    arcminutes: 'arcmin',

    BTUs: 'BTU',
    watts: 'watt',
    joules: 'joule',

    amperes: 'ampere',
    coulombs: 'coulomb',
    volts: 'volt',
    ohms: 'ohm',
    farads: 'farad',
    webers: 'weber',
    teslas: 'tesla',
    electronvolts: 'electronvolt',
    moles: 'mole'

  };

  /**
   * Calculate the values for the angle units.
   * Value is calculated as number or BigNumber depending on the configuration
   * @param {{number: 'number' | 'BigNumber'}} config
   */
  function calculateAngleValues (config) {
    if (config.number === 'BigNumber') {
      var pi = constants.pi(type.BigNumber);
      UNITS.rad.value = new type.BigNumber(1);
      UNITS.deg.value = pi.div(180);        // 2 * pi / 360;
      UNITS.grad.value = pi.div(200);       // 2 * pi / 400;
      UNITS.cycle.value = pi.times(2);      // 2 * pi
      UNITS.arcsec.value = pi.div(648000);  // 2 * pi / 360 / 3600
      UNITS.arcmin.value = pi.div(10800);   // 2 * pi / 360 / 60
    }
    else { // number
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;        // 2 * pi / 360;
      UNITS.grad.value = Math.PI / 200;       // 2 * pi / 400;
      UNITS.cycle.value = Math.PI * 2;        // 2 * pi
      UNITS.arcsec.value = Math.PI / 648000;  // 2 * pi / 360 / 3600;
      UNITS.arcmin.value = Math.PI / 10800;   // 2 * pi / 360 / 60;
    }
  }

  // apply the angle values now
  calculateAngleValues(config);

  // recalculate the values on change of configuration
  math.on('config', function (curr, prev) {
    if (curr.number !== prev.number) {
      calculateAngleValues(curr);
    }
  });

  /**
   * A unit system is a set of dimensionally independent base units plus a set of derived units, formed by multiplication and division of the base units, that are by convention used with the unit system.
   * A user perhaps could issue a command to select a preferred unit system, or use the default (see below).
   * Auto unit system: The default unit system is updated on the fly anytime a unit is parsed. The corresponding unit in the default unit system is updated, so that answers are given in the same units the user supplies.
   */
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE:                  {unit: UNIT_NONE, prefix: PREFIXES.NONE['']},
      LENGTH:                {unit: UNITS.m,   prefix: PREFIXES.SHORT['']},
      MASS:                  {unit: UNITS.g,   prefix: PREFIXES.SHORT['k']}, 
      TIME:                  {unit: UNITS.s,   prefix: PREFIXES.SHORT['']}, 
      CURRENT:               {unit: UNITS.A,   prefix: PREFIXES.SHORT['']}, 
      TEMPERATURE:           {unit: UNITS.K,   prefix: PREFIXES.SHORT['']}, 
      LUMINOUS_INTENSITY:    {unit: UNITS.cd,  prefix: PREFIXES.SHORT['']}, 
      AMOUNT_OF_SUBSTANCE:   {unit: UNITS.mol, prefix: PREFIXES.SHORT['']}, 
      ANGLE:                 {unit: UNITS.rad, prefix: PREFIXES.SHORT['']}, 
      BIT:                   {unit: UNITS.bit, prefix: PREFIXES.SHORT['']}, 

      // Derived units
      FORCE:                 {unit: UNITS.N,   prefix: PREFIXES.SHORT['']}, 
      ENERGY:                {unit: UNITS.J,   prefix: PREFIXES.SHORT['']},
      POWER:                 {unit: UNITS.W,   prefix: PREFIXES.SHORT['']},
      PRESSURE:              {unit: UNITS.Pa,  prefix: PREFIXES.SHORT['']},
      ELECTRIC_CHARGE:       {unit: UNITS.C,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_CAPACITANCE:  {unit: UNITS.F,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_POTENTIAL:    {unit: UNITS.V,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_RESISTANCE:   {unit: UNITS.ohm, prefix: PREFIXES.SHORT['']},
      ELECTRIC_INDUCTANCE:   {unit: UNITS.H,   prefix: PREFIXES.SHORT['']},
      ELECTRIC_CONDUCTANCE:  {unit: UNITS.S,   prefix: PREFIXES.SHORT['']},
      MAGNETIC_FLUX:         {unit: UNITS.Wb,  prefix: PREFIXES.SHORT['']},
      MAGNETIC_FLUX_DENSITY: {unit: UNITS.T,   prefix: PREFIXES.SHORT['']},
      FREQUENCY:             {unit: UNITS.Hz,  prefix: PREFIXES.SHORT['']}
    }
  };

  // Clone to create the other unit systems
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {unit: UNITS.m,   prefix: PREFIXES.SHORT['c']};
  UNIT_SYSTEMS.cgs.MASS =   {unit: UNITS.g,   prefix: PREFIXES.SHORT['']};
  UNIT_SYSTEMS.cgs.FORCE =  {unit: UNITS.dyn, prefix: PREFIXES.SHORT['']};
  UNIT_SYSTEMS.cgs.ENERGY = {unit: UNITS.erg, prefix: PREFIXES.NONE['']};
  // there are wholly 4 unique cgs systems for electricity and magnetism,
  // so let's not worry about it unless somebody complains
  
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH =      {unit: UNITS.ft,   prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.MASS =        {unit: UNITS.lbm,  prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.TEMPERATURE = {unit: UNITS.degF, prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.FORCE =       {unit: UNITS.lbf,  prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.ENERGY =      {unit: UNITS.BTU,  prefix: PREFIXES.BTU['']};
  UNIT_SYSTEMS.us.POWER =       {unit: UNITS.hp,   prefix: PREFIXES.NONE['']};
  UNIT_SYSTEMS.us.PRESSURE =    {unit: UNITS.psi,  prefix: PREFIXES.NONE['']};

  // Add additional unit systems here.



  // Choose a unit system to seed the auto unit system.
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));

  // Set the current unit system
  var currentUnitSystem = UNIT_SYSTEMS.auto;

  /**
   * Set a unit system for formatting derived units.
   * @param {string} [name] The name of the unit system.
   */
  Unit.setUnitSystem = function(name) {
    if(UNIT_SYSTEMS.hasOwnProperty(name)) {
      currentUnitSystem = UNIT_SYSTEMS[name];
    }
    else {
      throw new Error('Unit system ' + name + ' does not exist. Choices are: ' + Object.keys(UNIT_SYSTEMS).join(', '));
    }
  };

  /**
   * Return the current unit system.
   * @return {string} The current unit system.
   */
  Unit.getUnitSystem = function() {
    for(var key in UNIT_SYSTEMS) {
      if(UNIT_SYSTEMS[key] === currentUnitSystem) {
        return key;
      }
    }
  };

  /**
   * Converters to convert from number to an other numeric type like BigNumber
   * or Fraction
   */
  Unit.typeConverters = {
    BigNumber: function (x) {
      return new type.BigNumber(x + ''); // stringify to prevent constructor error
    },

    Fraction: function (x) {
      return new type.Fraction(x);
    },

    Complex: function (x) {
      return x;
    },

    number: function (x) {
      return x;
    }
  };

  /**
   * Retrieve the right convertor function corresponding with the type
   * of provided exampleValue.
   *
   * @param {string} type   A string 'number', 'BigNumber', or 'Fraction'
   *                        In case of an unknown type,
   * @return {Function}
   */
  Unit._getNumberConverter = function (type) {
    if (!Unit.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }

    return Unit.typeConverters[type];
  };

  // Add dimensions to each built-in unit
  for (var key in UNITS) {
    var unit = UNITS[key];
    unit.dimensions = unit.base.dimensions;
  }    

  // Create aliases
  for (var name in ALIASES) {
    if(ALIASES.hasOwnProperty(name)) {
      var unit = UNITS[ALIASES[name]];
      var alias = {};
      for(var key in unit) {
        if(unit.hasOwnProperty(key)) {
          alias[key] = unit[key];
        }
      }
      alias.name = name;
      UNITS[name] = alias;
    }
  }

  function assertUnitNameIsValid(name) {
    for(var i=0; i<name.length; i++) {
      var c = name.charAt(i);
       
      var isValidAlpha = function (p) {
        return /^[a-zA-Z]$/.test(p);
      };

      var isDigit = function (c) {
        return (c >= '0' && c <= '9');
      }

      if(i === 0 && !isValidAlpha(c))
        throw new Error('Invalid unit name (must begin with alpha character): "' + name + '"');

      if(i > 0 && !( isValidAlpha(c)
                  || isDigit(c)))
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name + '"');

    }
  }

  /**
   * Wrapper around createUnitSingle.
   * Example: 
   *  createUnit({
   *    foo: { },
   *    bar: {
   *      definition: 'kg/foo',
   *      aliases: ['ba', 'barr', 'bars'],
   *      offset: 200
   *    },
   *    baz: '4 bar'
   *  }, 
   *  {
   *    override: true;
   *  });
   * @param {object} obj      Object map. Each key becomes a unit which is defined by its value.
   * @param {object} options
   */
  Unit.createUnit = function(obj, options) {
    
    if(typeof(obj) !== 'object') {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }

    // Remove all units and aliases we are overriding
    if(options && options.override) {
      for(var key in obj) {
        if(obj.hasOwnProperty(key)) {
          Unit.deleteUnit(key);
        }
        if(obj[key].aliases) {
          for(var i=0; i<obj[key].aliases.length; i++) {
            Unit.deleteUnit(obj[key].aliases[i]);
          }
        }
      }
    }

    // TODO: traverse multiple times until all units have been added
    var lastUnit;
    for(var key in obj) {
      if(obj.hasOwnProperty(key)) {
        lastUnit = Unit.createUnitSingle(key, obj[key]);
      }
    }
    return lastUnit;
  };

  /**
   * Create a user-defined unit and register it with the Unit type.
   * Example: 
   *  createUnitSingle('knot', '0.514444444 m/s')
   *  createUnitSingle('acre', new Unit(43560, 'ft^2'))
   *
   * @param {string} name      The name of the new unit. Must be unique. Example: 'knot'
   * @param {string, Unit} definition      Definition of the unit in terms of existing units. For example, '0.514444444 m / s'.
   * @param {Object} options   (optional) An object containing any of the following properties:
   *     prefixes {string} "none", "short", "long", "binary_short", or "binary_long". The default is "none".
   *     aliases {Array} Array of strings. Example: ['knots', 'kt', 'kts']
   *     offset {Numeric} An offset to apply when converting from the unit. For example, the offset for celsius is 273.15 and the offset for farhenheit is 459.67. Default is 0.
   *
   * @return {Unit} 
   */
  Unit.createUnitSingle = function(name, obj, options) {

    if(typeof(obj) === 'undefined' || obj === null) {
      obj = {};
    }
    
    if(typeof(name) !== 'string') {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
   
    // Check collisions with existing units
    if(UNITS.hasOwnProperty(name)) {
      throw new Error('Cannot create unit "' + name + '": a unit with that name already exists');
    }

    // TODO: Validate name for collisions with other built-in functions (like abs or cos, for example), and for acceptable variable names. For example, '42' is probably not a valid unit. Nor is '%', since it is also an operator.

    assertUnitNameIsValid(name);

    var defUnit = null;   // The Unit from which the new unit will be created.
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    if(obj && obj.type === 'Unit') {
      defUnit = obj.clone();
    }
    else if(typeof(obj) === 'string') {
      if(obj !== '') {
        definition = obj;
      }
    }
    else if(typeof(obj) === 'object') {
      definition = obj.definition;
      prefixes = obj.prefixes; 
      offset = obj.offset;
      aliases = obj.aliases;
    }
    else {
      throw new TypeError('Cannot create unit "' + name + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }

    if(aliases) {
      for (var i=0; i<aliases.length; i++) {
        if(UNITS.hasOwnProperty(aliases[i])) {
          throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
        }
      }
    }

    if(definition && typeof(definition) === 'string' && !defUnit) {
      try {
        defUnit = Unit.parse(definition, {allowNoUnits: true});
      }
      catch (ex) {
        ex.message = 'Could not create unit "' + name + '" from "' + definition + '": ' + ex.message;
        throw(ex);
      }
    }
    else if(definition && definition.type === 'Unit') {
      defUnit = definition.clone();
    }

    aliases = aliases || [];
    offset = offset || 0;
    if(prefixes && prefixes.toUpperCase) 
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    else
      prefixes = PREFIXES.NONE;


    // If defUnit is null, it is because the user did not
    // specify a defintion. So create a new base dimension.
    var newUnit = {};
    if(!defUnit) {
      // Add a new base dimension
      var baseName = name + "_STUFF";   // foo --> foo_STUFF, or the essence of foo
      if(BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);

      // Push 0 onto existing base units
      for(var b in BASE_UNITS) {
        if(BASE_UNITS.hasOwnProperty(b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length-1] = 0;
        }
      }

      // Add the new base unit
      var newBaseUnit = { dimensions: [] };
      for(var i=0; i<BASE_DIMENSIONS.length; i++) {
        newBaseUnit.dimensions[i] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length-1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
       
      newUnit = {
        name: name,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes: prefixes,
        offset: offset,
        base: baseName
      };

      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE['']
      };

    }
    else {

      newUnit = {
        name: name,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes: prefixes,
        offset: offset,
      };
      
      // Create a new base if no matching base exists
      var anyMatch = false;
      for(var i in BASE_UNITS) {
        if(BASE_UNITS.hasOwnProperty(i)) {
          var match = true;
          for(var j=0; j<BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[i].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if(match) {
            anyMatch = true;
            break;
          }
        }
      }
      if(!anyMatch) {
        var baseName = name + "_STUFF";   // foo --> foo_STUFF, or the essence of foo
        // Add the new base unit
        var newBaseUnit = { dimensions: defUnit.dimensions.slice(0) };
        newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = newBaseUnit;

        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE['']
        };

        newUnit.base = baseName;
      }
    }

    Unit.UNITS[name] = newUnit;

    for (var i=0; i<aliases.length; i++) {
      var aliasName = aliases[i];
      var alias = {};
      for(var key in newUnit) {
        if(newUnit.hasOwnProperty(key)) {
          alias[key] = newUnit[key];
        }
      }
      alias.name = aliasName;
      Unit.UNITS[aliasName] = alias;
    }

    return new Unit(null, name);
  };

  Unit.deleteUnit = function(name) {
    delete Unit.UNITS[name];
  };


  Unit.PREFIXES = PREFIXES;
  Unit.BASE_UNITS = BASE_UNITS;
  Unit.UNITS = UNITS;
  Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;

  return Unit;
}

exports.name = 'Unit';
exports.path = 'type';
exports.factory = factory;
exports.math = true; // request access to the math namespace

},{"../../function/arithmetic/abs":241,"../../function/arithmetic/addScalar":243,"../../function/arithmetic/divideScalar":248,"../../function/arithmetic/fix":253,"../../function/arithmetic/multiplyScalar":263,"../../function/arithmetic/pow":266,"../../function/arithmetic/subtract":271,"../../function/relational/equal":287,"../../function/string/format":294,"../../function/utils/isNumeric":322,"../../function/utils/typeof":324,"../../type/complex/Complex":325,"../../type/number":342,"../../utils/bignumber/constants":347,"../../utils/object":362,"../../utils/string":363,"util":4}],345:[function(require,module,exports){
'use strict';

/**
 * Format a number using methods toPrecision, toFixed, toExponential.
 * @param {number | string} value
 * @constructor
 */
function NumberFormatter (value) {
  // parse the input value
  var match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError('Invalid number');
  }

  var sign         = match[1];
  var coefficients = match[2];
  var exponent     = parseFloat(match[4] || '0');

  var dot = coefficients.indexOf('.');
  exponent += (dot !== -1) ? (dot - 1) : (coefficients.length - 1);

  this.sign = sign;
  this.coefficients = coefficients
      .replace('.', '')  // remove the dot (must be removed before removing leading zeros)
      .replace(/^0*/, function (zeros) {
        // remove leading zeros, add their count to the exponent
        exponent -= zeros.length;
        return '';
      })
      .replace(/0*$/, '') // remove trailing zeros
      .split('')
      .map(function (d) {
        return parseInt(d);
      });

  if (this.coefficients.length === 0) {
    this.coefficients.push(0);
    exponent++;
  }

  this.exponent = exponent;
}


/**
 * Format a number with engineering notation.
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
NumberFormatter.prototype.toEngineering = function(precision) {
  var rounded = this.roundDigits(precision);

  var e = rounded.exponent;
  var c = rounded.coefficients;

  // find nearest lower multiple of 3 for exponent
  var newExp = e % 3 === 0 ? e : (e < 0 ? (e - 3) - (e % 3) : e - (e % 3));

  // concatenate coefficients with necessary zeros
  var significandsDiff = e >= 0 ? e : Math.abs(newExp);

  // add zeros if necessary (for ex: 1e+8)
  if (c.length - 1 < significandsDiff) c = c.concat(zeros(significandsDiff - (c.length - 1)));

  // find difference in exponents
  var expDiff = Math.abs(e - newExp);

  var decimalIdx = 1;
  var str = '';

  // push decimal index over by expDiff times
  while (--expDiff >= 0) decimalIdx++;

  // if all coefficient values are zero after the decimal point, don't add a decimal value. 
  // otherwise concat with the rest of the coefficients
  var decimals = c.slice(decimalIdx).join('');
  var decimalVal = decimals.match(/[1-9]/) ? ('.' + decimals) : '';

  str = c.slice(0, decimalIdx).join('') + decimalVal;

  str += 'e' + (e >= 0 ? '+' : '') + newExp.toString();
  return rounded.sign + str;
}

/**
 * Format a number with fixed notation.
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
NumberFormatter.prototype.toFixed = function (precision) {
  var rounded = this.roundDigits(this.exponent + 1 + (precision || 0));
  var c = rounded.coefficients;
  var p = rounded.exponent + 1; // exponent may have changed

  // append zeros if needed
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }

  // prepend zeros if needed
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }

  // insert a dot if needed
  if (precision) {
    c.splice(p, 0, (p === 0) ? '0.' : '.');
  }

  return this.sign + c.join('');
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 */
NumberFormatter.prototype.toExponential = function (precision) {
  // round if needed, else create a clone
  var rounded = precision ? this.roundDigits(precision) : this.clone();
  var c = rounded.coefficients;
  var e = rounded.exponent;

  // append zeros if needed
  if (c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }

  // format as `C.CCCe+EEE` or `C.CCCe-EEE`
  var first = c.shift();
  return this.sign + first + (c.length > 0 ? ('.' + c.join('')) : '') +
      'e' + (e >= 0 ? '+' : '') + e;
};

/**
 * Format a number with a certain precision
 * @param {number} [precision=undefined] Optional number of digits.
 * @param {{lower: number | undefined, upper: number | undefined}} [options]
 *                                       By default:
 *                                         lower = 1e-3 (excl)
 *                                         upper = 1e+5 (incl)
 * @return {string}
 */
NumberFormatter.prototype.toPrecision = function(precision, options) {
  // determine lower and upper bound for exponential notation.
  var lower = (options && options.lower !== undefined) ? options.lower : 1e-3;
  var upper = (options && options.upper !== undefined) ? options.upper : 1e+5;

  var abs = Math.abs(Math.pow(10, this.exponent));
  if (abs < lower || abs >= upper) {
    // exponential notation
    return this.toExponential(precision);
  }
  else {
    var rounded = precision ? this.roundDigits(precision) : this.clone();
    var c = rounded.coefficients;
    var e = rounded.exponent;

    // append trailing zeros
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }

    // append trailing zeros
    // TODO: simplify the next statement
    c = c.concat(zeros(e - c.length + 1 +
        (c.length < precision ? precision - c.length : 0)));

    // prepend zeros
    c = zeros(-e).concat(c);

    var dot = e > 0 ? e : 0;
    if (dot < c.length - 1) {
      c.splice(dot + 1, 0, '.');
    }

    return this.sign + c.join('');
  }
};

/**
 * Crete a clone of the NumberFormatter
 * @return {NumberFormatter} Returns a clone of the NumberFormatter
 */
NumberFormatter.prototype.clone = function () {
  var clone = new NumberFormatter('0');
  clone.sign = this.sign;
  clone.coefficients = this.coefficients.slice(0);
  clone.exponent = this.exponent;
  return clone;
};

/**
 * Round the number of digits of a number *
 * @param {number} precision  A positive integer
 * @return {NumberFormatter}  Returns a new NumberFormatter with the rounded
 *                            digits
 */
NumberFormatter.prototype.roundDigits = function (precision) {
  var rounded = this.clone();
  var c = rounded.coefficients;

  // prepend zeros if needed
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }

  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);

    if (removed[0] >= 5) {
      var i = precision - 1;
      c[i]++;
      while (c[i] === 10) {
        c.pop();
        if (i === 0) {
          c.unshift(0);
          rounded.exponent++;
          i++;
        }
        i--;
        c[i]++;
      }
    }
  }

  return rounded;
};

/**
 * Create an array filled with zeros.
 * @param {number} length
 * @return {Array}
 */
function zeros(length) {
  var arr = [];
  for (var i = 0; i < length; i++) {
    arr.push(0);
  }
  return arr;
}

module.exports = NumberFormatter;

},{}],346:[function(require,module,exports){
'use strict';

var number = require('./number');
var string = require('./string');
var object = require('./object');
var types = require('./types');

var DimensionError = require('../error/DimensionError');
var IndexError = require('../error/IndexError');

/**
 * Calculate the size of a multi dimensional array.
 * This function checks the size of the first entry, it does not validate
 * whether all dimensions match. (use function `validate` for that)
 * @param {Array} x
 * @Return {Number[]} size
 */
exports.size = function (x) {
  var s = [];

  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }

  return s;
};

/**
 * Recursively validate whether each element in a multi dimensional array
 * has a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {number[]} size  Array with the size of each dimension
 * @param {number} dim   Current dimension
 * @throws DimensionError
 * @private
 */
function _validate(array, size, dim) {
  var i;
  var len = array.length;

  if (len != size[dim]) {
    throw new DimensionError(len, size[dim]);
  }

  if (dim < size.length - 1) {
    // recursively validate each child array
    var dimNext = dim + 1;
    for (i = 0; i < len; i++) {
      var child = array[i];
      if (!Array.isArray(child)) {
        throw new DimensionError(size.length - 1, size.length, '<');
      }
      _validate(array[i], size, dimNext);
    }
  }
  else {
    // last dimension. none of the childs may be an array
    for (i = 0; i < len; i++) {
      if (Array.isArray(array[i])) {
        throw new DimensionError(size.length + 1, size.length, '>');
      }
    }
  }
}

/**
 * Validate whether each element in a multi dimensional array has
 * a size corresponding to the provided size array.
 * @param {Array} array    Array to be validated
 * @param {number[]} size  Array with the size of each dimension
 * @throws DimensionError
 */
exports.validate = function(array, size) {
  var isScalar = (size.length == 0);
  if (isScalar) {
    // scalar
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  }
  else {
    // array
    _validate(array, size, 0);
  }
};

/**
 * Test whether index is an integer number with index >= 0 and index < length
 * when length is provided
 * @param {number} index    Zero-based index
 * @param {number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.isInteger(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index < 0 || (typeof length === 'number' && index >= length)) {
    throw new IndexError(index, length);
  }
};

// a constant used to specify an undefined defaultValue
exports.UNINITIALIZED = {};

/**
 * Resize a multi dimensional array. The resized array is returned.
 * @param {Array} array         Array to be resized
 * @param {Array.<number>} size Array with the size of each dimension
 * @param {*} [defaultValue=0]  Value to be filled in in new entries,
 *                              zero by default. To leave new entries undefined,
 *                              specify array.UNINITIALIZED as defaultValue
 * @return {Array} array         The resized array
 */
exports.resize = function(array, size, defaultValue) {
  // TODO: add support for scalars, having size=[] ?

  // check the type of the arguments
  if (!Array.isArray(array) || !Array.isArray(size)) {
    throw new TypeError('Array expected');
  }
  if (size.length === 0) {
    throw new Error('Resizing to scalar is not supported');
  }

  // check whether size contains positive integers
  size.forEach(function (value) {
    if (!number.isNumber(value) || !number.isInteger(value) || value < 0) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + string.format(size) + ')');
    }
  });

  // recursively resize the array
  var _defaultValue = (defaultValue !== undefined) ? defaultValue : 0;
  _resize(array, size, 0, _defaultValue);

  return array;
};

/**
 * Recursively resize a multi dimensional array
 * @param {Array} array         Array to be resized
 * @param {number[]} size       Array with the size of each dimension
 * @param {number} dim          Current dimension
 * @param {*} [defaultValue]    Value to be filled in in new entries,
 *                              undefined by default.
 * @private
 */
function _resize (array, size, dim, defaultValue) {
  var i;
  var elem;
  var oldLen = array.length;
  var newLen = size[dim];
  var minLen = Math.min(oldLen, newLen);

  // apply new length
  array.length = newLen;

  if (dim < size.length - 1) {
    // non-last dimension
    var dimNext = dim + 1;

    // resize existing child arrays
    for (i = 0; i < minLen; i++) {
      // resize child array
      elem = array[i];
      if (!Array.isArray(elem)) {
        elem = [elem]; // add a dimension
        array[i] = elem;
      }
      _resize(elem, size, dimNext, defaultValue);
    }

    // create new child arrays
    for (i = minLen; i < newLen; i++) {
      // get child array
      elem = [];
      array[i] = elem;

      // resize new child array
      _resize(elem, size, dimNext, defaultValue);
    }
  }
  else {
    // last dimension

    // remove dimensions of existing values
    for (i = 0; i < minLen; i++) {
      while (Array.isArray(array[i])) {
        array[i] = array[i][0];
      }
    }

    if(defaultValue !== exports.UNINITIALIZED) {
      // fill new elements with the default value
      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
}

/**
 * Squeeze a multi dimensional array
 * @param {Array} array
 * @param {Array} [size]
 * @returns {Array} returns the array itself
 */
exports.squeeze = function(array, size) {
  var s = size || exports.size(array);

  // squeeze outer dimensions
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }

  // find the first dimension to be squeezed
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }

  // squeeze inner dimensions
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }

  return array;
};

/**
 * Recursively squeeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */
function _squeeze (array, dims, dim) {
  var i, ii;

  if (dim < dims) {
    var next = dim + 1;
    for (i = 0, ii = array.length; i < ii; i++) {
      array[i] = _squeeze(array[i], dims, next);
    }
  }
  else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }

  return array;
}

/**
 * Unsqueeze a multi dimensional array: add dimensions when missing
 * 
 * Paramter `size` will be mutated to match the new, unqueezed matrix size.
 * 
 * @param {Array} array
 * @param {number} dims     Desired number of dimensions of the array
 * @param {number} [outer]  Number of outer dimensions to be added
 * @param {Array} [size]    Current size of array.
 * @returns {Array} returns the array itself
 * @private
 */
exports.unsqueeze = function(array, dims, outer, size) {
  var s = size || exports.size(array);

  // unsqueeze outer dimensions
  if (outer) {
    for (var i = 0; i < outer; i++) {
      array = [array];
      s.unshift(1);
    }
  }

  // unsqueeze inner dimensions
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }

  return array;
};

/**
 * Recursively unsqueeze a multi dimensional array
 * @param {Array} array
 * @param {number} dims Required number of dimensions
 * @param {number} dim  Current dimension
 * @returns {Array | *} Returns the squeezed array
 * @private
 */
function _unsqueeze (array, dims, dim) {
  var i, ii;

  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i = 0, ii = array.length; i < ii; i++) {
      array[i] = _unsqueeze(array[i], dims, next);
    }
  }
  else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }

  return array;
}
/**
 * Flatten a multi dimensional array, put all elements in a one dimensional
 * array
 * @param {Array} array   A multi dimensional array
 * @return {Array}        The flattened array (1 dimensional)
 */
exports.flatten = function(array) {
  if (!Array.isArray(array)) {
    //if not an array, return as is
    return array;
  }
  var flat = [];

  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);  //traverse through sub-arrays recursively
    }
    else {
      flat.push(value);
    }
  });

  return flat;
};

/**
 * Test whether an object is an array
 * @param {*} value
 * @return {boolean} isArray
 */
exports.isArray = Array.isArray;

},{"../error/DimensionError":15,"../error/IndexError":16,"./number":361,"./object":362,"./string":363,"./types":364}],347:[function(require,module,exports){
var memoize = require('../function').memoize;

/**
 * Calculate BigNumber e
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns e
 */
exports.e = memoize(function (BigNumber) {
  return new BigNumber(1).exp();
}, hasher);

/**
 * Calculate BigNumber golden ratio, phi = (1+sqrt(5))/2
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns phi
 */
exports.phi = memoize(function (BigNumber) {
  return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
}, hasher);

/**
 * Calculate BigNumber pi.
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns pi
 */
exports.pi = memoize(function (BigNumber) {
  return pi = BigNumber.acos(-1);
}, hasher);

/**
 * Calculate BigNumber tau, tau = 2 * pi
 * @param {function} BigNumber   BigNumber constructor
 * @returns {BigNumber} Returns tau
 */
exports.tau = memoize(function (BigNumber) {
  return exports.pi(BigNumber).times(2);
}, hasher);

/**
 * Create a hash for a BigNumber constructor function. The created has is
 * the configured precision
 * @param {Array} args         Supposed to contain a single entry with
 *                             a BigNumber constructor
 * @return {number} precision
 * @private
 */
function hasher (args) {
  return args[0].precision;
}

},{"../function":358}],348:[function(require,module,exports){
/**
 * Convert a BigNumber to a formatted string representation.
 *
 * Syntax:
 *
 *    format(value)
 *    format(value, options)
 *    format(value, precision)
 *    format(value, fn)
 *
 * Where:
 *
 *    {number} value   The value to be formatted
 *    {Object} options An object with formatting options. Available options:
 *                     {string} notation
 *                         Number notation. Choose from:
 *                         'fixed'          Always use regular number notation.
 *                                          For example '123.40' and '14000000'
 *                         'exponential'    Always use exponential notation.
 *                                          For example '1.234e+2' and '1.4e+7'
 *                         'auto' (default) Regular number notation for numbers
 *                                          having an absolute value between
 *                                          `lower` and `upper` bounds, and uses
 *                                          exponential notation elsewhere.
 *                                          Lower bound is included, upper bound
 *                                          is excluded.
 *                                          For example '123.4' and '1.4e7'.
 *                     {number} precision   A number between 0 and 16 to round
 *                                          the digits of the number.
 *                                          In case of notations 'exponential' and
 *                                          'auto', `precision` defines the total
 *                                          number of significant digits returned
 *                                          and is undefined by default.
 *                                          In case of notation 'fixed',
 *                                          `precision` defines the number of
 *                                          significant digits after the decimal
 *                                          point, and is 0 by default.
 *                     {Object} exponential An object containing two parameters,
 *                                          {number} lower and {number} upper,
 *                                          used by notation 'auto' to determine
 *                                          when to return exponential notation.
 *                                          Default values are `lower=1e-3` and
 *                                          `upper=1e5`.
 *                                          Only applicable for notation `auto`.
 *    {Function} fn    A custom formatting function. Can be used to override the
 *                     built-in notations. Function `fn` is called with `value` as
 *                     parameter and must return a string. Is useful for example to
 *                     format all values inside a matrix in a particular way.
 *
 * Examples:
 *
 *    format(6.4);                                        // '6.4'
 *    format(1240000);                                    // '1.24e6'
 *    format(1/3);                                        // '0.3333333333333333'
 *    format(1/3, 3);                                     // '0.333'
 *    format(21385, 2);                                   // '21000'
 *    format(12.071, {notation: 'fixed'});                // '12'
 *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'
 *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'
 *
 * @param {BigNumber} value
 * @param {Object | Function | number} [options]
 * @return {string} str The formatted value
 */
exports.format = function (value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (!value.isFinite()) {
    return value.isNaN() ? 'NaN' : (value.gt(0) ? 'Infinity' : '-Infinity');
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options !== undefined) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (typeof options === 'number') {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'auto':
      // determine lower and upper bound for exponential notation.
      // TODO: implement support for upper and lower to be BigNumbers themselves
      var lower = 1e-3;
      var upper = 1e5;
      if (options && options.exponential) {
        if (options.exponential.lower !== undefined) {
          lower = options.exponential.lower;
        }
        if (options.exponential.upper !== undefined) {
          upper = options.exponential.upper;
        }
      }

      // adjust the configuration of the BigNumber constructor (yeah, this is quite tricky...)
      var oldConfig = {
        toExpNeg: value.constructor.toExpNeg,
        toExpPos: value.constructor.toExpPos
      };

      value.constructor.config({
        toExpNeg: Math.round(Math.log(lower) / Math.LN10),
        toExpPos: Math.round(Math.log(upper) / Math.LN10)
      });

      // handle special case zero
      if (value.isZero()) return '0';

      // determine whether or not to output exponential notation
      var str;
      var abs = value.abs();
      if (abs.gte(lower) && abs.lt(upper)) {
        // normal number notation
        str = value.toSignificantDigits(precision).toFixed();
      }
      else {
        // exponential notation
        str = exports.toExponential(value, precision);
      }

      // remove trailing zeros after the decimal point
      return str.replace(/((\.\d*?)(0+))($|e)/, function () {
        var digits = arguments[2];
        var e = arguments[4];
        return (digits !== '.') ? digits + e : e;
      });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {BigNumber} value
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toExponential = function (value, precision) {
  if (precision !== undefined) {
    return value.toExponential(precision - 1); // Note the offset of one
  }
  else {
    return value.toExponential();
  }
};

/**
 * Format a number with fixed notation.
 * @param {BigNumber} value
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
exports.toFixed = function (value, precision) {
  return value.toFixed(precision || 0);
  // Note: the (precision || 0) is needed as the toFixed of BigNumber has an
  // undefined default precision instead of 0.
};

},{}],349:[function(require,module,exports){
'use strict';

/**
 * Compares two BigNumbers.
 * @param {BigNumber} x       First value to compare
 * @param {BigNumber} y       Second value to compare
 * @param {number} [epsilon]  The maximum relative difference between x and y
 *                            If epsilon is undefined or null, the function will
 *                            test whether x and y are exactly equal.
 * @return {boolean} whether the two numbers are nearly equal
 */
module.exports = function nearlyEqual(x, y, epsilon) {
  // if epsilon is null or undefined, test whether x and y are exactly equal
  if (epsilon == null) {
    return x.eq(y);
  }


  // use "==" operator, handles infinities
  if (x.eq(y)) {
    return true;
  }

  // NaN
  if (x.isNaN() || y.isNaN()) {
    return false;
  }

  // at this point x and y should be finite
  if(x.isFinite() && y.isFinite()) {
    // check numbers are very close, needed when comparing numbers near zero
    var diff = x.minus(y).abs();
    if (diff.isZero()) {
      return true;
    }
    else {
      // use relative error
      var max = x.constructor.max(x.abs(), y.abs());
      return diff.lte(max.times(epsilon));
    }
  }

  // Infinite and Number or negative Infinite and positive Infinite cases
  return false;
};

},{}],350:[function(require,module,exports){
'use strict';

/**
 * Test whether value is a boolean
 * @param {*} value
 * @return {boolean} isBoolean
 */
exports.isBoolean = function(value) {
  return typeof value == 'boolean';
};

},{}],351:[function(require,module,exports){
'use strict';

var isCollection = require('./isCollection');

/**
 * Test whether an array contains collections
 * @param {Array} array
 * @returns {boolean} Returns true when the array contains one or multiple
 *                    collections (Arrays or Matrices). Returns false otherwise.
 */
module.exports = function containsCollections (array) {
  for (var i = 0; i < array.length; i++) {
    if (isCollection(array[i])) {
      return true;
    }
  }
  return false;
};

},{"./isCollection":354}],352:[function(require,module,exports){
'use strict';

/**
 * Recursively loop over all elements in a given multi dimensional array
 * and invoke the callback on each of the elements.
 * @param {Array | Matrix} array
 * @param {Function} callback     The callback method is invoked with one
 *                                parameter: the current element in the array
 */
module.exports = function deepForEach (array, callback) {
  if (array && array.isMatrix === true) {
    array = array.valueOf();
  }

  for (var i = 0, ii = array.length; i < ii; i++) {
    var value = array[i];

    if (Array.isArray(value)) {
      deepForEach(value, callback);
    }
    else {
      callback(value);
    }
  }
};

},{}],353:[function(require,module,exports){
'use strict';

/**
 * Execute the callback function element wise for each element in array and any
 * nested array
 * Returns an array with the results
 * @param {Array | Matrix} array
 * @param {Function} callback   The callback is called with two parameters:
 *                              value1 and value2, which contain the current
 *                              element of both arrays.
 * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
 *
 * @return {Array | Matrix} res
 */
module.exports = function deepMap(array, callback, skipZeros) {
  if (array && (typeof array.map === 'function')) {
    // TODO: replace array.map with a for loop to improve performance
    return array.map(function (x) {
      return deepMap(x, callback, skipZeros);
    });
  }
  else {
    return callback(array);
  }
};

},{}],354:[function(require,module,exports){
'use strict';

/**
 * Test whether a value is a collection: an Array or Matrix
 * @param {*} x
 * @returns {boolean} isCollection
 */
module.exports = function isCollection (x) {
  return (Array.isArray(x) || (x && x.isMatrix === true));
};

},{}],355:[function(require,module,exports){
'use strict';

var arraySize = require('../array').size;
var IndexError = require('../../error/IndexError');

/**
 * Reduce a given matrix or array to a new matrix or
 * array with one less dimension, applying the given
 * callback in the selected dimension.
 * @param {Array | Matrix} mat
 * @param {number} dim
 * @param {Function} callback
 * @return {Array | Matrix} res
 */
module.exports = function(mat, dim, callback) {
  var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || (dim >= size.length)) {
    // TODO: would be more clear when throwing a DimensionError here
    throw new IndexError(dim, size.length);
  }

  if (mat && mat.isMatrix === true) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  }else {
    return _reduce(mat, dim, callback);
  }
};

/**
 * Recursively reduce a matrix
 * @param {Array} mat
 * @param {number} dim
 * @param {Function} callback
 * @returns {Array} ret
 * @private
 */
function _reduce(mat, dim, callback){
  var i, ret, val, tran;

  if(dim<=0){
    if( !Array.isArray(mat[0]) ){
      val = mat[0];
      for(i=1; i<mat.length; i++){
        val = callback(val, mat[i]);
      }
      return val;
    }else{
      tran = _switch(mat);
      ret = [];
      for(i=0; i<tran.length; i++){
        ret[i] = _reduce(tran[i], dim-1, callback);
      }
      return ret;
    }
  }else{
    ret = [];
    for(i=0; i<mat.length; i++){
      ret[i] = _reduce(mat[i], dim-1, callback);
    }
    return ret;
  }
}

/**
 * Transpose a matrix
 * @param {Array} mat
 * @returns {Array} ret
 * @private
 */
function _switch(mat){
  var I = mat.length;
  var J = mat[0].length;
  var i, j;
  var ret = [];
  for( j=0; j<J; j++) {
    var tmp = [];
    for( i=0; i<I; i++) {
      tmp.push(mat[i][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

},{"../../error/IndexError":16,"../array":346}],356:[function(require,module,exports){
'use strict';

module.exports = function scatter(a, j, w, x, u, mark, c, f, inverse, update, value) {
  // a arrays
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  // c arrays
  var cindex = c._index;

  // vars
  var k, k0, k1, i;

  // check we need to process values (pattern matrix)
  if (x) {
    // values in j
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      // row
      i = aindex[k];
      // check value exists in current j
      if (w[i] !== mark) {
        // i is new entry in j
        w[i] = mark;
        // add i to pattern of C
        cindex.push(i);
        // x(i) = A, check we need to call function this time
        if (update) {
          // copy value to workspace calling callback function
          x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          // function was called on current row
          u[i] = mark;
        }
        else {
          // copy value to workspace
          x[i] = avalues[k];
        }
      }
      else {
        // i exists in C already
        x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
        // function was called on current row
        u[i] = mark;
      }
    }
  }
  else {
    // values in j
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      // row
      i = aindex[k];
      // check value exists in current j
      if (w[i] !== mark) {
        // i is new entry in j
        w[i] = mark;
        // add i to pattern of C
        cindex.push(i);
      }
      else {
        // indicate function was called on current row
        u[i] = mark;
      }
    }
  }
};

},{}],357:[function(require,module,exports){
var Emitter = require('tiny-emitter');

/**
 * Extend given object with emitter functions `on`, `off`, `once`, `emit`
 * @param {Object} obj
 * @return {Object} obj
 */
exports.mixin = function (obj) {
  // create event emitter
  var emitter = new Emitter();

  // bind methods to obj (we don't want to expose the emitter.e Array...)
  obj.on   = emitter.on.bind(emitter);
  obj.off  = emitter.off.bind(emitter);
  obj.once = emitter.once.bind(emitter);
  obj.emit = emitter.emit.bind(emitter);

  return obj;
};

},{"tiny-emitter":366}],358:[function(require,module,exports){
// function utils

/*
 * Memoize a given function by caching the computed result.
 * The cache of a memoized function can be cleared by deleting the `cache`
 * property of the function.
 *
 * @param {function} fn                     The function to be memoized.
 *                                          Must be a pure function.
 * @param {function(args: Array)} [hasher]  A custom hash builder.
 *                                          Is JSON.stringify by default.
 * @return {function}                       Returns the memoized function
 */
exports.memoize = function(fn, hasher) {
  return function memoize() {
    if (typeof memoize.cache !== 'object') {
      memoize.cache = {};
    }

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    var hash = hasher ? hasher(args) : JSON.stringify(args);
    if (!(hash in memoize.cache)) {
      return memoize.cache[hash] = fn.apply(fn, args);
    }
    return memoize.cache[hash];
  };
};

/**
 * Find the maximum number of arguments expected by a typed function.
 * @param {function} fn   A typed function
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.max(args, count);
      }, -1);
};

},{}],359:[function(require,module,exports){
'use strict';

exports.array = require('./array');
exports['boolean'] = require('./boolean');
exports['function'] = require('./function');
exports.number = require('./number');
exports.object = require('./object');
exports.string = require('./string');
exports.types = require('./types');
exports.emitter = require('./emitter');

},{"./array":346,"./boolean":350,"./emitter":357,"./function":358,"./number":361,"./object":362,"./string":363,"./types":364}],360:[function(require,module,exports){
'use strict';

exports.symbols = {
  // GREEK LETTERS
  Alpha: 'A',     alpha: '\\alpha',
  Beta: 'B',      beta: '\\beta',
  Gamma: '\\Gamma',    gamma: '\\gamma',
  Delta: '\\Delta',    delta: '\\delta',
  Epsilon: 'E',   epsilon: '\\epsilon',  varepsilon: '\\varepsilon',
  Zeta: 'Z',      zeta: '\\zeta',
  Eta: 'H',       eta: '\\eta',
  Theta: '\\Theta',    theta: '\\theta',    vartheta: '\\vartheta',
  Iota: 'I',      iota: '\\iota',
  Kappa: 'K',     kappa: '\\kappa',    varkappa: '\\varkappa',
  Lambda: '\\Lambda',   lambda: '\\lambda',
  Mu: 'M',        mu: '\\mu',
  Nu: 'N',        nu: '\\nu',
  Xi: '\\Xi',       xi: '\\xi',
  Omicron: 'O',   omicron: 'o',
  Pi: '\\Pi',       pi: '\\pi',       varpi: '\\varpi',
  Rho: 'P',       rho: '\\rho',      varrho: '\\varrho',
  Sigma: '\\Sigma',    sigma: '\\sigma',    varsigma: '\\varsigma',
  Tau: 'T',       tau: '\\tau',
  Upsilon: '\\Upsilon',  upsilon: '\\upsilon',
  Phi: '\\Phi',      phi: '\\phi',      varphi: '\\varphi',
  Chi: 'X',       chi: '\\chi',
  Psi: '\\Psi',      psi: '\\psi',
  Omega: '\\Omega',    omega: '\\omega',
  //logic
  'true': '\\mathrm{True}',
  'false': '\\mathrm{False}',
  //other
  i: 'i', //TODO use \i ??
  inf: '\\infty',
  Inf: '\\infty',
  infinity: '\\infty',
  Infinity: '\\infty',
  oo: '\\infty',
  lim: '\\lim',
  'undefined': '\\mathbf{?}'
};

exports.operators = {
  'transpose': '^\\top',
  'factorial': '!',
  'pow': '^',
  'dotPow': '.^\\wedge', //TODO find ideal solution
  'unaryPlus': '+',
  'unaryMinus': '-',
  'bitNot': '~', //TODO find ideal solution
  'not': '\\neg',
  'multiply': '\\cdot',
  'divide': '\\frac', //TODO how to handle that properly?
  'dotMultiply': '.\\cdot', //TODO find ideal solution
  'dotDivide': '.:', //TODO find ideal solution
  'mod': '\\mod',
  'add': '+',
  'subtract': '-',
  'to': '\\rightarrow',
  'leftShift': '<<',
  'rightArithShift': '>>',
  'rightLogShift': '>>>',
  'equal': '=',
  'unequal': '\\neq',
  'smaller': '<',
  'larger': '>',
  'smallerEq': '\\leq',
  'largerEq': '\\geq',
  'bitAnd': '\\&',
  'bitXor': '\\underline{|}',
  'bitOr': '|',
  'and': '\\wedge',
  'xor': '\\veebar',
  'or': '\\vee'
};

exports.defaultTemplate = '\\mathrm{${name}}\\left(${args}\\right)';

var units = {
  deg: '^\\circ'
};

//@param {string} name
//@param {boolean} isUnit
exports.toSymbol = function (name, isUnit) {
  isUnit = typeof isUnit === 'undefined' ? false : isUnit;
  if (isUnit) {
    if (units.hasOwnProperty(name)) {
      return units[name];
    }
    return '\\mathrm{' + name + '}';
  }

  if (exports.symbols.hasOwnProperty(name)) {
    return exports.symbols[name];
  }
  else if (name.indexOf('_') !== -1) {
    //symbol with index (eg. alpha_1)
    var index = name.indexOf('_');
    return exports.toSymbol(name.substring(0, index)) + '_{'
      + exports.toSymbol(name.substring(index + 1)) + '}';
  }
  return name;
};

},{}],361:[function(require,module,exports){
'use strict';

var NumberFormatter = require('./NumberFormatter');

/**
 * Test whether value is a number
 * @param {*} value
 * @return {boolean} isNumber
 */
exports.isNumber = function(value) {
  return typeof value === 'number';
};

/**
 * Check if a number is integer
 * @param {number | boolean} value
 * @return {boolean} isInteger
 */
exports.isInteger = function(value) {
  return isFinite(value)
      ? (value == Math.round(value))
      : false;
  // Note: we use ==, not ===, as we can have Booleans as well
};

/**
 * Calculate the sign of a number
 * @param {number} x
 * @returns {*}
 */
exports.sign = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  }
  else if (x < 0) {
    return -1;
  }
  else {
    return 0;
  }
};

/**
 * Convert a number to a formatted string representation.
 *
 * Syntax:
 *
 *    format(value)
 *    format(value, options)
 *    format(value, precision)
 *    format(value, fn)
 *
 * Where:
 *
 *    {number} value   The value to be formatted
 *    {Object} options An object with formatting options. Available options:
 *                     {string} notation
 *                         Number notation. Choose from:
 *                         'fixed'          Always use regular number notation.
 *                                          For example '123.40' and '14000000'
 *                         'exponential'    Always use exponential notation.
 *                                          For example '1.234e+2' and '1.4e+7'
 *                         'engineering'    Always use engineering notation.
 *                                          For example '123.4e+0' and '14.0e+6'
 *                         'auto' (default) Regular number notation for numbers
 *                                          having an absolute value between
 *                                          `lower` and `upper` bounds, and uses
 *                                          exponential notation elsewhere.
 *                                          Lower bound is included, upper bound
 *                                          is excluded.
 *                                          For example '123.4' and '1.4e7'.
 *                     {number} precision   A number between 0 and 16 to round
 *                                          the digits of the number.
 *                                          In case of notations 'exponential' and
 *                                          'auto', `precision` defines the total
 *                                          number of significant digits returned
 *                                          and is undefined by default.
 *                                          In case of notation 'fixed',
 *                                          `precision` defines the number of
 *                                          significant digits after the decimal
 *                                          point, and is 0 by default.
 *                     {Object} exponential An object containing two parameters,
 *                                          {number} lower and {number} upper,
 *                                          used by notation 'auto' to determine
 *                                          when to return exponential notation.
 *                                          Default values are `lower=1e-3` and
 *                                          `upper=1e5`.
 *                                          Only applicable for notation `auto`.
 *    {Function} fn    A custom formatting function. Can be used to override the
 *                     built-in notations. Function `fn` is called with `value` as
 *                     parameter and must return a string. Is useful for example to
 *                     format all values inside a matrix in a particular way.
 *
 * Examples:
 *
 *    format(6.4);                                        // '6.4'
 *    format(1240000);                                    // '1.24e6'
 *    format(1/3);                                        // '0.3333333333333333'
 *    format(1/3, 3);                                     // '0.333'
 *    format(21385, 2);                                   // '21000'
 *    format(12.071, {notation: 'fixed'});                // '12'
 *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'
 *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'
 *    format(12345678, {notation: 'engineering'});        // '12.345678e+6'
 *
 * @param {number} value
 * @param {Object | Function | number} [options]
 * @return {string} str The formatted value
 */
exports.format = function(value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (value === Infinity) {
    return 'Infinity';
  }
  else if (value === -Infinity) {
    return '-Infinity';
  }
  else if (isNaN(value)) {
    return 'NaN';
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (exports.isNumber(options)) {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'engineering':
      return exports.toEngineering(value, precision);

    case 'auto':
      return exports
          .toPrecision(value, precision, options && options.exponential)

          // remove trailing zeros after the decimal point
          .replace(/((\.\d*?)(0+))($|e)/, function () {
            var digits = arguments[2];
            var e = arguments[4];
            return (digits !== '.') ? digits + e : e;
          });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
};

/**
 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
 * @param {number} value
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toExponential = function(value, precision) {
  return new NumberFormatter(value).toExponential(precision);
};

/**
 * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
 * @param {number} value
 * @param {number} [precision]  Number of digits in formatted output.
 *                              If not provided, the maximum available digits
 *                              is used.
 * @returns {string} str
 */
exports.toEngineering = function(value, precision) {
  return new NumberFormatter(value).toEngineering(precision);
};

/**
 * Format a number with fixed notation.
 * @param {number} value
 * @param {number} [precision=0]        Optional number of decimals after the
 *                                      decimal point. Zero by default.
 */
exports.toFixed = function(value, precision) {
  return new NumberFormatter(value).toFixed(precision);
};

/**
 * Format a number with a certain precision
 * @param {number} value
 * @param {number} [precision=undefined] Optional number of digits.
 * @param {{lower: number, upper: number}} [options]  By default:
 *                                                    lower = 1e-3 (excl)
 *                                                    upper = 1e+5 (incl)
 * @return {string}
 */
exports.toPrecision = function(value, precision, options) {
  return new NumberFormatter(value).toPrecision(precision, options);
};

/**
 * Count the number of significant digits of a number.
 *
 * For example:
 *   2.34 returns 3
 *   0.0034 returns 2
 *   120.5e+30 returns 4
 *
 * @param {number} value
 * @return {number} digits   Number of significant digits
 */
exports.digits = function(value) {
  return value
      .toExponential()
      .replace(/e.*$/, '')          // remove exponential notation
      .replace( /^0\.?0*|\./, '')   // remove decimal point and leading zeros
      .length
};

/**
 * Minimum number added to one that makes the result different than one
 */
exports.DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;

/**
 * Compares two floating point numbers.
 * @param {number} x          First value to compare
 * @param {number} y          Second value to compare
 * @param {number} [epsilon]  The maximum relative difference between x and y
 *                            If epsilon is undefined or null, the function will
 *                            test whether x and y are exactly equal.
 * @return {boolean} whether the two numbers are nearly equal
*/
exports.nearlyEqual = function(x, y, epsilon) {
  // if epsilon is null or undefined, test whether x and y are exactly equal
  if (epsilon == null) {
    return x == y;
  }

  // use "==" operator, handles infinities
  if (x == y) {
    return true;
  }

  // NaN
  if (isNaN(x) || isNaN(y)) {
    return false;
  }

  // at this point x and y should be finite
  if(isFinite(x) && isFinite(y)) {
    // check numbers are very close, needed when comparing numbers near zero
    var diff = Math.abs(x - y);
    if (diff < exports.DBL_EPSILON) {
      return true;
    }
    else {
      // use relative error
      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }

  // Infinite and Number or negative Infinite and positive Infinite cases
  return false;
};

},{"./NumberFormatter":345}],362:[function(require,module,exports){
'use strict';

/**
 * Clone an object
 *
 *     clone(x)
 *
 * Can clone any primitive type, array, and object.
 * If x has a function clone, this function will be invoked to clone the object.
 *
 * @param {*} x
 * @return {*} clone
 */
exports.clone = function clone(x) {
  var type = typeof x;

  // immutable primitive types
  if (type === 'number' || type === 'string' || type === 'boolean' ||
      x === null || x === undefined) {
    return x;
  }

  // use clone function of the object when available
  if (typeof x.clone === 'function') {
    return x.clone();
  }

  // array
  if (Array.isArray(x)) {
    return x.map(function (value) {
      return clone(value);
    });
  }

  if (x instanceof Number)    return new Number(x.valueOf());
  if (x instanceof String)    return new String(x.valueOf());
  if (x instanceof Boolean)   return new Boolean(x.valueOf());
  if (x instanceof Date)      return new Date(x.valueOf());
  if (x && x.isBigNumber === true) return x; // bignumbers are immutable
  if (x instanceof RegExp)  throw new TypeError('Cannot clone ' + x);  // TODO: clone a RegExp

  // object
  var m = {};
  for (var key in x) {
    if (x.hasOwnProperty(key)) {
      m[key] = clone(x[key]);
    }
  }
  return m;
};

/**
 * Extend object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.extend = function(a, b) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @returns {Object}
 */
exports.deepExtend = function deepExtend (a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop]);
        }
        else {
          a[prop] = b[prop];
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        a[prop] = b[prop];
      }
    }
  }
  return a;
};

/**
 * Deep test equality of all fields in two pairs of arrays or objects.
 * @param {Array | Object} a
 * @param {Array | Object} b
 * @returns {boolean}
 */
exports.deepEqual = function deepEqual (a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }

    if (a.length != b.length) {
      return false;
    }

    for (i = 0, len = a.length; i < len; i++) {
      if (!exports.deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }

    for (prop in a) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    return true;
  }
  else {
    return (typeof a === typeof b) && (a == b);
  }
};

/**
 * Test whether the current JavaScript engine supports Object.defineProperty
 * @returns {boolean} returns true if supported
 */
exports.canDefineProperty = function () {
  // test needed for broken IE8 implementation
  try {
    if (Object.defineProperty) {
      Object.defineProperty({}, 'x', { get: function () {} });
      return true;
    }
  } catch (e) {}

  return false;
};

/**
 * Attach a lazy loading property to a constant.
 * The given function `fn` is called once when the property is first requested.
 * On older browsers (<IE8), the function will fall back to direct evaluation
 * of the properties value.
 * @param {Object} object   Object where to add the property
 * @param {string} prop     Property name
 * @param {Function} fn     Function returning the property value. Called
 *                          without arguments.
 */
exports.lazy = function (object, prop, fn) {
  if (exports.canDefineProperty()) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function () {
        if (_uninitialized) {
          _value = fn();
          _uninitialized = false;
        }
        return _value;
      },

      set: function (value) {
        _value = value;
        _uninitialized = false;
      },

      configurable: true,
      enumerable: true
    });
  }
  else {
    // fall back to immediate evaluation
    object[prop] = fn();
  }
};

/**
 * Traverse a path into an object.
 * When a namespace is missing, it will be created
 * @param {Object} object
 * @param {string} path   A dot separated string like 'name.space'
 * @return {Object} Returns the object at the end of the path
 */
exports.traverse = function(object, path) {
  var obj = object;

  if (path) {
    var names = path.split('.');
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (!(name in obj)) {
        obj[name] = {};
      }
      obj = obj[name];
    }
  }

  return obj;
};

/**
 * Test whether an object is a factory. a factory has fields:
 *
 * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)
 * - name: string (optional)
 * - path: string    A dot separated path (optional)
 * - math: boolean   If true (false by default), the math namespace is passed
 *                   as fifth argument of the factory function
 *
 * @param {*} object
 * @returns {boolean}
 */
exports.isFactory = function (object) {
  return object && typeof object.factory === 'function';
};

},{}],363:[function(require,module,exports){
'use strict';

var formatNumber = require('./number').format;
var formatBigNumber = require('./bignumber/formatter').format;

/**
 * Test whether value is a string
 * @param {*} value
 * @return {boolean} isString
 */
exports.isString = function(value) {
  return typeof value === 'string';
};

/**
 * Check if a text ends with a certain string.
 * @param {string} text
 * @param {string} search
 */
exports.endsWith = function(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return (text.substring(start, end) === search);
};

/**
 * Format a value of any type into a string.
 *
 * Usage:
 *     math.format(value)
 *     math.format(value, precision)
 *
 * When value is a function:
 *
 * - When the function has a property `syntax`, it returns this
 *   syntax description.
 * - In other cases, a string `'function'` is returned.
 *
 * When `value` is an Object:
 *
 * - When the object contains a property `format` being a function, this
 *   function is invoked as `value.format(options)` and the result is returned.
 * - When the object has its own `toString` method, this method is invoked
 *   and the result is returned.
 * - In other cases the function will loop over all object properties and
 *   return JSON object notation like '{"a": 2, "b": 3}'.
 *
 * Example usage:
 *     math.format(2/7);                // '0.2857142857142857'
 *     math.format(math.pi, 3);         // '3.14'
 *     math.format(new Complex(2, 3));  // '2 + 3i'
 *     math.format('hello');            // '"hello"'
 *
 * @param {*} value             Value to be stringified
 * @param {Object | number | Function} [options]  Formatting options. See
 *                                                lib/utils/number:format for a
 *                                                description of the available
 *                                                options.
 * @return {string} str
 */
exports.format = function(value, options) {
  if (typeof value === 'number') {
    return formatNumber(value, options);
  }

  if (value && value.isBigNumber === true) {
    return formatBigNumber(value, options);
  }

  if (value && value.isFraction === true) {
    if (!options || options.fraction !== 'decimal') {
      // output as ratio, like '1/3'
      return (value.s * value.n) + '/' + value.d;
    }
    else {
      // output as decimal, like '0.(3)'
      return value.toString();
    }
  }

  if (Array.isArray(value)) {
    return formatArray(value, options);
  }

  if (exports.isString(value)) {
    return '"' + value + '"';
  }

  if (typeof value === 'function') {
    return value.syntax ? String(value.syntax) : 'function';
  }

  if (value && typeof value === 'object') {
    if (typeof value.format === 'function') {
      return value.format(options);
    }
    else if (value && value.toString() !== {}.toString()) {
      // this object has a non-native toString method, use that one
      return value.toString();
    }
    else {
      var entries = [];

      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          entries.push('"' + key + '": ' + exports.format(value[key], options));
        }
      }

      return '{' + entries.join(', ') + '}';
    }
  }

  return String(value);
};

/**
 * Recursively format an n-dimensional matrix
 * Example output: "[[1, 2], [3, 4]]"
 * @param {Array} array
 * @param {Object | number | Function} [options]  Formatting options. See
 *                                                lib/utils/number:format for a
 *                                                description of the available
 *                                                options.
 * @returns {string} str
 */
function formatArray (array, options) {
  if (Array.isArray(array)) {
    var str = '[';
    var len = array.length;
    for (var i = 0; i < len; i++) {
      if (i != 0) {
        str += ', ';
      }
      str += formatArray(array[i], options);
    }
    str += ']';
    return str;
  }
  else {
    return exports.format(array, options);
  }
}

},{"./bignumber/formatter":348,"./number":361}],364:[function(require,module,exports){
'use strict';

/**
 * Determine the type of a variable
 *
 *     type(x)
 *
 * The following types are recognized:
 *
 *     'undefined'
 *     'null'
 *     'boolean'
 *     'number'
 *     'string'
 *     'Array'
 *     'Function'
 *     'Date'
 *     'RegExp'
 *     'Object'
 *
 * @param {*} x
 * @return {string} Returns the name of the type. Primitive types are lower case,
 *                  non-primitive types are upper-camel-case.
 *                  For example 'number', 'string', 'Array', 'Date'.
 */
exports.type = function(x) {
  var type = typeof x;

  if (type === 'object') {
    if (x === null)           return 'null';
    if (x instanceof Boolean) return 'boolean';
    if (x instanceof Number)  return 'number';
    if (x instanceof String)  return 'string';
    if (Array.isArray(x))     return 'Array';
    if (x instanceof Date)    return 'Date';
    if (x instanceof RegExp)  return 'RegExp';

    return 'Object';
  }

  if (type === 'function')    return 'Function';

  return type;
};

/**
 * Test whether a value is a scalar
 * @param x
 * @return {boolean} Returns true when x is a scalar, returns false when
 *                   x is a Matrix or Array.
 */
exports.isScalar = function (x) {
  return !((x && x.isMatrix) || Array.isArray(x));
};

},{}],365:[function(require,module,exports){
/**
 * @license Complex.js v2.0.1 11/02/2016
 *
 * Copyright (c) 2016, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/

/**
 *
 * This class allows the manipilation of complex numbers.
 * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
 *
 * Object form
 * { re: <real>, im: <imaginary> }
 * { arg: <angle>, abs: <radius> }
 * { phi: <angle>, r: <radius> }
 *
 * Double form
 * 99.3 - Single double value
 *
 * String form
 * "23.1337" - Simple real number
 * "15+3i" - a simple complex number
 * "3-i" - a simple complex number
 *
 * Example:
 *
 * var c = new Complex("99.3+8i");
 * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
 *
 */

(function(root) {

  "use strict";

  var P = {'re': 0, 'im': 0};

  Math.cosh = Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) * 0.5;
  };

  Math.sinh = Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) * 0.5;
  };

  var parser_exit = function() {
    throw SyntaxError("Invalid Param");
  };

  /**
   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
   *
   * @param {number} a
   * @param {number} b
   * @returns {number}
   */
  function logHypot(a, b) {

    var _a = Math.abs(a);
    var _b = Math.abs(b);

    if (a === 0) {
      return Math.log(_b);
    }

    if (b === 0) {
      return Math.log(_a);
    }

    if (_a < 3000 && _b < 3000) {
      return Math.log(a * a + b * b) * 0.5;
    }

    /* I got 4 ideas to compute this property without overflow:
     *
     * Testing 1000000 times with random samples for a,b  [1, 1000000000] against a big decimal library to get an error estimate
     *
     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

     Math.log(a * a + b * b) / 2

     *
     *
     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

     var fn = function(a, b) {
     a = Math.abs(a);
     b = Math.abs(b);
     var t = Math.min(a, b);
     a = Math.max(a, b);
     t = t / a;

     return Math.log(a) + Math.log(1 + t * t) / 2;
     };

     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

     Math.log(a / Math.cos(Math.atan2(b, a)))

     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

     */

    return Math.log(a / Math.cos(Math.atan2(b, a)));
  }

  var parse = function(a, b) {

    if (a === undefined || a === null) {
      P["re"] =
      P["im"] = 0;
    } else if (b !== undefined) {
      P["re"] = a;
      P["im"] = b;
    } else switch (typeof a) {

      case "object":

        if ("im" in a && "re" in a) {
          P["re"] = a["re"];
          P["im"] = a["im"];
        } else if ("abs" in a && "arg" in a) {
          P["re"] = a["abs"] * Math.cos(a["arg"]);
          P["im"] = a["abs"] * Math.sin(a["arg"]);
        } else if ("r" in a && "phi" in a) {
          P["re"] = a["r"] * Math.cos(a["phi"]);
          P["im"] = a["r"] * Math.sin(a["phi"]);
        } else {
          parser_exit();
        }
        break;

      case "string":

        P["im"] = /* void */
        P["re"] = 0;

        var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
        var plus = 1;
        var minus = 0;

        if (tokens === null) {
          parser_exit();
        }

        for (var i = 0; i < tokens.length; i++) {

          var c = tokens[i];

          if (c === ' ' || c === '\t' || c === '\n') {
            /* void */
          } else if (c === '+') {
            plus++;
          } else if (c === '-') {
            minus++;
          } else if (c === 'i' || c === 'I') {

            if (plus + minus === 0) {
              parser_exit();
            }

            if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
              P["im"]+= parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
              i++;
            } else {
              P["im"]+= parseFloat((minus % 2 ? "-" : "") + "1");
            }
            plus = minus = 0;

          } else {

            if (plus + minus === 0 || isNaN(c)) {
              parser_exit();
            }

            if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
              P["im"]+= parseFloat((minus % 2 ? "-" : "") + c);
              i++;
            } else {
              P["re"]+= parseFloat((minus % 2 ? "-" : "") + c);
            }
            plus = minus = 0;
          }
        }

        // Still something on the stack
        if (plus + minus > 0) {
          parser_exit();
        }
        break;

      case "number":
        P["im"] = 0;
        P["re"] = a;
        break;

      default:
        parser_exit();
    }

    if (isNaN(P["re"]) || isNaN(P["im"])) {
      // If a calculation is NaN, we treat it as NaN and don't throw
      //parser_exit();
    }
  };

  /**
   * @constructor
   * @returns {Complex}
   */
  function Complex(a, b) {

    if (!(this instanceof Complex)) {
      return new Complex(a, b);
    }

    parse(a, b); // mutates P

    this["re"] = P["re"];
    this["im"] = P["im"];
  }

  Complex.prototype = {

    "re": 0,
    "im": 0,

    /**
     * Calculates the sign of a complex number
     *
     * @returns {Complex}
     */
    "sign": function() {

      var abs = this["abs"]();

      return new Complex(
              this["re"] / abs,
              this["im"] / abs);
    },

    /**
     * Adds two complex numbers
     *
     * @returns {Complex}
     */
    "add": function(a, b) {

      parse(a, b); // mutates P

      return new Complex(
              this["re"] + P["re"],
              this["im"] + P["im"]);
    },

    /**
     * Subtracts two complex numbers
     *
     * @returns {Complex}
     */
    "sub": function(a, b) {

      parse(a, b); // mutates P

      return new Complex(
              this["re"] - P["re"],
              this["im"] - P["im"]);
    },

    /**
     * Multiplies two complex numbers
     *
     * @returns {Complex}
     */
    "mul": function(a, b) {

      parse(a, b); // mutates P

      // Besides the addition/subtraction, this helps having a solution for rational Infinity
      if (P['im'] === 0 && this['im'] === 0) {
        return new Complex(this['re'] * P['re'], 0);
      }

      return new Complex(
              this["re"] * P["re"] - this["im"] * P["im"],
              this["re"] * P["im"] + this["im"] * P["re"]);
    },

    /**
     * Divides two complex numbers
     *
     * @returns {Complex}
     */
    "div": function(a, b) {

      parse(a, b); // mutates P

      a = this["re"];
      b = this["im"];

      var c = P["re"];
      var d = P["im"];
      var t, x;

      // Divisor is zero
      if (0 === c && 0 === d) {
        return new Complex(
                (a !== 0) ? (a / 0) : 0,
                (b !== 0) ? (b / 0) : 0);
      }

      // Divisor is rational
      if (0 === d) {
        return new Complex(a / c, b / c);
      }

      if (Math.abs(c) < Math.abs(d)) {

        x = c / d;
        t = c * x + d;

        return new Complex(
                (a * x + b) / t,
                (b * x - a) / t);

      } else {

        x = d / c;
        t = d * x + c;

        return new Complex(
                (a + b * x) / t,
                (b - a * x) / t);
      }
    },

    /**
     * Calculate the power of two complex numbers
     *
     * @returns {Complex}
     */
    "pow": function(a, b) {

      parse(a, b); // mutates P

      a = this["re"];
      b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(0, 0);
      }

      var arg = Math.atan2(b, a);
      var loh = logHypot(a, b);

      if (P["im"] === 0) {

        if (b === 0 && a >= 0) {

          return new Complex(Math.pow(a, P["re"]), 0);

        } else if (a === 0) {

          switch (P["re"] % 4) {
            case 0:
              return new Complex(Math.pow(b, P["re"]), 0);
            case 1:
              return new Complex(0, Math.pow(b, P["re"]));
            case 2:
              return new Complex(-Math.pow(b, P["re"]), 0);
            case 3:
              return new Complex(0, -Math.pow(b, P["re"]));
          }
        }
      }

      /* I couldn"t find a good formula, so here is a derivation and optimization
       *
       * z_1^z_2 = (a + bi)^(c + di)
       *         = exp((c + di) * log(a + bi)
       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
       * =>...
       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       *
       * =>...
       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       *
       * =>
       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
       *
       */

      a = Math.exp(P["re"] * loh - P["im"] * arg);
      b = P["im"] * loh + P["re"] * arg;
      return new Complex(
              a * Math.cos(b),
              a * Math.sin(b));
    },

    /**
     * Calculate the complex square root
     *
     * @returns {Complex}
     */
    "sqrt": function() {

      var a = this["re"];
      var b = this["im"];
      var r = this["abs"]();

      var re, im;

      if (a >= 0 && b === 0) {
        return new Complex(Math.sqrt(a), 0);
      }

      if (a >= 0) {
        re = 0.5 * Math.sqrt(2.0 * (r + a));
      } else {
        re = Math.abs(b) / Math.sqrt(2 * (r - a));
      }

      if (a <= 0) {
        im = 0.5 * Math.sqrt(2.0 * (r - a));
      } else {
        im = Math.abs(b) / Math.sqrt(2 * (r + a));
      }

      return new Complex(re, b >= 0 ? im : -im);
    },

    /**
     * Calculate the complex exponent
     *
     * @returns {Complex}
     */
    "exp": function() {

      var tmp = Math.exp(this["re"]);

      if (this["im"] === 0) {
        //return new Complex(tmp, 0);
      }
      return new Complex(
              tmp * Math.cos(this["im"]),
              tmp * Math.sin(this["im"]));
    },

    /**
     * Calculate the natural log
     *
     * @returns {Complex}
     */
    "log": function() {

      var a = this["re"];
      var b = this["im"];
      
      if (b === 0 && a > 0) {
        //return new Complex(Math.log(a), 0);
      }

      return new Complex(
              logHypot(a, b),
              Math.atan2(b, a));
    },

    /**
     * Calculate the magniture of the complex number
     *
     * @returns {number}
     */
    "abs": function() {

      var a = Math.abs(this["re"]);
      var b = Math.abs(this["im"]);

      if (a < 3000 && b < 3000) {
        return Math.sqrt(a * a + b * b);
      }

      if (a < b) {
        a = b;
        b = this["re"] / this["im"];
      } else {
        b = this["im"] / this["re"];
      }
      return a * Math.sqrt(1 + b * b);
    },

    /**
     * Calculate the angle of the complex number
     *
     * @returns {number}
     */
    "arg": function() {

      return Math.atan2(this["im"], this["re"]);
    },

    /**
     * Calculate the sine of the complex number
     *
     * @returns {Complex}
     */
    "sin": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.sin(a) * Math.cosh(b),
              Math.cos(a) * Math.sinh(b));
    },

    /**
     * Calculate the cosine
     *
     * @returns {Complex}
     */
    "cos": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.cos(a) * Math.cosh(b),
             -Math.sin(a) * Math.sinh(b));
    },

    /**
     * Calculate the tangent
     *
     * @returns {Complex}
     */
    "tan": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cos(a) + Math.cosh(b);

      return new Complex(
              Math.sin(a) / d,
              Math.sinh(b) / d);
    },

    /**
     * Calculate the cotangent
     *
     * @returns {Complex}
     */
    "cot": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cos(a) - Math.cosh(b);

      return new Complex(
             -Math.sin(a) / d,
              Math.sinh(b) / d);
    },

    /**
     * Calculate the secant
     *
     * @returns {Complex}
     */
    "sec": function() {

      var a = this["re"];
      var b = this["im"];
      var d = 0.5 * Math.cosh(2 * b) + 0.5 * Math.cos(2 * a);

      return new Complex(
              Math.cos(a) * Math.cosh(b) / d,
              Math.sin(a) * Math.sinh(b) / d);
    },

    /**
     * Calculate the cosecans
     *
     * @returns {Complex}
     */
    "csc": function() {

      var a = this["re"];
      var b = this["im"];
      var d = 0.5 * Math.cosh(2 * b) - 0.5 * Math.cos(2 * a);

      return new Complex(
              Math.sin(a) * Math.cosh(b) / d,
             -Math.cos(a) * Math.sinh(b) / d);
    },

    /**
     * Calculate the complex arcus sinus
     *
     * @returns {Complex}
     */
    "asin": function() {

      var a = this["re"];
      var b = this["im"];

      var t1 = new Complex(
               b * b - a * a + 1,
              -2 * a * b)['sqrt']();

      var t2 = new Complex(
              t1['re'] - b,
              t1['im'] + a)['log']();

      return new Complex(t2['im'], -t2['re']);
    },

    /**
     * Calculate the complex arcus cosinus
     *
     * @returns {Complex}
     */
    "acos": function() {

      var a = this["re"];
      var b = this["im"];

      var t1 = new Complex(
               b * b - a * a + 1,
              -2 * a * b)['sqrt']();

      var t2 = new Complex(
              t1["re"] - b,
              t1["im"] + a)['log']();

      return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
    },

    /**
     * Calculate the complex arcus tangent
     *
     * @returns {Complex}
     */
    "atan": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0) {

        if (b === 1) {
          return new Complex(0, Infinity);
        }

        if (b === -1) {
          return new Complex(0, -Infinity);
        }
      }

      var d = a * a + (1.0 - b) * (1.0 - b);

      var t1 = new Complex(
              (1 - b * b - a * a) / d,
              -2 * a / d).log();

      return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
    },

    /**
     * Calculate the complex arcus cotangent
     *
     * @returns {Complex}
     */
    "acot": function() {

      var a = this["re"];
      var b = this["im"];

      if (b === 0) {
        return new Complex(Math.atan2(1, a), 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).atan()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).atan();
    },

    /**
     * Calculate the complex arcus secant
     *
     * @returns {Complex}
     */
    "asec": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(0, Infinity);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).acos()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).acos();
    },

    /**
     * Calculate the complex arcus cosecans
     *
     * @returns {Complex}
     */
    "acsc": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(Math.PI / 2, Infinity);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).asin()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).asin();
    },

    /**
     * Calculate the complex sinh
     *
     * @returns {Complex}
     */
    "sinh": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.sinh(a) * Math.cos(b),
              Math.cosh(a) * Math.sin(b));
    },

    /**
     * Calculate the complex cosh
     *
     * @returns {Complex}
     */
    "cosh": function() {

      var a = this["re"];
      var b = this["im"];

      return new Complex(
              Math.cosh(a) * Math.cos(b),
              Math.sinh(a) * Math.sin(b));
    },

    /**
     * Calculate the complex tanh
     *
     * @returns {Complex}
     */
    "tanh": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cosh(a) + Math.cos(b);

      return new Complex(
              Math.sinh(a) / d,
              Math.sin(b) / d);
    },

    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    "coth": function() {

      var a = 2 * this["re"];
      var b = 2 * this["im"];
      var d = Math.cosh(a) - Math.cos(b);

      return new Complex(
              Math.sinh(a) / d,
             -Math.sin(b) / d);
    },

    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    "csch": function() {

      var a = this["re"];
      var b = this["im"];
      var d = Math.cos(2 * b) - Math.cosh(2 * a);

      return new Complex(
           -2 * Math.sinh(a) * Math.cos(b) / d, 
            2 * Math.cosh(a) * Math.sin(b) / d);
    },

    /**
     * Calculate the complex sech
     *
     * @returns {Complex}
     */
    "sech": function() {

      var a = this["re"];
      var b = this["im"];
      var d = Math.cos(2 * b) + Math.cosh(2 * a);

      return new Complex(
              2 * Math.cosh(a) * Math.cos(b) / d, 
             -2 * Math.sinh(a) * Math.sin(b) / d);
    },

    /**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */
    "asinh": function() {

      var tmp = this["im"];
      this["im"] = -this["re"];
      this["re"] = tmp;
      var res = this["asin"]();

      this["re"] = -this["im"];
      this["im"] = tmp;
      tmp = res["re"];

      res["re"] = -res["im"];
      res["im"] = tmp;
      return res;
    },

    /**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */
    "acosh": function() {

      var tmp;
      var res = this["acos"]();
      if (res["im"] <= 0) {
        tmp = res["re"];
        res["re"] = -res["im"];
        res["im"] = tmp;
      } else {
        tmp = res["im"];
        res["im"] = -res["re"];
        res["re"] = tmp;
      }
      return res;
    },

    /**
     * Calculate the complex atanh
     *
     * @returns {Complex}
     */
    "atanh": function() {

      var a = this["re"];
      var b = this["im"];

      var noIM = a > 1 && b === 0;
      var oneMinus = 1 - a;
      var onePlus = 1 + a;
      var d = oneMinus * oneMinus + b * b;

      var x = (d !== 0)
              ? new Complex(
                      (onePlus * oneMinus - b * b) / d,
                      (b * oneMinus + onePlus * b) / d)
              : new Complex(
                      (a !== -1) ? (a / 0) : 0,
                      (b !== 0) ? (b / 0) : 0);

      var temp = x["re"];
      x["re"] = logHypot(x["re"], x["im"]) / 2;
      x["im"] = Math.atan2(x["im"], temp) / 2;
      if (noIM) {
        x["im"] = -x["im"];
      }
      return x;
    },

    /**
     * Calculate the complex acoth
     *
     * @returns {Complex}
     */
    "acoth": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {

        return new Complex(0, Math.PI / 2);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).atanh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).atanh();
    },

    /**
     * Calculate the complex acsch
     *
     * @returns {Complex}
     */
    "acsch": function() {

      var a = this["re"];
      var b = this["im"];

      if (b === 0) {

        return new Complex(
                (a !== 0)
                ? Math.log(a + Math.sqrt(a * a + 1))
                : Infinity, 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).asinh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).asinh();
    },

    /**
     * Calculate the complex asech
     *
     * @returns {Complex}
     */
    "asech": function() {

      var a = this["re"];
      var b = this["im"];

      if (a === 0 && b === 0) {
        return new Complex(Infinity, 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                     -b / d).acosh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ?-b / 0 : 0).acosh();
    },

    /**
     * Calculate the complex inverse 1/z
     *
     * @returns {Complex}
     */
    "inverse": function() {

      var a = this["re"];
      var b = this["im"];

      var d = a * a + b * b;

      return new Complex(
              a !== 0 ? a / d : 0,
              b !== 0 ?-b / d : 0);
    },

    /**
     * Returns the complex conjugate
     *
     * @returns {Complex}
     */
    "conjugate": function() {

      return new Complex(this["re"], -this["im"]);
    },

    /**
     * Gets the negated complex number
     *
     * @returns {Complex}
     */
    "neg": function() {

      return new Complex(-this["re"], -this["im"]);
    },

    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.ceil(this["re"] * places) / places,
              Math.ceil(this["im"] * places) / places);
    },

    /**
     * Floors the actual complex number
     *
     * @returns {Complex}
     */
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.floor(this["re"] * places) / places,
              Math.floor(this["im"] * places) / places);
    },

    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    "round": function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.round(this["re"] * places) / places,
              Math.round(this["im"] * places) / places);
    },

    /**
     * Compares two complex numbers
     *
     * @returns {boolean}
     */
    "equals": function(a, b) {

      parse(a, b); // mutates P

      return Math.abs(P["re"] - this["re"]) <= Complex["EPSILON"] &&
             Math.abs(P["im"] - this["im"]) <= Complex["EPSILON"];
    },

    /**
     * Clones the actual object
     *
     * @returns {Complex}
     */
    "clone": function() {

      return new Complex(this["re"], this["im"]);
    },

    /**
     * Gets a string of the actual complex number
     *
     * @returns {string}
     */
    "toString": function() {

      var a = this["re"];
      var b = this["im"];
      var ret = "";

      if (isNaN(a) || isNaN(b)) {
        return "NaN";
      }

      if (a !== 0) {
        ret+= a;
      }

      if (b !== 0) {

        if (a !== 0) {
          ret+= b < 0 ? " - " : " + ";
        } else if (b < 0) {
          ret+= "-";
        }

        b = Math.abs(b);

        if (1 !== b) {
          ret+= b;
        }
        ret+= "i";
      }

      if (!ret)
        return "0";

      return ret;
    },

    /**
     * Returns the actual number as a vector
     *
     * @returns {Array}
     */
    "toVector": function() {

      return [this["re"], this["im"]];
    },

    /**
     * Returns the actual real value of the current object
     *
     * @returns {number|null}
     */
    "valueOf": function() {

      if (this["im"] === 0) {
        return this["re"];
      }
      return null;
    },

    /**
     * Checks if the given complex number is not a number
     *
     * @returns {boolean}
     */
    isNaN: function() {
      return isNaN(this['re']) || isNaN(this['im']);
    }
  };

  Complex["ZERO"] = new Complex(0, 0);
  Complex["ONE"] = new Complex(1, 0);
  Complex["I"] = new Complex(0, 1);
  Complex["PI"] = new Complex(Math.PI, 0);
  Complex["E"] = new Complex(Math.E, 0);
  Complex['EPSILON'] = 1e-16;

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Complex;
    });
  } else if (typeof exports === "object") {
    module["exports"] = Complex;
  } else {
    root["Complex"] = Complex;
  }
  
})(this);

},{}],366:[function(require,module,exports){
function E () {
	// Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
	on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;

},{}],367:[function(require,module,exports){
/**
 * typed-function
 *
 * Type checking for JavaScript functions
 *
 * https://github.com/josdejong/typed-function
 */
'use strict';

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // OldNode. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like OldNode.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.typed = factory();
  }
}(this, function () {
  // factory function to create a new instance of typed-function
  // TODO: allow passing configuration, types, tests via the factory function
  function create() {
    /**
     * Get a type test function for a specific data type
     * @param {string} name                   Name of a data type like 'number' or 'string'
     * @returns {Function(obj: *) : boolean}  Returns a type testing function.
     *                                        Throws an error for an unknown type.
     */
    function getTypeTest(name) {
      var test;
      for (var i = 0; i < typed.types.length; i++) {
        var entry = typed.types[i];
        if (entry.name === name) {
          test = entry.test;
          break;
        }
      }

      if (!test) {
        var hint;
        for (i = 0; i < typed.types.length; i++) {
          entry = typed.types[i];
          if (entry.name.toLowerCase() == name.toLowerCase()) {
            hint = entry.name;
            break;
          }
        }

        throw new Error('Unknown type "' + name + '"' +
            (hint ? ('. Did you mean "' + hint + '"?') : ''));
      }
      return test;
    }

    /**
     * Retrieve the function name from a set of functions, and check
     * whether the name of all functions match (if given)
     * @param {Array.<function>} fns
     */
    function getName (fns) {
      var name = '';

      for (var i = 0; i < fns.length; i++) {
        var fn = fns[i];

        // merge function name when this is a typed function
        if (fn.signatures && fn.name != '') {
          if (name == '') {
            name = fn.name;
          }
          else if (name != fn.name) {
            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
            err.data = {
              actual: fn.name,
              expected: name
            };
            throw err;
          }
        }
      }

      return name;
    }

    /**
     * Create an ArgumentsError. Creates messages like:
     *
     *   Unexpected type of argument (expected: ..., actual: ..., index: ...)
     *   Too few arguments (expected: ..., index: ...)
     *   Too many arguments (expected: ..., actual: ...)
     *
     * @param {String} fn         Function name
     * @param {number} argCount   Number of arguments
     * @param {Number} index      Current argument index
     * @param {*} actual          Current argument
     * @param {string} [expected] An optional, comma separated string with
     *                            expected types on given index
     * @extends Error
     */
    function createError(fn, argCount, index, actual, expected) {
      var actualType = getTypeOf(actual);
      var _expected = expected ? expected.split(',') : null;
      var _fn = (fn || 'unnamed');
      var anyType = _expected && contains(_expected, 'any');
      var message;
      var data = {
        fn: fn,
        index: index,
        actual: actual,
        expected: _expected
      };

      if (_expected) {
        if (argCount > index && !anyType) {
          // unexpected type
          message = 'Unexpected type of argument in function ' + _fn +
              ' (expected: ' + _expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')';
        }
        else {
          // too few arguments
          message = 'Too few arguments in function ' + _fn +
              ' (expected: ' + _expected.join(' or ') + ', index: ' + index + ')';
        }
      }
      else {
        // too many arguments
        message = 'Too many arguments in function ' + _fn +
            ' (expected: ' + index + ', actual: ' + argCount + ')'
      }

      var err = new TypeError(message);
      err.data = data;
      return err;
    }

    /**
     * Collection with function references (local shortcuts to functions)
     * @constructor
     * @param {string} [name='refs']  Optional name for the refs, used to generate
     *                                JavaScript code
     */
    function Refs(name) {
      this.name = name || 'refs';
      this.categories = {};
    }

    /**
     * Add a function reference.
     * @param {Function} fn
     * @param {string} [category='fn']    A function category, like 'fn' or 'signature'
     * @returns {string} Returns the function name, for example 'fn0' or 'signature2'
     */
    Refs.prototype.add = function (fn, category) {
      var cat = category || 'fn';
      if (!this.categories[cat]) this.categories[cat] = [];

      var index = this.categories[cat].indexOf(fn);
      if (index == -1) {
        index = this.categories[cat].length;
        this.categories[cat].push(fn);
      }

      return cat + index;
    };

    /**
     * Create code lines for all function references
     * @returns {string} Returns the code containing all function references
     */
    Refs.prototype.toCode = function () {
      var code = [];
      var path = this.name + '.categories';
      var categories = this.categories;

      for (var cat in categories) {
        if (categories.hasOwnProperty(cat)) {
          var category = categories[cat];

          for (var i = 0; i < category.length; i++) {
            code.push('var ' + cat + i + ' = ' + path + '[\'' + cat + '\'][' + i + '];');
          }
        }
      }

      return code.join('\n');
    };

    /**
     * A function parameter
     * @param {string | string[] | Param} types    A parameter type like 'string',
     *                                             'number | boolean'
     * @param {boolean} [varArgs=false]            Variable arguments if true
     * @constructor
     */
    function Param(types, varArgs) {
      // parse the types, can be a string with types separated by pipe characters |
      if (typeof types === 'string') {
        // parse variable arguments operator (ellipses '...number')
        var _types = types.trim();
        var _varArgs = _types.substr(0, 3) === '...';
        if (_varArgs) {
          _types = _types.substr(3);
        }
        if (_types === '') {
          this.types = ['any'];
        }
        else {
          this.types = _types.split('|');
          for (var i = 0; i < this.types.length; i++) {
            this.types[i] = this.types[i].trim();
          }
        }
      }
      else if (Array.isArray(types)) {
        this.types = types;
      }
      else if (types instanceof Param) {
        return types.clone();
      }
      else {
        throw new Error('String or Array expected');
      }

      // can hold a type to which to convert when handling this parameter
      this.conversions = [];
      // TODO: implement better API for conversions, be able to add conversions via constructor (support a new type Object?)

      // variable arguments
      this.varArgs = _varArgs || varArgs || false;

      // check for any type arguments
      this.anyType = this.types.indexOf('any') !== -1;
    }

    /**
     * Order Params
     * any type ('any') will be ordered last, and object as second last (as other
     * types may be an object as well, like Array).
     *
     * @param {Param} a
     * @param {Param} b
     * @returns {number} Returns 1 if a > b, -1 if a < b, and else 0.
     */
    Param.compare = function (a, b) {
      // TODO: simplify parameter comparison, it's a mess
      if (a.anyType) return 1;
      if (b.anyType) return -1;

      if (contains(a.types, 'Object')) return 1;
      if (contains(b.types, 'Object')) return -1;

      if (a.hasConversions()) {
        if (b.hasConversions()) {
          var i, ac, bc;

          for (i = 0; i < a.conversions.length; i++) {
            if (a.conversions[i] !== undefined) {
              ac = a.conversions[i];
              break;
            }
          }

          for (i = 0; i < b.conversions.length; i++) {
            if (b.conversions[i] !== undefined) {
              bc = b.conversions[i];
              break;
            }
          }

          return typed.conversions.indexOf(ac) - typed.conversions.indexOf(bc);
        }
        else {
          return 1;
        }
      }
      else {
        if (b.hasConversions()) {
          return -1;
        }
        else {
          // both params have no conversions
          var ai, bi;

          for (i = 0; i < typed.types.length; i++) {
            if (typed.types[i].name === a.types[0]) {
              ai = i;
              break;
            }
          }

          for (i = 0; i < typed.types.length; i++) {
            if (typed.types[i].name === b.types[0]) {
              bi = i;
              break;
            }
          }

          return ai - bi;
        }
      }
    };

    /**
     * Test whether this parameters types overlap an other parameters types.
     * Will not match ['any'] with ['number']
     * @param {Param} other
     * @return {boolean} Returns true when there are overlapping types
     */
    Param.prototype.overlapping = function (other) {
      for (var i = 0; i < this.types.length; i++) {
        if (contains(other.types, this.types[i])) {
          return true;
        }
      }
      return false;
    };

    /**
     * Test whether this parameters types matches an other parameters types.
     * When any of the two parameters contains `any`, true is returned
     * @param {Param} other
     * @return {boolean} Returns true when there are matching types
     */
    Param.prototype.matches = function (other) {
      return this.anyType || other.anyType || this.overlapping(other);
    };

    /**
     * Create a clone of this param
     * @returns {Param} Returns a cloned version of this param
     */
    Param.prototype.clone = function () {
      var param = new Param(this.types.slice(), this.varArgs);
      param.conversions = this.conversions.slice();
      return param;
    };

    /**
     * Test whether this parameter contains conversions
     * @returns {boolean} Returns true if the parameter contains one or
     *                    multiple conversions.
     */
    Param.prototype.hasConversions = function () {
      return this.conversions.length > 0;
    };

    /**
     * Tests whether this parameters contains any of the provided types
     * @param {Object} types  A Map with types, like {'number': true}
     * @returns {boolean}     Returns true when the parameter contains any
     *                        of the provided types
     */
    Param.prototype.contains = function (types) {
      for (var i = 0; i < this.types.length; i++) {
        if (types[this.types[i]]) {
          return true;
        }
      }
      return false;
    };

    /**
     * Return a string representation of this params types, like 'string' or
     * 'number | boolean' or '...number'
     * @param {boolean} [toConversion]   If true, the returned types string
     *                                   contains the types where the parameter
     *                                   will convert to. If false (default)
     *                                   the "from" types are returned
     * @returns {string}
     */
    Param.prototype.toString = function (toConversion) {
      var types = [];
      var keys = {};

      for (var i = 0; i < this.types.length; i++) {
        var conversion = this.conversions[i];
        var type = toConversion && conversion ? conversion.to : this.types[i];
        if (!(type in keys)) {
          keys[type] = true;
          types.push(type);
        }
      }

      return (this.varArgs ? '...' : '') + types.join('|');
    };

    /**
     * A function signature
     * @param {string | string[] | Param[]} params
     *                         Array with the type(s) of each parameter,
     *                         or a comma separated string with types
     * @param {Function} fn    The actual function
     * @constructor
     */
    function Signature(params, fn) {
      var _params;
      if (typeof params === 'string') {
        _params = (params !== '') ? params.split(',') : [];
      }
      else if (Array.isArray(params)) {
        _params = params;
      }
      else {
        throw new Error('string or Array expected');
      }

      this.params = new Array(_params.length);
      this.anyType = false;
      this.varArgs = false;
      for (var i = 0; i < _params.length; i++) {
        var param = new Param(_params[i]);
        this.params[i] = param;
        if (param.anyType) {
          this.anyType = true;
        }
        if (i === _params.length - 1) {
          // the last argument
          this.varArgs = param.varArgs;
        }
        else {
          // non-last argument
          if (param.varArgs) {
            throw new SyntaxError('Unexpected variable arguments operator "..."');
          }
        }
      }

      this.fn = fn;
    }

    /**
     * Create a clone of this signature
     * @returns {Signature} Returns a cloned version of this signature
     */
    Signature.prototype.clone = function () {
      return new Signature(this.params.slice(), this.fn);
    };

    /**
     * Expand a signature: split params with union types in separate signatures
     * For example split a Signature "string | number" into two signatures.
     * @return {Signature[]} Returns an array with signatures (at least one)
     */
    Signature.prototype.expand = function () {
      var signatures = [];

      function recurse(signature, path) {
        if (path.length < signature.params.length) {
          var i, newParam, conversion;

          var param = signature.params[path.length];
          if (param.varArgs) {
            // a variable argument. do not split the types in the parameter
            newParam = param.clone();

            // add conversions to the parameter
            // recurse for all conversions
            for (i = 0; i < typed.conversions.length; i++) {
              conversion = typed.conversions[i];
              if (!contains(param.types, conversion.from) && contains(param.types, conversion.to)) {
                var j = newParam.types.length;
                newParam.types[j] = conversion.from;
                newParam.conversions[j] = conversion;
              }
            }

            recurse(signature, path.concat(newParam));
          }
          else {
            // split each type in the parameter
            for (i = 0; i < param.types.length; i++) {
              recurse(signature, path.concat(new Param(param.types[i])));
            }

            // recurse for all conversions
            for (i = 0; i < typed.conversions.length; i++) {
              conversion = typed.conversions[i];
              if (!contains(param.types, conversion.from) && contains(param.types, conversion.to)) {
                newParam = new Param(conversion.from);
                newParam.conversions[0] = conversion;
                recurse(signature, path.concat(newParam));
              }
            }
          }
        }
        else {
          signatures.push(new Signature(path, signature.fn));
        }
      }

      recurse(this, []);

      return signatures;
    };

    /**
     * Compare two signatures.
     *
     * When two params are equal and contain conversions, they will be sorted
     * by lowest index of the first conversions.
     *
     * @param {Signature} a
     * @param {Signature} b
     * @returns {number} Returns 1 if a > b, -1 if a < b, and else 0.
     */
    Signature.compare = function (a, b) {
      if (a.params.length > b.params.length) return 1;
      if (a.params.length < b.params.length) return -1;

      // count the number of conversions
      var i;
      var len = a.params.length; // a and b have equal amount of params
      var ac = 0;
      var bc = 0;
      for (i = 0; i < len; i++) {
        if (a.params[i].hasConversions()) ac++;
        if (b.params[i].hasConversions()) bc++;
      }

      if (ac > bc) return 1;
      if (ac < bc) return -1;

      // compare the order per parameter
      for (i = 0; i < a.params.length; i++) {
        var cmp = Param.compare(a.params[i], b.params[i]);
        if (cmp !== 0) {
          return cmp;
        }
      }

      return 0;
    };

    /**
     * Test whether any of the signatures parameters has conversions
     * @return {boolean} Returns true when any of the parameters contains
     *                   conversions.
     */
    Signature.prototype.hasConversions = function () {
      for (var i = 0; i < this.params.length; i++) {
        if (this.params[i].hasConversions()) {
          return true;
        }
      }
      return false;
    };

    /**
     * Test whether this signature should be ignored.
     * Checks whether any of the parameters contains a type listed in
     * typed.ignore
     * @return {boolean} Returns true when the signature should be ignored
     */
    Signature.prototype.ignore = function () {
      // create a map with ignored types
      var types = {};
      for (var i = 0; i < typed.ignore.length; i++) {
        types[typed.ignore[i]] = true;
      }

      // test whether any of the parameters contains this type
      for (i = 0; i < this.params.length; i++) {
        if (this.params[i].contains(types)) {
          return true;
        }
      }

      return false;
    };

    /**
     * Test whether the path of this signature matches a given path.
     * @param {Param[]} params
     */
    Signature.prototype.paramsStartWith = function (params) {
      if (params.length === 0) {
        return true;
      }

      var aLast = last(this.params);
      var bLast = last(params);

      for (var i = 0; i < params.length; i++) {
        var a = this.params[i] || (aLast.varArgs ? aLast: null);
        var b = params[i]      || (bLast.varArgs ? bLast: null);

        if (!a ||  !b || !a.matches(b)) {
          return false;
        }
      }

      return true;
    };

    /**
     * Generate the code to invoke this signature
     * @param {Refs} refs
     * @param {string} prefix
     * @returns {string} Returns code
     */
    Signature.prototype.toCode = function (refs, prefix) {
      var code = [];

      var args = new Array(this.params.length);
      for (var i = 0; i < this.params.length; i++) {
        var param = this.params[i];
        var conversion = param.conversions[0];
        if (param.varArgs) {
          args[i] = 'varArgs';
        }
        else if (conversion) {
          args[i] = refs.add(conversion.convert, 'convert') + '(arg' + i + ')';
        }
        else {
          args[i] = 'arg' + i;
        }
      }

      var ref = this.fn ? refs.add(this.fn, 'signature') : undefined;
      if (ref) {
        return prefix + 'return ' + ref + '(' + args.join(', ') + '); // signature: ' + this.params.join(', ');
      }

      return code.join('\n');
    };

    /**
     * Return a string representation of the signature
     * @returns {string}
     */
    Signature.prototype.toString = function () {
      return this.params.join(', ');
    };

    /**
     * A group of signatures with the same parameter on given index
     * @param {Param[]} path
     * @param {Signature} [signature]
     * @param {Node[]} childs
     * @param {boolean} [fallThrough=false]
     * @constructor
     */
    function Node(path, signature, childs, fallThrough) {
      this.path = path || [];
      this.param = path[path.length - 1] || null;
      this.signature = signature || null;
      this.childs = childs || [];
      this.fallThrough = fallThrough || false;
    }

    /**
     * Generate code for this group of signatures
     * @param {Refs} refs
     * @param {string} prefix
     * @returns {string} Returns the code as string
     */
    Node.prototype.toCode = function (refs, prefix) {
      // TODO: split this function in multiple functions, it's too large
      var code = [];

      if (this.param) {
        var index = this.path.length - 1;
        var conversion = this.param.conversions[0];
        var comment = '// type: ' + (conversion ?
                (conversion.from + ' (convert to ' + conversion.to + ')') :
                this.param);

        // non-root node (path is non-empty)
        if (this.param.varArgs) {
          if (this.param.anyType) {
            // variable arguments with any type
            code.push(prefix + 'if (arguments.length > ' + index + ') {');
            code.push(prefix + '  var varArgs = [];');
            code.push(prefix + '  for (var i = ' + index + '; i < arguments.length; i++) {');
            code.push(prefix + '    varArgs.push(arguments[i]);');
            code.push(prefix + '  }');
            code.push(this.signature.toCode(refs, prefix + '  '));
            code.push(prefix + '}');
          }
          else {
            // variable arguments with a fixed type
            var getTests = function (types, arg) {
              var tests = [];
              for (var i = 0; i < types.length; i++) {
                tests[i] = refs.add(getTypeTest(types[i]), 'test') + '(' + arg + ')';
              }
              return tests.join(' || ');
            }.bind(this);

            var allTypes = this.param.types;
            var exactTypes = [];
            for (var i = 0; i < allTypes.length; i++) {
              if (this.param.conversions[i] === undefined) {
                exactTypes.push(allTypes[i]);
              }
            }

            code.push(prefix + 'if (' + getTests(allTypes, 'arg' + index) + ') { ' + comment);
            code.push(prefix + '  var varArgs = [arg' + index + '];');
            code.push(prefix + '  for (var i = ' + (index + 1) + '; i < arguments.length; i++) {');
            code.push(prefix + '    if (' + getTests(exactTypes, 'arguments[i]') + ') {');
            code.push(prefix + '      varArgs.push(arguments[i]);');

            for (var i = 0; i < allTypes.length; i++) {
              var conversion_i = this.param.conversions[i];
              if (conversion_i) {
                var test = refs.add(getTypeTest(allTypes[i]), 'test');
                var convert = refs.add(conversion_i.convert, 'convert');
                code.push(prefix + '    }');
                code.push(prefix + '    else if (' + test + '(arguments[i])) {');
                code.push(prefix + '      varArgs.push(' + convert + '(arguments[i]));');
              }
            }
            code.push(prefix + '    } else {');
            code.push(prefix + '      throw createError(name, arguments.length, i, arguments[i], \'' + exactTypes.join(',') + '\');');
            code.push(prefix + '    }');
            code.push(prefix + '  }');
            code.push(this.signature.toCode(refs, prefix + '  '));
            code.push(prefix + '}');
          }
        }
        else {
          if (this.param.anyType) {
            // any type
            code.push(prefix + '// type: any');
            code.push(this._innerCode(refs, prefix));
          }
          else {
            // regular type
            var type = this.param.types[0];
            var test = type !== 'any' ? refs.add(getTypeTest(type), 'test') : null;

            code.push(prefix + 'if (' + test + '(arg' + index + ')) { ' + comment);
            code.push(this._innerCode(refs, prefix + '  '));
            code.push(prefix + '}');
          }
        }
      }
      else {
        // root node (path is empty)
        code.push(this._innerCode(refs, prefix));
      }

      return code.join('\n');
    };

    /**
     * Generate inner code for this group of signatures.
     * This is a helper function of Node.prototype.toCode
     * @param {Refs} refs
     * @param {string} prefix
     * @returns {string} Returns the inner code as string
     * @private
     */
    Node.prototype._innerCode = function (refs, prefix) {
      var code = [];
      var i;

      if (this.signature) {
        code.push(prefix + 'if (arguments.length === ' + this.path.length + ') {');
        code.push(this.signature.toCode(refs, prefix + '  '));
        code.push(prefix + '}');
      }

      for (i = 0; i < this.childs.length; i++) {
        code.push(this.childs[i].toCode(refs, prefix));
      }

      // TODO: shouldn't the this.param.anyType check be redundant
      if (!this.fallThrough || (this.param && this.param.anyType)) {
        var exceptions = this._exceptions(refs, prefix);
        if (exceptions) {
          code.push(exceptions);
        }
      }

      return code.join('\n');
    };


    /**
     * Generate code to throw exceptions
     * @param {Refs} refs
     * @param {string} prefix
     * @returns {string} Returns the inner code as string
     * @private
     */
    Node.prototype._exceptions = function (refs, prefix) {
      var index = this.path.length;

      if (this.childs.length === 0) {
        // TODO: can this condition be simplified? (we have a fall-through here)
        return [
          prefix + 'if (arguments.length > ' + index + ') {',
          prefix + '  throw createError(name, arguments.length, ' + index + ', arguments[' + index + ']);',
          prefix + '}'
        ].join('\n');
      }
      else {
        var keys = {};
        var types = [];

        for (var i = 0; i < this.childs.length; i++) {
          var node = this.childs[i];
          if (node.param) {
            for (var j = 0; j < node.param.types.length; j++) {
              var type = node.param.types[j];
              if (!(type in keys) && !node.param.conversions[j]) {
                keys[type] = true;
                types.push(type);
              }
            }
          }
        }

        return prefix + 'throw createError(name, arguments.length, ' + index + ', arguments[' + index + '], \'' + types.join(',') + '\');';
      }
    };

    /**
     * Split all raw signatures into an array with expanded Signatures
     * @param {Object.<string, Function>} rawSignatures
     * @return {Signature[]} Returns an array with expanded signatures
     */
    function parseSignatures(rawSignatures) {
      // FIXME: need to have deterministic ordering of signatures, do not create via object
      var signature;
      var keys = {};
      var signatures = [];
      var i;

      for (var types in rawSignatures) {
        if (rawSignatures.hasOwnProperty(types)) {
          var fn = rawSignatures[types];
          signature = new Signature(types, fn);

          if (signature.ignore()) {
            continue;
          }

          var expanded = signature.expand();

          for (i = 0; i < expanded.length; i++) {
            var signature_i = expanded[i];
            var key = signature_i.toString();
            var existing = keys[key];
            if (!existing) {
              keys[key] = signature_i;
            }
            else {
              var cmp = Signature.compare(signature_i, existing);
              if (cmp < 0) {
                // override if sorted first
                keys[key] = signature_i;
              }
              else if (cmp === 0) {
                throw new Error('Signature "' + key + '" is defined twice');
              }
              // else: just ignore
            }
          }
        }
      }

      // convert from map to array
      for (key in keys) {
        if (keys.hasOwnProperty(key)) {
          signatures.push(keys[key]);
        }
      }

      // order the signatures
      signatures.sort(function (a, b) {
        return Signature.compare(a, b);
      });

      // filter redundant conversions from signatures with varArgs
      // TODO: simplify this loop or move it to a separate function
      for (i = 0; i < signatures.length; i++) {
        signature = signatures[i];

        if (signature.varArgs) {
          var index = signature.params.length - 1;
          var param = signature.params[index];

          var t = 0;
          while (t < param.types.length) {
            if (param.conversions[t]) {
              var type = param.types[t];

              for (var j = 0; j < signatures.length; j++) {
                var other = signatures[j];
                var p = other.params[index];

                if (other !== signature &&
                    p &&
                    contains(p.types, type) && !p.conversions[index]) {
                  // this (conversion) type already exists, remove it
                  param.types.splice(t, 1);
                  param.conversions.splice(t, 1);
                  t--;
                  break;
                }
              }
            }
            t++;
          }
        }
      }

      return signatures;
    }

    /**
     * Filter all any type signatures
     * @param {Signature[]} signatures
     * @return {Signature[]} Returns only any type signatures
     */
    function filterAnyTypeSignatures (signatures) {
      var filtered = [];

      for (var i = 0; i < signatures.length; i++) {
        if (signatures[i].anyType) {
          filtered.push(signatures[i]);
        }
      }

      return filtered;
    }

    /**
     * create a map with normalized signatures as key and the function as value
     * @param {Signature[]} signatures   An array with split signatures
     * @return {Object.<string, Function>} Returns a map with normalized
     *                                     signatures as key, and the function
     *                                     as value.
     */
    function mapSignatures(signatures) {
      var normalized = {};

      for (var i = 0; i < signatures.length; i++) {
        var signature = signatures[i];
        if (signature.fn && !signature.hasConversions()) {
          var params = signature.params.join(',');
          normalized[params] = signature.fn;
        }
      }

      return normalized;
    }

    /**
     * Parse signatures recursively in a node tree.
     * @param {Signature[]} signatures  Array with expanded signatures
     * @param {Param[]} path            Traversed path of parameter types
     * @param {Signature[]} anys
     * @return {Node}                   Returns a node tree
     */
    function parseTree(signatures, path, anys) {
      var i, signature;
      var index = path.length;
      var nodeSignature;

      var filtered = [];
      for (i = 0; i < signatures.length; i++) {
        signature = signatures[i];

        // filter the first signature with the correct number of params
        if (signature.params.length === index && !nodeSignature) {
          nodeSignature = signature;
        }

        if (signature.params[index] != undefined) {
          filtered.push(signature);
        }
      }

      // sort the filtered signatures by param
      filtered.sort(function (a, b) {
        return Param.compare(a.params[index], b.params[index]);
      });

      // recurse over the signatures
      var entries = [];
      for (i = 0; i < filtered.length; i++) {
        signature = filtered[i];
        // group signatures with the same param at current index
        var param = signature.params[index];

        // TODO: replace the next filter loop
        var existing = entries.filter(function (entry) {
          return entry.param.overlapping(param);
        })[0];

        //var existing;
        //for (var j = 0; j < entries.length; j++) {
        //  if (entries[j].param.overlapping(param)) {
        //    existing = entries[j];
        //    break;
        //  }
        //}

        if (existing) {
          if (existing.param.varArgs) {
            throw new Error('Conflicting types "' + existing.param + '" and "' + param + '"');
          }
          existing.signatures.push(signature);
        }
        else {
          entries.push({
            param: param,
            signatures: [signature]
          });
        }
      }

      // find all any type signature that can still match our current path
      var matchingAnys = [];
      for (i = 0; i < anys.length; i++) {
        if (anys[i].paramsStartWith(path)) {
          matchingAnys.push(anys[i]);
        }
      }

      // see if there are any type signatures that don't match any of the
      // signatures that we have in our tree, i.e. we have alternative
      // matching signature(s) outside of our current tree and we should
      // fall through to them instead of throwing an exception
      var fallThrough = false;
      for (i = 0; i < matchingAnys.length; i++) {
        if (!contains(signatures, matchingAnys[i])) {
          fallThrough = true;
          break;
        }
      }

      // parse the childs
      var childs = new Array(entries.length);
      for (i = 0; i < entries.length; i++) {
        var entry = entries[i];
        childs[i] = parseTree(entry.signatures, path.concat(entry.param), matchingAnys)
      }

      return new Node(path, nodeSignature, childs, fallThrough);
    }

    /**
     * Generate an array like ['arg0', 'arg1', 'arg2']
     * @param {number} count Number of arguments to generate
     * @returns {Array} Returns an array with argument names
     */
    function getArgs(count) {
      // create an array with all argument names
      var args = [];
      for (var i = 0; i < count; i++) {
        args[i] = 'arg' + i;
      }

      return args;
    }

    /**
     * Compose a function from sub-functions each handling a single type signature.
     * Signatures:
     *   typed(signature: string, fn: function)
     *   typed(name: string, signature: string, fn: function)
     *   typed(signatures: Object.<string, function>)
     *   typed(name: string, signatures: Object.<string, function>)
     *
     * @param {string | null} name
     * @param {Object.<string, Function>} signatures
     * @return {Function} Returns the typed function
     * @private
     */
    function _typed(name, signatures) {
      var refs = new Refs();

      // parse signatures, expand them
      var _signatures = parseSignatures(signatures);
      if (_signatures.length == 0) {
        throw new Error('No signatures provided');
      }

      // filter all any type signatures
      var anys = filterAnyTypeSignatures(_signatures);

      // parse signatures into a node tree
      var node = parseTree(_signatures, [], anys);

      //var util = require('util');
      //console.log('ROOT');
      //console.log(util.inspect(node, { depth: null }));

      // generate code for the typed function
      var code = [];
      var _name = name || '';
      var _args = getArgs(maxParams(_signatures));
      code.push('function ' + _name + '(' + _args.join(', ') + ') {');
      code.push('  "use strict";');
      code.push('  var name = \'' + _name + '\';');
      code.push(node.toCode(refs, '  ', false));
      code.push('}');

      // generate body for the factory function
      var body = [
        refs.toCode(),
        'return ' + code.join('\n')
      ].join('\n');

      // evaluate the JavaScript code and attach function references
      var factory = (new Function(refs.name, 'createError', body));
      var fn = factory(refs, createError);

      //console.log('FN\n' + fn.toString()); // TODO: cleanup

      // attach the signatures with sub-functions to the constructed function
      fn.signatures = mapSignatures(_signatures);

      return fn;
    }

    /**
     * Calculate the maximum number of parameters in givens signatures
     * @param {Signature[]} signatures
     * @returns {number} The maximum number of parameters
     */
    function maxParams(signatures) {
      var max = 0;

      for (var i = 0; i < signatures.length; i++) {
        var len = signatures[i].params.length;
        if (len > max) {
          max = len;
        }
      }

      return max;
    }

    /**
     * Get the type of a value
     * @param {*} x
     * @returns {string} Returns a string with the type of value
     */
    function getTypeOf(x) {
      var obj;

      for (var i = 0; i < typed.types.length; i++) {
        var entry = typed.types[i];

        if (entry.name === 'Object') {
          // Array and Date are also Object, so test for Object afterwards
          obj = entry;
        }
        else {
          if (entry.test(x)) return entry.name;
        }
      }

      // at last, test whether an object
      if (obj && obj.test(x)) return obj.name;

      return 'unknown';
    }

    /**
     * Test whether an array contains some item
     * @param {Array} array
     * @param {*} item
     * @return {boolean} Returns true if array contains item, false if not.
     */
    function contains(array, item) {
      return array.indexOf(item) !== -1;
    }

    /**
     * Returns the last item in the array
     * @param {Array} array
     * @return {*} item
     */
    function last (array) {
      return array[array.length - 1];
    }

    // data type tests
    var types = [
      { name: 'number',    test: function (x) { return typeof x === 'number' } },
      { name: 'string',    test: function (x) { return typeof x === 'string' } },
      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },
      { name: 'Function',  test: function (x) { return typeof x === 'function'} },
      { name: 'Array',     test: Array.isArray },
      { name: 'Date',      test: function (x) { return x instanceof Date } },
      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },
      { name: 'Object',    test: function (x) { return typeof x === 'object' } },
      { name: 'null',      test: function (x) { return x === null } },
      { name: 'undefined', test: function (x) { return x === undefined } }
    ];

    // configuration
    var config = {};

    // type conversions. Order is important
    var conversions = [];

    // types to be ignored
    var ignore = [];

    // temporary object for holding types and conversions, for constructing
    // the `typed` function itself
    // TODO: find a more elegant solution for this
    var typed = {
      config: config,
      types: types,
      conversions: conversions,
      ignore: ignore
    };

    /**
     * Construct the typed function itself with various signatures
     *
     * Signatures:
     *
     *   typed(signatures: Object.<string, function>)
     *   typed(name: string, signatures: Object.<string, function>)
     */
    typed = _typed('typed', {
      'Object': function (signatures) {
        var fns = [];
        for (var signature in signatures) {
          if (signatures.hasOwnProperty(signature)) {
            fns.push(signatures[signature]);
          }
        }
        var name = getName(fns);

        return _typed(name, signatures);
      },
      'string, Object': _typed,
      // TODO: add a signature 'Array.<function>'
      '...Function': function (fns) {
        var err;
        var name = getName(fns);
        var signatures = {};

        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];

          // test whether this is a typed-function
          if (!(typeof fn.signatures === 'object')) {
            err = new TypeError('Function is no typed-function (index: ' + i + ')');
            err.data = {index: i};
            throw err;
          }

          // merge the signatures
          for (var signature in fn.signatures) {
            if (fn.signatures.hasOwnProperty(signature)) {
              if (signatures.hasOwnProperty(signature)) {
                if (fn.signatures[signature] !== signatures[signature]) {
                  err = new Error('Signature "' + signature + '" is defined twice');
                  err.data = {signature: signature};
                  throw err;
                }
                // else: both signatures point to the same function, that's fine
              }
              else {
                signatures[signature] = fn.signatures[signature];
              }
            }
          }
        }

        return _typed(name, signatures);
      }
    });

    /**
     * Find a specific signature from a (composed) typed function, for
     * example:
     *
     *   typed.find(fn, ['number', 'string'])
     *   typed.find(fn, 'number, string')
     *
     * Function find only only works for exact matches.
     *
     * @param {Function} fn                   A typed-function
     * @param {string | string[]} signature   Signature to be found, can be
     *                                        an array or a comma separated string.
     * @return {Function}                     Returns the matching signature, or
     *                                        throws an errror when no signature
     *                                        is found.
     */
    function find (fn, signature) {
      if (!fn.signatures) {
        throw new TypeError('Function is no typed-function');
      }

      // normalize input
      var arr;
      if (typeof signature === 'string') {
        arr = signature.split(',');
        for (var i = 0; i < arr.length; i++) {
          arr[i] = arr[i].trim();
        }
      }
      else if (Array.isArray(signature)) {
        arr = signature;
      }
      else {
        throw new TypeError('String array or a comma separated string expected');
      }

      var str = arr.join(',');

      // find an exact match
      var match = fn.signatures[str];
      if (match) {
        return match;
      }

      // TODO: extend find to match non-exact signatures

      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
    }

    /**
     * Convert a given value to another data type.
     * @param {*} value
     * @param {string} type
     */
    function convert (value, type) {
      var from = getTypeOf(value);

      // check conversion is needed
      if (type === from) {
        return value;
      }

      for (var i = 0; i < typed.conversions.length; i++) {
        var conversion = typed.conversions[i];
        if (conversion.from === from && conversion.to === type) {
          return conversion.convert(value);
        }
      }

      throw new Error('Cannot convert from ' + from + ' to ' + type);
    }

    // attach types and conversions to the final `typed` function
    typed.config = config;
    typed.types = types;
    typed.conversions = conversions;
    typed.ignore = ignore;
    typed.create = create;
    typed.find = find;
    typed.convert = convert;

    // add a type
    typed.addType = function (type) {
      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
        throw new TypeError('Object with properties {name: string, test: function} expected');
      }

      typed.types.push(type);
    };

    // add a conversion
    typed.addConversion = function (conversion) {
      if (!conversion
          || typeof conversion.from !== 'string'
          || typeof conversion.to !== 'string'
          || typeof conversion.convert !== 'function') {
        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
      }

      typed.conversions.push(conversion);
    };

    return typed;
  }

  return create();
}));

},{}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIuLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibGliL2Vhc3ktY3VydmUtZml0dGluZy5qcyIsImxpYi9tYWluLmpzIiwibGliL21hdGgtY3VzdG9tLmpzIiwibGliL29wdGltaXplLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvY29yZS9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvY29yZS9mdW5jdGlvbi9jb25maWcuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9jb3JlL2Z1bmN0aW9uL2ltcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2NvcmUvdHlwZWQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9lcnJvci9Bcmd1bWVudHNFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Vycm9yL0RpbWVuc2lvbkVycm9yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXJyb3IvSW5kZXhFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vSGVscC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9JbmZpbml0eS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvTE4xMC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvTE4yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9MT0cxMEUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL0xPRzJFLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9OYU4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL1NRUlQxXzIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RhbnRzL1NRUlQyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9lLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9mYWxzZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvaS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvbnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvcGhpLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy9waS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdGFudHMvdGF1LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy90cnVlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0YW50cy92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL2Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL2NvbXBsZXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL2NyZWF0ZVVuaXQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL2ZyYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdHJ1Y3Rpb24vbWF0cml4LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9udW1iZXIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL3NwYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9jb25zdHJ1Y3Rpb24vc3BsaXRVbml0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2NvbnN0cnVjdGlvbi9zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29uc3RydWN0aW9uL3VuaXQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29yZS9jb25maWcuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29yZS9pbXBvcnQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvY29yZS90eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hbGdlYnJhL2Rlcml2YXRpdmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYWxnZWJyYS9sc29sdmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYWxnZWJyYS9sdXAuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYWxnZWJyYS9sdXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FsZ2VicmEvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYWxnZWJyYS9zbHUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYWxnZWJyYS91c29sdmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9hYnMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9hZGQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9jYnJ0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvY2VpbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2N1YmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9kaXZpZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3REaXZpZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RNdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2RvdFBvdy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2ZpeC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL2Zsb29yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvZ2NkLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvaHlwb3QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9sY20uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cxMC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL21vZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL250aFJvb3QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9wb3cuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9yb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9hcml0aG1ldGljL3NpZ24uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXJ0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3F1YXJlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3VidHJhY3QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeU1pbnVzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlQbHVzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2FyaXRobWV0aWMveGdjZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9iaXR3aXNlL2JpdEFuZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9iaXR3aXNlL2JpdE5vdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9iaXR3aXNlL2JpdE9yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvYml0WG9yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvbGVmdFNoaWZ0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvcmlnaHRBcml0aFNoaWZ0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2JpdHdpc2UvcmlnaHRMb2dTaGlmdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21iaW5hdG9yaWNzL2JlbGxOdW1iZXJzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvY2F0YWxhbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21iaW5hdG9yaWNzL2NvbXBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3Mvc3RpcmxpbmdTMi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21wbGV4L2FyZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21wbGV4L2NvbmouanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vY29tcGxleC9pbS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9jb21wbGV4L3JlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2V4cHJlc3Npb24vZXZhbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9leHByZXNzaW9uL2hlbHAuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vZ2VvbWV0cnkvZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vZ2VvbWV0cnkvaW50ZXJzZWN0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2xvZ2ljYWwvYW5kLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2xvZ2ljYWwvbm90LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL2xvZ2ljYWwvb3IuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbG9naWNhbC94b3IuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvY3Jvc3MuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L2RldC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZGlhZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZG90LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9leWUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvZm9yRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvaW52LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9rcm9uLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC9tYXAuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L29uZXMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L3BhcnRpdGlvblNlbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vbWF0cml4L3Jlc2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvc2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvc3F1ZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvc3Vic2V0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC90cmFjZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9tYXRyaXgvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL21hdHJpeC96ZXJvcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9jb21iaW5hdGlvbnMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkvZmFjdG9yaWFsLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2dhbW1hLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2tsZGl2ZXJnZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9tdWx0aW5vbWlhbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9wZXJtdXRhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkvcGlja1JhbmRvbS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9wcm9iYWJpbGl0eS9yYW5kb20uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tSW50LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9yZWxhdGlvbmFsL2RlZXBFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvbGFyZ2VyRXEuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvc21hbGxlckVxLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3JlbGF0aW9uYWwvdW5lcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zcGVjaWFsL2VyZi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21hZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21heC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL21lYW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9tZWRpYW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9taW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vc3RhdGlzdGljcy9tb2RlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3MvcHJvZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi9zdGF0aXN0aWNzL3F1YW50aWxlU2VxLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3RkLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3VtLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3N0YXRpc3RpY3MvdmFyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY29zLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvdGguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjc2MuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjc2NoLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2VjLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2VjaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbmguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2F0YW4yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3NoLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdGguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NzYy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zZWNoLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NpbmguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3Rhbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91bml0cy90by5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvaXNJbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL2lzTmFOLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL2lzTmVnYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvaXNOdW1lcmljLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2Z1bmN0aW9uL3V0aWxzL2lzUG9zaXRpdmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvaXNQcmltZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZG9jcy9mdW5jdGlvbi91dGlscy9pc1plcm8uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2RvY3MvZnVuY3Rpb24vdXRpbHMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9kb2NzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9jb21waWxlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9ldmFsLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9oZWxwLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vZnVuY3Rpb24vcGFyc2UuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2Z1bmN0aW9uL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL2tleXdvcmRzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL0FjY2Vzc29yTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9BcnJheU5vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQXNzaWdubWVudE5vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvQmxvY2tOb2RlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL0NvbmRpdGlvbmFsTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9Db25zdGFudE5vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9GdW5jdGlvbk5vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvSW5kZXhOb2RlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL05vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvT2JqZWN0Tm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9PcGVyYXRvck5vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvUGFyZW50aGVzaXNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL1JhbmdlTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vbm9kZS9TeW1ib2xOb2RlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL1VwZGF0ZU5vZGUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL25vZGUvdXRpbHMvYWNjZXNzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9ub2RlL3V0aWxzL2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vb3BlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL2NvbmNhdC50cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9lcnJvci50cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9maWx0ZXIudHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vZm9yRWFjaC50cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL2luZGV4LnRyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24vdHJhbnNmb3JtL21hcC50cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9tYXgudHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vbWVhbi50cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9leHByZXNzaW9uL3RyYW5zZm9ybS9taW4udHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vcmFuZ2UudHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZXhwcmVzc2lvbi90cmFuc2Zvcm0vc3Vic2V0LnRyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWJzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9hZGQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2FkZFNjYWxhci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY2JydC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY2VpbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvY3ViZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZGl2aWRlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9kaXZpZGVTY2FsYXIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdERpdmlkZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZG90TXVsdGlwbHkuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2RvdFBvdy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvZXhwLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9maXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2Zsb29yLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9nY2QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2h5cG90LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbGNtLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL2xvZzEwLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9tb2QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9tdWx0aXBseVNjYWxhci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvbnRoUm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvcG93LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9yb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3FydC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3F1YXJlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlNaW51cy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlQbHVzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vYXJpdGhtZXRpYy94Z2NkLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9kZXQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvZXllLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9mb3JFYWNoLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L2ludi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC9tYXAuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9tYXRyaXgvc3Vic2V0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3RyYWNlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vbWF0cml4L3RyYW5zcG9zZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL21hdHJpeC96ZXJvcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWwuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vcmVsYXRpb25hbC9sYXJnZXIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9yZWxhdGlvbmFsL3NtYWxsZXIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9zdGF0aXN0aWNzL21heC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVhbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWluLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vc3RyaW5nL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY29zLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3NoLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2Fjb3QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNvdGguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYWNzYy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY3NjaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2VjLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2FzZWNoLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2FzaW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXNpbmguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuMi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3MuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3QuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY290aC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jc2MuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zZWMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS90YW4uanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL2Z1bmN0aW9uL3V0aWxzL2lzTmVnYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91dGlscy9pc051bWVyaWMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi91dGlscy9pc1Bvc2l0aXZlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvZnVuY3Rpb24vdXRpbHMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9jb21wbGV4L0NvbXBsZXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL2ZyYWN0aW9uL2Z1bmN0aW9uL2ZyYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvUmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA1LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDYuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA5LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTAuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS9yZXN1bHRzZXQvUmVzdWx0U2V0LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdHlwZS91bml0L1VuaXQuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9OdW1iZXJGb3JtYXR0ZXIuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2JpZ251bWJlci9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9iaWdudW1iZXIvZm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvYmlnbnVtYmVyL25lYXJseUVxdWFsLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvYm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2NvbGxlY3Rpb24vY29udGFpbnNDb2xsZWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2NvbGxlY3Rpb24vZGVlcEZvckVhY2guanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAuanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9jb2xsZWN0aW9uL2lzQ29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2NvbGxlY3Rpb24vcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvY29sbGVjdGlvbi9zY2F0dGVyLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL2Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9saWIvdXRpbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWF0aGpzL2xpYi91dGlscy9sYXRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL3N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoanMvbGliL3V0aWxzL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9ub2RlX21vZHVsZXMvY29tcGxleC5qcy9jb21wbGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9ub2RlX21vZHVsZXMvdGlueS1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hdGhqcy9ub2RlX21vZHVsZXMvdHlwZWQtZnVuY3Rpb24vdHlwZWQtZnVuY3Rpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9vR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwidmFyIG1hdGggPSByZXF1aXJlKCcuL21hdGgtY3VzdG9tLmpzJyk7XHJcbnZhciBvcHRpbWl6ZSA9IHJlcXVpcmUoJy4vb3B0aW1pemUuanMnKTtcclxuXHJcblxyXG5cclxudmFyIGVhc3lDdXJ2ZUZpdHRpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbmVhc3lDdXJ2ZUZpdHRpbmcucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqKSk7XHJcbn07XHJcblxyXG5cclxuZWFzeUN1cnZlRml0dGluZy5wcm90b3R5cGUuZG9MZWFzdFNxdWFyZXMgPSBmdW5jdGlvbihtb2RlbFN0ciwgZGF0YSwgZ3Vlc3NTdHIpIHtcclxuICBcclxuICB2YXIgbW9kZWwgPSBwYXJzZU1vZGVsKG1vZGVsU3RyKTtcclxuICAgIFxyXG4gIHZhciBndWVzcyA9IHBhcnNlR3Vlc3NlcyhndWVzc1N0cik7XHJcbiAgXHJcbiAgLy8gSW5pdGlhbGl6ZSBhbnkgdW5zcGVjaWZpZWQgZ3Vlc3MgdmFsdWVzIHRvIDBcclxuICBmb3IodmFyIHBhcmFtIGluIG1vZGVsLnBhcmFtcykge1xyXG4gICAgaWYobW9kZWwucGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSAmJiAhZ3Vlc3MuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XHJcbiAgICAgIGd1ZXNzW3BhcmFtXSA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gICAgXHJcbiAgLy8gQ29tcGlsZSB0aGUgcGFyc2VkIGV4cHJlc3Npb24gdHJlZVxyXG4gIHZhciBjb2RlID0gbW9kZWwubm9kZS5jb21waWxlKCk7XHJcblxyXG5cclxuICAvLyBCdWlsZCB0aGUgZ3Vlc3MgYXJyYXlzXHJcbiAgdmFyIGd1ZXNzQ29lZmYgPSBbXTtcclxuICB2YXIgZ3Vlc3NWYWx1ZSA9IFtdO1xyXG4gIGZvcih2YXIga2V5IGluIGd1ZXNzKSB7XHJcbiAgICBpZihndWVzcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ3gnKSB7XHJcbiAgICAgIGd1ZXNzQ29lZmYucHVzaChrZXkpO1xyXG4gICAgICBndWVzc1ZhbHVlLnB1c2goZ3Vlc3Nba2V5XSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBCdWlsZCB0aGUgb2JqZWN0aXZlIGZ1bmN0aW9uXHJcbiAgdmFyIG9iamVjdGl2ZSA9IGZ1bmN0aW9uKGMpIHtcclxuICAgIHZhciBTU0UgPSAwO1xyXG4gICAgdmFyIHNjb3BlID0ge307XHJcbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIHNjb3BlW2d1ZXNzQ29lZmZbal1dID0gY1tqXTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHggPSBkYXRhW2ldLng7XHJcbiAgICAgIHZhciB5ID0gZGF0YVtpXS55O1xyXG4gICAgICBzY29wZS54ID0geDtcclxuICAgICAgXHJcbiAgICAgIHZhciBwcmVkID0gY29kZS5ldmFsKHNjb3BlKTtcclxuICAgICAgU1NFICs9ICh5IC0gcHJlZCkgKiAoeSAtIHByZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNTRTtcclxuICB9O1xyXG5cclxuXHJcbiAgdmFyIHJlc3VsdCA9IG9wdGltaXplKG9iamVjdGl2ZSwgZ3Vlc3NWYWx1ZSk7XHJcblxyXG4gIFxyXG4gIC8vIERpc3BsYXkgdGhlIHJlc3VsdHNcclxuICB2YXIgZ3Vlc3NTdHIgPSBcIlwiO1xyXG4gIHZhciBvcHRpbWl6ZWQgPSB7fTtcclxuICBmb3IodmFyIGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgIG9wdGltaXplZFtndWVzc0NvZWZmW2ldXSA9IHJlc3VsdFtpXTtcclxuICB9XHJcbiAgICAgIFxyXG4gICAgXHJcbiAgICAgIFxyXG4gIHJldHVybiB7XHJcbiAgICBndWVzc2VzOiBndWVzcyxcclxuICAgIG1vZGVsU3RyOiBtb2RlbFN0cixcclxuICAgIGRhdGE6IGRhdGEsXHJcbiAgICBvcHRpbWl6ZWQ6IG9wdGltaXplZFxyXG4gIH07XHJcbiAgICAgIFxyXG4gICAgICAvKlxyXG4gICAgICAkKCcjZ3Vlc3MnKS52YWwoZ3Vlc3NTdHIpO1xyXG5cclxuXHRcdFx0dmFyIGRhdGFTdHIgPSBcInhcXHR5XFx0cHJlZFxcdHNxLmVyclxcblwiO1xyXG5cdFx0XHR2YXIgU1NFID0gMDtcclxuXHRcdFx0dmFyIG1pblggPSBkYXRhWzBdLng7XHJcblx0XHRcdHZhciBtYXhYID0gZGF0YVswXS54O1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHggPSBkYXRhW2ldLng7XHJcblx0XHRcdFx0dmFyIHkgPSBkYXRhW2ldLnk7XHJcblx0XHRcdFx0aWYoeCA+IG1heFgpXHJcblx0XHRcdFx0XHRtYXhYID0geDtcclxuXHRcdFx0XHRpZih4IDwgbWluWClcclxuXHRcdFx0XHRcdG1pblggPSB4O1xyXG5cdFx0XHRcdGNvZWZmcy54ID0geDtcclxuXHRcdFx0XHR2YXIgcHJlZCA9IGNvZGUuZXZhbChjb2VmZnMpO1xyXG5cdFx0XHRcdGRhdGFbaV0ucHJlZCA9IHByZWQ7XHJcblx0XHRcdFx0dmFyIFNFID0gKHByZWQteSk7XHJcblx0XHRcdFx0U0UgPSBTRSAqIFNFO1xyXG5cdFx0XHRcdFNTRSArPSBTRTtcclxuXHRcdFx0XHRkYXRhU3RyICs9IHgudG9TdHJpbmcoKSArIFwiXFx0XCIgKyB5LnRvU3RyaW5nKCkgKyBcIlxcdFwiICsgcHJlZC50b1N0cmluZygpICsgXCJcXHRcIiArIFNFLnRvU3RyaW5nKCkgKyBcIlxcblwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFTdHIgPSBcIlN1bSBvZiBzcXVhcmVkIGVycm9yczpcXHRcIiArIFNTRS50b1N0cmluZygpICsgXCJcXG5cIiArIGRhdGFTdHI7XHJcblx0XHRcdCQoJyNkYXRhJykudmFsKGRhdGFTdHIpO1xyXG5cclxuXHRcdFx0XHJcblx0XHRcdHZhciBkb21haW4gPSBtYXhYIC0gbWluWDtcclxuXHRcdFx0bWluWCA9IG1pblggLSBkb21haW4gKiAwLjE7XHJcblx0XHRcdG1heFggPSBtYXhYICsgZG9tYWluICogMC4xO1xyXG5cdFx0XHR2YXIgc21vb3RoID0gW107XHJcblx0XHRcdGZvcih2YXIgeCA9IG1pblg7IHg8bWF4WDsgeCArPSBkb21haW4gKiAwLjAwMikge1xyXG5cdFx0XHRcdGNvZWZmcy54ID0geDtcclxuXHRcdFx0XHR2YXIgcHJlZCA9IGNvZGUuZXZhbChjb2VmZnMpO1xyXG5cdFx0XHRcdHNtb290aC5wdXNoKHt4OiB4LCB5OiBwcmVkfSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBsb3R0ZXIuc2V0RGF0YShkYXRhLCBzbW9vdGgpO1xyXG5cdFx0XHRwbG90dGVyLmRyYXcoKTtcclxuKi9cclxuICBcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTW9kZWwobW9kZWxTdHIpIHtcclxuICBcclxuICBpZih0eXBlb2YobW9kZWxTdHIpICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicGFyc2VNb2RlbCBleHBlY3RlZCBwYXJhbWV0ZXIgMSAobW9kZWxTdHIpIHRvIGJlIG9mIHR5cGUgJ1N0cmluZydcIik7XHJcbiAgfVxyXG4gXHJcbiAgdmFyIG5vZGUgPSBtYXRoLnBhcnNlKG1vZGVsU3RyKTtcclxuICBcclxuICAvLyBGaW5kIHRoZSBTeW1ib2xOb2Rlc1xyXG4gIHZhciBwYXJhbXMgPSB7fTtcclxuICB2YXIgaGFzeCA9IGZhbHNlO1xyXG4gIHZhciBoYXNQYXJhbXMgPSBmYWxzZTtcclxuICB2YXIgc3ltYm9scyA9IG5vZGUuZmlsdGVyKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLmlzU3ltYm9sTm9kZTtcclxuICB9KTtcclxuXHJcbiAgc3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIGlmKG5vZGUubmFtZSA9PT0gJ3gnKSB7XHJcbiAgICAgIGhhc3ggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHBhcmFtc1tub2RlLm5hbWVdID0gMDtcclxuICAgICAgaGFzUGFyYW1zID0gdHJ1ZTtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICBpZighaGFzeCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgZG9lcyBub3QgY29udGFpbiAneCcuXCIpO1xyXG4gIH1cclxuICBpZighaGFzUGFyYW1zKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBkb2VzIG5vdCBjb250YWluIGFueSBwYXJhbWV0ZXJzLlwiKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIG5vZGU6IG5vZGUsXHJcbiAgICBwYXJhbXM6IHBhcmFtc1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlR3Vlc3NlcyhsaW5lcykge1xyXG4gIGlmKCFsaW5lcykge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuICBcclxuICAvLyBHZXQgdGhlIGd1ZXNzIHZhbHVlc1xyXG4gIHZhciBndWVzcyA9IHt9O1xyXG4gIFxyXG4gIGZvcih2YXIgaT0wOyBpPGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZihsaW5lc1tpXS50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcnRzID0gbGluZXNbaV0uc3BsaXQoJz0nKTtcclxuICAgIGlmKHBhcnRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkd1ZXNzIHZhbHVlcyBtdXN0IGJlIG9uZSB2YWx1ZSBvbiBlYWNoIGxpbmUsIGxpa2UgdGhpczogXFxcImEgPSAyXFxcIlwiKTtcclxuICAgIH1cclxuICAgIHZhciBnID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7XHJcbiAgICBpZihpc05hTihnKSkge1xyXG4gICAgICBhbGVydChcIkludmFsaWQgZ3Vlc3MgdmFsdWU6IFwiICsgcGFydHNbMV0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBndWVzc1twYXJ0c1swXS50cmltKCldID0gZztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGd1ZXNzO1xyXG59XHJcbiAgXHJcbiAgXHJcblxyXG4vKlxyXG5cclxuJChmdW5jdGlvbigpIHtcclxuXHJcblx0XHJcblxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBkb1RoZVRoaW5nKGZpdCkge1xyXG5cclxuXHRcdFx0Ly8gU2F2ZSB0aGUgZGF0YSBmb3IgbGF0ZXJcclxuXHRcdFx0bG9jYWxTdG9yYWdlLmN1cnZlRml0X2RhdGEgPSAkKCcjZGF0YScpLnZhbCgpO1xyXG5cdFx0XHRsb2NhbFN0b3JhZ2UuY3VydmVGaXRfZ3Vlc3MgPSAkKCcjZ3Vlc3MnKS52YWwoKTtcclxuXHRcdFx0bG9jYWxTdG9yYWdlLmN1cnZlRml0X2Zvcm0gPSAkKCcjZm9ybScpLnZhbCgpO1xyXG5cclxuXHRcdFx0Ly8gUmVhZCB0aGUgZGF0YVxyXG5cdFx0XHR2YXIgbGluZXMgPSAkKCcjZGF0YScpLnZhbCgpLnNwbGl0KCdcXG4nKTtcclxuXHRcdFx0aWYobGluZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0YWxlcnQoXCJQbGVhc2UgZW50ZXIgc29tZSBkYXRhLlwiKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGRhdGEgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGluZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZihsaW5lc1tpXS50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHh5ID0gbGluZXNbaV0uc3BsaXQoL1tcXHMsXSsvKTtcclxuXHRcdFx0XHRpZih4eS5sZW5ndGggPCAyKSB7XHJcblx0XHRcdFx0XHRhbGVydChcIkVycm9yLCBvbmx5IG9uZSB2YWx1ZSBmb3VuZCBvbiBsaW5lIFwiICsgKGkrMSkudG9TdHJpbmcoKSArIFwiLiBQbGVhc2UgZW50ZXIgdHdvIGNvbHVtbnMuXCIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgeEZsb2F0ID0gcGFyc2VGbG9hdCh4eVswXSk7XHJcblx0XHRcdFx0dmFyIHlGbG9hdCA9IHBhcnNlRmxvYXQoeHlbMV0pO1xyXG5cdFx0XHRcdGlmKGlzTmFOKHhGbG9hdCkgfHwgaXNOYU4oeUZsb2F0KSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRhdGEucHVzaCh7eDogeEZsb2F0LCB5OiB5RmxvYXR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUGFyc2UgdGhlIGZvcm1cclxuXHRcdFx0dmFyIGZvcm0gPSAkKCcjZm9ybScpLnZhbCgpO1xyXG5cdFx0XHRpZihmb3JtLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdGFsZXJ0KFwiUGxlYXNlIGVudGVyIGEgZm9ybSBvZiB0aGUgY3VydmUgdG8gZml0LCBzdWNoIGFzIFxcXCJhIHheMiArIGIgeCArIGNcXFwiLlwiKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuICAgICAgXHJcbiAgICAgIFxyXG5cclxuXHRcdFxyXG5cclxuXHRcdH1cclxuXHJcblx0fSk7XHJcbiovXHJcbiAgXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgZWFzeUN1cnZlRml0dGluZygpOyIsImN1cnZlID0gcmVxdWlyZSgnLi9lYXN5LWN1cnZlLWZpdHRpbmcuanMnKTtcclxuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvbWF0aGpzL2NvcmUuanMnKTtcclxuXHJcbnZhciBtYXRoID0gY29yZS5jcmVhdGUoKTtcclxuXHJcbm1hdGguaW1wb3J0KHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL3R5cGUvbnVtYmVyLmpzJykpO1xyXG5tYXRoLmltcG9ydChyZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi9hcml0aG1ldGljJykpO1xyXG5tYXRoLmltcG9ydChyZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvbWF0aGpzL2xpYi9mdW5jdGlvbi90cmlnb25vbWV0cnknKSk7XHJcbm1hdGguaW1wb3J0KHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9tYXRoanMvbGliL2V4cHJlc3Npb24nKSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGg7IiwiLy92YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuXHJcbi8qKlxyXG4gKiBPcHRpbWl6ZSBndWVzcyBhY2NvcmRpbmcgdG8gbWluaW1pemUgb2JqZWN0aXZlIGZ1bmN0aW9uLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3RpdmUsIGd1ZXNzKSB7XHJcblx0XHJcblx0Ly8gUGFyYW1ldGVyc1xyXG5cdHZhciBhbHBoYSA9IDEuMDtcdFx0Ly8gUmVmbGVjdGlvblxyXG5cdHZhciBnYW1tYSA9IDIuMDtcdFx0Ly8gRXhwYW5zaW9uXHJcblx0dmFyIHJobyA9IC0wLjU7XHRcdFx0Ly8gQ29udHJhY3Rpb25cclxuXHR2YXIgc2lnbWEgPSAwLjU7XHRcdC8vIFJlZHVjdGlvblxyXG5cclxuXHQvLyBIb3cgbWFueSB2YXJpYWJsZXM/XHJcblx0dmFyIG4gPSBndWVzcy5sZW5ndGg7XHJcblx0XHJcblx0Ly8gQ29uc3RydWN0IHRoZSBzaW1wbGV4XHJcblx0dmFyIHNpbXBsZXggPSBbXTtcclxuXHRmb3IodmFyIGk9MDsgaTxuKzE7IGkrKykge1xyXG5cdFx0c2ltcGxleFtpXSA9IHt4OltdfTtcclxuXHRcdGZvcih2YXIgaj0wOyBqPG47IGorKykge1xyXG5cdFx0XHRzaW1wbGV4W2ldLnhbal0gPSBndWVzc1tqXSAqICgxICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMWUtNikgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxZS05O1xyXG5cdFx0fVxyXG5cdFx0c2ltcGxleFtpXS5mID0gb2JqZWN0aXZlKHNpbXBsZXhbaV0ueCk7XHJcblx0fVxyXG5cdFxyXG5cdHZhciBpdGVyID0gLTE7XHJcblxyXG5cdHdoaWxlKGl0ZXIgPCAxMDAwKSB7XHJcblx0XHJcblx0ICAvLyBTdGVwIDE6IE9yZGVyIHZlcnRpY2VzXHJcblx0XHRpdGVyKys7XHJcblx0XHRzaW1wbGV4LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5mIC0gYi5mOyB9ICk7XHJcblx0XHRpZihzaW1wbGV4W25dLmYgLSBzaW1wbGV4WzBdLmYgPCAxZS0xNCApIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRpZmYgPSAwO1xyXG5cdFx0Zm9yKHZhciBqPTA7IGo8bjsgaisrKSB7XHJcblx0XHRcdGRpZmYgKz0gKHNpbXBsZXhbbl0ueFtqXSAtIHNpbXBsZXhbMF0ueFtqXSkgKiAoc2ltcGxleFtuXS54W2pdIC0gc2ltcGxleFswXS54W2pdKTtcclxuXHRcdH1cclxuXHRcdGlmKGRpZmYgPCAxZS0yOCkge1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdGVwIDI6IENvbXB1dGUgY2VudHJvaWRcclxuXHRcdHZhciBjZW50cm9pZCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBqPTA7IGo8bjsgaisrKSB7XHJcblx0XHRcdGNlbnRyb2lkW2pdID0gMDtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bjsgaSsrKSB7XHRcdC8vIEl0ZXJhdGUgb25seSBvdmVyIHRoZSBmaXJzdCBuIHNpbXBsZXggcG9pbnRzIChub3QgdGhlIGxhc3Qgb25lKVxyXG5cdFx0XHRcdGNlbnRyb2lkW2pdICs9IHNpbXBsZXhbaV0ueFtqXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjZW50cm9pZFtqXSAvPSBuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0ZXAgMzogUmVmbGVjdGlvblxyXG5cdFx0dmFyIHJlZmxlY3RlZCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBqPTA7IGo8bjsgaisrKSB7XHJcblx0XHRcdHJlZmxlY3RlZFtqXSA9IGNlbnRyb2lkW2pdICsgYWxwaGEgKiAoY2VudHJvaWRbal0gLSBzaW1wbGV4W25dLnhbal0pO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGZSZWZsZWN0ZWQgPSBvYmplY3RpdmUocmVmbGVjdGVkKTtcclxuXHRcdGlmIChmUmVmbGVjdGVkIDwgc2ltcGxleFtuLTFdLmYgJiYgZlJlZmxlY3RlZCA+PSBzaW1wbGV4WzBdLmYpIHtcclxuXHRcdFx0Ly8gUmVwbGFjZSB3b3JzdCBwb2ludCB3aXRoIHJlZmxlY3RlZCBwb2ludFxyXG5cdFx0XHRzaW1wbGV4W25dID0ge2Y6IGZSZWZsZWN0ZWQsIHg6cmVmbGVjdGVkfTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3RlcCA0OiBFeHBhbnNpb25cclxuXHRcdGlmIChmUmVmbGVjdGVkIDwgc2ltcGxleFswXS5mKSB7XHJcblx0XHRcdHZhciBleHBhbmRlZCA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGo9MDsgajxuOyBqKyspIHtcclxuXHRcdFx0XHRleHBhbmRlZFtqXSA9IGNlbnRyb2lkW2pdICsgZ2FtbWEgKiAoY2VudHJvaWRbal0gLSBzaW1wbGV4W25dLnhbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBmRXhwYW5kZWQgPSBvYmplY3RpdmUoZXhwYW5kZWQpO1xyXG5cdFx0XHRpZiAoZkV4cGFuZGVkIDwgZlJlZmxlY3RlZCkge1xyXG5cdFx0XHRcdC8vIFJlcGxhY2Ugd29yc3QgcG9pbnQgd2l0aCBleHBhbmRlZCBwb2ludFxyXG5cdFx0XHRcdHNpbXBsZXhbbl0gPSB7ZjogZkV4cGFuZGVkLCB4OmV4cGFuZGVkfTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBSZXBsYWNlIHdvcnN0IHBvaW50IHdpdGggcmVmbGVjdGVkIHBvaW50XHJcblx0XHRcdFx0c2ltcGxleFtuXSA9IHtmOiBmUmVmbGVjdGVkLCB4OnJlZmxlY3RlZH07XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdGVwIDU6IENvbnRyYWN0aW9uXHJcblx0XHR2YXIgY29udHJhY3RlZCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBqPTA7IGo8bjsgaisrKSB7XHJcblx0XHRcdGNvbnRyYWN0ZWRbal0gPSBjZW50cm9pZFtqXSArIHJobyAqIChjZW50cm9pZFtqXSAtIHNpbXBsZXhbbl0ueFtqXSk7XHJcblx0XHR9XHJcblx0XHR2YXIgZkNvbnRyYWN0ZWQgPSBvYmplY3RpdmUoY29udHJhY3RlZCk7XHJcblx0XHRpZiAoZkNvbnRyYWN0ZWQgPCBzaW1wbGV4W25dLmYpIHtcclxuXHRcdFx0Ly8gUmVwbGFjZSB3b3JzdCBwb2ludCB3aXRoIGNvbnRyYWN0ZWQgcG9pbnRcclxuXHRcdFx0c2ltcGxleFtuXSA9IHtmOiBmQ29udHJhY3RlZCwgeDpjb250cmFjdGVkfTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3RlcCA2OiBSZWR1Y3Rpb25cclxuXHRcdGZvcih2YXIgaT0xOyBpPG4rMTsgaSsrKSB7XHJcblx0XHRcdGZvcih2YXIgaj0wOyBqPG47IGorKykge1xyXG5cdFx0XHRcdHNpbXBsZXhbaV0ueFtqXSA9IHNpbXBsZXhbMF0ueFtqXSArIHNpZ21hICogKHNpbXBsZXhbaV0ueFtqXSAtIHNpbXBsZXhbMF0ueFtqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c2ltcGxleFtpXS5mID0gb2JqZWN0aXZlKHNpbXBsZXhbaV0ueCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc2ltcGxleFswXS54O1xyXG59XHJcblxyXG4vLyBHZW5lcmF0ZSBzb21lIHJhbmRvbSBkYXRhXHJcbi8qXHJcbnZhciBkYXRhID0gW107XHJcbmZvcih2YXIgaT0wOyBpPDEwMDsgaSsrKSB7XHJcblx0ZGF0YVtpXSA9IHt9O1xyXG5cdGRhdGFbaV0ueCA9IGkgKiAwLjE7XHJcblx0ZGF0YVtpXS55ID0gMiAqIGRhdGFbaV0ueCAvIChkYXRhW2ldLnggKyA0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGVzdChjKSB7XHJcblx0dmFyIFNTRSA9IDA7XHJcblx0Zm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIHggPSBkYXRhW2ldLng7XHJcblx0XHR2YXIgeSA9IGRhdGFbaV0ueTtcclxuXHRcdHZhciBwcmVkID0gY1swXSAqIHggLyAoeCArIGNbMV0pICsgY1syXTtcclxuXHRcdFNTRSArPSAoeS1wcmVkKSAqICh5LXByZWQpO1xyXG5cdH1cclxuXHRyZXR1cm4gU1NFO1xyXG59XHJcblxyXG52YXIgZ3Vlc3MgPSBbMCwgMCwgMF07XHJcblxyXG5vcHRpbWl6ZSh0ZXN0LCBndWVzcyk7XHJcbiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2NvcmUnKTsiLCJ2YXIgaXNGYWN0b3J5ID0gcmVxdWlyZSgnLi8uLi91dGlscy9vYmplY3QnKS5pc0ZhY3Rvcnk7XG52YXIgZGVlcEV4dGVuZCA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvb2JqZWN0JykuZGVlcEV4dGVuZDtcbnZhciB0eXBlZEZhY3RvcnkgPSByZXF1aXJlKCcuL3R5cGVkJyk7XG52YXIgZW1pdHRlciA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvZW1pdHRlcicpO1xuXG52YXIgaW1wb3J0RmFjdG9yeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vaW1wb3J0Jyk7XG52YXIgY29uZmlnRmFjdG9yeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29uZmlnJyk7XG5cbi8qKlxuICogTWF0aC5qcyBjb3JlLiBDcmVhdGVzIGEgbmV3LCBlbXB0eSBtYXRoLmpzIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gZXBzaWxvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d29cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZWQgdmFsdWVzLCB1c2VkIGJ5IGFsbCBjb21wYXJpc29uIGZ1bmN0aW9ucy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG1hdHJpeFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnTWF0cml4JyAoZGVmYXVsdCkgb3IgJ0FycmF5Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnbnVtYmVyJyAoZGVmYXVsdCksICdCaWdOdW1iZXInLCBvciAnRnJhY3Rpb24nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBwcmVjaXNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgZm9yIEJpZ051bWJlcnMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdCBhcHBsaWNhYmxlIGZvciBOdW1iZXJzLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IHByZWRpY3RhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByZWRpY3RhYmxlIG91dHB1dCB0eXBlIG9mIGZ1bmN0aW9ucy4gV2hlbiB0cnVlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgdHlwZSBkZXBlbmRzIG9ubHkgb24gdGhlIGlucHV0IHR5cGVzLiBXaGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIChkZWZhdWx0KSwgb3V0cHV0IHR5cGUgY2FuIHZhcnkgZGVwZW5kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIGlucHV0IHZhbHVlcy4gRm9yIGV4YW1wbGUgYG1hdGguc3FydCgtMilgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYE5hTmAgd2hlbiBwcmVkaWN0YWJsZSBpcyBmYWxzZSwgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYGNvbXBsZXgoJzJpJylgIHdoZW4gdHJ1ZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBiYXJlLWJvbmUgbWF0aC5qcyBpbnN0YW5jZSBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAtIGBpbXBvcnRgIHRvIGFkZCBuZXcgZnVuY3Rpb25zXG4gKiAgICAgICAgICAgICAgICAgICAtIGBjb25maWdgIHRvIGNoYW5nZSBjb25maWd1cmF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAtIGBvbmAsIGBvZmZgLCBgb25jZWAsIGBlbWl0YCBmb3IgZXZlbnRzXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChvcHRpb25zKSB7XG4gIC8vIHNpbXBsZSB0ZXN0IGZvciBFUzUgc3VwcG9ydFxuICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VTNSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgSmF2YVNjcmlwdCBlbmdpbmUuICcgK1xuICAgICdQbGVhc2UgbG9hZCB0aGUgZXM1LXNoaW0gYW5kIGVzNS1zaGFtIGxpYnJhcnkgZm9yIGNvbXBhdGliaWxpdHkuJyk7XG4gIH1cblxuICAvLyBjYWNoZWQgZmFjdG9yaWVzIGFuZCBpbnN0YW5jZXNcbiAgdmFyIGZhY3RvcmllcyA9IFtdO1xuICB2YXIgaW5zdGFuY2VzID0gW107XG5cbiAgLy8gY3JlYXRlIGEgbmFtZXNwYWNlIGZvciB0aGUgbWF0aGpzIGluc3RhbmNlLCBhbmQgYXR0YWNoIGVtaXR0ZXIgZnVuY3Rpb25zXG4gIHZhciBtYXRoID0gZW1pdHRlci5taXhpbih7fSk7XG4gIG1hdGgudHlwZSA9IHt9O1xuICBtYXRoLmV4cHJlc3Npb24gPSB7XG4gICAgdHJhbnNmb3JtOiBPYmplY3QuY3JlYXRlKG1hdGgpXG4gIH07XG4gIG1hdGguYWxnZWJyYSA9IHt9O1xuXG4gIC8vIGNyZWF0ZSBhIG5ldyB0eXBlZCBpbnN0YW5jZVxuICBtYXRoLnR5cGVkID0gdHlwZWRGYWN0b3J5LmNyZWF0ZShtYXRoLnR5cGUpO1xuXG4gIC8vIGNyZWF0ZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFRoZXNlIGFyZSBwcml2YXRlXG4gIHZhciBfY29uZmlnID0ge1xuICAgIC8vIG1pbmltdW0gcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBjb21wYXJlZCB2YWx1ZXMsXG4gICAgLy8gdXNlZCBieSBhbGwgY29tcGFyaXNvbiBmdW5jdGlvbnNcbiAgICBlcHNpbG9uOiAxZS0xMixcblxuICAgIC8vIHR5cGUgb2YgZGVmYXVsdCBtYXRyaXggb3V0cHV0LiBDaG9vc2UgJ21hdHJpeCcgKGRlZmF1bHQpIG9yICdhcnJheSdcbiAgICBtYXRyaXg6ICdNYXRyaXgnLFxuXG4gICAgLy8gdHlwZSBvZiBkZWZhdWx0IG51bWJlciBvdXRwdXQuIENob29zZSAnbnVtYmVyJyAoZGVmYXVsdCkgJ0JpZ051bWJlcicsIG9yICdGcmFjdGlvblxuICAgIG51bWJlcjogJ251bWJlcicsXG5cbiAgICAvLyBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIGluIEJpZ051bWJlcnNcbiAgICBwcmVjaXNpb246IDY0LFxuXG4gICAgLy8gcHJlZGljdGFibGUgb3V0cHV0IHR5cGUgb2YgZnVuY3Rpb25zLiBXaGVuIHRydWUsIG91dHB1dCB0eXBlIGRlcGVuZHMgb25seVxuICAgIC8vIG9uIHRoZSBpbnB1dCB0eXBlcy4gV2hlbiBmYWxzZSAoZGVmYXVsdCksIG91dHB1dCB0eXBlIGNhbiB2YXJ5IGRlcGVuZGluZ1xuICAgIC8vIG9uIGlucHV0IHZhbHVlcy4gRm9yIGV4YW1wbGUgYG1hdGguc3FydCgtMilgIHJldHVybnMgYE5hTmAgd2hlblxuICAgIC8vIHByZWRpY3RhYmxlIGlzIGZhbHNlLCBhbmQgcmV0dXJucyBgY29tcGxleCgnMmknKWAgd2hlbiB0cnVlLlxuICAgIHByZWRpY3RhYmxlOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgZnVuY3Rpb24gb3IgZGF0YSB0eXBlIGZyb20gYSBmYWN0b3J5LlxuICAgKiBJZiB0aGUgZnVuY3Rpb24gb3IgZGF0YSB0eXBlIGFscmVhZHkgZXhpc3RzLCB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7e3R5cGU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBmYWN0b3J5OiBGdW5jdGlvbn19IGZhY3RvcnlcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBmdW5jdGlvbiBsb2FkIChmYWN0b3J5KSB7XG4gICAgaWYgKCFpc0ZhY3RvcnkoZmFjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFjdG9yeSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGB0eXBlYCwgYG5hbWVgLCBhbmQgYGZhY3RvcnlgIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZmFjdG9yaWVzLmluZGV4T2YoZmFjdG9yeSk7XG4gICAgdmFyIGluc3RhbmNlO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIC8vIGRvZXNuJ3QgeWV0IGV4aXN0XG4gICAgICBpZiAoZmFjdG9yeS5tYXRoID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHBhc3Mgd2l0aCBtYXRoIG5hbWVzcGFjZVxuICAgICAgICBpbnN0YW5jZSA9IGZhY3RvcnkuZmFjdG9yeShtYXRoLnR5cGUsIF9jb25maWcsIGxvYWQsIG1hdGgudHlwZWQsIG1hdGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGluc3RhbmNlID0gZmFjdG9yeS5mYWN0b3J5KG1hdGgudHlwZSwgX2NvbmZpZywgbG9hZCwgbWF0aC50eXBlZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGVuZCB0byB0aGUgY2FjaGVcbiAgICAgIGZhY3Rvcmllcy5wdXNoKGZhY3RvcnkpO1xuICAgICAgaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGFscmVhZHkgZXhpc3RpbmcgZnVuY3Rpb24sIHJldHVybiB0aGUgY2FjaGVkIGluc3RhbmNlXG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbmRleF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLy8gbG9hZCB0aGUgaW1wb3J0IGFuZCBjb25maWcgZnVuY3Rpb25zXG4gIG1hdGhbJ2ltcG9ydCddID0gbG9hZChpbXBvcnRGYWN0b3J5KTtcbiAgbWF0aFsnY29uZmlnJ10gPSBsb2FkKGNvbmZpZ0ZhY3RvcnkpO1xuXG4gIC8vIGFwcGx5IG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBtYXRoLmNvbmZpZyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBtYXRoO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBNQVRSSVggPSBbJ01hdHJpeCcsICdBcnJheSddOyAgICAgICAgICAgICAgICAgICAvLyB2YWxpZCB2YWx1ZXMgZm9yIG9wdGlvbiBtYXRyaXhcbiAgdmFyIE5VTUJFUiA9IFsnbnVtYmVyJywgJ0JpZ051bWJlcicsICdGcmFjdGlvbiddOyAgIC8vIHZhbGlkIHZhbHVlcyBmb3Igb3B0aW9uIG51bWJlclxuXG4gIC8qKlxuICAgKiBTZXQgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBtYXRoLmpzLCBhbmQgZ2V0IGN1cnJlbnQgb3B0aW9ucy5cbiAgICogV2lsbCBlbWl0IGEgJ2NvbmZpZycgZXZlbnQsIHdpdGggYXJndW1lbnRzIChjdXJyLCBwcmV2KS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5jb25maWcoY29uZmlnOiBPYmplY3QpOiBPYmplY3RcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbmZpZygpLm51bWJlcjsgICAgICAgICAgICAgICAgLy8gb3V0cHV0cyAnbnVtYmVyJ1xuICAgKiAgICAgbWF0aC5ldmFsKCcwLjQnKTsgICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dHMgbnVtYmVyIDAuNFxuICAgKiAgICAgbWF0aC5jb25maWcoe251bWJlcjogJ0ZyYWN0aW9uJ30pO1xuICAgKiAgICAgbWF0aC5ldmFsKCcwLjQnKTsgICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dHMgRnJhY3Rpb24gMi81XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXJ9IGVwc2lsb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNaW5pbXVtIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d29cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlZCB2YWx1ZXMsIHVzZWQgYnkgYWxsIGNvbXBhcmlzb24gZnVuY3Rpb25zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBtYXRyaXhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHN0cmluZyAnTWF0cml4JyAoZGVmYXVsdCkgb3IgJ0FycmF5Jy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbnVtYmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzdHJpbmcgJ251bWJlcicgKGRlZmF1bHQpLCAnQmlnTnVtYmVyJywgb3IgJ0ZyYWN0aW9uJ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBwcmVjaXNpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBmb3IgQmlnTnVtYmVycy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3QgYXBwbGljYWJsZSBmb3IgTnVtYmVycy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gcGFyZW50aGVzaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIb3cgdG8gZGlzcGxheSBwYXJlbnRoZXNlcyBpbiBMYVRlWCBhbmQgc3RyaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gX2NvbmZpZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcmV2ID0gb2JqZWN0LmNsb25lKGNvbmZpZyk7XG5cbiAgICAgIC8vIHZhbGlkYXRlIHNvbWUgb2YgdGhlIG9wdGlvbnNcbiAgICAgIHZhbGlkYXRlT3B0aW9uKG9wdGlvbnMsICdtYXRyaXgnLCBNQVRSSVgpO1xuICAgICAgdmFsaWRhdGVPcHRpb24ob3B0aW9ucywgJ251bWJlcicsIE5VTUJFUik7XG5cbiAgICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICAgIG9iamVjdC5kZWVwRXh0ZW5kKGNvbmZpZywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBjdXJyID0gb2JqZWN0LmNsb25lKGNvbmZpZyk7XG5cbiAgICAgIC8vIGVtaXQgJ2NvbmZpZycgZXZlbnRcbiAgICAgIG1hdGguZW1pdCgnY29uZmlnJywgY3VyciwgcHJldik7XG5cbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmplY3QuY2xvbmUoY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvLyBhdHRhY2ggdGhlIHZhbGlkIG9wdGlvbnMgdG8gdGhlIGZ1bmN0aW9uIHNvIHRoZXkgY2FuIGJlIGV4dGVuZGVkXG4gIF9jb25maWcuTUFUUklYID0gTUFUUklYO1xuICBfY29uZmlnLk5VTUJFUiA9IE5VTUJFUjtcblxuICByZXR1cm4gX2NvbmZpZztcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gQXJyYXkgY29udGFpbnMgYSBzcGVjaWZpYyBpdGVtLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gYXJyYXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWlucyAoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufVxuXG4vKipcbiAqIEZpbmQgYSBzdHJpbmcgaW4gYW4gYXJyYXkuIENhc2UgaW5zZW5zaXRpdmUgc2VhcmNoXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBhcnJheVxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1cbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggd2hlbiBmb3VuZC4gUmV0dXJucyAtMSB3aGVuIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXggKGFycmF5LCBpdGVtKSB7XG4gIHJldHVybiBhcnJheVxuICAgICAgLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSlcbiAgICAgIC5pbmRleE9mKGl0ZW0udG9Mb3dlckNhc2UoKSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gb3B0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgIE9iamVjdCB3aXRoIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgICAgICAgTmFtZSBvZiB0aGUgb3B0aW9uIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB2YWx1ZXMgIEFycmF5IHdpdGggdmFsaWQgdmFsdWVzIGZvciB0aGlzIG9wdGlvblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbihvcHRpb25zLCBuYW1lLCB2YWx1ZXMpIHtcbiAgaWYgKG9wdGlvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiAhY29udGFpbnModmFsdWVzLCBvcHRpb25zW25hbWVdKSkge1xuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleCh2YWx1ZXMsIG9wdGlvbnNbbmFtZV0pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIHJpZ2h0IHZhbHVlLCB3cm9uZyBjYXNpbmdcbiAgICAgIC8vIFRPRE86IGxvd2VyIGNhc2UgdmFsdWVzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHYzLCByZW1vdmUgdGhpcyB3YXJuaW5nIHNvbWUgZGF5LlxuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBXcm9uZyBjYXNpbmcgZm9yIGNvbmZpZ3VyYXRpb24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIsIHNob3VsZCBiZSBcIicgKyB2YWx1ZXNbaW5kZXhdICsgJ1wiIGluc3RlYWQgb2YgXCInICsgb3B0aW9uc1tuYW1lXSArICdcIi4nKTtcblxuICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07IC8vIGNoYW5nZSB0aGUgb3B0aW9uIHRvIHRoZSByaWdodCBjYXNpbmdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB1bmtub3duIHZhbHVlXG4gICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IFVua25vd24gdmFsdWUgXCInICsgb3B0aW9uc1tuYW1lXSArICdcIiBmb3IgY29uZmlndXJhdGlvbiBvcHRpb24gXCInICsgbmFtZSArICdcIi4gQXZhaWxhYmxlIG9wdGlvbnM6ICcgKyB2YWx1ZXMubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKCcsICcpICsgJy4nKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NvbmZpZyc7XG5leHBvcnRzLm1hdGggPSB0cnVlOyAvLyByZXF1ZXN0IHRoZSBtYXRoIG5hbWVzcGFjZSBhcyBmaWZ0aCBhcmd1bWVudFxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxhenkgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5sYXp5O1xudmFyIGlzRmFjdG9yeSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmlzRmFjdG9yeTtcbnZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLnRyYXZlcnNlO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmV4dGVuZDtcbnZhciBBcmd1bWVudHNFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL0FyZ3VtZW50c0Vycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgLyoqXG4gICAqIEltcG9ydCBmdW5jdGlvbnMgZnJvbSBhbiBvYmplY3Qgb3IgYSBtb2R1bGVcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmltcG9ydChvYmplY3QpXG4gICAqICAgIG1hdGguaW1wb3J0KG9iamVjdCwgb3B0aW9ucylcbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIC0gYG9iamVjdDogT2JqZWN0YFxuICAgKiAgIEFuIG9iamVjdCB3aXRoIGZ1bmN0aW9ucyB0byBiZSBpbXBvcnRlZC5cbiAgICogLSBgb3B0aW9uczogT2JqZWN0YCBBbiBvYmplY3Qgd2l0aCBpbXBvcnQgb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgLSBgb3ZlcnJpZGU6IGJvb2xlYW5gXG4gICAqICAgICBJZiB0cnVlLCBleGlzdGluZyBmdW5jdGlvbnMgd2lsbCBiZSBvdmVyd3JpdHRlbi4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogICAtIGBzaWxlbnQ6IGJvb2xlYW5gXG4gICAqICAgICBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCBub3QgdGhyb3cgZXJyb3JzIG9uIGR1cGxpY2F0ZXMgb3IgaW52YWxpZFxuICAgKiAgICAgdHlwZXMuIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAqICAgLSBgd3JhcDogYm9vbGVhbmBcbiAgICogICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSB3cmFwcGVkIGluIGEgd3JhcHBlciBmdW5jdGlvblxuICAgKiAgICAgd2hpY2ggY29udmVydHMgZGF0YSB0eXBlcyBsaWtlIE1hdHJpeCB0byBwcmltaXRpdmUgZGF0YSB0eXBlcyBsaWtlIEFycmF5LlxuICAgKiAgICAgVGhlIHdyYXBwZXIgaXMgbmVlZGVkIHdoZW4gZXh0ZW5kaW5nIG1hdGguanMgd2l0aCBsaWJyYXJpZXMgd2hpY2ggZG8gbm90XG4gICAqICAgICBzdXBwb3J0IHRoZXNlIGRhdGEgdHlwZS4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIC8vIGRlZmluZSBuZXcgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcbiAgICogICAgbWF0aC5pbXBvcnQoe1xuICAgKiAgICAgIG15dmFsdWU6IDQyLFxuICAgKiAgICAgIGhlbGxvOiBmdW5jdGlvbiAobmFtZSkge1xuICAgKiAgICAgICAgcmV0dXJuICdoZWxsbywgJyArIG5hbWUgKyAnISc7XG4gICAqICAgICAgfVxuICAgKiAgICB9KTtcbiAgICpcbiAgICogICAgLy8gdXNlIHRoZSBpbXBvcnRlZCBmdW5jdGlvbiBhbmQgdmFyaWFibGVcbiAgICogICAgbWF0aC5teXZhbHVlICogMjsgICAgICAgICAgICAgICAvLyA4NFxuICAgKiAgICBtYXRoLmhlbGxvKCd1c2VyJyk7ICAgICAgICAgICAgIC8vICdoZWxsbywgdXNlciEnXG4gICAqXG4gICAqICAgIC8vIGltcG9ydCB0aGUgbnBtIG1vZHVsZSAnbnVtYmVycydcbiAgICogICAgLy8gKG11c3QgYmUgaW5zdGFsbGVkIGZpcnN0IHdpdGggYG5wbSBpbnN0YWxsIG51bWJlcnNgKVxuICAgKiAgICBtYXRoLmltcG9ydChyZXF1aXJlKCdudW1iZXJzJyksIHt3cmFwOiB0cnVlfSk7XG4gICAqXG4gICAqICAgIG1hdGguZmlib25hY2NpKDcpOyAvLyByZXR1cm5zIDEzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IG9iamVjdCAgIE9iamVjdCB3aXRoIGZ1bmN0aW9ucyB0byBiZSBpbXBvcnRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgSW1wb3J0IG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXRoX2ltcG9ydChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgbnVtID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobnVtICE9IDEgJiYgbnVtICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBBcmd1bWVudHNFcnJvcignaW1wb3J0JywgbnVtLCAxLCAyKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoaXNGYWN0b3J5KG9iamVjdCkpIHtcbiAgICAgIF9pbXBvcnRGYWN0b3J5KG9iamVjdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRPRE86IGFsbG93IGEgdHlwZWQtZnVuY3Rpb24gd2l0aCBuYW1lIHRvb1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIG1hdGhfaW1wb3J0KGVudHJ5LCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBtYXAgd2l0aCBmdW5jdGlvbnNcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RbbmFtZV07XG4gICAgICAgICAgaWYgKGlzU3VwcG9ydGVkVHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIF9pbXBvcnQobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0ZhY3Rvcnkob2JqZWN0KSkge1xuICAgICAgICAgICAgX2ltcG9ydEZhY3Rvcnkob2JqZWN0LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRoX2ltcG9ydCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWN0b3J5LCBPYmplY3QsIG9yIEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHByb3BlcnR5IHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhbmQgY3JlYXRlIGEgY2hhaW4gcHJveHkgZm9yIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBTZWUgaW1wb3J0IGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfaW1wb3J0KG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud3JhcCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHdyYXBwZXIgYXJvdW5kIHRoZSBmdW5jdGlvblxuICAgICAgdmFsdWUgPSBfd3JhcCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzVHlwZWRGdW5jdGlvbihtYXRoW25hbWVdKSAmJiBpc1R5cGVkRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBpZiAob3B0aW9ucy5vdmVycmlkZSkge1xuICAgICAgICAvLyBnaXZlIHRoZSB0eXBlZCBmdW5jdGlvbiB0aGUgcmlnaHQgbmFtZVxuICAgICAgICB2YWx1ZSA9IHR5cGVkKG5hbWUsIHZhbHVlLnNpZ25hdHVyZXMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG1lcmdlIHRoZSBleGlzdGluZyBhbmQgdHlwZWQgZnVuY3Rpb25cbiAgICAgICAgdmFsdWUgPSB0eXBlZChtYXRoW25hbWVdLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG1hdGhbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIF9pbXBvcnRUcmFuc2Zvcm0obmFtZSwgdmFsdWUpO1xuICAgICAgbWF0aC5lbWl0KCdpbXBvcnQnLCBuYW1lLCBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hdGhbbmFtZV0gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm92ZXJyaWRlKSB7XG4gICAgICBtYXRoW25hbWVdID0gdmFsdWU7XG4gICAgICBfaW1wb3J0VHJhbnNmb3JtKG5hbWUsIHZhbHVlKTtcbiAgICAgIG1hdGguZW1pdCgnaW1wb3J0JywgbmFtZSwgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGltcG9ydCBcIicgKyBuYW1lICsgJ1wiOiBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbXBvcnRUcmFuc2Zvcm0gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1hdGguZXhwcmVzc2lvbi50cmFuc2Zvcm1bbmFtZV0gPSB2YWx1ZS50cmFuc2Zvcm07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHdyYXBwZXIgYSByb3VuZCBhbiBmdW5jdGlvbiB3aGljaCBjb252ZXJ0cyB0aGUgYXJndW1lbnRzXG4gICAqIHRvIHRoZWlyIHByaW1pdGl2ZSB2YWx1ZXMgKGxpa2UgY29udmVydCBhIE1hdHJpeCB0byBBcnJheSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF93cmFwIChmbikge1xuICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlciAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBhcmdzW2ldID0gYXJnICYmIGFyZy52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4uYXBwbHkobWF0aCwgYXJncyk7XG4gICAgfTtcblxuICAgIGlmIChmbi50cmFuc2Zvcm0pIHtcbiAgICAgIHdyYXBwZXIudHJhbnNmb3JtID0gZm4udHJhbnNmb3JtO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydCBhbiBpbnN0YW5jZSBvZiBhIGZhY3RvcnkgaW50byBtYXRoLmpzXG4gICAqIEBwYXJhbSB7e2ZhY3Rvcnk6IEZ1bmN0aW9uLCBuYW1lOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgbWF0aDogYm9vbGVhbn19IGZhY3RvcnlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIFNlZSBpbXBvcnQgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9pbXBvcnRGYWN0b3J5KGZhY3RvcnksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZhY3RvcnkubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuYW1lID0gZmFjdG9yeS5uYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IGZhY3RvcnkucGF0aCA/IHRyYXZlcnNlKG1hdGgsIGZhY3RvcnkucGF0aCkgOiBtYXRoO1xuICAgICAgdmFyIGV4aXN0aW5nID0gbmFtZXNwYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gbmFtZXNwYWNlW25hbWVdIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGxvYWQoZmFjdG9yeSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiB0eXBlb2YgaW5zdGFuY2UudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2Zvcm1zIGNhbm5vdCBiZSBhdHRhY2hlZCB0byBmYWN0b3J5IGZ1bmN0aW9ucy4gJyArXG4gICAgICAgICAgICAgICdQbGVhc2UgY3JlYXRlIGEgc2VwYXJhdGUgZnVuY3Rpb24gZm9yIGl0IHdpdGggZXhwb3J0cy5wYXRoPVwiZXhwcmVzc2lvbi50cmFuc2Zvcm1cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVHlwZWRGdW5jdGlvbihleGlzdGluZykgJiYgaXNUeXBlZEZ1bmN0aW9uKGluc3RhbmNlKSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBleGlzdGluZyB0eXBlZCBmdW5jdGlvbiAobm90aGluZyB0byBkbylcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBtZXJnZSB0aGUgZXhpc3RpbmcgYW5kIG5ldyB0eXBlZCBmdW5jdGlvblxuICAgICAgICAgICAgaW5zdGFuY2UgPSB0eXBlZChleGlzdGluZywgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub3ZlcnJpZGUpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IFwiJyArIG5hbWUgKyAnXCI6IGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChmYWN0b3J5LmxhenkgIT09IGZhbHNlKSB7XG4gICAgICAgIGxhenkobmFtZXNwYWNlLCBuYW1lLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmFtZXNwYWNlW25hbWVdID0gcmVzb2x2ZXIoKTtcbiAgICAgIH1cblxuICAgICAgbWF0aC5lbWl0KCdpbXBvcnQnLCBuYW1lLCByZXNvbHZlciwgZmFjdG9yeS5wYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB1bm5hbWVkIGZhY3RvcnkuXG4gICAgICAvLyBubyBsYXp5IGxvYWRpbmdcbiAgICAgIGxvYWQoZmFjdG9yeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgdHlwZSB3aGljaCBjYW4gYmUgaW1wb3J0ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbiB8IG51bWJlciB8IHN0cmluZyB8IGJvb2xlYW4gfCBudWxsIHwgVW5pdCB8IENvbXBsZXh9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09ICdmdW5jdGlvbidcbiAgICAgICAgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ251bWJlcidcbiAgICAgICAgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZydcbiAgICAgICAgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgIHx8IG9iamVjdCA9PT0gbnVsbFxuICAgICAgICB8fCAob2JqZWN0ICYmIG9iamVjdC5pc1VuaXQgPT09IHRydWUpXG4gICAgICAgIHx8IChvYmplY3QgJiYgb2JqZWN0LmlzQ29tcGxleCA9PT0gdHJ1ZSlcbiAgICAgICAgfHwgKG9iamVjdCAmJiBvYmplY3QuaXNCaWdOdW1iZXIgPT09IHRydWUpXG4gICAgICAgIHx8IChvYmplY3QgJiYgb2JqZWN0LmlzRnJhY3Rpb24gPT09IHRydWUpXG4gICAgICAgIHx8IChvYmplY3QgJiYgb2JqZWN0LmlzTWF0cml4ID09PSB0cnVlKVxuICAgICAgICB8fCAob2JqZWN0ICYmIEFycmF5LmlzQXJyYXkob2JqZWN0KSA9PT0gdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSBnaXZlbiB0aGluZyBpcyBhIHR5cGVkLWZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gZm5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gYGZuYCBpcyBhIHR5cGVkLWZ1bmN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBpc1R5cGVkRnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZm4uc2lnbmF0dXJlcyA9PT0gJ29iamVjdCc7XG4gIH1cblxuICByZXR1cm4gbWF0aF9pbXBvcnQ7XG59XG5cbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbmV4cG9ydHMubmFtZSA9ICdpbXBvcnQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbmV4cG9ydHMubGF6eSA9IHRydWU7XG4iLCJ2YXIgdHlwZWRGdW5jdGlvbiA9IHJlcXVpcmUoJ3R5cGVkLWZ1bmN0aW9uJyk7XG52YXIgZGlnaXRzID0gcmVxdWlyZSgnLi8uLi91dGlscy9udW1iZXInKS5kaWdpdHM7XG5cbi8vIHJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgdHlwZWQtZnVuY3Rpb25cbnZhciBjcmVhdGVUeXBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaW5pdGlhbGx5LCByZXR1cm4gdGhlIG9yaWdpbmFsIGluc3RhbmNlIG9mIHR5cGVkLWZ1bmN0aW9uXG4gIC8vIGNvbnNlY3V0aXZlbHksIHJldHVybiBhIG5ldyBpbnN0YW5jZSBmcm9tIHR5cGVkLmNyZWF0ZS5cbiAgY3JlYXRlVHlwZWQgPSB0eXBlZEZ1bmN0aW9uLmNyZWF0ZTtcbiAgcmV0dXJuIHR5cGVkRnVuY3Rpb247XG59O1xuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IHR5cGVkIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZSAgIE9iamVjdCB3aXRoIGRhdGEgdHlwZXMgbGlrZSBDb21wbGV4IGFuZCBCaWdOdW1iZXJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUodHlwZSkge1xuICAvLyBUT0RPOiB0eXBlZC1mdW5jdGlvbiBtdXN0IGJlIGFibGUgdG8gc2lsZW50bHkgaWdub3JlIHNpZ25hdHVyZXMgd2l0aCB1bmtub3duIGRhdGEgdHlwZXNcblxuICAvLyBnZXQgYSBuZXcgaW5zdGFuY2Ugb2YgdHlwZWQtZnVuY3Rpb25cbiAgdmFyIHR5cGVkID0gY3JlYXRlVHlwZWQoKTtcblxuICAvLyBkZWZpbmUgYWxsIHR5cGVzLiBUaGUgb3JkZXIgb2YgdGhlIHR5cGVzIGRldGVybWluZXMgaW4gd2hpY2ggb3JkZXIgZnVuY3Rpb25cbiAgLy8gYXJndW1lbnRzIGFyZSB0eXBlLWNoZWNrZWQgKHNvIGZvciBwZXJmb3JtYW5jZSBpdCdzIGltcG9ydGFudCB0byBwdXQgdGhlXG4gIC8vIG1vc3QgdXNlZCB0eXBlcyBmaXJzdCkuXG4gIHR5cGVkLnR5cGVzID0gW1xuICAgIHsgbmFtZTogJ251bWJlcicsICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgfSB9LFxuICAgIHsgbmFtZTogJ0NvbXBsZXgnLCAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNDb21wbGV4IH0gfSxcbiAgICB7IG5hbWU6ICdCaWdOdW1iZXInLCAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzQmlnTnVtYmVyIH0gfSxcbiAgICB7IG5hbWU6ICdGcmFjdGlvbicsICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzRnJhY3Rpb24gfSB9LFxuICAgIHsgbmFtZTogJ1VuaXQnLCAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNVbml0IH0gfSxcbiAgICB7IG5hbWU6ICdzdHJpbmcnLCAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnIH0gfSxcbiAgICB7IG5hbWU6ICdBcnJheScsICAgICAgICAgICB0ZXN0OiBBcnJheS5pc0FycmF5IH0sXG4gICAgeyBuYW1lOiAnTWF0cml4JywgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc01hdHJpeCB9IH0sXG4gICAgeyBuYW1lOiAnRGVuc2VNYXRyaXgnLCAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0RlbnNlTWF0cml4IH0gfSxcbiAgICB7IG5hbWU6ICdTcGFyc2VNYXRyaXgnLCAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzU3BhcnNlTWF0cml4IH0gfSxcbiAgICB7IG5hbWU6ICdSYW5nZScsICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzUmFuZ2UgfSB9LFxuICAgIHsgbmFtZTogJ0luZGV4JywgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNJbmRleCB9IH0sXG4gICAgeyBuYW1lOiAnYm9vbGVhbicsICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnYm9vbGVhbicgfSB9LFxuICAgIHsgbmFtZTogJ1Jlc3VsdFNldCcsICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNSZXN1bHRTZXQgfSB9LFxuICAgIHsgbmFtZTogJ0hlbHAnLCAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNIZWxwIH0gfSxcbiAgICB7IG5hbWU6ICdmdW5jdGlvbicsICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbid9IH0sXG4gICAgeyBuYW1lOiAnRGF0ZScsICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBEYXRlIH0gfSxcbiAgICB7IG5hbWU6ICdSZWdFeHAnLCAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIFJlZ0V4cCB9IH0sXG4gICAgeyBuYW1lOiAnT2JqZWN0JywgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB9IH0sXG4gICAgeyBuYW1lOiAnbnVsbCcsICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IG51bGwgfSB9LFxuICAgIHsgbmFtZTogJ3VuZGVmaW5lZCcsICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID09PSB1bmRlZmluZWQgfSB9LFxuICAgIFxuICAgIHsgbmFtZTogJ09wZXJhdG9yTm9kZScsICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNPcGVyYXRvck5vZGUgfSB9LFxuICAgIHsgbmFtZTogJ0NvbnN0YW50Tm9kZScsICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNDb25zdGFudE5vZGUgfSB9LFxuICAgIHsgbmFtZTogJ1N5bWJvbE5vZGUnLCAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNTeW1ib2xOb2RlIH0gfSxcbiAgICB7IG5hbWU6ICdQYXJlbnRoZXNpc05vZGUnLCB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzUGFyZW50aGVzaXNOb2RlIH0gfSxcbiAgICB7IG5hbWU6ICdGdW5jdGlvbk5vZGUnLCAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzRnVuY3Rpb25Ob2RlIH0gfSxcbiAgICB7IG5hbWU6ICdGdW5jdGlvbkFzc2lnbm1lbnROb2RlJywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0Z1bmN0aW9uQXNzaWdubWVudE5vZGUgfSB9LFxuICAgIHsgbmFtZTogJ0FycmF5Tm9kZScsICAgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzQXJyYXlOb2RlIH0gfSxcbiAgICB7IG5hbWU6ICdBc3NpZ25tZW50Tm9kZScsICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0Fzc2lnbm1lbnROb2RlIH0gfSxcbiAgICB7IG5hbWU6ICdCbG9ja05vZGUnLCAgICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc0Jsb2NrTm9kZSB9IH0sXG4gICAgeyBuYW1lOiAnQ29uZGl0aW9uYWxOb2RlJywgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNDb25kaXRpb25hbE5vZGUgfSB9LFxuICAgIHsgbmFtZTogJ0luZGV4Tm9kZScsICAgICAgICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB4LmlzSW5kZXhOb2RlIH0gfSxcbiAgICB7IG5hbWU6ICdSYW5nZU5vZGUnLCAgICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc1JhbmdlTm9kZSB9IH0sXG4gICAgeyBuYW1lOiAnVXBkYXRlTm9kZScsICAgICAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHguaXNVcGRhdGVOb2RlIH0gfSxcbiAgICB7IG5hbWU6ICdOb2RlJywgICAgICAgICAgICAgICAgICAgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgeC5pc05vZGUgfSB9XG4gIF07XG5cbiAgLy8gVE9ETzogYWRkIGNvbnZlcnNpb24gZnJvbSBCaWdOdW1iZXIgdG8gbnVtYmVyP1xuICB0eXBlZC5jb252ZXJzaW9ucyA9IFtcbiAgICB7XG4gICAgICBmcm9tOiAnbnVtYmVyJyxcbiAgICAgIHRvOiAnQmlnTnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIC8vIG5vdGU6IGNvbnZlcnNpb24gZnJvbSBudW1iZXIgdG8gQmlnTnVtYmVyIGNhbiBmYWlsIGlmIHggaGFzID4xNSBkaWdpdHNcbiAgICAgICAgaWYgKGRpZ2l0cyh4KSA+IDE1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGltcGxpY2l0bHkgY29udmVydCBhIG51bWJlciB3aXRoID4xNSBzaWduaWZpY2FudCBkaWdpdHMgdG8gQmlnTnVtYmVyICcgK1xuICAgICAgICAgICcodmFsdWU6ICcgKyB4ICsgJykuICcgK1xuICAgICAgICAgICdVc2UgZnVuY3Rpb24gYmlnbnVtYmVyKHgpIHRvIGNvbnZlcnQgdG8gQmlnTnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoeCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bWJlcicsXG4gICAgICB0bzogJ0NvbXBsZXgnLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bWJlcicsXG4gICAgICB0bzogJ3N0cmluZycsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCArICcnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdCaWdOdW1iZXInLFxuICAgICAgdG86ICdDb21wbGV4JyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgudG9OdW1iZXIoKSwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ0ZyYWN0aW9uJyxcbiAgICAgIHRvOiAnQmlnTnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbXBsaWNpdGx5IGNvbnZlcnQgYSBGcmFjdGlvbiB0byBCaWdOdW1iZXIgb3IgdmljZSB2ZXJzYS4gJyArXG4gICAgICAgICAgICAnVXNlIGZ1bmN0aW9uIGJpZ251bWJlcih4KSB0byBjb252ZXJ0IHRvIEJpZ051bWJlciBvciBmcmFjdGlvbih4KSB0byBjb252ZXJ0IHRvIEZyYWN0aW9uLicpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdGcmFjdGlvbicsXG4gICAgICB0bzogJ0NvbXBsZXgnLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeC52YWx1ZU9mKCksIDApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdudW1iZXInLFxuICAgICAgdG86ICdGcmFjdGlvbicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoZGlnaXRzKHgpID4gMTUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgaW1wbGljaXRseSBjb252ZXJ0IGEgbnVtYmVyIHdpdGggPjE1IHNpZ25pZmljYW50IGRpZ2l0cyB0byBGcmFjdGlvbiAnICtcbiAgICAgICAgICAgICAgJyh2YWx1ZTogJyArIHggKyAnKS4gJyArXG4gICAgICAgICAgICAgICdVc2UgZnVuY3Rpb24gZnJhY3Rpb24oeCkgdG8gY29udmVydCB0byBGcmFjdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oeCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgIC8vIEZJWE1FOiBhZGQgY29udmVyc2lvbiBmcm9tIEZyYWN0aW9uIHRvIG51bWJlciwgZm9yIGV4YW1wbGUgZm9yIGBzcXJ0KGZyYWN0aW9uKDEsMykpYFxuICAgIC8vICBmcm9tOiAnRnJhY3Rpb24nLFxuICAgIC8vICB0bzogJ251bWJlcicsXG4gICAgLy8gIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgLy8gICAgcmV0dXJuIHgudmFsdWVPZigpO1xuICAgIC8vICB9XG4gICAgLy99LCB7XG4gICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgIHRvOiAnbnVtYmVyJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBuID0gTnVtYmVyKHgpO1xuICAgICAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IFwiJyArIHggKyAnXCIgdG8gYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnYm9vbGVhbicsXG4gICAgICB0bzogJ251bWJlcicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gK3g7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ2Jvb2xlYW4nLFxuICAgICAgdG86ICdCaWdOdW1iZXInLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigreCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ2Jvb2xlYW4nLFxuICAgICAgdG86ICdGcmFjdGlvbicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oK3gpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdib29sZWFuJyxcbiAgICAgIHRvOiAnc3RyaW5nJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiAreDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnbnVsbCcsXG4gICAgICB0bzogJ251bWJlcicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGZyb206ICdudWxsJyxcbiAgICAgIHRvOiAnc3RyaW5nJyxcbiAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnbnVsbCcsXG4gICAgICB0bzogJ0JpZ051bWJlcicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbTogJ251bGwnLFxuICAgICAgdG86ICdGcmFjdGlvbicsXG4gICAgICBjb252ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5GcmFjdGlvbigwKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnQXJyYXknLFxuICAgICAgdG86ICdNYXRyaXgnLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIC8vIFRPRE86IGhvdyB0byBkZWNpZGUgb24gdGhlIHJpZ2h0IHR5cGUgb2YgbWF0cml4IHRvIGNyZWF0ZT9cbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkRlbnNlTWF0cml4KGFycmF5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBmcm9tOiAnTWF0cml4JyxcbiAgICAgIHRvOiAnQXJyYXknLFxuICAgICAgY29udmVydDogZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gbWF0cml4LnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICB9XG4gIF07XG5cbiAgcmV0dXJuIHR5cGVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW50YXggZXJyb3Igd2l0aCB0aGUgbWVzc2FnZTpcbiAqICAgICAnV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBmdW5jdGlvbiA8Zm4+ICg8Y291bnQ+IHByb3ZpZGVkLCA8bWluPi08bWF4PiBleHBlY3RlZCknXG4gKiBAcGFyYW0ge3N0cmluZ30gZm4gICAgIEZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAgQWN0dWFsIGFyZ3VtZW50IGNvdW50XG4gKiBAcGFyYW0ge251bWJlcn0gbWluICAgIE1pbmltdW0gcmVxdWlyZWQgYXJndW1lbnQgY291bnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XSAgTWF4aW11bSByZXF1aXJlZCBhcmd1bWVudCBjb3VudFxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xuZnVuY3Rpb24gQXJndW1lbnRzRXJyb3IoZm4sIGNvdW50LCBtaW4sIG1heCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXJndW1lbnRzRXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb3VudCA9IGNvdW50O1xuICB0aGlzLm1pbiA9IG1pbjtcbiAgdGhpcy5tYXggPSBtYXg7XG5cbiAgdGhpcy5tZXNzYWdlID0gJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgaW4gZnVuY3Rpb24gJyArIGZuICtcbiAgICAgICcgKCcgKyBjb3VudCArICcgcHJvdmlkZWQsICcgK1xuICAgICAgbWluICsgKChtYXggIT0gdW5kZWZpbmVkKSA/ICgnLScgKyBtYXgpIDogJycpICsgJyBleHBlY3RlZCknO1xuXG4gIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuXG5Bcmd1bWVudHNFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkFyZ3VtZW50c0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVycm9yO1xuQXJndW1lbnRzRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXJndW1lbnRzRXJyb3InO1xuQXJndW1lbnRzRXJyb3IucHJvdG90eXBlLmlzQXJndW1lbnRzRXJyb3IgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZ3VtZW50c0Vycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGVycm9yIHdpdGggdGhlIG1lc3NhZ2U6XG4gKiAgICAgJ0RpbWVuc2lvbiBtaXNtYXRjaCAoPGFjdHVhbCBzaXplPiAhPSA8ZXhwZWN0ZWQgc2l6ZT4pJ1xuICogQHBhcmFtIHtudW1iZXIgfCBudW1iZXJbXX0gYWN0dWFsICAgICAgICBUaGUgYWN0dWFsIHNpemVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVtYmVyW119IGV4cGVjdGVkICAgICAgVGhlIGV4cGVjdGVkIHNpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVsYXRpb249JyE9J10gICAgICAgICAgT3B0aW9uYWwgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGV4cGVjdGVkIHNpemU6ICchPScsICc8JywgZXRjLlxuICogQGV4dGVuZHMgUmFuZ2VFcnJvclxuICovXG5mdW5jdGlvbiBEaW1lbnNpb25FcnJvcihhY3R1YWwsIGV4cGVjdGVkLCByZWxhdGlvbikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGltZW5zaW9uRXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgfVxuXG4gIHRoaXMuYWN0dWFsICAgPSBhY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuXG4gIHRoaXMubWVzc2FnZSA9ICdEaW1lbnNpb24gbWlzbWF0Y2ggKCcgK1xuICAgICAgKEFycmF5LmlzQXJyYXkoYWN0dWFsKSA/ICgnWycgKyBhY3R1YWwuam9pbignLCAnKSArICddJykgOiBhY3R1YWwpICtcbiAgICAgICcgJyArICh0aGlzLnJlbGF0aW9uIHx8ICchPScpICsgJyAnICtcbiAgICAgIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSA/ICgnWycgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJ10nKSA6IGV4cGVjdGVkKSArXG4gICAgICAnKSc7XG5cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cbkRpbWVuc2lvbkVycm9yLnByb3RvdHlwZSA9IG5ldyBSYW5nZUVycm9yKCk7XG5EaW1lbnNpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5nZUVycm9yO1xuRGltZW5zaW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRGltZW5zaW9uRXJyb3InO1xuRGltZW5zaW9uRXJyb3IucHJvdG90eXBlLmlzRGltZW5zaW9uRXJyb3IgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbkVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGVycm9yIHdpdGggdGhlIG1lc3NhZ2U6XG4gKiAgICAgJ0luZGV4IG91dCBvZiByYW5nZSAoaW5kZXggPCBtaW4pJ1xuICogICAgICdJbmRleCBvdXQgb2YgcmFuZ2UgKGluZGV4IDwgbWF4KSdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggICAgIFRoZSBhY3R1YWwgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdICAgTWluaW11bSBpbmRleCAoaW5jbHVkZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW21heF0gICAgIE1heGltdW0gaW5kZXggKGV4Y2x1ZGVkKVxuICogQGV4dGVuZHMgUmFuZ2VFcnJvclxuICovXG5mdW5jdGlvbiBJbmRleEVycm9yKGluZGV4LCBtaW4sIG1heCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5kZXhFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgdGhpcy5pbmRleCA9IGluZGV4O1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICB0aGlzLm1pbiA9IDA7XG4gICAgdGhpcy5tYXggPSBtaW47XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBpZiAodGhpcy5taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluZGV4IDwgdGhpcy5taW4pIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnSW5kZXggb3V0IG9mIHJhbmdlICgnICsgdGhpcy5pbmRleCArICcgPCAnICsgdGhpcy5taW4gKyAnKSc7XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5tYXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluZGV4ID49IHRoaXMubWF4KSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ0luZGV4IG91dCBvZiByYW5nZSAoJyArIHRoaXMuaW5kZXggKyAnID4gJyArICh0aGlzLm1heCAtIDEpICsgJyknO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9ICdJbmRleCBvdXQgb2YgcmFuZ2UgKCcgKyB0aGlzLmluZGV4ICsgJyknO1xuICB9XG5cbiAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cbkluZGV4RXJyb3IucHJvdG90eXBlID0gbmV3IFJhbmdlRXJyb3IoKTtcbkluZGV4RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2VFcnJvcjtcbkluZGV4RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSW5kZXhFcnJvcic7XG5JbmRleEVycm9yLnByb3RvdHlwZS5pc0luZGV4RXJyb3IgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi91dGlscy9vYmplY3QnKTtcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuLi91dGlscy9zdHJpbmcnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgcGFyc2VyID0gbG9hZChyZXF1aXJlKCcuL2Z1bmN0aW9uL3BhcnNlcicpKSgpO1xuXG4gIC8qKlxuICAgKiBEb2N1bWVudGF0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZG9jICBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGNhdGVnb3J5XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGRlc2NyaXB0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmdbXX0gc3ludGF4XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmdbXX0gZXhhbXBsZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAge3N0cmluZ1tdfSBzZWVhbHNvXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSGVscChkb2MpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGVscCkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb2MpICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IFwiZG9jXCIgbWlzc2luZycpO1xuXG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIEhlbHAucHJvdG90eXBlLnR5cGUgPSAnSGVscCc7XG4gIEhlbHAucHJvdG90eXBlLmlzSGVscCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBIZWxwIG9iamVjdFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgYSBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEhlbHAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmRvYyB8fCB7fTtcbiAgICB2YXIgZGVzYyA9ICdcXG4nO1xuXG4gICAgaWYgKGRvYy5uYW1lKSB7XG4gICAgICBkZXNjICs9ICdOYW1lOiAnICsgZG9jLm5hbWUgKyAnXFxuXFxuJztcbiAgICB9XG4gICAgaWYgKGRvYy5jYXRlZ29yeSkge1xuICAgICAgZGVzYyArPSAnQ2F0ZWdvcnk6ICcgKyBkb2MuY2F0ZWdvcnkgKyAnXFxuXFxuJztcbiAgICB9XG4gICAgaWYgKGRvYy5kZXNjcmlwdGlvbikge1xuICAgICAgZGVzYyArPSAnRGVzY3JpcHRpb246XFxuICAgICcgKyBkb2MuZGVzY3JpcHRpb24gKyAnXFxuXFxuJztcbiAgICB9XG4gICAgaWYgKGRvYy5zeW50YXgpIHtcbiAgICAgIGRlc2MgKz0gJ1N5bnRheDpcXG4gICAgJyArIGRvYy5zeW50YXguam9pbignXFxuICAgICcpICsgJ1xcblxcbic7XG4gICAgfVxuICAgIGlmIChkb2MuZXhhbXBsZXMpIHtcbiAgICAgIGRlc2MgKz0gJ0V4YW1wbGVzOlxcbic7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5leGFtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXhwciA9IGRvYy5leGFtcGxlc1tpXTtcbiAgICAgICAgZGVzYyArPSAnICAgICcgKyBleHByICsgJ1xcbic7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBwYXJzZXIuZXZhbChleHByKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcyA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcyAmJiAhcmVzLmlzSGVscCkge1xuICAgICAgICAgIGRlc2MgKz0gJyAgICAgICAgJyArIHN0cmluZy5mb3JtYXQocmVzLCB7cHJlY2lzaW9uOiAxNH0pICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc2MgKz0gJ1xcbic7XG4gICAgfVxuICAgIGlmIChkb2Muc2VlYWxzbykge1xuICAgICAgZGVzYyArPSAnU2VlIGFsc286ICcgKyBkb2Muc2VlYWxzby5qb2luKCcsICcpICsgJ1xcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgaGVscCBvYmplY3QgdG8gSlNPTlxuICAgKi9cbiAgSGVscC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSBvYmplY3QuY2xvbmUodGhpcy5kb2MpO1xuICAgIG9iai5tYXRoanMgPSAnSGVscCc7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYSBIZWxwIG9iamVjdCBmcm9tIGEgSlNPTiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAgICogQHJldHVybnMge0hlbHB9IFJldHVybnMgYSBuZXcgSGVscCBvYmplY3RcbiAgICovXG4gIEhlbHAuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBkb2MgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIGpzb24pIHtcbiAgICAgIGlmIChwcm9wICE9PSAnbWF0aGpzJykgeyAvLyBpZ25vcmUgbWF0aGpzIGZpZWxkXG4gICAgICAgIGRvY1twcm9wXSA9IGpzb25bcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSGVscChkb2MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBIZWxwIG9iamVjdFxuICAgKi9cbiAgSGVscC5wcm90b3R5cGUudmFsdWVPZiA9IEhlbHAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIHJldHVybiBIZWxwO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnSGVscCc7XG5leHBvcnRzLnBhdGggPSAndHlwZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbHMvb2JqZWN0JykuZXh0ZW5kO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBfcGFyc2UgPSBsb2FkKHJlcXVpcmUoJy4vcGFyc2UnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBQYXJzZXJcbiAgICogUGFyc2VyIGNvbnRhaW5zIG1ldGhvZHMgdG8gZXZhbHVhdGUgb3IgcGFyc2UgZXhwcmVzc2lvbnMsIGFuZCBoYXMgYSBudW1iZXJcbiAgICogb2YgY29udmVuaWVuY2UgbWV0aG9kcyB0byBnZXQsIHNldCwgYW5kIHJlbW92ZSB2YXJpYWJsZXMgZnJvbSBtZW1vcnkuIFBhcnNlclxuICAgKiBrZWVwcyBhIHNjb3BlIGNvbnRhaW5pbmcgdmFyaWFibGVzIGluIG1lbW9yeSwgd2hpY2ggaXMgdXNlZCBmb3IgYWxsXG4gICAqIGV2YWx1YXRpb25zLlxuICAgKlxuICAgKiBNZXRob2RzOlxuICAgKiAgICB2YXIgcmVzdWx0ID0gcGFyc2VyLmV2YWwoZXhwcik7ICAgIC8vIGV2YWx1YXRlIGFuIGV4cHJlc3Npb25cbiAgICogICAgdmFyIHZhbHVlID0gcGFyc2VyLmdldChuYW1lKTsgICAgICAvLyByZXRyaWV2ZSBhIHZhcmlhYmxlIGZyb20gdGhlIHBhcnNlclxuICAgKiAgICB2YXIgdmFsdWVzID0gcGFyc2VyLmdldEFsbCgpOyAgICAgIC8vIHJldHJpZXZlIGFsbCBkZWZpbmVkIHZhcmlhYmxlc1xuICAgKiAgICBwYXJzZXIuc2V0KG5hbWUsIHZhbHVlKTsgICAgICAgICAgIC8vIHNldCBhIHZhcmlhYmxlIGluIHRoZSBwYXJzZXJcbiAgICogICAgcGFyc2VyLnJlbW92ZShuYW1lKTsgICAgICAgICAgICAgICAvLyBjbGVhciBhIHZhcmlhYmxlIGZyb20gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2VycyBzY29wZVxuICAgKiAgICBwYXJzZXIuY2xlYXIoKTsgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBwYXJzZXJzIHNjb3BlXG4gICAqXG4gICAqIEV4YW1wbGUgdXNhZ2U6XG4gICAqICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAqICAgIC8vIE5vdGU6IHRoZXJlIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHdoaWNoIGNhbiBiZSB1c2VkIGluc3RlYWQ6XG4gICAqICAgIC8vIHZhciBwYXJzZXIgPSBuZXcgbWF0aC5wYXJzZXIoKTtcbiAgICpcbiAgICogICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvbnNcbiAgICogICAgcGFyc2VyLmV2YWwoJ3NxcnQoM14yICsgNF4yKScpOyAgICAgICAgIC8vIDVcbiAgICogICAgcGFyc2VyLmV2YWwoJ3NxcnQoLTQpJyk7ICAgICAgICAgICAgICAgIC8vIDJpXG4gICAqICAgIHBhcnNlci5ldmFsKCcyIGluY2ggaW4gY20nKTsgICAgICAgICAgICAvLyA1LjA4IGNtXG4gICAqICAgIHBhcnNlci5ldmFsKCdjb3MoNDUgZGVnKScpOyAgICAgICAgICAgICAvLyAwLjcwNzEwNjc4MTE4NjU0NzZcbiAgICpcbiAgICogICAgLy8gZGVmaW5lIHZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zXG4gICAqICAgIHBhcnNlci5ldmFsKCd4ID0gNyAvIDInKTsgICAgICAgICAgICAgICAvLyAzLjVcbiAgICogICAgcGFyc2VyLmV2YWwoJ3ggKyAzJyk7ICAgICAgICAgICAgICAgICAgIC8vIDYuNVxuICAgKiAgICBwYXJzZXIuZXZhbCgnZnVuY3Rpb24gZih4LCB5KSA9IHheeScpOyAgLy8gZih4LCB5KVxuICAgKiAgICBwYXJzZXIuZXZhbCgnZigyLCAzKScpOyAgICAgICAgICAgICAgICAgLy8gOFxuICAgKlxuICAgKiAgICAvLyBnZXQgYW5kIHNldCB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9uc1xuICAgKiAgICB2YXIgeCA9IHBhcnNlci5nZXQoJ3gnKTsgICAgICAgICAgICAgICAgLy8gN1xuICAgKiAgICB2YXIgZiA9IHBhcnNlci5nZXQoJ2YnKTsgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25cbiAgICogICAgdmFyIGcgPSBmKDMsIDIpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIDlcbiAgICogICAgcGFyc2VyLnNldCgnaCcsIDUwMCk7XG4gICAqICAgIHZhciBpID0gcGFyc2VyLmV2YWwoJ2ggLyAyJyk7ICAgICAgICAgICAvLyAyNTBcbiAgICogICAgcGFyc2VyLnNldCgnaGVsbG8nLCBmdW5jdGlvbiAobmFtZSkge1xuICAgKiAgICAgICAgcmV0dXJuICdoZWxsbywgJyArIG5hbWUgKyAnISc7XG4gICAqICAgIH0pO1xuICAgKiAgICBwYXJzZXIuZXZhbCgnaGVsbG8oXCJ1c2VyXCIpJyk7ICAgICAgICAgICAvLyBcImhlbGxvLCB1c2VyIVwiXG4gICAqXG4gICAqICAgIC8vIGNsZWFyIGRlZmluZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcbiAgICogICAgcGFyc2VyLmNsZWFyKCk7XG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhcnNlcikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgUGFyc2VyLnByb3RvdHlwZS50eXBlID0gJ1BhcnNlcic7XG4gIFBhcnNlci5wcm90b3R5cGUuaXNQYXJzZXIgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIGFuZCByZXR1cm4gdGhlIHBhcnNlZCBmdW5jdGlvbiBub2RlLlxuICAgKiBUaGUgbm9kZSB0cmVlIGNhbiBiZSBjb21waWxlZCB2aWEgYGNvZGUgPSBub2RlLmNvbXBpbGUobWF0aClgLFxuICAgKiBhbmQgdGhlIGNvbXBpbGVkIGNvZGUgY2FuIGJlIGV4ZWN1dGVkIGFzIGBjb2RlLmV2YWwoW3Njb3BlXSlgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlci5wYXJzZSBpcyBkZXByZWNhdGVkLiBVc2UgbWF0aC5wYXJzZSBpbnN0ZWFkLicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbmQgY29tcGlsZSBhbiBleHByZXNzaW9uLCByZXR1cm4gdGhlIGNvbXBpbGVkIGphdmFzY3JpcHQgY29kZS5cbiAgICogVGhlIG5vZGUgY2FuIGJlIGV2YWx1YXRlZCB2aWEgY29kZS5ldmFsKFtzY29wZV0pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gICAqIEByZXR1cm4ge3tldmFsOiBmdW5jdGlvbn19IGNvZGVcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBQYXJzZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyLmNvbXBpbGUgaXMgZGVwcmVjYXRlZC4gVXNlIG1hdGguY29tcGlsZSBpbnN0ZWFkLicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbmQgZXZhbHVhdGUgdGhlIGdpdmVuIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHIgICBBIHN0cmluZyBjb250YWluaW5nIGFuIGV4cHJlc3Npb24sIGZvciBleGFtcGxlIFwiMiszXCJcbiAgICogQHJldHVybiB7Kn0gcmVzdWx0ICAgICBUaGUgcmVzdWx0LCBvciB1bmRlZmluZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiB3YXMgZW1wdHlcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBQYXJzZXIucHJvdG90eXBlLmV2YWwgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGFyZ3VtZW50c1xuICAgIHJldHVybiBfcGFyc2UoZXhwcilcbiAgICAgICAgLmNvbXBpbGUoKVxuICAgICAgICAuZXZhbCh0aGlzLnNjb3BlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgdmFyaWFibGUgKGEgZnVuY3Rpb24gb3IgdmFyaWFibGUpIGJ5IG5hbWUgZnJvbSB0aGUgcGFyc2VycyBzY29wZS5cbiAgICogUmV0dXJucyB1bmRlZmluZWQgd2hlbiBub3QgZm91bmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7KiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICovXG4gIFBhcnNlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgICByZXR1cm4gdGhpcy5zY29wZVtuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgbWFwIHdpdGggYWxsIGRlZmluZWQgdmFyaWFibGVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gdmFsdWVzXG4gICAqL1xuICBQYXJzZXIucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLnNjb3BlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgc3ltYm9sIChhIGZ1bmN0aW9uIG9yIHZhcmlhYmxlKSBieSBuYW1lIGZyb20gdGhlIHBhcnNlcnMgc2NvcGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7KiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAgICovXG4gIFBhcnNlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUgYXJndW1lbnRzXG4gICAgcmV0dXJuIHRoaXMuc2NvcGVbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUgZnJvbSB0aGUgcGFyc2VycyBzY29wZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgUGFyc2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGFyZ3VtZW50c1xuICAgIGRlbGV0ZSB0aGlzLnNjb3BlW25hbWVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgc2NvcGUgd2l0aCB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9uc1xuICAgKi9cbiAgUGFyc2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuc2NvcGUpIHtcbiAgICAgIGlmICh0aGlzLnNjb3BlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjb3BlW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGFyc2VyO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnUGFyc2VyJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLm1hdGggPSB0cnVlOyAvLyByZXF1aXJlcyB0aGUgbWF0aCBuYW1lc3BhY2UgYXMgNXRoIGFyZ3VtZW50XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnSW5maW5pdHknLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnSW5maW5pdHknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdJbmZpbml0eSwgYSBudW1iZXIgd2hpY2ggaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHRoYXQgY2FuIGJlIGhhbmRsZWQgYnkgYSBmbG9hdGluZyBwb2ludCBudW1iZXIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdJbmZpbml0eScsXG4gICAgJzEgLyAwJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ0xOMTAnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnTE4xMCdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JldHVybnMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIDEwLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDIuMzAyJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdMTjEwJyxcbiAgICAnbG9nKDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdMTjInLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnTE4yJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMiwgYXBwcm94aW1hdGVseSBlcXVhbCB0byAwLjY5MycsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnTE4yJyxcbiAgICAnbG9nKDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ0xPRzEwRScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdMT0cxMEUnXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXR1cm5zIHRoZSBiYXNlLTEwIGxvZ2FyaXRobSBvZiBFLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDAuNDM0JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdMT0cxMEUnLFxuICAgICdsb2coZSwgMTApJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ0xPRzJFJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ0xPRzJFJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUmV0dXJucyB0aGUgYmFzZS0yIGxvZ2FyaXRobSBvZiBFLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDEuNDQyJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdMT0cyRScsXG4gICAgJ2xvZyhlLCAyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdOYU4nLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnTmFOJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTm90IGEgbnVtYmVyJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdOYU4nLFxuICAgICcwIC8gMCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdTUVJUMV8yJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ1NRUlQxXzInXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiAxLzIsIGFwcHJveGltYXRlbHkgZXF1YWwgdG8gMC43MDcnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ1NRUlQxXzInLFxuICAgICdzcXJ0KDEvMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnU1FSVDInLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnU1FSVDInXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdSZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiAyLCBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDEuNDE0JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdTUVJUMicsXG4gICAgJ3NxcnQoMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdlJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRXVsZXJcXCdzIG51bWJlciwgdGhlIGJhc2Ugb2YgdGhlIG5hdHVyYWwgbG9nYXJpdGhtLiBBcHByb3hpbWF0ZWx5IGVxdWFsIHRvIDIuNzE4MjgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2UnLFxuICAgICdlIF4gMicsXG4gICAgJ2V4cCgyKScsXG4gICAgJ2xvZyhlKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2V4cCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZhbHNlJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2ZhbHNlJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQm9vbGVhbiB2YWx1ZSBmYWxzZScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZmFsc2UnXG4gIF0sXG4gICdzZWVhbHNvJzogWyd0cnVlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaScsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnSW1hZ2luYXJ5IHVuaXQsIGRlZmluZWQgYXMgaSppPS0xLiBBIGNvbXBsZXggbnVtYmVyIGlzIGRlc2NyaWJlZCBhcyBhICsgYippLCB3aGVyZSBhIGlzIHRoZSByZWFsIHBhcnQsIGFuZCBiIGlzIHRoZSBpbWFnaW5hcnkgcGFydC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2knLFxuICAgICdpICogaScsXG4gICAgJ3NxcnQoLTEpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ251bGwnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbnVsbCdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1ZhbHVlIG51bGwnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ251bGwnXG4gIF0sXG4gICdzZWVhbHNvJzogWyd0cnVlJywgJ2ZhbHNlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncGhpJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0YW50cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3BoaSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1BoaSBpcyB0aGUgZ29sZGVuIHJhdGlvLiBUd28gcXVhbnRpdGllcyBhcmUgaW4gdGhlIGdvbGRlbiByYXRpbyBpZiB0aGVpciByYXRpbyBpcyB0aGUgc2FtZSBhcyB0aGUgcmF0aW8gb2YgdGhlaXIgc3VtIHRvIHRoZSBsYXJnZXIgb2YgdGhlIHR3byBxdWFudGl0aWVzLiBQaGkgaXMgZGVmaW5lZCBhcyBgKDEgKyBzcXJ0KDUpKSAvIDJgIGFuZCBpcyBhcHByb3hpbWF0ZWx5IDEuNjE4MDM0Li4uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0YXUnXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncGknLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncGknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUaGUgbnVtYmVyIHBpIGlzIGEgbWF0aGVtYXRpY2FsIGNvbnN0YW50IHRoYXQgaXMgdGhlIHJhdGlvIG9mIGEgY2lyY2xlXFwncyBjaXJjdW1mZXJlbmNlIHRvIGl0cyBkaWFtZXRlciwgYW5kIGlzIGFwcHJveGltYXRlbHkgZXF1YWwgdG8gMy4xNDE1OScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAncGknLFxuICAgICdzaW4ocGkvMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWyd0YXUnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0YXUnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndGF1J1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGF1IGlzIHRoZSByYXRpbyBjb25zdGFudCBvZiBhIGNpcmNsZVxcJ3MgY2lyY3VtZmVyZW5jZSB0byByYWRpdXMsIGVxdWFsIHRvIDIgKiBwaSwgYXBwcm94aW1hdGVseSA2LjI4MzIuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0YXUnLFxuICAgICcyICogcGknXG4gIF0sXG4gICdzZWVhbHNvJzogWydwaSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3RydWUnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RhbnRzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndHJ1ZSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0Jvb2xlYW4gdmFsdWUgdHJ1ZScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndHJ1ZSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2ZhbHNlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndmVyc2lvbicsXG4gICdjYXRlZ29yeSc6ICdDb25zdGFudHMnLFxuICAnc3ludGF4JzogW1xuICAgICd2ZXJzaW9uJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQSBzdHJpbmcgd2l0aCB0aGUgdmVyc2lvbiBudW1iZXIgb2YgbWF0aC5qcycsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndmVyc2lvbidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdiaWdudW1iZXInLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYmlnbnVtYmVyKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIGJpZyBudW1iZXIgZnJvbSBhIG51bWJlciBvciBzdHJpbmcuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcwLjEgKyAwLjInLFxuICAgICdiaWdudW1iZXIoMC4xKSArIGJpZ251bWJlcigwLjIpJyxcbiAgICAnYmlnbnVtYmVyKFwiNy4yXCIpJyxcbiAgICAnYmlnbnVtYmVyKFwiNy4yZTUwMFwiKScsXG4gICAgJ2JpZ251bWJlcihbMC4xLCAwLjIsIDAuM10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYm9vbGVhbicsICdjb21wbGV4JywgJ2ZyYWN0aW9uJywgJ2luZGV4JywgJ21hdHJpeCcsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdib29sZWFuJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ3gnLFxuICAgICdib29sZWFuKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbnZlcnQgYSBzdHJpbmcgb3IgbnVtYmVyIGludG8gYSBib29sZWFuLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYm9vbGVhbigwKScsXG4gICAgJ2Jvb2xlYW4oMSknLFxuICAgICdib29sZWFuKDMpJyxcbiAgICAnYm9vbGVhbihcInRydWVcIiknLFxuICAgICdib29sZWFuKFwiZmFsc2VcIiknLFxuICAgICdib29sZWFuKFsxLCAwLCAxLCAxXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnY29tcGxleCcsICdpbmRleCcsICdtYXRyaXgnLCAnbnVtYmVyJywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbXBsZXgnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY29tcGxleCgpJyxcbiAgICAnY29tcGxleChyZSwgaW0pJyxcbiAgICAnY29tcGxleChzdHJpbmcpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIGNvbXBsZXggbnVtYmVyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY29tcGxleCgpJyxcbiAgICAnY29tcGxleCgyLCAzKScsXG4gICAgJ2NvbXBsZXgoXCI3IC0gMmlcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdpbmRleCcsICdtYXRyaXgnLCAnbnVtYmVyJywgJ3N0cmluZycsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NyZWF0ZVVuaXQnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY3JlYXRlVW5pdChkZWZpbml0aW9ucyknLFxuICAgICdjcmVhdGVVbml0KG5hbWUsIGRlZmluaXRpb24pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIHVzZXItZGVmaW5lZCB1bml0IGFuZCByZWdpc3RlciBpdCB3aXRoIHRoZSBVbml0IHR5cGUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjcmVhdGVVbml0KFwiZm9vXCIpJyxcbiAgICAnY3JlYXRlVW5pdChcImtub3RcIiwge2RlZmluaXRpb246IFwiMC41MTQ0NDQ0NDQgbS9zXCIsIGFsaWFzZXM6IFtcImtub3RzXCIsIFwia3RcIiwgXCJrdHNcIl19KScsXG4gICAgJ2NyZWF0ZVVuaXQoXCJtcGhcIiwgXCIxIG1pbGUvaG91clwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3VuaXQnLCAnc3BsaXRVbml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZyYWN0aW9uJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ2ZyYWN0aW9uKG51bSknLFxuICAgICdmcmFjdGlvbihudW0sZGVuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAnQ3JlYXRlIGEgZnJhY3Rpb24gZnJvbSBhIG51bWJlciBvciBmcm9tIGEgbnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ZyYWN0aW9uKDAuMTI1KScsXG4gICAgJ2ZyYWN0aW9uKDEsIDMpICsgZnJhY3Rpb24oMiwgNSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2luZGV4JywgJ21hdHJpeCcsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpbmRleCcsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICdbc3RhcnRdJyxcbiAgICAnW3N0YXJ0OmVuZF0nLFxuICAgICdbc3RhcnQ6c3RlcDplbmRdJyxcbiAgICAnW3N0YXJ0MSwgc3RhcnQgMiwgLi4uXScsXG4gICAgJ1tzdGFydDE6ZW5kMSwgc3RhcnQyOmVuZDIsIC4uLl0nLFxuICAgICdbc3RhcnQxOnN0ZXAxOmVuZDEsIHN0YXJ0MjpzdGVwMjplbmQyLCAuLi5dJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhbiBpbmRleCB0byBnZXQgb3IgcmVwbGFjZSBhIHN1YnNldCBvZiBhIG1hdHJpeCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnW10nLFxuICAgICdbMSwgMiwgM10nLFxuICAgICdBID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnQVsxLCA6XScsXG4gICAgJ0FbMSwgMl0gPSA1MCcsXG4gICAgJ0FbMDoyLCAwOjJdID0gb25lcygyLCAyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpZ251bWJlcicsICdib29sZWFuJywgJ2NvbXBsZXgnLCAnbWF0cml4LCcsICdudW1iZXInLCAncmFuZ2UnLCAnc3RyaW5nJywgJ3VuaXQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWF0cml4JyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ1tdJyxcbiAgICAnW2ExLCBiMSwgLi4uOyBhMiwgYjIsIC4uLl0nLFxuICAgICdtYXRyaXgoKScsXG4gICAgJ21hdHJpeChcImRlbnNlXCIpJyxcbiAgICAnbWF0cml4KFsuLi5dKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdbXScsXG4gICAgJ1sxLCAyLCAzXScsXG4gICAgJ1sxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ21hdHJpeCgpJyxcbiAgICAnbWF0cml4KFszLCA0XSknLFxuICAgICdtYXRyaXgoWzMsIDQ7IDUsIDZdLCBcInNwYXJzZVwiKScsXG4gICAgJ21hdHJpeChbMywgNDsgNSwgNl0sIFwic3BhcnNlXCIsIFwibnVtYmVyXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYmlnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnY29tcGxleCcsICdpbmRleCcsICdudW1iZXInLCAnc3RyaW5nJywgJ3VuaXQnLCAnc3BhcnNlJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ251bWJlcicsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICd4JyxcbiAgICAnbnVtYmVyKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIG51bWJlciBvciBjb252ZXJ0IGEgc3RyaW5nIG9yIGJvb2xlYW4gaW50byBhIG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzInLFxuICAgICcyZTMnLFxuICAgICc0LjA1JyxcbiAgICAnbnVtYmVyKDIpJyxcbiAgICAnbnVtYmVyKFwiNy4yXCIpJyxcbiAgICAnbnVtYmVyKHRydWUpJyxcbiAgICAnbnVtYmVyKFt0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZV0pJyxcbiAgICAnbnVtYmVyKFwiNTJjbVwiLCBcIm1cIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2ZyYWN0aW9uJywgJ2luZGV4JywgJ21hdHJpeCcsICdzdHJpbmcnLCAndW5pdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzcGFyc2UnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3BhcnNlKCknLFxuICAgICdzcGFyc2UoW2ExLCBiMSwgLi4uOyBhMSwgYjIsIC4uLl0pJyxcbiAgICAnc3BhcnNlKFthMSwgYjEsIC4uLjsgYTEsIGIyLCAuLi5dLCBcIm51bWJlclwiKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgJ0NyZWF0ZSBhIHNwYXJzZSBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzcGFyc2UoKScsXG4gICAgJ3NwYXJzZShbMywgNDsgNSwgNl0pJyxcbiAgICAnc3BhcnNlKFszLCAwOyA1LCAwXSwgXCJudW1iZXJcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2luZGV4JywgJ251bWJlcicsICdzdHJpbmcnLCAndW5pdCcsICdtYXRyaXgnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3BsaXRVbml0JyxcbiAgJ2NhdGVnb3J5JzogJ0NvbnN0cnVjdGlvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NwbGl0VW5pdCh1bml0OiBVbml0LCBwYXJ0czogVW5pdFtdKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdTcGxpdCBhIHVuaXQgaW4gYW4gYXJyYXkgb2YgdW5pdHMgd2hvc2Ugc3VtIGlzIGVxdWFsIHRvIHRoZSBvcmlnaW5hbCB1bml0LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3BsaXRVbml0KDEgbSwgW1wiZmVldFwiLCBcImluY2hcIl0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAndW5pdCcsICdjcmVhdGVVbml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N0cmluZycsXG4gICdjYXRlZ29yeSc6ICdDb25zdHJ1Y3Rpb24nLFxuICAnc3ludGF4JzogW1xuICAgICdcInRleHRcIicsXG4gICAgJ3N0cmluZyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDcmVhdGUgYSBzdHJpbmcgb3IgY29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdcIkhlbGxvIFdvcmxkIVwiJyxcbiAgICAnc3RyaW5nKDQuMiknLFxuICAgICdzdHJpbmcoMyArIDJpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpZ251bWJlcicsICdib29sZWFuJywgJ2NvbXBsZXgnLCAnaW5kZXgnLCAnbWF0cml4JywgJ251bWJlcicsICd1bml0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3VuaXQnLFxuICAnY2F0ZWdvcnknOiAnQ29uc3RydWN0aW9uJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndmFsdWUgdW5pdCcsXG4gICAgJ3VuaXQodmFsdWUsIHVuaXQpJyxcbiAgICAndW5pdChzdHJpbmcpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NyZWF0ZSBhIHVuaXQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc1LjUgbW0nLFxuICAgICczIGluY2gnLFxuICAgICd1bml0KDcuMSwgXCJraWxvZ3JhbVwiKScsXG4gICAgJ3VuaXQoXCIyMyBkZWdcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaWdudW1iZXInLCAnYm9vbGVhbicsICdjb21wbGV4JywgJ2luZGV4JywgJ21hdHJpeCcsICdudW1iZXInLCAnc3RyaW5nJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbmZpZycsXG4gICdjYXRlZ29yeSc6ICdDb3JlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY29uZmlnKCknLFxuICAgICdjb25maWcob3B0aW9ucyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgY29uZmlndXJhdGlvbiBvciBjaGFuZ2UgY29uZmlndXJhdGlvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbmZpZygpJyxcbiAgICAnMS8zICsgMS80JyxcbiAgICAnY29uZmlnKHtudW1iZXI6IFwiRnJhY3Rpb25cIn0pJyxcbiAgICAnMS8zICsgMS80J1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ltcG9ydCcsXG4gICdjYXRlZ29yeSc6ICdDb3JlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaW1wb3J0KGZ1bmN0aW9ucyknLFxuICAgICdpbXBvcnQoZnVuY3Rpb25zLCBvcHRpb25zKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0ltcG9ydCBmdW5jdGlvbnMgb3IgY29uc3RhbnRzIGZyb20gYW4gb2JqZWN0LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaW1wb3J0KHtteUZuOiBmKHgpPXheMiwgbXlDb25zdGFudDogMzIgfSknLFxuICAgICdteUZuKDIpJyxcbiAgICAnbXlDb25zdGFudCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0eXBlZCcsXG4gICdjYXRlZ29yeSc6ICdDb3JlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndHlwZWQoc2lnbmF0dXJlcyknLFxuICAgICd0eXBlZChuYW1lLCBzaWduYXR1cmVzKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NyZWF0ZSBhIHR5cGVkIGZ1bmN0aW9uLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZG91YmxlID0gdHlwZWQoeyBcIm51bWJlciwgbnVtYmVyXCI6IGYoeCk9eCt4IH0pJyxcbiAgICAnZG91YmxlKDIpJyxcbiAgICAnZG91YmxlKFwiaGVsbG9cIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGVyaXZhdGl2ZScsXG4gICdjYXRlZ29yeSc6ICdBbGdlYnJhJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZGVyaXZhdGl2ZShleHByKScsXG4gICAgJ2Rlcml2YXRpdmUoZXhwciwge3NpbXBsaWZ5OiBib29sZWFufSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUYWtlcyB0aGUgZGVyaXZhdGl2ZSBvZiBhbiBleHByZXNzaW9uIGV4cHJlc3NlZCBpbiBwYXJzZXIgTm9kZXMuIFRoZSBkZXJpdmF0aXZlIHdpbGwgYmUgdGFrZW4gb3ZlciB0aGUgc3VwcGxpZWQgdmFyaWFibGUgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIuIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YXJpYWJsZXMgaW4gdGhlIGV4cHJlc3Npb24sIGl0IHdpbGwgcmV0dXJuIGEgcGFydGlhbCBkZXJpdmF0aXZlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZGVyaXZhdGl2ZShcIjJ4XjNcIiwgXCJ4XCIpJyxcbiAgICAnZGVyaXZhdGl2ZShcIjJ4XjNcIiwgXCJ4XCIsIHtzaW1wbGlmeTogZmFsc2V9KScsXG4gICAgJ2Rlcml2YXRpdmUoXCIyeF4yICsgM3ggKyA0XCIsIFwieFwiKScsXG4gICAgJ2Rlcml2YXRpdmUoXCJzaW4oMngpXCIsIFwieFwiKScsXG4gICAgJ2YgPSBwYXJzZShcInheMiArIHhcIiknLFxuICAgICd4ID0gcGFyc2UoXCJ4XCIpJyxcbiAgICAnZGYgPSBkZXJpdmF0aXZlKGYsIHgpJyxcbiAgICAnZGYuZXZhbCh7eDogM30pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnc2ltcGxpZnknLCAncGFyc2UnLCAnZXZhbCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsc29sdmUnLFxuICAnY2F0ZWdvcnknOiAnQWxnZWJyYScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3g9bHNvbHZlKEwsIGIpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAnU29sdmVzIHRoZSBsaW5lYXIgc3lzdGVtIEwgKiB4ID0gYiB3aGVyZSBMIGlzIGFuIFtuIHggbl0gbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggYW5kIGIgaXMgYSBbbl0gY29sdW1uIHZlY3Rvci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSBbLTIsIDM7IDIsIDFdJyxcbiAgICAnYiA9IFsxMSwgOV0nLFxuICAgICd4ID0gbHNvbHZlKGEsIGIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbHVwJywgJ2x1c29sdmUnLCAndXNvbHZlJywgJ21hdHJpeCcsICdzcGFyc2UnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbHVwJyxcbiAgJ2NhdGVnb3J5JzogJ0FsZ2VicmEnLFxuICAnc3ludGF4JzogW1xuICAgICdsdXAobSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICdDYWxjdWxhdGUgdGhlIE1hdHJpeCBMVSBkZWNvbXBvc2l0aW9uIHdpdGggcGFydGlhbCBwaXZvdGluZy4gTWF0cml4IEEgaXMgZGVjb21wb3NlZCBpbiB0aHJlZSBtYXRyaWNlcyAoTCwgVSwgUCkgd2hlcmUgUCAqIEEgPSBMICogVScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbHVwKFtbMiwgMV0sIFsxLCA0XV0pJyxcbiAgICAnbHVwKG1hdHJpeChbWzIsIDFdLCBbMSwgNF1dKSknLFxuICAgICdsdXAoc3BhcnNlKFtbMiwgMV0sIFsxLCA0XV0pKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2x1c29sdmUnLCAnbHNvbHZlJywgJ3Vzb2x2ZScsICdtYXRyaXgnLCAnc3BhcnNlJywgJ3NsdSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsdXNvbHZlJyxcbiAgJ2NhdGVnb3J5JzogJ0FsZ2VicmEnLFxuICAnc3ludGF4JzogW1xuICAgICd4PWx1c29sdmUoQSwgYiknLFxuICAgICd4PWx1c29sdmUobHUsIGIpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnU29sdmVzIHRoZSBsaW5lYXIgc3lzdGVtIEEgKiB4ID0gYiB3aGVyZSBBIGlzIGFuIFtuIHggbl0gbWF0cml4IGFuZCBiIGlzIGEgW25dIGNvbHVtbiB2ZWN0b3IuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWy0yLCAzOyAyLCAxXScsXG4gICAgJ2IgPSBbMTEsIDldJyxcbiAgICAneCA9IGx1c29sdmUoYSwgYiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdsdXAnLCAnc2x1JywgJ2xzb2x2ZScsICd1c29sdmUnLCAnbWF0cml4JywgJ3NwYXJzZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzaW1wbGlmeScsXG4gICdjYXRlZ29yeSc6ICdBbGdlYnJhJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc2ltcGxpZnkoZXhwciknLFxuICAgICdzaW1wbGlmeShleHByLCBydWxlcyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdTaW1wbGlmeSBhbiBleHByZXNzaW9uIHRyZWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzaW1wbGlmeShcIjMgKyAyIC8gNFwiKScsXG4gICAgJ3NpbXBsaWZ5KFwiMnggKyB4XCIpJyxcbiAgICAnZiA9IHBhcnNlKFwieCAqICh4ICsgMiArIHgpXCIpJyxcbiAgICAnc2ltcGxpZmllZCA9IHNpbXBsaWZ5KGYpJyxcbiAgICAnc2ltcGxpZmllZC5ldmFsKHt4OiAyfSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdkZXJpdmF0aXZlJywgJ3BhcnNlJywgJ2V2YWwnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2x1JyxcbiAgJ2NhdGVnb3J5JzogJ0FsZ2VicmEnLFxuICAnc3ludGF4JzogW1xuICAgICdzbHUoQSwgb3JkZXIsIHRocmVzaG9sZCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIE1hdHJpeCBMVSBkZWNvbXBvc2l0aW9uIHdpdGggZnVsbCBwaXZvdGluZy4gTWF0cml4IEEgaXMgZGVjb21wb3NlZCBpbiB0d28gbWF0cmljZXMgKEwsIFUpIGFuZCB0d28gcGVybXV0YXRpb24gdmVjdG9ycyAocGludiwgcSkgd2hlcmUgUCAqIEEgKiBRID0gTCAqIFUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3NsdShzcGFyc2UoWzQuNSwgMCwgMy4yLCAwOyAzLjEsIDIuOSwgMCwgMC45OyAwLCAxLjcsIDMsIDA7IDMuNSwgMC40LCAwLCAxXSksIDEsIDAuMDAxKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2x1c29sdmUnLCAnbHNvbHZlJywgJ3Vzb2x2ZScsICdtYXRyaXgnLCAnc3BhcnNlJywgJ2x1cCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd1c29sdmUnLFxuICAnY2F0ZWdvcnknOiAnQWxnZWJyYScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3g9dXNvbHZlKFUsIGIpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAnU29sdmVzIHRoZSBsaW5lYXIgc3lzdGVtIFUgKiB4ID0gYiB3aGVyZSBVIGlzIGFuIFtuIHggbl0gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggYW5kIGIgaXMgYSBbbl0gY29sdW1uIHZlY3Rvci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3g9dXNvbHZlKHNwYXJzZShbMSwgMSwgMSwgMTsgMCwgMSwgMSwgMTsgMCwgMCwgMSwgMTsgMCwgMCwgMCwgMV0pLCBbMTsgMjsgMzsgNF0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbHVwJywgJ2x1c29sdmUnLCAnbHNvbHZlJywgJ21hdHJpeCcsICdzcGFyc2UnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYWJzJyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdhYnMoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FicygzLjUpJyxcbiAgICAnYWJzKC00LjIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnc2lnbiddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FkZCcsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4ICsgeScsXG4gICAgJ2FkZCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0FkZCB0d28gdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IDIuMSArIDMuNicsXG4gICAgJ2EgLSAzLjYnLFxuICAgICczICsgMmknLFxuICAgICczIGNtICsgMiBpbmNoJyxcbiAgICAnXCIyLjNcIiArIFwiNFwiJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnc3VidHJhY3QnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY2JydCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY2JydCh4KScsXG4gICAgJ2NicnQoeCwgYWxsUm9vdHMpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGUgdGhlIGN1YmljIHJvb3QgdmFsdWUuIElmIHggPSB5ICogeSAqIHksIHRoZW4geSBpcyB0aGUgY3ViaWMgcm9vdCBvZiB4LiBXaGVuIGB4YCBpcyBhIG51bWJlciBvciBjb21wbGV4IG51bWJlciwgYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IGBhbGxSb290c2AgY2FuIGJlIHByb3ZpZGVkIHRvIHJldHVybiBhbGwgdGhyZWUgY3ViaWMgcm9vdHMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHByaW5jaXBhbCByb290IGlzIHJldHVybmVkJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjYnJ0KDY0KScsXG4gICAgJ2N1YmUoNCknLFxuICAgICdjYnJ0KC04KScsXG4gICAgJ2NicnQoMiArIDNpKScsXG4gICAgJ2NicnQoOGkpJyxcbiAgICAnY2JydCg4aSwgdHJ1ZSknLFxuICAgICdjYnJ0KDI3IG1eMyknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzcXVhcmUnLFxuICAgICdzcXJ0JyxcbiAgICAnY3ViZScsXG4gICAgJ211bHRpcGx5J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NlaWwnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NlaWwoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnUm91bmQgYSB2YWx1ZSB0b3dhcmRzIHBsdXMgaW5maW5pdHkuIElmIHggaXMgY29tcGxleCwgYm90aCByZWFsIGFuZCBpbWFnaW5hcnkgcGFydCBhcmUgcm91bmRlZCB0b3dhcmRzIHBsdXMgaW5maW5pdHkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjZWlsKDMuMiknLFxuICAgICdjZWlsKDMuOCknLFxuICAgICdjZWlsKC00LjIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnZmxvb3InLCAnZml4JywgJ3JvdW5kJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY3ViZScsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY3ViZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGN1YmUgb2YgYSB2YWx1ZS4gVGhlIGN1YmUgb2YgeCBpcyB4ICogeCAqIHguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjdWJlKDIpJyxcbiAgICAnMl4zJyxcbiAgICAnMiAqIDIgKiAyJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdzcXVhcmUnLFxuICAgICdwb3cnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGl2aWRlJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggLyB5JyxcbiAgICAnZGl2aWRlKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRGl2aWRlIHR3byB2YWx1ZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gMiAvIDMnLFxuICAgICdhICogMycsXG4gICAgJzQuNSAvIDInLFxuICAgICczICsgNCAvIDInLFxuICAgICcoMyArIDQpIC8gMicsXG4gICAgJzE4IGttIC8gNC41J1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZG90RGl2aWRlJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggLi8geScsXG4gICAgJ2RvdERpdmlkZSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0RpdmlkZSB0d28gdmFsdWVzIGVsZW1lbnQgd2lzZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSBbMSwgMiwgMzsgNCwgNSwgNl0nLFxuICAgICdiID0gWzIsIDEsIDE7IDMsIDIsIDVdJyxcbiAgICAnYSAuLyBiJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdkb3RNdWx0aXBseScsXG4gICAgJ2RpdmlkZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdkb3RNdWx0aXBseScsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC4qIHknLFxuICAgICdkb3RNdWx0aXBseSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ011bHRpcGx5IHR3byB2YWx1ZXMgZWxlbWVudCB3aXNlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2IgPSBbMiwgMSwgMTsgMywgMiwgNV0nLFxuICAgICdhIC4qIGInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtdWx0aXBseScsXG4gICAgJ2RpdmlkZScsXG4gICAgJ2RvdERpdmlkZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdkb3Rwb3cnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAuXiB5JyxcbiAgICAnZG90cG93KHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBvd2VyIG9mIHggdG8geSBlbGVtZW50IHdpc2UuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnYSAuXiAyJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAncG93J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2V4cCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZXhwKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBleHBvbmVudCBvZiBhIHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZXhwKDEuMyknLFxuICAgICdlIF4gMS4zJyxcbiAgICAnbG9nKGV4cCgxLjMpKScsXG4gICAgJ3ggPSAyLjQnLFxuICAgICcoZXhwKGkqeCkgPT0gY29zKHgpICsgaSpzaW4oeCkpICAgIyBFdWxlclxcJ3MgZm9ybXVsYSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3BvdycsXG4gICAgJ2xvZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmaXgnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2ZpeCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdSb3VuZCBhIHZhbHVlIHRvd2FyZHMgemVyby4gSWYgeCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgemVyby4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ZpeCgzLjIpJyxcbiAgICAnZml4KDMuOCknLFxuICAgICdmaXgoLTQuMiknLFxuICAgICdmaXgoLTQuOCknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2Zsb29yJywgJ3JvdW5kJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZmxvb3InLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Zsb29yKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ1JvdW5kIGEgdmFsdWUgdG93YXJkcyBtaW51cyBpbmZpbml0eS5JZiB4IGlzIGNvbXBsZXgsIGJvdGggcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnQgYXJlIHJvdW5kZWQgdG93YXJkcyBtaW51cyBpbmZpbml0eS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Zsb29yKDMuMiknLFxuICAgICdmbG9vcigzLjgpJyxcbiAgICAnZmxvb3IoLTQuMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2ZpeCcsICdyb3VuZCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2djZCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZ2NkKGEsIGIpJyxcbiAgICAnZ2NkKGEsIGIsIGMsIC4uLiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2djZCg4LCAxMiknLFxuICAgICdnY2QoLTQsIDYpJyxcbiAgICAnZ2NkKDI1LCAxNSwgLTEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbICdsY20nLCAneGdjZCcgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdoeXBvdCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaHlwb3QoYSwgYiwgYywgLi4uKScsXG4gICAgJ2h5cG90KFthLCBiLCBjLCAuLi5dKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaHlwb3RlbnVzYSBvZiBhIGxpc3Qgd2l0aCB2YWx1ZXMuICcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaHlwb3QoMywgNCknLFxuICAgICdzcXJ0KDNeMiArIDReMiknLFxuICAgICdoeXBvdCgtMiknLFxuICAgICdoeXBvdChbMywgNCwgNV0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsgJ2FicycsICdub3JtJyBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2xjbScsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbGNtKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbGNtKDQsIDYpJyxcbiAgICAnbGNtKDYsIDIxKScsXG4gICAgJ2xjbSg2LCAyMSwgNSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnZ2NkJyBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2xvZycsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbG9nKHgpJyxcbiAgICAnbG9nKHgsIGJhc2UpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbG9nYXJpdGhtIG9mIGEgdmFsdWUuIElmIG5vIGJhc2UgaXMgcHJvdmlkZWQsIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB4IGlzIGNhbGN1bGF0ZWQuIElmIGJhc2UgaWYgcHJvdmlkZWQsIHRoZSBsb2dhcml0aG0gaXMgY2FsY3VsYXRlZCBmb3IgdGhlIHNwZWNpZmllZCBiYXNlLiBsb2coeCwgYmFzZSkgaXMgZGVmaW5lZCBhcyBsb2coeCkgLyBsb2coYmFzZSkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdsb2coMy41KScsXG4gICAgJ2EgPSBsb2coMi40KScsXG4gICAgJ2V4cChhKScsXG4gICAgJzEwIF4gNCcsXG4gICAgJ2xvZygxMDAwMCwgMTApJyxcbiAgICAnbG9nKDEwMDAwKSAvIGxvZygxMCknLFxuICAgICdiID0gbG9nKDEwMjQsIDIpJyxcbiAgICAnMiBeIGInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdleHAnLFxuICAgICdsb2cxMCdcbiAgXVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbG9nMTAnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2xvZzEwKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgMTAtYmFzZSBsb2dhcml0aG0gb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2xvZzEwKDAuMDAwMDEpJyxcbiAgICAnbG9nMTAoMTAwMDApJyxcbiAgICAnMTAgXiA0JyxcbiAgICAnbG9nKDEwMDAwKSAvIGxvZygxMCknLFxuICAgICdsb2coMTAwMDAsIDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2V4cCcsXG4gICAgJ2xvZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtb2QnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCAlIHknLFxuICAgICd4IG1vZCB5JyxcbiAgICAnbW9kKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIG1vZHVsdXMsIHRoZSByZW1haW5kZXIgb2YgYW4gaW50ZWdlciBkaXZpc2lvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzcgJSAzJyxcbiAgICAnMTEgJSAyJyxcbiAgICAnMTAgbW9kIDQnLFxuICAgICdmdW5jdGlvbiBpc09kZCh4KSA9IHggJSAyJyxcbiAgICAnaXNPZGQoMiknLFxuICAgICdpc09kZCgzKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2RpdmlkZSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ211bHRpcGx5JyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggKiB5JyxcbiAgICAnbXVsdGlwbHkoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdtdWx0aXBseSB0d28gdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IDIuMSAqIDMuNCcsXG4gICAgJ2EgLyAzLjQnLFxuICAgICcyICogMyArIDQnLFxuICAgICcyICogKDMgKyA0KScsXG4gICAgJzMgKiAyLjEga20nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdkaXZpZGUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbm9ybScsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbm9ybSh4KScsXG4gICAgJ25vcm0oeCwgcCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIG5vcm0gb2YgYSBudW1iZXIsIHZlY3RvciBvciBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhYnMoLTMuNSknLFxuICAgICdub3JtKC0zLjUpJyxcbiAgICAnbm9ybSgzIC0gNGkpKScsXG4gICAgJ25vcm0oWzEsIDIsIC0zXSwgSW5maW5pdHkpJyxcbiAgICAnbm9ybShbMSwgMiwgLTNdLCAtSW5maW5pdHkpJyxcbiAgICAnbm9ybShbMywgNF0sIDIpJyxcbiAgICAnbm9ybShbWzEsIDJdLCBbMywgNF1dLCAxKScsXG4gICAgJ25vcm0oW1sxLCAyXSwgWzMsIDRdXSwgXFwnaW5mXFwnKScsXG4gICAgJ25vcm0oW1sxLCAyXSwgWzMsIDRdXSwgXFwnZnJvXFwnKSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdudGhSb290JyxcbiAgJ2NhdGVnb3J5JzogJ0FyaXRobWV0aWMnLFxuICAnc3ludGF4JzogW1xuICAgICdudGhSb290KGEpJyxcbiAgICAnbnRoUm9vdChhLCByb290KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgbnRoIHJvb3Qgb2YgYSB2YWx1ZS4gJyArXG4gICAgICAnVGhlIHByaW5jaXBhbCBudGggcm9vdCBvZiBhIHBvc2l0aXZlIHJlYWwgbnVtYmVyIEEsICcgK1xuICAgICAgJ2lzIHRoZSBwb3NpdGl2ZSByZWFsIHNvbHV0aW9uIG9mIHRoZSBlcXVhdGlvbiBcInhecm9vdCA9IEFcIi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzQgXiAzJyxcbiAgICAnbnRoUm9vdCg2NCwgMyknLFxuICAgICdudGhSb290KDksIDIpJyxcbiAgICAnc3FydCg5KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NxcnQnLFxuICAgICdwb3cnXG4gIF1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3BvdycsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IF4geScsXG4gICAgJ3Bvdyh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIHheeS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzJeMyA9IDgnLFxuICAgICcyKjIqMicsXG4gICAgJzEgKyBlIF4gKHBpICogaSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnbXVsdGlwbHknIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncm91bmQnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JvdW5kKHgpJyxcbiAgICAncm91bmQoeCwgbiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAncm91bmQgYSB2YWx1ZSB0b3dhcmRzIHRoZSBuZWFyZXN0IGludGVnZXIuSWYgeCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgdGhlIG5lYXJlc3QgaW50ZWdlci4gV2hlbiBuIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlIGlzIHJvdW5kZWQgdG8gbiBkZWNpbWFscy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JvdW5kKDMuMiknLFxuICAgICdyb3VuZCgzLjgpJyxcbiAgICAncm91bmQoLTQuMiknLFxuICAgICdyb3VuZCgtNC44KScsXG4gICAgJ3JvdW5kKHBpLCAzKScsXG4gICAgJ3JvdW5kKDEyMy40NTY3OCwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWydjZWlsJywgJ2Zsb29yJywgJ2ZpeCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NpZ24nLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NpZ24oeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ29tcHV0ZSB0aGUgc2lnbiBvZiBhIHZhbHVlLiBUaGUgc2lnbiBvZiBhIHZhbHVlIHggaXMgMSB3aGVuIHg+MSwgLTEgd2hlbiB4PDAsIGFuZCAwIHdoZW4geD0wLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc2lnbigzLjUpJyxcbiAgICAnc2lnbigtNC4yKScsXG4gICAgJ3NpZ24oMCknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhYnMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc3FydCcsXG4gICdjYXRlZ29yeSc6ICdBcml0aG1ldGljJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3FydCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBzcXVhcmUgcm9vdCB2YWx1ZS4gSWYgeCA9IHkgKiB5LCB0aGVuIHkgaXMgdGhlIHNxdWFyZSByb290IG9mIHguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzcXJ0KDI1KScsXG4gICAgJzUgKiA1JyxcbiAgICAnc3FydCgtMSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdzcXVhcmUnLFxuICAgICdtdWx0aXBseSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzcXVhcmUnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NxdWFyZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBzcXVhcmUgb2YgYSB2YWx1ZS4gVGhlIHNxdWFyZSBvZiB4IGlzIHggKiB4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3F1YXJlKDMpJyxcbiAgICAnc3FydCg5KScsXG4gICAgJzNeMicsXG4gICAgJzMgKiAzJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdwb3cnLFxuICAgICdzcXJ0JyxcbiAgICAnY3ViZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdWJ0cmFjdCcsXG4gICdjYXRlZ29yeSc6ICdPcGVyYXRvcnMnLFxuICAnc3ludGF4JzogW1xuICAgICd4IC0geScsXG4gICAgJ3N1YnRyYWN0KHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnc3VidHJhY3QgdHdvIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSA1LjMgLSAyJyxcbiAgICAnYSArIDInLFxuICAgICcyLzMgLSAxLzYnLFxuICAgICcyICogMyAtIDMnLFxuICAgICcyLjEga20gLSA1MDBtJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWRkJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3VuYXJ5TWludXMnLFxuICAnY2F0ZWdvcnknOiAnT3BlcmF0b3JzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnLXgnLFxuICAgICd1bmFyeU1pbnVzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0ludmVyc2UgdGhlIHNpZ24gb2YgYSB2YWx1ZS4gQ29udmVydHMgYm9vbGVhbnMgYW5kIHN0cmluZ3MgdG8gbnVtYmVycy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJy00LjUnLFxuICAgICctKC01LjYpJyxcbiAgICAnLVwiMjJcIidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2FkZCcsICdzdWJ0cmFjdCcsICd1bmFyeVBsdXMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndW5hcnlQbHVzJyxcbiAgJ2NhdGVnb3J5JzogJ09wZXJhdG9ycycsXG4gICdzeW50YXgnOiBbXG4gICAgJyt4JyxcbiAgICAndW5hcnlQbHVzKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbnZlcnRzIGJvb2xlYW5zIGFuZCBzdHJpbmdzIHRvIG51bWJlcnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcrdHJ1ZScsXG4gICAgJytcIjJcIidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2FkZCcsICdzdWJ0cmFjdCcsICd1bmFyeU1pbnVzJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3hnY2QnLFxuICAnY2F0ZWdvcnknOiAnQXJpdGhtZXRpYycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3hnY2QoYSwgYiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGV4dGVuZGVkIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIGZvciB0d28gdmFsdWVzJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd4Z2NkKDgsIDEyKScsXG4gICAgJ2djZCg4LCAxMiknLFxuICAgICd4Z2NkKDM2MTYzLCAyMTE5OSknXG4gIF0sXG4gICdzZWVhbHNvJzogWyAnZ2NkJywgJ2xjbScgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdiaXRBbmQnLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggJiB5JyxcbiAgICAnYml0QW5kKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQml0d2lzZSBBTkQgb3BlcmF0aW9uLiBQZXJmb3JtcyB0aGUgbG9naWNhbCBBTkQgb3BlcmF0aW9uIG9uIGVhY2ggcGFpciBvZiB0aGUgY29ycmVzcG9uZGluZyBiaXRzIG9mIHRoZSB0d28gZ2l2ZW4gdmFsdWVzIGJ5IG11bHRpcGx5aW5nIHRoZW0uIElmIGJvdGggYml0cyBpbiB0aGUgY29tcGFyZWQgcG9zaXRpb24gYXJlIDEsIHRoZSBiaXQgaW4gdGhlIHJlc3VsdGluZyBiaW5hcnkgcmVwcmVzZW50YXRpb24gaXMgMSwgb3RoZXJ3aXNlLCB0aGUgcmVzdWx0IGlzIDAnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzUgJiAzJyxcbiAgICAnYml0QW5kKDUzLCAxMzEpJyxcbiAgICAnWzEsIDEyLCAzMV0gJiA0MidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpdE5vdCcsICdiaXRPcicsICdiaXRYb3InLCAnbGVmdFNoaWZ0JywgJ3JpZ2h0QXJpdGhTaGlmdCcsICdyaWdodExvZ1NoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2JpdE5vdCcsXG4gICdjYXRlZ29yeSc6ICdCaXR3aXNlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnfngnLFxuICAgICdiaXROb3QoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCaXR3aXNlIE5PVCBvcGVyYXRpb24uIFBlcmZvcm1zIGEgbG9naWNhbCBuZWdhdGlvbiBvbiBlYWNoIGJpdCBvZiB0aGUgZ2l2ZW4gdmFsdWUuIEJpdHMgdGhhdCBhcmUgMCBiZWNvbWUgMSwgYW5kIHRob3NlIHRoYXQgYXJlIDEgYmVjb21lIDAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd+MScsXG4gICAgJ34yJyxcbiAgICAnYml0Tm90KFsyLCAtMywgNF0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYml0QW5kJywgJ2JpdE9yJywgJ2JpdFhvcicsICdsZWZ0U2hpZnQnLCAncmlnaHRBcml0aFNoaWZ0JywgJ3JpZ2h0TG9nU2hpZnQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYml0T3InLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggfCB5JyxcbiAgICAnYml0T3IoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCaXR3aXNlIE9SIG9wZXJhdGlvbi4gUGVyZm9ybXMgdGhlIGxvZ2ljYWwgaW5jbHVzaXZlIE9SIG9wZXJhdGlvbiBvbiBlYWNoIHBhaXIgb2YgY29ycmVzcG9uZGluZyBiaXRzIG9mIHRoZSB0d28gZ2l2ZW4gdmFsdWVzLiBUaGUgcmVzdWx0IGluIGVhY2ggcG9zaXRpb24gaXMgMSBpZiB0aGUgZmlyc3QgYml0IGlzIDEgb3IgdGhlIHNlY29uZCBiaXQgaXMgMSBvciBib3RoIGJpdHMgYXJlIDEsIG90aGVyd2lzZSwgdGhlIHJlc3VsdCBpcyAwLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNSB8IDMnLFxuICAgICdiaXRPcihbMSwgMiwgM10sIDQpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYml0QW5kJywgJ2JpdE5vdCcsICdiaXRYb3InLCAnbGVmdFNoaWZ0JywgJ3JpZ2h0QXJpdGhTaGlmdCcsICdyaWdodExvZ1NoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2JpdFhvcicsXG4gICdjYXRlZ29yeSc6ICdCaXR3aXNlJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYml0WG9yKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQml0d2lzZSBYT1Igb3BlcmF0aW9uLCBleGNsdXNpdmUgT1IuIFBlcmZvcm1zIHRoZSBsb2dpY2FsIGV4Y2x1c2l2ZSBPUiBvcGVyYXRpb24gb24gZWFjaCBwYWlyIG9mIGNvcnJlc3BvbmRpbmcgYml0cyBvZiB0aGUgdHdvIGdpdmVuIHZhbHVlcy4gVGhlIHJlc3VsdCBpbiBlYWNoIHBvc2l0aW9uIGlzIDEgaWYgb25seSB0aGUgZmlyc3QgYml0IGlzIDEgb3Igb25seSB0aGUgc2Vjb25kIGJpdCBpcyAxLCBidXQgd2lsbCBiZSAwIGlmIGJvdGggYXJlIDAgb3IgYm90aCBhcmUgMS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2JpdE9yKDEsIDIpJyxcbiAgICAnYml0WG9yKFsyLCAzLCA0XSwgNCknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaXRBbmQnLCAnYml0Tm90JywgJ2JpdE9yJywgJ2xlZnRTaGlmdCcsICdyaWdodEFyaXRoU2hpZnQnLCAncmlnaHRMb2dTaGlmdCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsZWZ0U2hpZnQnLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPDwgeScsXG4gICAgJ2xlZnRTaGlmdCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0JpdHdpc2UgbGVmdCBsb2dpY2FsIHNoaWZ0IG9mIGEgdmFsdWUgeCBieSB5IG51bWJlciBvZiBiaXRzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNCA8PCAxJyxcbiAgICAnOCA+PiAxJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYml0QW5kJywgJ2JpdE5vdCcsICdiaXRPcicsICdiaXRYb3InLCAncmlnaHRBcml0aFNoaWZ0JywgJ3JpZ2h0TG9nU2hpZnQnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmlnaHRBcml0aFNoaWZ0JyxcbiAgJ2NhdGVnb3J5JzogJ0JpdHdpc2UnLFxuICAnc3ludGF4JzogW1xuICAgICd4ID4+IHknLFxuICAgICdsZWZ0U2hpZnQoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdCaXR3aXNlIHJpZ2h0IGFyaXRobWV0aWMgc2hpZnQgb2YgYSB2YWx1ZSB4IGJ5IHkgbnVtYmVyIG9mIGJpdHMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc4ID4+IDEnLFxuICAgICc0IDw8IDEnLFxuICAgICctMTIgPj4gMidcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2JpdEFuZCcsICdiaXROb3QnLCAnYml0T3InLCAnYml0WG9yJywgJ2xlZnRTaGlmdCcsICdyaWdodExvZ1NoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3JpZ2h0TG9nU2hpZnQnLFxuICAnY2F0ZWdvcnknOiAnQml0d2lzZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPj4geScsXG4gICAgJ2xlZnRTaGlmdCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0JpdHdpc2UgcmlnaHQgbG9naWNhbCBzaGlmdCBvZiBhIHZhbHVlIHggYnkgeSBudW1iZXIgb2YgYml0cy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzggPj4+IDEnLFxuICAgICc0IDw8IDEnLFxuICAgICctMTIgPj4+IDInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdiaXRBbmQnLCAnYml0Tm90JywgJ2JpdE9yJywgJ2JpdFhvcicsICdsZWZ0U2hpZnQnLCAncmlnaHRBcml0aFNoaWZ0J1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2JlbGxOdW1iZXJzJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbWJpbmF0b3JpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdiZWxsTnVtYmVycyhuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBCZWxsIE51bWJlcnMgY291bnQgdGhlIG51bWJlciBvZiBwYXJ0aXRpb25zIG9mIGEgc2V0LiBBIHBhcnRpdGlvbiBpcyBhIHBhaXJ3aXNlIGRpc2pvaW50IHN1YnNldCBvZiBTIHdob3NlIHVuaW9uIGlzIFMuIGBiZWxsTnVtYmVyc2Agb25seSB0YWtlcyBpbnRlZ2VyIGFyZ3VtZW50cy4gVGhlIGZvbGxvd2luZyBjb25kaXRpb24gbXVzdCBiZSBlbmZvcmNlZDogbiA+PSAwLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYmVsbE51bWJlcnMoMyknLFxuICAgICdiZWxsTnVtYmVycyg4KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3N0aXJsaW5nUzInXVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY2F0YWxhbicsXG4gICdjYXRlZ29yeSc6ICdDb21iaW5hdG9yaWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY2F0YWxhbihuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBDYXRhbGFuIE51bWJlcnMgZW51bWVyYXRlIGNvbWJpbmF0b3JpYWwgc3RydWN0dXJlcyBvZiBtYW55IGRpZmZlcmVudCB0eXBlcy4gY2F0YWxhbiBvbmx5IHRha2VzIGludGVnZXIgYXJndW1lbnRzLiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBuID49IDAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjYXRhbGFuKDMpJyxcbiAgICAnY2F0YWxhbig4KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2JlbGxOdW1iZXJzJ11cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbXBvc2l0aW9uJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbWJpbmF0b3JpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdjb21wb3NpdGlvbihuLCBrKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RoZSBjb21wb3NpdGlvbiBjb3VudHMgb2YgbiBpbnRvIGsgcGFydHMuIGNvbXBvc2l0aW9uIG9ubHkgdGFrZXMgaW50ZWdlciBhcmd1bWVudHMuIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IGsgPD0gbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbXBvc2l0aW9uKDUsIDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJ11cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N0aXJsaW5nUzInLFxuICAnY2F0ZWdvcnknOiAnQ29tYmluYXRvcmljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N0aXJsaW5nUzIobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdoZSBTdGlybGluZyBudW1iZXJzIG9mIHRoZSBzZWNvbmQga2luZCwgY291bnRzIHRoZSBudW1iZXIgb2Ygd2F5cyB0byBwYXJ0aXRpb24gYSBzZXQgb2YgbiBsYWJlbGxlZCBvYmplY3RzIGludG8gayBub25lbXB0eSB1bmxhYmVsbGVkIHN1YnNldHMuIGBzdGlybGluZ1MyYCBvbmx5IHRha2VzIGludGVnZXIgYXJndW1lbnRzLiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBtdXN0IGJlIGVuZm9yY2VkOiBrIDw9IG4uIElmIG4gPSBrIG9yIGsgPSAxLCB0aGVuIHMobixrKSA9IDEuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzdGlybGluZ1MyKDUsIDMpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnYmVsbE51bWJlcnMnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhcmcnLFxuICAnY2F0ZWdvcnknOiAnQ29tcGxleCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2FyZyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDb21wdXRlIHRoZSBhcmd1bWVudCBvZiBhIGNvbXBsZXggdmFsdWUuIElmIHggPSBhK2JpLCB0aGUgYXJndW1lbnQgaXMgY29tcHV0ZWQgYXMgYXRhbjIoYiwgYSkuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhcmcoMiArIDJpKScsXG4gICAgJ2F0YW4yKDMsIDIpJyxcbiAgICAnYXJnKDIgKyAzaSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdyZScsXG4gICAgJ2ltJyxcbiAgICAnY29uaicsXG4gICAgJ2FicydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb25qJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbXBsZXgnLFxuICAnc3ludGF4JzogW1xuICAgICdjb25qKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NvbXB1dGUgdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGEgY29tcGxleCB2YWx1ZS4gSWYgeCA9IGErYmksIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBpcyBhLWJpLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY29uaigyICsgM2kpJyxcbiAgICAnY29uaigyIC0gM2kpJyxcbiAgICAnY29uaigtNS4yaSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdyZScsXG4gICAgJ2ltJyxcbiAgICAnYWJzJyxcbiAgICAnYXJnJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ltJyxcbiAgJ2NhdGVnb3J5JzogJ0NvbXBsZXgnLFxuICAnc3ludGF4JzogW1xuICAgICdpbSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0dldCB0aGUgaW1hZ2luYXJ5IHBhcnQgb2YgYSBjb21wbGV4IG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ltKDIgKyAzaSknLFxuICAgICdyZSgyICsgM2kpJyxcbiAgICAnaW0oLTUuMmkpJyxcbiAgICAnaW0oMi40KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3JlJyxcbiAgICAnY29uaicsXG4gICAgJ2FicycsXG4gICAgJ2FyZydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdyZScsXG4gICdjYXRlZ29yeSc6ICdDb21wbGV4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncmUoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgdGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAncmUoMiArIDNpKScsXG4gICAgJ2ltKDIgKyAzaSknLFxuICAgICdyZSgtNS4yaSknLFxuICAgICdyZSgyLjQpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnaW0nLFxuICAgICdjb25qJyxcbiAgICAnYWJzJyxcbiAgICAnYXJnJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2V2YWwnLFxuICAnY2F0ZWdvcnknOiAnRXhwcmVzc2lvbicsXG4gICdzeW50YXgnOiBbXG4gICAgJ2V2YWwoZXhwcmVzc2lvbiknLFxuICAgICdldmFsKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0V2YWx1YXRlIGFuIGV4cHJlc3Npb24gb3IgYW4gYXJyYXkgd2l0aCBleHByZXNzaW9ucy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2V2YWwoXCIyICsgM1wiKScsXG4gICAgJ2V2YWwoXCJzcXJ0KFwiICsgNCArIFwiKVwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdoZWxwJyxcbiAgJ2NhdGVnb3J5JzogJ0V4cHJlc3Npb24nLFxuICAnc3ludGF4JzogW1xuICAgICdoZWxwKG9iamVjdCknLFxuICAgICdoZWxwKHN0cmluZyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdEaXNwbGF5IGRvY3VtZW50YXRpb24gb24gYSBmdW5jdGlvbiBvciBkYXRhIHR5cGUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdoZWxwKHNxcnQpJyxcbiAgICAnaGVscChcImNvbXBsZXhcIiknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGlzdGFuY2UnLFxuICAnY2F0ZWdvcnknOiAnR2VvbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdkaXN0YW5jZShbeDEsIHkxXSwgW3gyLCB5Ml0pJyxcbiAgICAnZGlzdGFuY2UoW1t4MSwgeTFdLCBbeDIsIHkyXSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGVzIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZGlzdGFuY2UoWzAsMF0sIFs0LDRdKScsXG4gICAgJ2Rpc3RhbmNlKFtbMCwwXSwgWzQsNF1dKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpbnRlcnNlY3QnLFxuICAnY2F0ZWdvcnknOiAnR2VvbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdpbnRlcnNlY3QoZXhwcjEsIGV4cHIyLCBleHByMywgZXhwcjQpJyxcbiAgICAnaW50ZXJzZWN0KGV4cHIxLCBleHByMiwgZXhwcjMpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBwb2ludCBvZiBsaW5lcyBhbmQvb3IgcGxhbmVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaW50ZXJzZWN0KFswLCAwXSwgWzEwLCAxMF0sIFsxMCwgMF0sIFswLCAxMF0pJyxcbiAgICAnaW50ZXJzZWN0KFsxLCAwLCAxXSwgIFs0LCAtMiwgMl0sIFsxLCAxLCAxLCA2XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYW5kJyxcbiAgJ2NhdGVnb3J5JzogJ0xvZ2ljYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IGFuZCB5JyxcbiAgICAnYW5kKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTG9naWNhbCBhbmQuIFRlc3Qgd2hldGhlciB0d28gdmFsdWVzIGFyZSBib3RoIGRlZmluZWQgd2l0aCBhIG5vbnplcm8vbm9uZW1wdHkgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0cnVlIGFuZCBmYWxzZScsXG4gICAgJ3RydWUgYW5kIHRydWUnLFxuICAgICcyIGFuZCA0J1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbm90JywgJ29yJywgJ3hvcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdub3QnLFxuICAnY2F0ZWdvcnknOiAnTG9naWNhbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ25vdCB4JyxcbiAgICAnbm90KHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTG9naWNhbCBub3QuIEZsaXBzIHRoZSBib29sZWFuIHZhbHVlIG9mIGdpdmVuIGFyZ3VtZW50LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbm90IHRydWUnLFxuICAgICdub3QgZmFsc2UnLFxuICAgICdub3QgMicsXG4gICAgJ25vdCAwJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYW5kJywgJ29yJywgJ3hvcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdvcicsXG4gICdjYXRlZ29yeSc6ICdMb2dpY2FsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCBvciB5JyxcbiAgICAnb3IoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdMb2dpY2FsIG9yLiBUZXN0IGlmIGF0IGxlYXN0IG9uZSB2YWx1ZSBpcyBkZWZpbmVkIHdpdGggYSBub256ZXJvL25vbmVtcHR5IHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAndHJ1ZSBvciBmYWxzZScsXG4gICAgJ2ZhbHNlIG9yIGZhbHNlJyxcbiAgICAnMCBvciA0J1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbm90JywgJ2FuZCcsICd4b3InXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAneG9yJyxcbiAgJ2NhdGVnb3J5JzogJ0xvZ2ljYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IG9yIHknLFxuICAgICdvcih4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0xvZ2ljYWwgZXhjbHVzaXZlIG9yLCB4b3IuIFRlc3Qgd2hldGhlciBvbmUgYW5kIG9ubHkgb25lIHZhbHVlIGlzIGRlZmluZWQgd2l0aCBhIG5vbnplcm8vbm9uZW1wdHkgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0cnVlIHhvciBmYWxzZScsXG4gICAgJ2ZhbHNlIHhvciBmYWxzZScsXG4gICAgJ3RydWUgeG9yIHRydWUnLFxuICAgICcwIG9yIDQnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdub3QnLCAnYW5kJywgJ29yJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbmNhdCcsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdjb25jYXQoQSwgQiwgQywgLi4uKScsXG4gICAgJ2NvbmNhdChBLCBCLCBDLCAuLi4sIGRpbSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb25jYXRlbmF0ZSBtYXRyaWNlcy4gQnkgZGVmYXVsdCwgdGhlIG1hdHJpY2VzIGFyZSBjb25jYXRlbmF0ZWQgYnkgdGhlIGxhc3QgZGltZW5zaW9uLiBUaGUgZGltZW5zaW9uIG9uIHdoaWNoIHRvIGNvbmNhdGVuYXRlIGNhbiBiZSBwcm92aWRlZCBhcyBsYXN0IGFyZ3VtZW50LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnQSA9IFsxLCAyOyA1LCA2XScsXG4gICAgJ0IgPSBbMywgNDsgNywgOF0nLFxuICAgICdjb25jYXQoQSwgQiknLFxuICAgICdjb25jYXQoQSwgQiwgMSknLFxuICAgICdjb25jYXQoQSwgQiwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdkZXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY3Jvc3MnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY3Jvc3MoQSwgQiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGNyb3NzIHByb2R1Y3QgZm9yIHR3byB2ZWN0b3JzIGluIHRocmVlIGRpbWVuc2lvbmFsIHNwYWNlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY3Jvc3MoWzEsIDEsIDBdLCAgWzAsIDEsIDFdKScsXG4gICAgJ2Nyb3NzKFszLCAtMywgMV0sIFs0LCA5LCAyXSknLFxuICAgICdjcm9zcyhbMiwgMywgNF0sICBbNSwgNiwgN10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbXVsdGlwbHknLFxuICAgICdkb3QnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGV0JyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2RldCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2RldChbMSwgMjsgMywgNF0pJyxcbiAgICAnZGV0KFstMiwgMiwgMzsgLTEsIDEsIDM7IDIsIDAsIC0xXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGlhZycsICdleWUnLCAnaW52JywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGlhZycsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdkaWFnKHgpJyxcbiAgICAnZGlhZyh4LCBrKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NyZWF0ZSBhIGRpYWdvbmFsIG1hdHJpeCBvciByZXRyaWV2ZSB0aGUgZGlhZ29uYWwgb2YgYSBtYXRyaXguIFdoZW4geCBpcyBhIHZlY3RvciwgYSBtYXRyaXggd2l0aCB0aGUgdmVjdG9yIHZhbHVlcyBvbiB0aGUgZGlhZ29uYWwgd2lsbCBiZSByZXR1cm5lZC4gV2hlbiB4IGlzIGEgbWF0cml4LCBhIHZlY3RvciB3aXRoIHRoZSBkaWFnb25hbCB2YWx1ZXMgb2YgdGhlIG1hdHJpeCBpcyByZXR1cm5lZC4gV2hlbiBrIGlzIHByb3ZpZGVkLCB0aGUgay10aCBkaWFnb25hbCB3aWxsIGJlIGZpbGxlZCBpbiBvciByZXRyaWV2ZWQsIGlmIGsgaXMgcG9zaXRpdmUsIHRoZSB2YWx1ZXMgYXJlIHBsYWNlZCBvbiB0aGUgc3VwZXIgZGlhZ29uYWwuIFdoZW4gayBpcyBuZWdhdGl2ZSwgdGhlIHZhbHVlcyBhcmUgcGxhY2VkIG9uIHRoZSBzdWIgZGlhZ29uYWwuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdkaWFnKDE6MyknLFxuICAgICdkaWFnKDE6MywgMSknLFxuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDY7IDcsIDgsIDldJyxcbiAgICAnZGlhZyhhKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhY2UnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2RvdCcsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdkb3QoQSwgQiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLiAnICtcbiAgICAgICdUaGUgZG90IHByb2R1Y3Qgb2YgQSA9IFthMSwgYTIsIGEzLCAuLi4sIGFuXSBhbmQgQiA9IFtiMSwgYjIsIGIzLCAuLi4sIGJuXSAnICtcbiAgICAgICdpcyBkZWZpbmVkIGFzIGRvdChBLCBCKSA9IGExICogYjEgKyBhMiAqIGIyICsgYTMgKiBiMyArIC4uLiArIGFuICogYm4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2RvdChbMiwgNCwgMV0sIFsyLCAyLCAzXSknLFxuICAgICdbMiwgNCwgMV0gKiBbMiwgMiwgM10nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtdWx0aXBseScsXG4gICAgJ2Nyb3NzJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2V5ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdleWUobiknLFxuICAgICdleWUobSwgbiknLFxuICAgICdleWUoW20sIG5dKScsXG4gICAgJ2V5ZSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JldHVybnMgdGhlIGlkZW50aXR5IG1hdHJpeCB3aXRoIHNpemUgbS1ieS1uLiBUaGUgbWF0cml4IGhhcyBvbmVzIG9uIHRoZSBkaWFnb25hbCBhbmQgemVyb3MgZWxzZXdoZXJlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnZXllKDMpJyxcbiAgICAnZXllKDMsIDUpJyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2V5ZShzaXplKGEpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdkZXQnLCAnZGlhZycsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmaWx0ZXInLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZmlsdGVyKHgsIHRlc3QpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnRmlsdGVyIGl0ZW1zIGluIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNQb3NpdGl2ZSh4KSA9IHggPiAwJyxcbiAgICAnZmlsdGVyKFs2LCAtMiwgLTEsIDQsIDNdLCBpc1Bvc2l0aXZlKScsXG4gICAgJ2ZpbHRlcihbNiwgLTIsIDAsIDEsIDBdLCB4ICE9IDApJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnc29ydCcsICdtYXAnLCAnZm9yRWFjaCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZsYXR0ZW4nLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZmxhdHRlbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0ZsYXR0ZW4gYSBtdWx0aSBkaW1lbnNpb25hbCBtYXRyaXggaW50byBhIHNpbmdsZSBkaW1lbnNpb25hbCBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhID0gWzEsIDIsIDM7IDQsIDUsIDZdJyxcbiAgICAnc2l6ZShhKScsXG4gICAgJ2IgPSBmbGF0dGVuKGEpJyxcbiAgICAnc2l6ZShiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvbmNhdCcsICdyZXNpemUnLCAnc2l6ZScsICdzcXVlZXplJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ZvckVhY2gnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZm9yRWFjaCh4LCBjYWxsYmFjayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdJdGVyYXRlcyBvdmVyIGFsbCBlbGVtZW50cyBvZiBhIG1hdHJpeC9hcnJheSwgYW5kIGV4ZWN1dGVzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ZvckVhY2goWzEsIDIsIDNdLCBmdW5jdGlvbih2YWwpIHsgY29uc29sZS5sb2codmFsKSB9KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ21hcCcsICdzb3J0JywgJ2ZpbHRlciddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2ludicsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdpbnYoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXgnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2ludihbMSwgMjsgMywgNF0pJyxcbiAgICAnaW52KDQpJyxcbiAgICAnMSAvIDQnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ29uZXMnLCAncmFuZ2UnLCAnc2l6ZScsICdzcXVlZXplJywgJ3N1YnNldCcsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAna3JvbicsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdtYXRoLmtyb24oeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGVzIHRoZSBrcm9uZWNrZXIgcHJvZHVjdCBvZiAyIG1hdHJpY2VzIG9yIHZlY3RvcnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdrcm9uKFtbMSwgMF0sIFswLCAxXV0sIFtbMSwgMl0sIFszLCA0XV0pJyxcbiAgICAna3JvbihbMSwxXSwgWzIsMyw0XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtdWx0aXBseScsICdkb3QnLCAnY3Jvc3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWFwJyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ21hcCh4LCBjYWxsYmFjayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDcmVhdGUgYSBuZXcgbWF0cml4IG9yIGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeC9hcnJheS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21hcChbMSwgMiwgM10sIGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsdWUgKiB2YWx1ZSB9KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2ZpbHRlcicsICdmb3JFYWNoJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnb25lcycsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdvbmVzKG0pJyxcbiAgICAnb25lcyhtLCBuKScsXG4gICAgJ29uZXMobSwgbiwgcCwgLi4uKScsXG4gICAgJ29uZXMoW21dKScsXG4gICAgJ29uZXMoW20sIG5dKScsXG4gICAgJ29uZXMoW20sIG4sIHAsIC4uLl0pJyxcbiAgICAnb25lcydcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NyZWF0ZSBhIG1hdHJpeCBjb250YWluaW5nIG9uZXMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdvbmVzKDMpJyxcbiAgICAnb25lcygzLCA1KScsXG4gICAgJ29uZXMoWzIsM10pICogNC41JyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ29uZXMoc2l6ZShhKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdwYXJ0aXRpb25TZWxlY3QnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncGFydGl0aW9uU2VsZWN0KHgsIGspJyxcbiAgICAncGFydGl0aW9uU2VsZWN0KHgsIGssIGNvbXBhcmUpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnUGFydGl0aW9uLWJhc2VkIHNlbGVjdGlvbiBvZiBhbiBhcnJheSBvciAxRCBtYXRyaXguIFdpbGwgZmluZCB0aGUga3RoIHNtYWxsZXN0IHZhbHVlLCBhbmQgbXV0YXRlcyB0aGUgaW5wdXQgYXJyYXkuIFVzZXMgUXVpY2tzZWxlY3QuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdwYXJ0aXRpb25TZWxlY3QoWzUsIDEwLCAxXSwgMiknLFxuICAgICdwYXJ0aXRpb25TZWxlY3QoW1wiQ1wiLCBcIkJcIiwgXCJBXCIsIFwiRFwiXSwgMSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydzb3J0J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmFuZ2UnLFxuICAnY2F0ZWdvcnknOiAnVHlwZScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N0YXJ0OmVuZCcsXG4gICAgJ3N0YXJ0OnN0ZXA6ZW5kJyxcbiAgICAncmFuZ2Uoc3RhcnQsIGVuZCknLFxuICAgICdyYW5nZShzdGFydCwgZW5kLCBzdGVwKScsXG4gICAgJ3JhbmdlKHN0cmluZyknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ3JlYXRlIGEgcmFuZ2UuIExvd2VyIGJvdW5kIG9mIHRoZSByYW5nZSBpcyBpbmNsdWRlZCwgdXBwZXIgYm91bmQgaXMgZXhjbHVkZWQuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcxOjUnLFxuICAgICczOi0xOi0zJyxcbiAgICAncmFuZ2UoMywgNyknLFxuICAgICdyYW5nZSgwLCAxMiwgMiknLFxuICAgICdyYW5nZShcIjQ6MTBcIiknLFxuICAgICdhID0gWzEsIDIsIDMsIDQ7IDUsIDYsIDcsIDhdJyxcbiAgICAnYVsxOjIsIDE6Ml0nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhY2UnLCAndHJhbnNwb3NlJywgJ3plcm9zJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3Jlc2l6ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdyZXNpemUoeCwgc2l6ZSknLFxuICAgICdyZXNpemUoeCwgc2l6ZSwgZGVmYXVsdFZhbHVlKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1Jlc2l6ZSBhIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3Jlc2l6ZShbMSwyLDMsNCw1XSwgWzNdKScsXG4gICAgJ3Jlc2l6ZShbMSwyLDNdLCBbNV0pJyxcbiAgICAncmVzaXplKFsxLDIsM10sIFs1XSwgLTEpJyxcbiAgICAncmVzaXplKDIsIFsyLCAzXSknLFxuICAgICdyZXNpemUoXCJoZWxsb1wiLCBbOF0sIFwiIVwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NpemUnLCAnc3Vic2V0JywgJ3NxdWVlemUnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2l6ZScsXG4gICdjYXRlZ29yeSc6ICdNYXRyaXgnLFxuICAnc3ludGF4JzogW1xuICAgICdzaXplKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgbWF0cml4LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc2l6ZSgyLjMpJyxcbiAgICAnc2l6ZShcImhlbGxvIHdvcmxkXCIpJyxcbiAgICAnYSA9IFsxLCAyOyAzLCA0OyA1LCA2XScsXG4gICAgJ3NpemUoYSknLFxuICAgICdzaXplKDE6NiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzb3J0JyxcbiAgJ2NhdGVnb3J5JzogJ01hdHJpeCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NvcnQoeCknLFxuICAgICdzb3J0KHgsIGNvbXBhcmUpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnU29ydCB0aGUgaXRlbXMgaW4gYSBtYXRyaXguIENvbXBhcmUgY2FuIGJlIGEgc3RyaW5nIFwiYXNjXCIgb3IgXCJkZXNjXCIsIG9yIGEgY3VzdG9tIHNvcnQgZnVuY3Rpb24uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzb3J0KFs1LCAxMCwgMV0pJyxcbiAgICAnc29ydChbXCJDXCIsIFwiQlwiLCBcIkFcIiwgXCJEXCJdKScsXG4gICAgJ3NvcnRCeUxlbmd0aChhLCBiKSA9IHNpemUoYSlbMV0gLSBzaXplKGIpWzFdJyxcbiAgICAnc29ydChbXCJMYW5nZG9uXCIsIFwiVG9tXCIsIFwiU2FyYVwiXSwgc29ydEJ5TGVuZ3RoKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ21hcCcsICdmaWx0ZXInLCAnZm9yRWFjaCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3NxdWVlemUnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3F1ZWV6ZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1JlbW92ZSBpbm5lciBhbmQgb3V0ZXIgc2luZ2xldG9uIGRpbWVuc2lvbnMgZnJvbSBhIG1hdHJpeC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2EgPSB6ZXJvcygzLDIsMSknLFxuICAgICdzaXplKHNxdWVlemUoYSkpJyxcbiAgICAnYiA9IHplcm9zKDEsMSwzKScsXG4gICAgJ3NpemUoc3F1ZWV6ZShiKSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdWJzZXQnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndmFsdWUoaW5kZXgpJyxcbiAgICAndmFsdWUoaW5kZXgpID0gcmVwbGFjZW1lbnQnLFxuICAgICdzdWJzZXQodmFsdWUsIFtpbmRleF0pJyxcbiAgICAnc3Vic2V0KHZhbHVlLCBbaW5kZXhdLCByZXBsYWNlbWVudCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdHZXQgb3Igc2V0IGEgc3Vic2V0IG9mIGEgbWF0cml4IG9yIHN0cmluZy4gJyArXG4gICAgICAnSW5kZXhlcyBhcmUgb25lLWJhc2VkLiAnICtcbiAgICAgICdCb3RoIHRoZSByYW5nZXMgbG93ZXItYm91bmQgYW5kIHVwcGVyLWJvdW5kIGFyZSBpbmNsdWRlZC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2QgPSBbMSwgMjsgMywgNF0nLFxuICAgICdlID0gW10nLFxuICAgICdlWzEsIDE6Ml0gPSBbNSwgNl0nLFxuICAgICdlWzIsIDpdID0gWzcsIDhdJyxcbiAgICAnZiA9IGQgKiBlJyxcbiAgICAnZlsyLCAxXScsXG4gICAgJ2ZbOiwgMV0nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICd0cmFjZScsICd0cmFuc3Bvc2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndHJhY2UnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndHJhY2UoQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIHRyYWNlIG9mIGEgbWF0cml4OiB0aGUgc3VtIG9mIHRoZSBlbGVtZW50cyBvbiB0aGUgbWFpbiBkaWFnb25hbCBvZiBhIHNxdWFyZSBtYXRyaXguJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdBID0gWzEsIDIsIDM7IC0xLCAyLCAzOyAyLCAwLCAzXScsXG4gICAgJ3RyYWNlKEEpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYW5zcG9zZScsICd6ZXJvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0cmFuc3Bvc2UnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneFxcJycsXG4gICAgJ3RyYW5zcG9zZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1RyYW5zcG9zZSBhIG1hdHJpeCcsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ2FcXCcnLFxuICAgICd0cmFuc3Bvc2UoYSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb25jYXQnLCAnZGV0JywgJ2RpYWcnLCAnZXllJywgJ2ludicsICdvbmVzJywgJ3JhbmdlJywgJ3NpemUnLCAnc3F1ZWV6ZScsICdzdWJzZXQnLCAndHJhY2UnLCAnemVyb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnemVyb3MnLFxuICAnY2F0ZWdvcnknOiAnTWF0cml4JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnemVyb3MobSknLFxuICAgICd6ZXJvcyhtLCBuKScsXG4gICAgJ3plcm9zKG0sIG4sIHAsIC4uLiknLFxuICAgICd6ZXJvcyhbbV0pJyxcbiAgICAnemVyb3MoW20sIG5dKScsXG4gICAgJ3plcm9zKFttLCBuLCBwLCAuLi5dKScsXG4gICAgJ3plcm9zJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ3JlYXRlIGEgbWF0cml4IGNvbnRhaW5pbmcgemVyb3MuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd6ZXJvcygzKScsXG4gICAgJ3plcm9zKDMsIDUpJyxcbiAgICAnYSA9IFsxLCAyLCAzOyA0LCA1LCA2XScsXG4gICAgJ3plcm9zKHNpemUoYSkpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29uY2F0JywgJ2RldCcsICdkaWFnJywgJ2V5ZScsICdpbnYnLCAnb25lcycsICdyYW5nZScsICdzaXplJywgJ3NxdWVlemUnLCAnc3Vic2V0JywgJ3RyYWNlJywgJ3RyYW5zcG9zZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb21iaW5hdGlvbnMnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdjb21iaW5hdGlvbnMobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBudW1iZXIgb2YgY29tYmluYXRpb25zIG9mIG4gaXRlbXMgdGFrZW4gayBhdCBhIHRpbWUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbWJpbmF0aW9ucyg3LCA1KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3Blcm11dGF0aW9ucycsICdmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdmYWN0b3JpYWwnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdrbGRpdmVyZ2VuY2UoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBmYWN0b3JpYWwgb2YgYSB2YWx1ZScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnNSEnLFxuICAgICc1ICogNCAqIDMgKiAyICogMScsXG4gICAgJzMhJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJywgJ3Blcm11dGF0aW9ucycsICdnYW1tYSddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2dhbW1hJyxcbiAgJ2NhdGVnb3J5JzogJ1Byb2JhYmlsaXR5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnZ2FtbWEobiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBnYW1tYSBmdW5jdGlvbi4gRm9yIHNtYWxsIHZhbHVlcywgdGhlIExhbmN6b3MgYXBwcm94aW1hdGlvbiBpcyB1c2VkLCBhbmQgZm9yIGxhcmdlIHZhbHVlcyB0aGUgZXh0ZW5kZWQgU3RpcmxpbmcgYXBwcm94aW1hdGlvbi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2dhbW1hKDQpJyxcbiAgICAnMyEnLFxuICAgICdnYW1tYSgxLzIpJyxcbiAgICAnc3FydChwaSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdrbGRpdmVyZ2VuY2UnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICduIScsXG4gICAgJ2ZhY3RvcmlhbChuKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgS3VsbGJhY2stTGVpYmxlciAoS0wpIGRpdmVyZ2VuY2UgIGJldHdlZW4gdHdvIGRpc3RyaWJ1dGlvbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtYXRoLmtsZGl2ZXJnZW5jZShbMC43LDAuNSwwLjRdLCBbMC4yLDAuOSwwLjVdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtdWx0aW5vbWlhbCcsXG4gICdjYXRlZ29yeSc6ICdQcm9iYWJpbGl0eScsXG4gICdzeW50YXgnOiBbXG4gICAgJ211bHRpbm9taWFsKEEpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnTXVsdGlub21pYWwgQ29lZmZpY2llbnRzIGNvbXB1dGUgdGhlIG51bWJlciBvZiB3YXlzIG9mIHBpY2tpbmcgYTEsIGEyLCAuLi4sIGFpIHVub3JkZXJlZCBvdXRjb21lcyBmcm9tIGBuYCBwb3NzaWJpbGl0aWVzLiBtdWx0aW5vbWlhbCB0YWtlcyBvbmUgYXJyYXkgb2YgaW50ZWdlcnMgYXMgYW4gYXJndW1lbnQuIFRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIG11c3QgYmUgZW5mb3JjZWQ6IGV2ZXJ5IGFpIDw9IDAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtdWx0aW5vbWlhbChbMSwgMiwgMV0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnY29tYmluYXRpb25zJywgJ2ZhY3RvcmlhbCddXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdwZXJtdXRhdGlvbnMnLFxuICAnY2F0ZWdvcnknOiAnUHJvYmFiaWxpdHknLFxuICAnc3ludGF4JzogW1xuICAgICdwZXJtdXRhdGlvbnMobiknLFxuICAgICdwZXJtdXRhdGlvbnMobiwgayknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBudW1iZXIgb2YgcGVybXV0YXRpb25zIG9mIG4gaXRlbXMgdGFrZW4gayBhdCBhIHRpbWUnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3Blcm11dGF0aW9ucyg1KScsXG4gICAgJ3Blcm11dGF0aW9ucyg1LCAzKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2NvbWJpbmF0aW9ucycsICdmYWN0b3JpYWwnXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdwaWNrUmFuZG9tJyxcbiAgJ2NhdGVnb3J5JzogJ1Byb2JhYmlsaXR5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncGlja1JhbmRvbShhcnJheSknLFxuICAgICdwaWNrUmFuZG9tKGFycmF5LCBudW1iZXIpJyxcbiAgICAncGlja1JhbmRvbShhcnJheSwgd2VpZ2h0cyknLFxuICAgICdwaWNrUmFuZG9tKGFycmF5LCBudW1iZXIsIHdlaWdodHMpJyxcbiAgICAncGlja1JhbmRvbShhcnJheSwgd2VpZ2h0cywgbnVtYmVyKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdQaWNrIGEgcmFuZG9tIGVudHJ5IGZyb20gYSBnaXZlbiBhcnJheS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3BpY2tSYW5kb20oMDoxMCknLFxuICAgICdwaWNrUmFuZG9tKFsxLCAzLCAxLCA2XSknLFxuICAgICdwaWNrUmFuZG9tKFsxLCAzLCAxLCA2XSwgMiknLFxuICAgICdwaWNrUmFuZG9tKFsxLCAzLCAxLCA2XSwgWzIsIDMsIDIsIDFdKScsXG4gICAgJ3BpY2tSYW5kb20oWzEsIDMsIDEsIDZdLCAyLCBbMiwgMywgMiwgMV0pJyxcbiAgICAncGlja1JhbmRvbShbMSwgMywgMSwgNl0sIFsyLCAzLCAyLCAxXSwgMiknXG4gIF0sXG4gICdzZWVhbHNvJzogWydyYW5kb20nLCAncmFuZG9tSW50J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmFuZG9tJyxcbiAgJ2NhdGVnb3J5JzogJ1Byb2JhYmlsaXR5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncmFuZG9tKCknLFxuICAgICdyYW5kb20obWF4KScsXG4gICAgJ3JhbmRvbShtaW4sIG1heCknLFxuICAgICdyYW5kb20oc2l6ZSknLFxuICAgICdyYW5kb20oc2l6ZSwgbWF4KScsXG4gICAgJ3JhbmRvbShzaXplLCBtaW4sIG1heCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnUmV0dXJuIGEgcmFuZG9tIG51bWJlci4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3JhbmRvbSgpJyxcbiAgICAncmFuZG9tKDEwLCAyMCknLFxuICAgICdyYW5kb20oWzIsIDNdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3BpY2tSYW5kb20nLCAncmFuZG9tSW50J11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncmFuZEludCcsXG4gICdjYXRlZ29yeSc6ICdQcm9iYWJpbGl0eScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3JhbmRJbnQobWF4KScsXG4gICAgJ3JhbmRJbnQobWluLCBtYXgpJyxcbiAgICAncmFuZEludChzaXplKScsXG4gICAgJ3JhbmRJbnQoc2l6ZSwgbWF4KScsXG4gICAgJ3JhbmRJbnQoc2l6ZSwgbWluLCBtYXgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ1JldHVybiBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlcicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAncmFuZEludCgxMCwgMjApJyxcbiAgICAncmFuZEludChbMiwgM10sIDEwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ3BpY2tSYW5kb20nLCAncmFuZG9tJ11cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvbXBhcmUnLFxuICAnY2F0ZWdvcnknOiAnUmVsYXRpb25hbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NvbXBhcmUoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ29tcGFyZSB0d28gdmFsdWVzLiBSZXR1cm5zIDEgaWYgeCBpcyBsYXJnZXIgdGhhbiB5LCAtMSBpZiB4IGlzIHNtYWxsZXIgdGhhbiB5LCBhbmQgMCBpZiB4IGFuZCB5IGFyZSBlcXVhbC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvbXBhcmUoMiwgMyknLFxuICAgICdjb21wYXJlKDMsIDIpJyxcbiAgICAnY29tcGFyZSgyLCAyKScsXG4gICAgJ2NvbXBhcmUoNWNtLCA0MG1tKScsXG4gICAgJ2NvbXBhcmUoMiwgWzEsIDIsIDNdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2VxdWFsJywgJ3VuZXF1YWwnLCAnc21hbGxlcicsICdzbWFsbGVyRXEnLCAnbGFyZ2VyRXEnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZGVlcEVxdWFsJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICdkZWVwRXF1YWwoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgZXF1YWxpdHkgb2YgdHdvIG1hdHJpY2VzIGVsZW1lbnQgd2lzZS4gUmV0dXJucyB0cnVlIGlmIHRoZSBzaXplIG9mIGJvdGggbWF0cmljZXMgaXMgZXF1YWwgYW5kIHdoZW4gYW5kIGVhY2ggb2YgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ1sxLDMsNF0gPT0gWzEsMyw0XScsXG4gICAgJ1sxLDMsNF0gPT0gWzEsM10nXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ3NtYWxsZXInLCAnbGFyZ2VyJywgJ3NtYWxsZXJFcScsICdsYXJnZXJFcScsICdjb21wYXJlJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2VxdWFsJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4ID09IHknLFxuICAgICdlcXVhbCh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDaGVjayBlcXVhbGl0eSBvZiB0d28gdmFsdWVzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlcyBhcmUgZXF1YWwsIGFuZCBmYWxzZSBpZiBub3QuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyKzIgPT0gMycsXG4gICAgJzIrMiA9PSA0JyxcbiAgICAnYSA9IDMuMicsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJ2EgPT0gYicsXG4gICAgJzUwY20gPT0gMC41bSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3VuZXF1YWwnLCAnc21hbGxlcicsICdsYXJnZXInLCAnc21hbGxlckVxJywgJ2xhcmdlckVxJywgJ2NvbXBhcmUnLCAnZGVlcEVxdWFsJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2xhcmdlcicsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCA+IHknLFxuICAgICdsYXJnZXIoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgaWYgdmFsdWUgeCBpcyBsYXJnZXIgdGhhbiB5LiBSZXR1cm5zIHRydWUgaWYgeCBpcyBsYXJnZXIgdGhhbiB5LCBhbmQgZmFsc2UgaWYgbm90LicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnMiA+IDMnLFxuICAgICc1ID4gMioyJyxcbiAgICAnYSA9IDMuMycsXG4gICAgJ2IgPSA2LTIuOCcsXG4gICAgJyhhID4gYiknLFxuICAgICcoYiA8IGEpJyxcbiAgICAnNSBjbSA+IDIgaW5jaCdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2VxdWFsJywgJ3VuZXF1YWwnLCAnc21hbGxlcicsICdzbWFsbGVyRXEnLCAnbGFyZ2VyRXEnLCAnY29tcGFyZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdsYXJnZXJFcScsXG4gICdjYXRlZ29yeSc6ICdSZWxhdGlvbmFsJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAneCA+PSB5JyxcbiAgICAnbGFyZ2VyRXEoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgaWYgdmFsdWUgeCBpcyBsYXJnZXIgb3IgZXF1YWwgdG8geS4gUmV0dXJucyB0cnVlIGlmIHggaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHksIGFuZCBmYWxzZSBpZiBub3QuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyID4gMSsxJyxcbiAgICAnMiA+PSAxKzEnLFxuICAgICdhID0gMy4yJyxcbiAgICAnYiA9IDYtMi44JyxcbiAgICAnKGEgPiBiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2VxdWFsJywgJ3VuZXF1YWwnLCAnc21hbGxlckVxJywgJ3NtYWxsZXInLCAnbGFyZ2VyRXEnLCAnY29tcGFyZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzbWFsbGVyJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4IDwgeScsXG4gICAgJ3NtYWxsZXIoeCwgeSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ2hlY2sgaWYgdmFsdWUgeCBpcyBzbWFsbGVyIHRoYW4gdmFsdWUgeS4gUmV0dXJucyB0cnVlIGlmIHggaXMgc21hbGxlciB0aGFuIHksIGFuZCBmYWxzZSBpZiBub3QuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyIDwgMycsXG4gICAgJzUgPCAyKjInLFxuICAgICdhID0gMy4zJyxcbiAgICAnYiA9IDYtMi44JyxcbiAgICAnKGEgPCBiKScsXG4gICAgJzUgY20gPCAyIGluY2gnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICd1bmVxdWFsJywgJ2xhcmdlcicsICdzbWFsbGVyRXEnLCAnbGFyZ2VyRXEnLCAnY29tcGFyZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzbWFsbGVyRXEnLFxuICAnY2F0ZWdvcnknOiAnUmVsYXRpb25hbCcsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggPD0geScsXG4gICAgJ3NtYWxsZXJFcSh4LCB5KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzpcbiAgICAgICdDaGVjayBpZiB2YWx1ZSB4IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8gdmFsdWUgeS4gUmV0dXJucyB0cnVlIGlmIHggaXMgc21hbGxlciB0aGFuIHksIGFuZCBmYWxzZSBpZiBub3QuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICcyIDwgMSsxJyxcbiAgICAnMiA8PSAxKzEnLFxuICAgICdhID0gMy4yJyxcbiAgICAnYiA9IDYtMi44JyxcbiAgICAnKGEgPCBiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2VxdWFsJywgJ3VuZXF1YWwnLCAnbGFyZ2VyJywgJ3NtYWxsZXInLCAnbGFyZ2VyRXEnLCAnY29tcGFyZSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd1bmVxdWFsJyxcbiAgJ2NhdGVnb3J5JzogJ1JlbGF0aW9uYWwnLFxuICAnc3ludGF4JzogW1xuICAgICd4ICE9IHknLFxuICAgICd1bmVxdWFsKHgsIHkpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOlxuICAgICAgJ0NoZWNrIHVuZXF1YWxpdHkgb2YgdHdvIHZhbHVlcy4gUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZXMgYXJlIHVuZXF1YWwsIGFuZCBmYWxzZSBpZiB0aGV5IGFyZSBlcXVhbC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJzIrMiAhPSAzJyxcbiAgICAnMisyICE9IDQnLFxuICAgICdhID0gMy4yJyxcbiAgICAnYiA9IDYtMi44JyxcbiAgICAnYSAhPSBiJyxcbiAgICAnNTBjbSAhPSAwLjVtJyxcbiAgICAnNSBjbSAhPSAyIGluY2gnXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdlcXVhbCcsICdzbWFsbGVyJywgJ2xhcmdlcicsICdzbWFsbGVyRXEnLCAnbGFyZ2VyRXEnLCAnY29tcGFyZScsICdkZWVwRXF1YWwnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnZXJmJyxcbiAgJ2NhdGVnb3J5JzogJ1NwZWNpYWwnLFxuICAnc3ludGF4JzogW1xuICAgICdlcmYoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBlcmYgZnVuY3Rpb24gb2YgYSB2YWx1ZSB1c2luZyBhIHJhdGlvbmFsIENoZWJ5c2hldiBhcHByb3hpbWF0aW9ucyBmb3IgZGlmZmVyZW50IGludGVydmFscyBvZiB4JyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdlcmYoMC4yKScsXG4gICAgJ2VyZigtMC41KScsXG4gICAgJ2VyZig0KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtYWQnLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ21hZChhLCBiLCBjLCAuLi4pJyxcbiAgICAnbWFkKEEpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbWVkaWFuIGFic29sdXRlIGRldmlhdGlvbiBvZiBhIG1hdHJpeCBvciBhIGxpc3Qgd2l0aCB2YWx1ZXMuIFRoZSBtZWRpYW4gYWJzb2x1dGUgZGV2aWF0aW9uIGlzIGRlZmluZWQgYXMgdGhlIG1lZGlhbiBvZiB0aGUgYWJzb2x1dGUgZGV2aWF0aW9ucyBmcm9tIHRoZSBtZWRpYW4uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdtYWQoMTAsIDIwLCAzMCknLFxuICAgICdtYWQoWzEsIDIsIDNdKScsXG4gICAgJ21hZCgxMCwgMjAsIDMwKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21lYW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdzdGQnLFxuICAgICdhYnMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWF4JyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdtYXgoYSwgYiwgYywgLi4uKScsXG4gICAgJ21heChBKScsXG4gICAgJ21heChBLCBkaW0pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIGxpc3Qgb2YgdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbWF4KDIsIDMsIDQsIDEpJyxcbiAgICAnbWF4KFsyLCAzLCA0LCAxXSknLFxuICAgICdtYXgoWzIsIDU7IDQsIDNdKScsXG4gICAgJ21heChbMiwgNTsgNCwgM10sIDEpJyxcbiAgICAnbWF4KFsyLCA1OyA0LCAzXSwgMiknLFxuICAgICdtYXgoMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKScsXG4gICAgJ21pbigyLjcsIDcuMSwgLTQuNSwgMi4wLCA0LjEpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWVhbicsXG4gICAgJ21lZGlhbicsXG4gICAgJ21pbicsXG4gICAgJ3Byb2QnLFxuICAgICdzdGQnLFxuICAgICdzdW0nLFxuICAgICd2YXInXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnbWVhbicsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbWVhbihhLCBiLCBjLCAuLi4pJyxcbiAgICAnbWVhbihBKScsXG4gICAgJ21lYW4oQSwgZGltKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGFyaXRobWV0aWMgbWVhbiBvZiBhIGxpc3Qgb2YgdmFsdWVzLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnbWVhbigyLCAzLCA0LCAxKScsXG4gICAgJ21lYW4oWzIsIDMsIDQsIDFdKScsXG4gICAgJ21lYW4oWzIsIDU7IDQsIDNdKScsXG4gICAgJ21lYW4oWzIsIDU7IDQsIDNdLCAxKScsXG4gICAgJ21lYW4oWzIsIDU7IDQsIDNdLCAyKScsXG4gICAgJ21lYW4oWzEuMCwgMi43LCAzLjIsIDQuMF0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdtZWRpYW4nLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ21lZGlhbihhLCBiLCBjLCAuLi4pJyxcbiAgICAnbWVkaWFuKEEpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFsbCB2YWx1ZXMuIFRoZSB2YWx1ZXMgYXJlIHNvcnRlZCBhbmQgdGhlIG1pZGRsZSB2YWx1ZSBpcyByZXR1cm5lZC4gSW4gY2FzZSBvZiBhbiBldmVuIG51bWJlciBvZiB2YWx1ZXMsIHRoZSBhdmVyYWdlIG9mIHRoZSB0d28gbWlkZGxlIHZhbHVlcyBpcyByZXR1cm5lZC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21lZGlhbig1LCAyLCA3KScsXG4gICAgJ21lZGlhbihbMywgLTEsIDUsIDddKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lYW4nLFxuICAgICdtaW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21pbicsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnbWluKGEsIGIsIGMsIC4uLiknLFxuICAgICdtaW4oQSknLFxuICAgICdtaW4oQSwgZGltKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIG1pbmltdW0gdmFsdWUgb2YgYSBsaXN0IG9mIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21pbigyLCAzLCA0LCAxKScsXG4gICAgJ21pbihbMiwgMywgNCwgMV0pJyxcbiAgICAnbWluKFsyLCA1OyA0LCAzXSknLFxuICAgICdtaW4oWzIsIDU7IDQsIDNdLCAxKScsXG4gICAgJ21pbihbMiwgNTsgNCwgM10sIDIpJyxcbiAgICAnbWluKDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSknLFxuICAgICdtYXgoMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lYW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ21vZGUnLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ21vZGUoYSwgYiwgYywgLi4uKScsXG4gICAgJ21vZGUoQSknLFxuICAgICdtb2RlKEEsIGEsIGIsIEIsIGMsIC4uLiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlcyB0aGUgbW9kZSBvZiBhbGwgdmFsdWVzIGFzIGFuIGFycmF5LiBJbiBjYXNlIG1vZGUgYmVpbmcgbW9yZSB0aGFuIG9uZSwgbXVsdGlwbGUgdmFsdWVzIGFyZSByZXR1cm5lZCBpbiBhbiBhcnJheS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ21vZGUoNSwgMiwgNyknLFxuICAgICdtb2RlKFszLCAtMSwgNSwgN10pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnbWF4JyxcbiAgICAnbWVhbicsXG4gICAgJ21pbicsXG4gICAgJ21lZGlhbicsXG4gICAgJ3Byb2QnLFxuICAgICdzdGQnLFxuICAgICdzdW0nLFxuICAgICd2YXInXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAncHJvZCcsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAncHJvZChhLCBiLCBjLCAuLi4pJyxcbiAgICAncHJvZChBKSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYWxsIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3Byb2QoMiwgMywgNCknLFxuICAgICdwcm9kKFsyLCAzLCA0XSknLFxuICAgICdwcm9kKFsyLCA1OyA0LCAzXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWluJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3F1YW50aWxlU2VxJyxcbiAgJ2NhdGVnb3J5JzogJ1N0YXRpc3RpY3MnLFxuICAnc3ludGF4JzogW1xuICAgICdxdWFudGlsZVNlcShBLCBwcm9iWywgc29ydGVkXSknLFxuICAgICdxdWFudGlsZVNlcShBLCBbcHJvYjEsIHByb2IyLCAuLi5dWywgc29ydGVkXSknLFxuICAgICdxdWFudGlsZVNlcShBLCBOWywgc29ydGVkXSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBwcm9iIG9yZGVyIHF1YW50aWxlIG9mIGEgbWF0cml4IG9yIGEgbGlzdCB3aXRoIHZhbHVlcy4gVGhlIHNlcXVlbmNlIGlzIHNvcnRlZCBhbmQgdGhlIG1pZGRsZSB2YWx1ZSBpcyByZXR1cm5lZC4gU3VwcG9ydGVkIHR5cGVzIG9mIHNlcXVlbmNlIHZhbHVlcyBhcmU6IE51bWJlciwgQmlnTnVtYmVyLCBVbml0IFN1cHBvcnRlZCB0eXBlcyBvZiBwcm9iYWJsaXR5IGFyZTogTnVtYmVyLCBCaWdOdW1iZXIuIFxcblxcbkluIGNhc2Ugb2YgYSAobXVsdGkgZGltZW5zaW9uYWwpIGFycmF5IG9yIG1hdHJpeCwgdGhlIHByb2Igb3JkZXIgcXVhbnRpbGUgb2YgYWxsIGVsZW1lbnRzIHdpbGwgYmUgY2FsY3VsYXRlZC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3F1YW50aWxlU2VxKFszLCAtMSwgNSwgN10sIDAuNSknLFxuICAgICdxdWFudGlsZVNlcShbMywgLTEsIDUsIDddLCBbMS8zLCAyLzNdKScsXG4gICAgJ3F1YW50aWxlU2VxKFszLCAtMSwgNSwgN10sIDIpJyxcbiAgICAncXVhbnRpbGVTZXEoWy0xLCAzLCA1LCA3XSwgMC41LCB0cnVlKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21lYW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdtaW4nLFxuICAgICdtYXgnLFxuICAgICdwcm9kJyxcbiAgICAnc3RkJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzdGQnLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3N0ZChhLCBiLCBjLCAuLi4pJyxcbiAgICAnc3RkKEEpJyxcbiAgICAnc3RkKEEsIG5vcm1hbGl6YXRpb24pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFsbCB2YWx1ZXMsIGRlZmluZWQgYXMgc3RkKEEpID0gc3FydCh2YXIoQSkpLiBPcHRpb25hbCBwYXJhbWV0ZXIgbm9ybWFsaXphdGlvbiBjYW4gYmUgXCJ1bmJpYXNlZFwiIChkZWZhdWx0KSwgXCJ1bmNvcnJlY3RlZFwiLCBvciBcImJpYXNlZFwiLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnc3RkKDIsIDQsIDYpJyxcbiAgICAnc3RkKFsyLCA0LCA2LCA4XSknLFxuICAgICdzdGQoWzIsIDQsIDYsIDhdLCBcInVuY29ycmVjdGVkXCIpJyxcbiAgICAnc3RkKFsyLCA0LCA2LCA4XSwgXCJiaWFzZWRcIiknLFxuICAgICdzdGQoWzEsIDIsIDM7IDQsIDUsIDZdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ21heCcsXG4gICAgJ21lYW4nLFxuICAgICdtaW4nLFxuICAgICdtZWRpYW4nLFxuICAgICdtaW4nLFxuICAgICdwcm9kJyxcbiAgICAnc3VtJyxcbiAgICAndmFyJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ3N1bScsXG4gICdjYXRlZ29yeSc6ICdTdGF0aXN0aWNzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc3VtKGEsIGIsIGMsIC4uLiknLFxuICAgICdzdW0oQSknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBzdW0gb2YgYWxsIHZhbHVlcy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3N1bSgyLCAzLCA0LCAxKScsXG4gICAgJ3N1bShbMiwgMywgNCwgMV0pJyxcbiAgICAnc3VtKFsyLCA1OyA0LCAzXSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bScsXG4gICAgJ3ZhcidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd2YXInLFxuICAnY2F0ZWdvcnknOiAnU3RhdGlzdGljcycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ZhcihhLCBiLCBjLCAuLi4pJyxcbiAgICAndmFyKEEpJyxcbiAgICAndmFyKEEsIG5vcm1hbGl6YXRpb24pJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgdmFyaWFuY2Ugb2YgYWxsIHZhbHVlcy4gT3B0aW9uYWwgcGFyYW1ldGVyIG5vcm1hbGl6YXRpb24gY2FuIGJlIFwidW5iaWFzZWRcIiAoZGVmYXVsdCksIFwidW5jb3JyZWN0ZWRcIiwgb3IgXCJiaWFzZWRcIi4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3ZhcigyLCA0LCA2KScsXG4gICAgJ3ZhcihbMiwgNCwgNiwgOF0pJyxcbiAgICAndmFyKFsyLCA0LCA2LCA4XSwgXCJ1bmNvcnJlY3RlZFwiKScsXG4gICAgJ3ZhcihbMiwgNCwgNiwgOF0sIFwiYmlhc2VkXCIpJyxcbiAgICAndmFyKFsxLCAyLCAzOyA0LCA1LCA2XSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdtYXgnLFxuICAgICdtZWFuJyxcbiAgICAnbWluJyxcbiAgICAnbWVkaWFuJyxcbiAgICAnbWluJyxcbiAgICAncHJvZCcsXG4gICAgJ3N0ZCcsXG4gICAgJ3N1bSdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhY29zJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Fjb3MoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBpbnZlcnNlIGNvc2luZSBvZiBhIHZhbHVlIGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhY29zKDAuNSknLFxuICAgICdhY29zKGNvcygyLjMpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvcycsXG4gICAgJ2F0YW4nLFxuICAgICdhc2luJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Fjb3NoJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Fjb3NoKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGFyY2NvcyBvZiBhIHZhbHVlLCBkZWZpbmVkIGFzIGBhY29zaCh4KSA9IGxuKHNxcnQoeF4yIC0gMSkgKyB4KWAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhY29zaCgxLjUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY29zaCcsXG4gICAgJ2FzaW5oJyxcbiAgICAnYXRhbmgnXG4gIF1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Fjb3QnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYWNvdCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaW52ZXJzZSBjb3RhbmdlbnQgb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Fjb3QoMC41KScsXG4gICAgJ2Fjb3QoY290KDAuNSkpJyxcbiAgICAnYWNvdCgyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2NvdCcsXG4gICAgJ2F0YW4nXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYWNvdGgnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYWNvdGgoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjY290YW5nZW50IG9mIGEgdmFsdWUsIGRlZmluZWQgYXMgYGFjb3RoKHgpID0gKGxuKCh4KzEpL3gpICsgbG4oeC8oeC0xKSkpIC8gMmAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhY290aCgwLjUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWNzY2gnLFxuICAgICdhc2VjaCdcbiAgXVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYWNzYycsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhY3NjKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIGNvdGFuZ2VudCBvZiBhIHZhbHVlLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYWNzYygwLjUpJyxcbiAgICAnYWNzYyhjc2MoMC41KSknLFxuICAgICdhY3NjKDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnY3NjJyxcbiAgICAnYXNpbicsXG4gICAgJ2FzZWMnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYWNzY2gnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYWNzY2goeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjY29zZWNhbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYWNzY2goeCkgPSBsbigxL3ggKyBzcXJ0KDEveF4yICsgMSkpYC4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Fjc2NoKDAuNSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhc2VjaCcsXG4gICAgJ2Fjb3RoJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FzZWMnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXNlYyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaW52ZXJzZSBzZWNhbnQgb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FzZWMoMC41KScsXG4gICAgJ2FzZWMoc2VjKDAuNSkpJyxcbiAgICAnYXNlYygyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2Fjb3MnLFxuICAgICdhY290JyxcbiAgICAnYWNzYydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdhc2VjaCcsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhc2VjaCh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NhbGN1bGF0ZSB0aGUgaW52ZXJzZSBzZWNhbnQgb2YgYSB2YWx1ZS4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2FzZWNoKDAuNSknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhY3NjaCcsXG4gICAgJ2Fjb3RoJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FzaW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXNpbih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGludmVyc2Ugc2luZSBvZiBhIHZhbHVlIGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhc2luKDAuNSknLFxuICAgICdhc2luKHNpbigyLjMpKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NpbicsXG4gICAgJ2Fjb3MnLFxuICAgICdhdGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2FzaW5oJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2FzaW5oKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGFyY3NpbmUgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYXNpbmgoeCkgPSBsbih4ICsgc3FydCh4XjIgKyAxKSlgLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnYXNpbmgoMC41KSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ2Fjb3NoJyxcbiAgICAnYXRhbmgnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYXRhbicsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdhdGFuKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgaW52ZXJzZSB0YW5nZW50IG9mIGEgdmFsdWUgaW4gcmFkaWFucy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2F0YW4oMC41KScsXG4gICAgJ2F0YW4odGFuKDIuMykpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAndGFuJyxcbiAgICAnYWNvcycsXG4gICAgJ2FzaW4nXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnYXRhbjInLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnYXRhbjIoeSwgeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6XG4gICAgICAnQ29tcHV0ZXMgdGhlIHByaW5jaXBhbCB2YWx1ZSBvZiB0aGUgYXJjIHRhbmdlbnQgb2YgeS94IGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhdGFuMigyLCAyKSAvIHBpJyxcbiAgICAnYW5nbGUgPSA2MCBkZWcgaW4gcmFkJyxcbiAgICAneCA9IGNvcyhhbmdsZSknLFxuICAgICd5ID0gc2luKGFuZ2xlKScsXG4gICAgJ2F0YW4yKHksIHgpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnc2luJyxcbiAgICAnY29zJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2F0YW5oJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2F0YW5oKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGFyY3RhbmdlbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYXRhbmgoeCkgPSBsbigoMSArIHgpLygxIC0geCkpIC8gMmAuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdhdGFuaCgwLjUpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYWNvc2gnLFxuICAgICdhc2luaCdcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjb3MnLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnY29zKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgY29zaW5lIG9mIHggaW4gcmFkaWFucy4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2NvcygyKScsXG4gICAgJ2NvcyhwaSAvIDQpIF4gMicsXG4gICAgJ2NvcygxODAgZGVnKScsXG4gICAgJ2Nvcyg2MCBkZWcpJyxcbiAgICAnc2luKDAuMileMiArIGNvcygwLjIpXjInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhY29zJyxcbiAgICAnc2luJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnY29zaCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdjb3NoKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIHggaW4gcmFkaWFucy4nLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdjb3NoKDAuNSknXHJcbiAgXSxcclxuICAnc2VlYWxzbyc6IFtcclxuICAgICdzaW5oJyxcclxuICAgICd0YW5oJyxcclxuICAgICdjb3RoJ1xyXG4gIF1cclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2NvdCcsXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxuICAnc3ludGF4JzogW1xuICAgICdjb3QoeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBjb3RhbmdlbnQgb2YgeCBpbiByYWRpYW5zLiBEZWZpbmVkIGFzIDEvdGFuKHgpJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdjb3QoMiknLFxuICAgICcxIC8gdGFuKDIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnc2VjJyxcbiAgICAnY3NjJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnY290aCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdjb3RoKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgY290YW5nZW50IG9mIHggaW4gcmFkaWFucy4nLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdjb3RoKDIpJyxcclxuICAgICcxIC8gdGFuaCgyKSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ3NlY2gnLFxyXG4gICAgJ2NzY2gnLFxyXG4gICAgJ3RhbmgnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnY3NjJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ2NzYyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGNvc2VjYW50IG9mIHggaW4gcmFkaWFucy4gRGVmaW5lZCBhcyAxL3Npbih4KScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnY3NjKDIpJyxcbiAgICAnMSAvIHNpbigyKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXG4gICAgJ3NlYycsXG4gICAgJ2NvdCcsXG4gICAgJ3NpbidcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ2NzY2gnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAnY3NjaCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIGNvc2VjYW50IG9mIHggaW4gcmFkaWFucy4gRGVmaW5lZCBhcyAxL3NpbmgoeCknLFxyXG4gICdleGFtcGxlcyc6IFtcclxuICAgICdjc2NoKDIpJyxcclxuICAgICcxIC8gc2luaCgyKSdcclxuICBdLFxyXG4gICdzZWVhbHNvJzogW1xyXG4gICAgJ3NlY2gnLFxyXG4gICAgJ2NvdGgnLFxyXG4gICAgJ3NpbmgnXHJcbiAgXVxyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnc2VjJyxcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXG4gICdzeW50YXgnOiBbXG4gICAgJ3NlYyh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIHNlY2FudCBvZiB4IGluIHJhZGlhbnMuIERlZmluZWQgYXMgMS9jb3MoeCknLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ3NlYygyKScsXG4gICAgJzEgLyBjb3MoMiknXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdjb3QnLFxuICAgICdjc2MnLFxuICAgICdjb3MnXG4gIF1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAnbmFtZSc6ICdzZWNoJyxcclxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcclxuICAnc3ludGF4JzogW1xyXG4gICAgJ3NlY2goeCknXHJcbiAgXSxcclxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgaHlwZXJib2xpYyBzZWNhbnQgb2YgeCBpbiByYWRpYW5zLiBEZWZpbmVkIGFzIDEvY29zaCh4KScsXHJcbiAgJ2V4YW1wbGVzJzogW1xyXG4gICAgJ3NlY2goMiknLFxyXG4gICAgJzEgLyBjb3NoKDIpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnY290aCcsXHJcbiAgICAnY3NjaCcsXHJcbiAgICAnY29zaCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdzaW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnc2luKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgc2luZSBvZiB4IGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdzaW4oMiknLFxuICAgICdzaW4ocGkgLyA0KSBeIDInLFxuICAgICdzaW4oOTAgZGVnKScsXG4gICAgJ3NpbigzMCBkZWcpJyxcbiAgICAnc2luKDAuMileMiArIGNvcygwLjIpXjInXG4gIF0sXG4gICdzZWVhbHNvJzogW1xuICAgICdhc2luJyxcbiAgICAnY29zJyxcbiAgICAndGFuJ1xuICBdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgJ25hbWUnOiAnc2luaCcsXHJcbiAgJ2NhdGVnb3J5JzogJ1RyaWdvbm9tZXRyeScsXHJcbiAgJ3N5bnRheCc6IFtcclxuICAgICdzaW5oKHgpJ1xyXG4gIF0sXHJcbiAgJ2Rlc2NyaXB0aW9uJzogJ0NvbXB1dGUgdGhlIGh5cGVyYm9saWMgc2luZSBvZiB4IGluIHJhZGlhbnMuJyxcclxuICAnZXhhbXBsZXMnOiBbXHJcbiAgICAnc2luaCgwLjUpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnY29zaCcsXHJcbiAgICAndGFuaCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0YW4nLFxuICAnY2F0ZWdvcnknOiAnVHJpZ29ub21ldHJ5JyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndGFuKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ29tcHV0ZSB0aGUgdGFuZ2VudCBvZiB4IGluIHJhZGlhbnMuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0YW4oMC41KScsXG4gICAgJ3NpbigwLjUpIC8gY29zKDAuNSknLFxuICAgICd0YW4ocGkgLyA0KScsXG4gICAgJ3Rhbig0NSBkZWcpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtcbiAgICAnYXRhbicsXG4gICAgJ3NpbicsXG4gICAgJ2NvcydcbiAgXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICduYW1lJzogJ3RhbmgnLFxyXG4gICdjYXRlZ29yeSc6ICdUcmlnb25vbWV0cnknLFxyXG4gICdzeW50YXgnOiBbXHJcbiAgICAndGFuaCh4KSdcclxuICBdLFxyXG4gICdkZXNjcmlwdGlvbic6ICdDb21wdXRlIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgeCBpbiByYWRpYW5zLicsXHJcbiAgJ2V4YW1wbGVzJzogW1xyXG4gICAgJ3RhbmgoMC41KScsXHJcbiAgICAnc2luaCgwLjUpIC8gY29zaCgwLjUpJ1xyXG4gIF0sXHJcbiAgJ3NlZWFsc28nOiBbXHJcbiAgICAnc2luaCcsXHJcbiAgICAnY29zaCdcclxuICBdXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICd0bycsXG4gICdjYXRlZ29yeSc6ICdVbml0cycsXG4gICdzeW50YXgnOiBbXG4gICAgJ3ggdG8gdW5pdCcsXG4gICAgJ3RvKHgsIHVuaXQpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2hhbmdlIHRoZSB1bml0IG9mIGEgdmFsdWUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICc1IGluY2ggdG8gY20nLFxuICAgICczLjJrZyB0byBnJyxcbiAgICAnMTYgYnl0ZXMgaW4gYml0cydcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdjbG9uZScsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Nsb25lKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnQ2xvbmUgYSB2YXJpYWJsZS4gQ3JlYXRlcyBhIGNvcHkgb2YgcHJpbWl0aXZlIHZhcmlhYmxlcyxhbmQgYSBkZWVwIGNvcHkgb2YgbWF0cmljZXMnLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2Nsb25lKDMuNSknLFxuICAgICdjbG9uZSgyIC0gNGkpJyxcbiAgICAnY2xvbmUoNDUgZGVnKScsXG4gICAgJ2Nsb25lKFsxLCAyOyAzLCA0XSknLFxuICAgICdjbG9uZShcImhlbGxvIHdvcmxkXCIpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFtdXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2Zvcm1hdCcsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2Zvcm1hdCh2YWx1ZSknLFxuICAgICdmb3JtYXQodmFsdWUsIHByZWNpc2lvbiknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdGb3JtYXQgYSB2YWx1ZSBvZiBhbnkgdHlwZSBhcyBzdHJpbmcuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdmb3JtYXQoMi4zKScsXG4gICAgJ2Zvcm1hdCgzIC0gNGkpJyxcbiAgICAnZm9ybWF0KFtdKScsXG4gICAgJ2Zvcm1hdChwaSwgMyknXG4gIF0sXG4gICdzZWVhbHNvJzogWydwcmludCddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2lzSW50ZWdlcicsXG4gICdjYXRlZ29yeSc6ICdVdGlscycsXG4gICdzeW50YXgnOiBbXG4gICAgJ2lzSW50ZWdlcih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1Rlc3Qgd2hldGhlciBhIHZhbHVlIGlzIGFuIGludGVnZXIgbnVtYmVyLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNJbnRlZ2VyKDIpJyxcbiAgICAnaXNJbnRlZ2VyKDMuNSknLFxuICAgICdpc0ludGVnZXIoWzMsIDAuNSwgLTJdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2lzTmVnYXRpdmUnLCAnaXNOdW1lcmljJywgJ2lzUG9zaXRpdmUnLCAnaXNaZXJvJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaXNOYU4nLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc05hTih4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1Rlc3Qgd2hldGhlciBhIHZhbHVlIGlzIE5hTiAobm90IGEgbnVtYmVyKScsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNOYU4oMiknLFxuICAgICdpc05hTigwIC8gMCknLFxuICAgICdpc05hTihOYU4pJyxcbiAgICAnaXNOYU4oSW5maW5pdHkpJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnaXNOZWdhdGl2ZScsICdpc051bWVyaWMnLCAnaXNQb3NpdGl2ZScsICdpc1plcm8nXVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpc05lZ2F0aXZlJyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaXNOZWdhdGl2ZSh4KSdcbiAgXSxcbiAgJ2Rlc2NyaXB0aW9uJzogJ1Rlc3Qgd2hldGhlciBhIHZhbHVlIGlzIG5lZ2F0aXZlOiBzbWFsbGVyIHRoYW4gemVyby4nLFxuICAnZXhhbXBsZXMnOiBbXG4gICAgJ2lzTmVnYXRpdmUoMiknLFxuICAgICdpc05lZ2F0aXZlKDApJyxcbiAgICAnaXNOZWdhdGl2ZSgtNCknLFxuICAgICdpc05lZ2F0aXZlKFszLCAwLjUsIC0yXSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydpc0ludGVnZXInLCAnaXNOdW1lcmljJywgJ2lzUG9zaXRpdmUnLCAnaXNaZXJvJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAnaXNOdW1lcmljJyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAnaXNOdW1lcmljKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBudW1lcmljIHZhbHVlLiAnICtcbiAgICAnUmV0dXJucyB0cnVlIHdoZW4gdGhlIGlucHV0IGlzIGEgbnVtYmVyLCBCaWdOdW1iZXIsIEZyYWN0aW9uLCBvciBib29sZWFuLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNOdW1lcmljKDIpJyxcbiAgICAnaXNOdW1lcmljKDApJyxcbiAgICAnaXNOdW1lcmljKGJpZ251bWJlcig1MDApKScsXG4gICAgJ2lzTnVtZXJpYyhmcmFjdGlvbigwLjEyNSkpJyxcbiAgICAnaXNOdW1lcmljKFwiM1wiKScsXG4gICAgJ2lzTnVtZXJpYygyICsgM2kpJyxcbiAgICAnaXNOdW1lcmljKFsyLjMsIFwiZm9vXCIsIGZhbHNlXSknXG4gIF0sXG4gICdzZWVhbHNvJzogWydpc0ludGVnZXInLCAnaXNaZXJvJywgJ2lzTmVnYXRpdmUnLCAnaXNQb3NpdGl2ZScsICdpc05hTiddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2lzUG9zaXRpdmUnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc1Bvc2l0aXZlKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgcG9zaXRpdmU6IGxhcmdlciB0aGFuIHplcm8uJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICdpc1Bvc2l0aXZlKDIpJyxcbiAgICAnaXNQb3NpdGl2ZSgwKScsXG4gICAgJ2lzUG9zaXRpdmUoLTQpJyxcbiAgICAnaXNQb3NpdGl2ZShbMywgMC41LCAtMl0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnaXNJbnRlZ2VyJywgJ2lzTnVtZXJpYycsICdpc05lZ2F0aXZlJywgJ2lzWmVybyddXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICduYW1lJzogJ2lzUHJpbWUnLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc1ByaW1lKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgcHJpbWU6IGhhcyBubyBkaXZpc29ycyBvdGhlciB0aGFuIGl0c2VsZiBhbmQgb25lLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNQcmltZSgzKScsXG4gICAgJ2lzUHJpbWUoLTIpJyxcbiAgICAnaXNQcmltZShbMiwgMTcsIDEwMF0pJ1xuICBdLFxuICAnc2VlYWxzbyc6IFsnaXNJbnRlZ2VyJywgJ2lzTnVtZXJpYycsICdpc05lZ2F0aXZlJywgJ2lzWmVybyddXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAnbmFtZSc6ICdpc1plcm8nLFxuICAnY2F0ZWdvcnknOiAnVXRpbHMnLFxuICAnc3ludGF4JzogW1xuICAgICdpc1plcm8oeCknXG4gIF0sXG4gICdkZXNjcmlwdGlvbic6ICdUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyB6ZXJvLicsXG4gICdleGFtcGxlcyc6IFtcbiAgICAnaXNaZXJvKDIpJyxcbiAgICAnaXNaZXJvKDApJyxcbiAgICAnaXNaZXJvKC00KScsXG4gICAgJ2lzWmVybyhbMywgMCwgLTIsIDBdKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbJ2lzSW50ZWdlcicsICdpc051bWVyaWMnLCAnaXNOZWdhdGl2ZScsICdpc1Bvc2l0aXZlJ11cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ25hbWUnOiAndHlwZW9mJyxcbiAgJ2NhdGVnb3J5JzogJ1V0aWxzJyxcbiAgJ3N5bnRheCc6IFtcbiAgICAndHlwZW9mKHgpJ1xuICBdLFxuICAnZGVzY3JpcHRpb24nOiAnR2V0IHRoZSB0eXBlIG9mIGEgdmFyaWFibGUuJyxcbiAgJ2V4YW1wbGVzJzogW1xuICAgICd0eXBlb2YoMy41KScsXG4gICAgJ3R5cGVvZigyIC0gNGkpJyxcbiAgICAndHlwZW9mKDQ1IGRlZyknLFxuICAgICd0eXBlb2YoXCJoZWxsbyB3b3JsZFwiKSdcbiAgXSxcbiAgJ3NlZWFsc28nOiBbXVxufTtcbiIsImZ1bmN0aW9uIGZhY3RvcnkgKGNvbnN0cnVjdGlvbiwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZG9jcyA9IHt9O1xuXG5cbiAgLy8gY29uc3RydWN0aW9uIGZ1bmN0aW9uc1xuICBkb2NzLmJpZ251bWJlciA9IHJlcXVpcmUoJy4vY29uc3RydWN0aW9uL2JpZ251bWJlcicpO1xuICBkb2NzWydib29sZWFuJ10gPSByZXF1aXJlKCcuL2NvbnN0cnVjdGlvbi9ib29sZWFuJyk7XG4gIGRvY3MuY29tcGxleCA9IHJlcXVpcmUoJy4vY29uc3RydWN0aW9uL2NvbXBsZXgnKTtcbiAgZG9jcy5jcmVhdGVVbml0ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vY3JlYXRlVW5pdCcpO1xuICBkb2NzLmZyYWN0aW9uID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vZnJhY3Rpb24nKTtcbiAgZG9jcy5pbmRleCA9IHJlcXVpcmUoJy4vY29uc3RydWN0aW9uL2luZGV4Jyk7XG4gIGRvY3MubWF0cml4ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vbWF0cml4Jyk7XG4gIGRvY3MubnVtYmVyID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vbnVtYmVyJyk7XG4gIGRvY3Muc3BhcnNlID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vc3BhcnNlJyk7XG4gIGRvY3Muc3BsaXRVbml0ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vc3BsaXRVbml0Jyk7XG4gIGRvY3Muc3RyaW5nID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3Rpb24vc3RyaW5nJyk7XG4gIGRvY3MudW5pdCA9IHJlcXVpcmUoJy4vY29uc3RydWN0aW9uL3VuaXQnKTtcblxuICAvLyBjb25zdGFudHNcbiAgZG9jcy5lID0gcmVxdWlyZSgnLi9jb25zdGFudHMvZScpO1xuICBkb2NzLkUgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9lJyk7XG4gIGRvY3NbJ2ZhbHNlJ10gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9mYWxzZScpO1xuICBkb2NzLmkgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9pJyk7XG4gIGRvY3NbJ0luZmluaXR5J10gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9JbmZpbml0eScpO1xuICBkb2NzLkxOMiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xOMicpO1xuICBkb2NzLkxOMTAgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9MTjEwJyk7XG4gIGRvY3MuTE9HMkUgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9MT0cyRScpO1xuICBkb2NzLkxPRzEwRSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0xPRzEwRScpO1xuICBkb2NzLk5hTiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL05hTicpO1xuICBkb2NzWydudWxsJ10gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9udWxsJyk7XG4gIGRvY3MucGkgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9waScpO1xuICBkb2NzLlBJID0gcmVxdWlyZSgnLi9jb25zdGFudHMvcGknKTtcbiAgZG9jcy5waGkgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9waGknKTtcbiAgZG9jcy5TUVJUMV8yID0gcmVxdWlyZSgnLi9jb25zdGFudHMvU1FSVDFfMicpO1xuICBkb2NzLlNRUlQyID0gcmVxdWlyZSgnLi9jb25zdGFudHMvU1FSVDInKTtcbiAgZG9jcy50YXUgPSByZXF1aXJlKCcuL2NvbnN0YW50cy90YXUnKTtcbiAgZG9jc1sndHJ1ZSddID0gcmVxdWlyZSgnLi9jb25zdGFudHMvdHJ1ZScpO1xuICBkb2NzLnZlcnNpb24gPSByZXF1aXJlKCcuL2NvbnN0YW50cy92ZXJzaW9uJyk7XG5cbiAgLy8gcGh5c2ljYWwgY29uc3RhbnRzXG4gIC8vIFRPRE86IG1vcmUgZGV0YWlsZWQgZG9jcyBmb3IgcGh5c2ljYWwgY29uc3RhbnRzXG4gIGRvY3Muc3BlZWRPZkxpZ2h0ID0ge2Rlc2NyaXB0aW9uOiAnU3BlZWQgb2YgbGlnaHQgaW4gdmFjdXVtJywgZXhhbXBsZXM6IFsnc3BlZWRPZkxpZ2h0J119O1xuICBkb2NzLmdyYXZpdGF0aW9uQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdOZXd0b25pYW4gY29uc3RhbnQgb2YgZ3Jhdml0YXRpb24nLCBleGFtcGxlczogWydncmF2aXRhdGlvbkNvbnN0YW50J119O1xuICBkb2NzLnBsYW5ja0NvbnN0YW50ID0ge2Rlc2NyaXB0aW9uOiAnUGxhbmNrIGNvbnN0YW50JywgZXhhbXBsZXM6IFsncGxhbmNrQ29uc3RhbnQnXX07XG4gIGRvY3MucmVkdWNlZFBsYW5ja0NvbnN0YW50ID0ge2Rlc2NyaXB0aW9uOiAnUmVkdWNlZCBQbGFuY2sgY29uc3RhbnQnLCBleGFtcGxlczogWydyZWR1Y2VkUGxhbmNrQ29uc3RhbnQnXX07XG5cbiAgZG9jcy5tYWduZXRpY0NvbnN0YW50ID0ge2Rlc2NyaXB0aW9uOiAnTWFnbmV0aWMgY29uc3RhbnQgKHZhY3V1bSBwZXJtZWFiaWxpdHkpJywgZXhhbXBsZXM6IFsnbWFnbmV0aWNDb25zdGFudCddfTtcbiAgZG9jcy5lbGVjdHJpY0NvbnN0YW50ID0ge2Rlc2NyaXB0aW9uOiAnRWxlY3RyaWMgY29uc3RhbnQgKHZhY3V1bSBwZXJtZWFiaWxpdHkpJywgZXhhbXBsZXM6IFsnZWxlY3RyaWNDb25zdGFudCddfTtcbiAgZG9jcy52YWN1dW1JbXBlZGFuY2UgPSB7ZGVzY3JpcHRpb246ICdDaGFyYWN0ZXJpc3RpYyBpbXBlZGFuY2Ugb2YgdmFjdXVtJywgZXhhbXBsZXM6IFsndmFjdXVtSW1wZWRhbmNlJ119O1xuICBkb2NzLmNvdWxvbWIgPSB7ZGVzY3JpcHRpb246ICdDb3Vsb21iXFwncyBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2NvdWxvbWInXX07XG4gIGRvY3MuZWxlbWVudGFyeUNoYXJnZSA9IHtkZXNjcmlwdGlvbjogJ0VsZW1lbnRhcnkgY2hhcmdlJywgZXhhbXBsZXM6IFsnZWxlbWVudGFyeUNoYXJnZSddfTtcbiAgZG9jcy5ib2hyTWFnbmV0b24gPSB7ZGVzY3JpcHRpb246ICdCb3JoIG1hZ25ldG9uJywgZXhhbXBsZXM6IFsnYm9ock1hZ25ldG9uJ119O1xuICBkb2NzLmNvbmR1Y3RhbmNlUXVhbnR1bSA9IHtkZXNjcmlwdGlvbjogJ0NvbmR1Y3RhbmNlIHF1YW50dW0nLCBleGFtcGxlczogWydjb25kdWN0YW5jZVF1YW50dW0nXX07XG4gIGRvY3MuaW52ZXJzZUNvbmR1Y3RhbmNlUXVhbnR1bSA9IHtkZXNjcmlwdGlvbjogJ0ludmVyc2UgY29uZHVjdGFuY2UgcXVhbnR1bScsIGV4YW1wbGVzOiBbJ2ludmVyc2VDb25kdWN0YW5jZVF1YW50dW0nXX07XG4gIC8vZG9jcy5qb3NlcGhzb24gPSB7ZGVzY3JpcHRpb246ICdKb3NlcGhzb24gY29uc3RhbnQnLCBleGFtcGxlczogWydqb3NlcGhzb24nXX07XG4gIGRvY3MubWFnbmV0aWNGbHV4UXVhbnR1bSA9IHtkZXNjcmlwdGlvbjogJ01hZ25ldGljIGZsdXggcXVhbnR1bScsIGV4YW1wbGVzOiBbJ21hZ25ldGljRmx1eFF1YW50dW0nXX07XG4gIGRvY3MubnVjbGVhck1hZ25ldG9uID0ge2Rlc2NyaXB0aW9uOiAnTnVjbGVhciBtYWduZXRvbicsIGV4YW1wbGVzOiBbJ251Y2xlYXJNYWduZXRvbiddfTtcbiAgZG9jcy5rbGl0emluZyA9IHtkZXNjcmlwdGlvbjogJ1ZvbiBLbGl0emluZyBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2tsaXR6aW5nJ119O1xuXG4gIGRvY3MuYm9oclJhZGl1cyA9IHtkZXNjcmlwdGlvbjogJ0JvcmggcmFkaXVzJywgZXhhbXBsZXM6IFsnYm9oclJhZGl1cyddfTtcbiAgZG9jcy5jbGFzc2ljYWxFbGVjdHJvblJhZGl1cyA9IHtkZXNjcmlwdGlvbjogJ0NsYXNzaWNhbCBlbGVjdHJvbiByYWRpdXMnLCBleGFtcGxlczogWydjbGFzc2ljYWxFbGVjdHJvblJhZGl1cyddfTtcbiAgZG9jcy5lbGVjdHJvbk1hc3MgPSB7ZGVzY3JpcHRpb246ICdFbGVjdHJvbiBtYXNzJywgZXhhbXBsZXM6IFsnZWxlY3Ryb25NYXNzJ119O1xuICBkb2NzLmZlcm1pQ291cGxpbmcgPSB7ZGVzY3JpcHRpb246ICdGZXJtaSBjb3VwbGluZyBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ2Zlcm1pQ291cGxpbmcnXX07XG4gIGRvY3MuZmluZVN0cnVjdHVyZSA9IHtkZXNjcmlwdGlvbjogJ0ZpbmUtc3RydWN0dXJlIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnZmluZVN0cnVjdHVyZSddfTtcbiAgZG9jcy5oYXJ0cmVlRW5lcmd5ID0ge2Rlc2NyaXB0aW9uOiAnSGFydHJlZSBlbmVyZ3knLCBleGFtcGxlczogWydoYXJ0cmVlRW5lcmd5J119O1xuICBkb2NzLnByb3Rvbk1hc3MgPSB7ZGVzY3JpcHRpb246ICdQcm90b24gbWFzcycsIGV4YW1wbGVzOiBbJ3Byb3Rvbk1hc3MnXX07XG4gIGRvY3MuZGV1dGVyb25NYXNzID0ge2Rlc2NyaXB0aW9uOiAnRGV1dGVyb24gTWFzcycsIGV4YW1wbGVzOiBbJ2RldXRlcm9uTWFzcyddfTtcbiAgZG9jcy5uZXV0cm9uTWFzcyA9IHtkZXNjcmlwdGlvbjogJ05ldXRyb24gbWFzcycsIGV4YW1wbGVzOiBbJ25ldXRyb25NYXNzJ119O1xuICBkb2NzLnF1YW50dW1PZkNpcmN1bGF0aW9uID0ge2Rlc2NyaXB0aW9uOiAnUXVhbnR1bSBvZiBjaXJjdWxhdGlvbicsIGV4YW1wbGVzOiBbJ3F1YW50dW1PZkNpcmN1bGF0aW9uJ119O1xuICBkb2NzLnJ5ZGJlcmcgPSB7ZGVzY3JpcHRpb246ICdSeWRiZXJnIGNvbnN0YW50JywgZXhhbXBsZXM6IFsncnlkYmVyZyddfTtcbiAgZG9jcy50aG9tc29uQ3Jvc3NTZWN0aW9uID0ge2Rlc2NyaXB0aW9uOiAnVGhvbXNvbiBjcm9zcyBzZWN0aW9uJywgZXhhbXBsZXM6IFsndGhvbXNvbkNyb3NzU2VjdGlvbiddfTtcbiAgZG9jcy53ZWFrTWl4aW5nQW5nbGUgPSB7ZGVzY3JpcHRpb246ICdXZWFrIG1peGluZyBhbmdsZScsIGV4YW1wbGVzOiBbJ3dlYWtNaXhpbmdBbmdsZSddfTtcbiAgZG9jcy5lZmltb3ZGYWN0b3IgPSB7ZGVzY3JpcHRpb246ICdFZmltb3YgZmFjdG9yJywgZXhhbXBsZXM6IFsnZWZpbW92RmFjdG9yJ119O1xuXG4gIGRvY3MuYXRvbWljTWFzcyA9IHtkZXNjcmlwdGlvbjogJ0F0b21pYyBtYXNzIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnYXRvbWljTWFzcyddfTtcbiAgZG9jcy5hdm9nYWRybyA9IHtkZXNjcmlwdGlvbjogJ0F2b2dhZHJvXFwncyBudW1iZXInLCBleGFtcGxlczogWydhdm9nYWRybyddfTtcbiAgZG9jcy5ib2x0em1hbm4gPSB7ZGVzY3JpcHRpb246ICdCb2x0em1hbm4gY29uc3RhbnQnLCBleGFtcGxlczogWydib2x0em1hbm4nXX07XG4gIGRvY3MuZmFyYWRheSA9IHtkZXNjcmlwdGlvbjogJ0ZhcmFkYXkgY29uc3RhbnQnLCBleGFtcGxlczogWydmYXJhZGF5J119O1xuICBkb2NzLmZpcnN0UmFkaWF0aW9uID0ge2Rlc2NyaXB0aW9uOiAnRmlyc3QgcmFkaWF0aW9uIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnZmlyc3RSYWRpYXRpb24nXX07XG4gIGRvY3MubG9zY2htaWR0ID0ge2Rlc2NyaXB0aW9uOiAnTG9zY2htaWR0IGNvbnN0YW50IGF0IFQ9MjczLjE1IEsgYW5kIHA9MTAxLjMyNSBrUGEnLCBleGFtcGxlczogWydsb3NjaG1pZHQnXX07XG4gIGRvY3MuZ2FzQ29uc3RhbnQgPSB7ZGVzY3JpcHRpb246ICdHYXMgY29uc3RhbnQnLCBleGFtcGxlczogWydnYXNDb25zdGFudCddfTtcbiAgZG9jcy5tb2xhclBsYW5ja0NvbnN0YW50ID0ge2Rlc2NyaXB0aW9uOiAnTW9sYXIgUGxhbmNrIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnbW9sYXJQbGFuY2tDb25zdGFudCddfTtcbiAgZG9jcy5tb2xhclZvbHVtZSA9IHtkZXNjcmlwdGlvbjogJ01vbGFyIHZvbHVtZSBvZiBhbiBpZGVhbCBnYXMgYXQgVD0yNzMuMTUgSyBhbmQgcD0xMDEuMzI1IGtQYScsIGV4YW1wbGVzOiBbJ21vbGFyVm9sdW1lJ119O1xuICBkb2NzLnNhY2t1clRldHJvZGUgPSB7ZGVzY3JpcHRpb246ICdTYWNrdXItVGV0cm9kZSBjb25zdGFudCBhdCBUPTEgSyBhbmQgcD0xMDEuMzI1IGtQYScsIGV4YW1wbGVzOiBbJ3NhY2t1clRldHJvZGUnXX07XG4gIGRvY3Muc2Vjb25kUmFkaWF0aW9uID0ge2Rlc2NyaXB0aW9uOiAnU2Vjb25kIHJhZGlhdGlvbiBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ3NlY29uZFJhZGlhdGlvbiddfTtcbiAgZG9jcy5zdGVmYW5Cb2x0em1hbm4gPSB7ZGVzY3JpcHRpb246ICdTdGVmYW4tQm9sdHptYW5uIGNvbnN0YW50JywgZXhhbXBsZXM6IFsnc3RlZmFuQm9sdHptYW5uJ119O1xuICBkb2NzLndpZW5EaXNwbGFjZW1lbnQgPSB7ZGVzY3JpcHRpb246ICdXaWVuIGRpc3BsYWNlbWVudCBsYXcgY29uc3RhbnQnLCBleGFtcGxlczogWyd3aWVuRGlzcGxhY2VtZW50J119O1xuICAvL2RvY3Muc3BlY3RyYWxSYWRpYW5jZSA9IHtkZXNjcmlwdGlvbjogJ0ZpcnN0IHJhZGlhdGlvbiBjb25zdGFudCBmb3Igc3BlY3RyYWwgcmFkaWFuY2UnLCBleGFtcGxlczogWydzcGVjdHJhbFJhZGlhbmNlJ119O1xuXG4gIGRvY3MubW9sYXJNYXNzID0ge2Rlc2NyaXB0aW9uOiAnTW9sYXIgbWFzcyBjb25zdGFudCcsIGV4YW1wbGVzOiBbJ21vbGFyTWFzcyddfTtcbiAgZG9jcy5tb2xhck1hc3NDMTIgPSB7ZGVzY3JpcHRpb246ICdNb2xhciBtYXNzIGNvbnN0YW50IG9mIGNhcmJvbi0xMicsIGV4YW1wbGVzOiBbJ21vbGFyTWFzc0MxMiddfTtcbiAgZG9jcy5ncmF2aXR5ID0ge2Rlc2NyaXB0aW9uOiAnU3RhbmRhcmQgYWNjZWxlcmF0aW9uIG9mIGdyYXZpdHkgKHN0YW5kYXJkIGFjY2VsZXJhdGlvbiBvZiBmcmVlLWZhbGwgb24gRWFydGgpJywgZXhhbXBsZXM6IFsnZ3Jhdml0eSddfTtcblxuICBkb2NzLnBsYW5ja0xlbmd0aCA9IHtkZXNjcmlwdGlvbjogJ1BsYW5jayBsZW5ndGgnLCBleGFtcGxlczogWydwbGFuY2tMZW5ndGgnXX07XG4gIGRvY3MucGxhbmNrTWFzcyA9IHtkZXNjcmlwdGlvbjogJ1BsYW5jayBtYXNzJywgZXhhbXBsZXM6IFsncGxhbmNrTWFzcyddfTtcbiAgZG9jcy5wbGFuY2tUaW1lID0ge2Rlc2NyaXB0aW9uOiAnUGxhbmNrIHRpbWUnLCBleGFtcGxlczogWydwbGFuY2tUaW1lJ119O1xuICBkb2NzLnBsYW5ja0NoYXJnZSA9IHtkZXNjcmlwdGlvbjogJ1BsYW5jayBjaGFyZ2UnLCBleGFtcGxlczogWydwbGFuY2tDaGFyZ2UnXX07XG4gIGRvY3MucGxhbmNrVGVtcGVyYXR1cmUgPSB7ZGVzY3JpcHRpb246ICdQbGFuY2sgdGVtcGVyYXR1cmUnLCBleGFtcGxlczogWydwbGFuY2tUZW1wZXJhdHVyZSddfTtcblxuICAvLyBmdW5jdGlvbnMgLSBhbGdlYnJhXG4gIGRvY3MuZGVyaXZhdGl2ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYWxnZWJyYS9kZXJpdmF0aXZlJyk7XG4gIGRvY3MubHNvbHZlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hbGdlYnJhL2xzb2x2ZScpO1xuICBkb2NzLmx1cCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYWxnZWJyYS9sdXAnKTtcbiAgZG9jcy5sdXNvbHZlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hbGdlYnJhL2x1c29sdmUnKTtcbiAgZG9jcy5zaW1wbGlmeSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYWxnZWJyYS9zaW1wbGlmeScpO1xuICBkb2NzLnNsdSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYWxnZWJyYS9zbHUnKTtcbiAgZG9jcy51c29sdmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FsZ2VicmEvdXNvbHZlJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gYXJpdGhtZXRpY1xuICBkb2NzLmFicyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9hYnMnKTtcbiAgZG9jcy5hZGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWRkJyk7XG4gIGRvY3MuY2JydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jYnJ0Jyk7XG4gIGRvY3MuY2VpbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jZWlsJyk7XG4gIGRvY3MuY3ViZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9jdWJlJyk7XG4gIGRvY3MuZGl2aWRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2RpdmlkZScpO1xuICBkb2NzLmRvdERpdmlkZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3REaXZpZGUnKTtcbiAgZG9jcy5kb3RNdWx0aXBseSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RNdWx0aXBseScpO1xuICBkb2NzLmRvdFBvdyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9kb3RQb3cnKTtcbiAgZG9jcy5leHAgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvZXhwJyk7XG4gIGRvY3MuZml4ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2ZpeCcpO1xuICBkb2NzLmZsb29yID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2Zsb29yJyk7XG4gIGRvY3MuZ2NkID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2djZCcpO1xuICBkb2NzLmh5cG90ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2h5cG90Jyk7XG4gIGRvY3MubGNtID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL2xjbScpO1xuICBkb2NzLmxvZyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cnKTtcbiAgZG9jcy5sb2cxMCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9sb2cxMCcpO1xuICBkb2NzLm1vZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9tb2QnKTtcbiAgZG9jcy5tdWx0aXBseSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9tdWx0aXBseScpO1xuICBkb2NzLm5vcm0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbm9ybScpO1xuICBkb2NzLm50aFJvb3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvbnRoUm9vdCcpO1xuICBkb2NzLnBvdyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9wb3cnKTtcbiAgZG9jcy5yb3VuZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9yb3VuZCcpO1xuICBkb2NzLnNpZ24gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvc2lnbicpO1xuICBkb2NzLnNxcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvc3FydCcpO1xuICBkb2NzLnNxdWFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zcXVhcmUnKTtcbiAgZG9jcy5zdWJ0cmFjdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy9zdWJ0cmFjdCcpO1xuICBkb2NzLnVuYXJ5TWludXMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2FyaXRobWV0aWMvdW5hcnlNaW51cycpO1xuICBkb2NzLnVuYXJ5UGx1cyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYXJpdGhtZXRpYy91bmFyeVBsdXMnKTtcbiAgZG9jcy54Z2NkID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9hcml0aG1ldGljL3hnY2QnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBiaXR3aXNlXG4gIGRvY3MuYml0QW5kID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9iaXR3aXNlL2JpdEFuZCcpO1xuICBkb2NzLmJpdE5vdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYml0d2lzZS9iaXROb3QnKTtcbiAgZG9jcy5iaXRPciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYml0d2lzZS9iaXRPcicpO1xuICBkb2NzLmJpdFhvciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vYml0d2lzZS9iaXRYb3InKTtcbiAgZG9jcy5sZWZ0U2hpZnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2JpdHdpc2UvbGVmdFNoaWZ0Jyk7XG4gIGRvY3MucmlnaHRBcml0aFNoaWZ0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9iaXR3aXNlL3JpZ2h0QXJpdGhTaGlmdCcpO1xuICBkb2NzLnJpZ2h0TG9nU2hpZnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2JpdHdpc2UvcmlnaHRMb2dTaGlmdCcpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIGNvbWJpbmF0b3JpY3NcbiAgZG9jcy5iZWxsTnVtYmVycyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tYmluYXRvcmljcy9iZWxsTnVtYmVycycpO1xuICBkb2NzLmNhdGFsYW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbWJpbmF0b3JpY3MvY2F0YWxhbicpO1xuICBkb2NzLmNvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21iaW5hdG9yaWNzL2NvbXBvc2l0aW9uJyk7XG4gIGRvY3Muc3RpcmxpbmdTMiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vY29tYmluYXRvcmljcy9zdGlybGluZ1MyJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gY29yZVxuICBkb2NzWydjb25maWcnXSA9ICByZXF1aXJlKCcuL2NvcmUvY29uZmlnJyk7XG4gIGRvY3NbJ2ltcG9ydCddID0gIHJlcXVpcmUoJy4vY29yZS9pbXBvcnQnKTtcbiAgZG9jc1sndHlwZWQnXSA9ICByZXF1aXJlKCcuL2NvcmUvdHlwZWQnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBjb21wbGV4XG4gIGRvY3MuYXJnID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L2FyZycpO1xuICBkb2NzLmNvbmogPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbXBsZXgvY29uaicpO1xuICBkb2NzLnJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9jb21wbGV4L3JlJyk7XG4gIGRvY3MuaW0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2NvbXBsZXgvaW0nKTtcblxuICAvLyBmdW5jdGlvbnMgLSBleHByZXNzaW9uXG4gIGRvY3NbJ2V2YWwnXSA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL2V4cHJlc3Npb24vZXZhbCcpO1xuICBkb2NzLmhlbHAgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi9leHByZXNzaW9uL2hlbHAnKTtcblxuICAvLyBmdW5jdGlvbnMgLSBnZW9tZXRyeVxuICBkb2NzLmRpc3RhbmNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9nZW9tZXRyeS9kaXN0YW5jZScpO1xuICBkb2NzLmludGVyc2VjdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vZ2VvbWV0cnkvaW50ZXJzZWN0Jyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gbG9naWNhbFxuICBkb2NzWydhbmQnXSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbG9naWNhbC9hbmQnKTtcbiAgZG9jc1snbm90J10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2xvZ2ljYWwvbm90Jyk7XG4gIGRvY3NbJ29yJ10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2xvZ2ljYWwvb3InKTtcbiAgZG9jc1sneG9yJ10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL2xvZ2ljYWwveG9yJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gbWF0cml4XG4gIGRvY3NbJ2NvbmNhdCddID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvY29uY2F0Jyk7XG4gIGRvY3MuY3Jvc3MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9jcm9zcycpO1xuICBkb2NzLmRldCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2RldCcpO1xuICBkb2NzLmRpYWcgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9kaWFnJyk7XG4gIGRvY3MuZG90ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZG90Jyk7XG4gIGRvY3MuZXllID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvZXllJyk7XG4gIGRvY3MuZmlsdGVyID0gIHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2ZpbHRlcicpO1xuICBkb2NzLmZsYXR0ZW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9mbGF0dGVuJyk7XG4gIGRvY3MuZm9yRWFjaCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9mb3JFYWNoJyk7XG4gIGRvY3MuaW52ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvaW52Jyk7XG4gIGRvY3Mua3JvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L2tyb24nKTtcbiAgZG9jcy5tYXAgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvbWFwJyk7XG4gIGRvY3Mub25lcyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L29uZXMnKTtcbiAgZG9jcy5wYXJ0aXRpb25TZWxlY3QgPSAgcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvcGFydGl0aW9uU2VsZWN0Jyk7XG4gIGRvY3MucmFuZ2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9yYW5nZScpO1xuICBkb2NzLnJlc2l6ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3Jlc2l6ZScpO1xuICBkb2NzLnNpemUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zaXplJyk7XG4gIGRvY3Muc29ydCA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zb3J0Jyk7XG4gIGRvY3Muc3F1ZWV6ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3NxdWVlemUnKTtcbiAgZG9jcy5zdWJzZXQgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC9zdWJzZXQnKTtcbiAgZG9jcy50cmFjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vbWF0cml4L3RyYWNlJyk7XG4gIGRvY3MudHJhbnNwb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9tYXRyaXgvdHJhbnNwb3NlJyk7XG4gIGRvY3MuemVyb3MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL21hdHJpeC96ZXJvcycpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIHByb2JhYmlsaXR5XG4gIGRvY3MuY29tYmluYXRpb25zID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9jb21iaW5hdGlvbnMnKTtcbiAgLy9kb2NzLmRpc3RyaWJ1dGlvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvZGlzdHJpYnV0aW9uJyk7XG4gIGRvY3MuZmFjdG9yaWFsID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9mYWN0b3JpYWwnKTtcbiAgZG9jcy5nYW1tYSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvZ2FtbWEnKTtcbiAgZG9jcy5rbGRpdmVyZ2VuY2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3Byb2JhYmlsaXR5L2tsZGl2ZXJnZW5jZScpO1xuICBkb2NzLm11bHRpbm9taWFsID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9tdWx0aW5vbWlhbCcpO1xuICBkb2NzLnBlcm11dGF0aW9ucyA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcGVybXV0YXRpb25zJyk7XG4gIGRvY3MucGlja1JhbmRvbSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcGlja1JhbmRvbScpO1xuICBkb2NzLnJhbmRvbSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcHJvYmFiaWxpdHkvcmFuZG9tJyk7XG4gIGRvY3MucmFuZG9tSW50ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9wcm9iYWJpbGl0eS9yYW5kb21JbnQnKTtcblxuICAvLyBmdW5jdGlvbnMgLSByZWxhdGlvbmFsXG4gIGRvY3MuY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9jb21wYXJlJyk7XG4gIGRvY3MuZGVlcEVxdWFsID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2RlZXBFcXVhbCcpO1xuICBkb2NzWydlcXVhbCddID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsJyk7XG4gIGRvY3MubGFyZ2VyID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2xhcmdlcicpO1xuICBkb2NzLmxhcmdlckVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2xhcmdlckVxJyk7XG4gIGRvY3Muc21hbGxlciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vcmVsYXRpb25hbC9zbWFsbGVyJyk7XG4gIGRvY3Muc21hbGxlckVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9yZWxhdGlvbmFsL3NtYWxsZXJFcScpO1xuICBkb2NzLnVuZXF1YWwgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3JlbGF0aW9uYWwvdW5lcXVhbCcpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIHNwZWNpYWxcbiAgZG9jcy5lcmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3NwZWNpYWwvZXJmJyk7XG5cbiAgLy8gZnVuY3Rpb25zIC0gc3RhdGlzdGljc1xuICBkb2NzLm1hZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9tYWQnKTtcbiAgZG9jcy5tYXggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWF4Jyk7XG4gIGRvY3MubWVhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9tZWFuJyk7XG4gIGRvY3MubWVkaWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21lZGlhbicpO1xuICBkb2NzLm1pbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9taW4nKTtcbiAgZG9jcy5tb2RlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21vZGUnKTtcbiAgZG9jcy5wcm9kID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL3Byb2QnKTtcbiAgZG9jcy5xdWFudGlsZVNlcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9xdWFudGlsZVNlcScpO1xuICBkb2NzLnN0ZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vc3RhdGlzdGljcy9zdGQnKTtcbiAgZG9jcy5zdW0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3N0YXRpc3RpY3Mvc3VtJyk7XG4gIGRvY3NbJ3ZhciddID0gcmVxdWlyZSgnLi9mdW5jdGlvbi9zdGF0aXN0aWNzL3ZhcicpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIHRyaWdvbm9tZXRyeVxuICBkb2NzLmFjb3MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY29zJyk7XG4gIGRvY3MuYWNvc2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY29zaCcpO1xuICBkb2NzLmFjb3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY290Jyk7XG4gIGRvY3MuYWNvdGggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY290aCcpO1xuICBkb2NzLmFjc2MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY3NjJyk7XG4gIGRvY3MuYWNzY2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hY3NjaCcpO1xuICBkb2NzLmFzZWMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2VjJyk7XG4gIGRvY3MuYXNlY2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2VjaCcpO1xuICBkb2NzLmFzaW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2luJyk7XG4gIGRvY3MuYXNpbmggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hc2luaCcpO1xuICBkb2NzLmF0YW4gPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuJyk7XG4gIGRvY3MuYXRhbmggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9hdGFuaCcpO1xuICBkb2NzLmF0YW4yID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvYXRhbjInKTtcbiAgZG9jcy5jb3MgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3MnKTtcbiAgZG9jcy5jb3NoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY29zaCcpO1xuICBkb2NzLmNvdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NvdCcpO1xuICBkb2NzLmNvdGggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9jb3RoJyk7XG4gIGRvY3MuY3NjID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvY3NjJyk7XG4gIGRvY3MuY3NjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L2NzY2gnKTtcbiAgZG9jcy5zZWMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zZWMnKTtcbiAgZG9jcy5zZWNoID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvc2VjaCcpO1xuICBkb2NzLnNpbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3NpbicpO1xuICBkb2NzLnNpbmggPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3RyaWdvbm9tZXRyeS9zaW5oJyk7XG4gIGRvY3MudGFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbi90cmlnb25vbWV0cnkvdGFuJyk7XG4gIGRvY3MudGFuaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdHJpZ29ub21ldHJ5L3RhbmgnKTtcblxuICAvLyBmdW5jdGlvbnMgLSB1bml0c1xuICBkb2NzLnRvID0gcmVxdWlyZSgnLi9mdW5jdGlvbi91bml0cy90bycpO1xuXG4gIC8vIGZ1bmN0aW9ucyAtIHV0aWxzXG4gIGRvY3MuY2xvbmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2Nsb25lJyk7XG4gIGRvY3MuZm9ybWF0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9mb3JtYXQnKTtcbiAgZG9jcy5pc05hTiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvaXNOYU4nKTtcbiAgZG9jcy5pc0ludGVnZXIgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2lzSW50ZWdlcicpO1xuICBkb2NzLmlzTmVnYXRpdmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2lzTmVnYXRpdmUnKTtcbiAgZG9jcy5pc051bWVyaWMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2lzTnVtZXJpYycpO1xuICBkb2NzLmlzUG9zaXRpdmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL2lzUG9zaXRpdmUnKTtcbiAgZG9jcy5pc1ByaW1lID0gcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9pc1ByaW1lJyk7XG4gIGRvY3MuaXNaZXJvID0gcmVxdWlyZSgnLi9mdW5jdGlvbi91dGlscy9pc1plcm8nKTtcbiAgLy8gZG9jcy5wcmludCA9IHJlcXVpcmUoJy4vZnVuY3Rpb24vdXRpbHMvcHJpbnQnKTsgLy8gVE9ETzogYWRkIGRvY3VtZW50YXRpb24gZm9yIHByaW50IGFzIHNvb24gYXMgdGhlIHBhcnNlciBzdXBwb3J0cyBvYmplY3RzLlxuICBkb2NzWyd0eXBlb2YnXSA9ICByZXF1aXJlKCcuL2Z1bmN0aW9uL3V0aWxzL3R5cGVvZicpO1xuXG4gIHJldHVybiBkb2NzO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZG9jcyc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBwYXJzZSA9IGxvYWQocmVxdWlyZSgnLi4vcGFyc2UnKSk7XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuZCBjb21waWxlIGFuIGV4cHJlc3Npb24uXG4gICAqIFJldHVybnMgYSBhbiBvYmplY3Qgd2l0aCBhIGZ1bmN0aW9uIGBldmFsKFtzY29wZV0pYCB0byBldmFsdWF0ZSB0aGVcbiAgICogY29tcGlsZWQgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5jb21waWxlKGV4cHIpICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG9uZSBub2RlXG4gICAqICAgICBtYXRoLmNvbXBpbGUoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0pIC8vIHJldHVybnMgYW4gYXJyYXkgd2l0aCBub2Rlc1xuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIHZhciBjb2RlID0gbWF0aC5jb21waWxlKCdzcXJ0KDNeMiArIDReMiknKTtcbiAgICogICAgIGNvZGUuZXZhbCgpOyAvLyA1XG4gICAqXG4gICAqICAgICB2YXIgc2NvcGUgPSB7YTogMywgYjogNH1cbiAgICogICAgIHZhciBjb2RlID0gbWF0aC5jb21waWxlKCdhICogYicpOyAvLyAxMlxuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMTJcbiAgICogICAgIHNjb3BlLmEgPSA1O1xuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMjBcbiAgICpcbiAgICogICAgIHZhciBub2RlcyA9IG1hdGguY29tcGlsZShbJ2EgPSAzJywgJ2IgPSA0JywgJ2EgKiBiJ10pO1xuICAgKiAgICAgbm9kZXNbMl0uZXZhbCgpOyAvLyAxMlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgcGFyc2UsIGV2YWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IEFycmF5IHwgTWF0cml4fSBleHByXG4gICAqICAgICAgICAgICAgVGhlIGV4cHJlc3Npb24gdG8gYmUgY29tcGlsZWRcbiAgICogQHJldHVybiB7e2V2YWw6IEZ1bmN0aW9ufSB8IEFycmF5Ljx7ZXZhbDogRnVuY3Rpb259Pn0gY29kZVxuICAgKiAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgcmV0dXJuIHR5cGVkKCdjb21waWxlJywge1xuICAgICdzdHJpbmcnOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgcmV0dXJuIHBhcnNlKGV4cHIpLmNvbXBpbGUoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKGV4cHIsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gcGFyc2UoZW50cnkpLmNvbXBpbGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjb21waWxlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHBhcnNlID0gbG9hZChyZXF1aXJlKCcuLi9wYXJzZScpKTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5ldmFsKGV4cHIpXG4gICAqICAgICBtYXRoLmV2YWwoZXhwciwgc2NvcGUpXG4gICAqICAgICBtYXRoLmV2YWwoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0pXG4gICAqICAgICBtYXRoLmV2YWwoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0sIHNjb3BlKVxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgbWF0aC5ldmFsKCcoMiszKS80Jyk7ICAgICAgICAgICAgICAgIC8vIDEuMjVcbiAgICogICAgIG1hdGguZXZhbCgnc3FydCgzXjIgKyA0XjIpJyk7ICAgICAgICAvLyA1XG4gICAqICAgICBtYXRoLmV2YWwoJ3NxcnQoLTQpJyk7ICAgICAgICAgICAgICAgLy8gMmlcbiAgICogICAgIG1hdGguZXZhbChbJ2E9MycsICdiPTQnLCAnYSpiJ10pOywgICAvLyBbMywgNCwgMTJdXG4gICAqXG4gICAqICAgICB2YXIgc2NvcGUgPSB7YTozLCBiOjR9O1xuICAgKiAgICAgbWF0aC5ldmFsKCdhICogYicsIHNjb3BlKTsgICAgICAgICAgIC8vIDEyXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBwYXJzZSwgY29tcGlsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgTWF0cml4fSBleHByICAgVGhlIGV4cHJlc3Npb24gdG8gYmUgZXZhbHVhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdICAgICAgICAgICAgICAgICAgICBTY29wZSB0byByZWFkL3dyaXRlIHZhcmlhYmxlc1xuICAgKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0IG9mIHRoZSBleHByZXNzaW9uXG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgcmV0dXJuIHR5cGVkKCdjb21waWxlJywge1xuICAgICdzdHJpbmcnOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICByZXR1cm4gcGFyc2UoZXhwcikuY29tcGlsZSgpLmV2YWwoc2NvcGUpO1xuICAgIH0sXG5cbiAgICAnc3RyaW5nLCBPYmplY3QnOiBmdW5jdGlvbiAoZXhwciwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBwYXJzZShleHByKS5jb21waWxlKCkuZXZhbChzY29wZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgIHJldHVybiBkZWVwTWFwKGV4cHIsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gcGFyc2UoZW50cnkpLmNvbXBpbGUoKS5ldmFsKHNjb3BlKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgsIE9iamVjdCc6IGZ1bmN0aW9uIChleHByLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoZXhwciwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBwYXJzZShlbnRyeSkuY29tcGlsZSgpLmV2YWwoc2NvcGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2V2YWwnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgdmFyIGRvY3MgPSBsb2FkKHJlcXVpcmUoJy4uL2RvY3MnKSk7XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGhlbHAgb24gYSBmdW5jdGlvbiBvciBkYXRhIHR5cGUuXG4gICAqIEhlbHAgZmlsZXMgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBkb2N1bWVudGF0aW9uIGluIG1hdGguZXhwcmVzc2lvbi5kb2NzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguaGVscChzZWFyY2gpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBjb25zb2xlLmxvZyhtYXRoLmhlbHAoJ3NpbicpLnRvU3RyaW5nKCkpO1xuICAgKiAgICBjb25zb2xlLmxvZyhtYXRoLmhlbHAobWF0aC5hZGQpLnRvU3RyaW5nKCkpO1xuICAgKiAgICBjb25zb2xlLmxvZyhtYXRoLmhlbHAobWF0aC5hZGQpLnRvSlNPTigpKTtcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbiB8IHN0cmluZyB8IE9iamVjdH0gc2VhcmNoICAgQSBmdW5jdGlvbiBvciBmdW5jdGlvbiBuYW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB3aGljaCB0byBnZXQgaGVscFxuICAgKiBAcmV0dXJuIHtIZWxwfSBBIGhlbHAgb2JqZWN0XG4gICAqL1xuICByZXR1cm4gdHlwZWQoJ2hlbHAnLCB7XG4gICAgJ2FueSc6IGZ1bmN0aW9uIChzZWFyY2gpIHtcbiAgICAgIHZhciBwcm9wO1xuICAgICAgdmFyIG5hbWUgPSBzZWFyY2g7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKHByb3AgaW4gbWF0aCkge1xuICAgICAgICAgIC8vIHNlYXJjaCBpbiBmdW5jdGlvbnMgYW5kIGNvbnN0YW50c1xuICAgICAgICAgIGlmIChtYXRoLmhhc093blByb3BlcnR5KHByb3ApICYmIChzZWFyY2ggPT09IG1hdGhbcHJvcF0pKSB7XG4gICAgICAgICAgICBuYW1lID0gcHJvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFRPRE86IGltcGxlbWVudCBoZWxwIGZvciBkYXRhIHR5cGVzXG4gICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgIC8vIHNlYXJjaCBkYXRhIHR5cGVcbiAgICAgICAgIGZvciAocHJvcCBpbiBtYXRoLnR5cGUpIHtcbiAgICAgICAgIGlmIChtYXRoLnR5cGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgIGlmIChzZWFyY2ggPT09IG1hdGgudHlwZVtwcm9wXSkge1xuICAgICAgICAgdGV4dCA9IHByb3A7XG4gICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICB9XG5cbiAgICAgIHZhciBkb2MgPSBkb2NzW25hbWVdO1xuICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkb2N1bWVudGF0aW9uIGZvdW5kIG9uIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgdHlwZS5IZWxwKGRvYyk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgLy8gcmVxdWVzdCBhY2Nlc3MgdG8gdGhlIG1hdGggbmFtZXNwYWNlIGFzIDV0aCBhcmd1bWVudCBvZiB0aGUgZmFjdG9yeSBmdW5jdGlvblxuZXhwb3J0cy5uYW1lID0gJ2hlbHAnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICByZXF1aXJlKCcuL2NvbXBpbGUnKSxcbiAgcmVxdWlyZSgnLi9ldmFsJyksXG4gIHJlcXVpcmUoJy4vaGVscCcpLFxuICByZXF1aXJlKCcuL3BhcnNlJyksXG4gIHJlcXVpcmUoJy4vcGFyc2VyJylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHBhcnNlID0gbG9hZChyZXF1aXJlKCcuLi9wYXJzZScpKTtcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbi4gUmV0dXJucyBhIG5vZGUgdHJlZSwgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCBieVxuICAgKiBpbnZva2luZyBub2RlLmV2YWwoKTtcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5wYXJzZShleHByKVxuICAgKiAgICAgbWF0aC5wYXJzZShleHByLCBvcHRpb25zKVxuICAgKiAgICAgbWF0aC5wYXJzZShbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSlcbiAgICogICAgIG1hdGgucGFyc2UoW2V4cHIxLCBleHByMiwgZXhwcjMsIC4uLl0sIG9wdGlvbnMpXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICB2YXIgbm9kZSA9IG1hdGgucGFyc2UoJ3NxcnQoM14yICsgNF4yKScpO1xuICAgKiAgICAgbm9kZS5jb21waWxlKCkuZXZhbCgpOyAvLyA1XG4gICAqXG4gICAqICAgICB2YXIgc2NvcGUgPSB7YTozLCBiOjR9XG4gICAqICAgICB2YXIgbm9kZSA9IG1hdGgucGFyc2UoJ2EgKiBiJyk7IC8vIDEyXG4gICAqICAgICB2YXIgY29kZSA9IG5vZGUuY29tcGlsZSgpO1xuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMTJcbiAgICogICAgIHNjb3BlLmEgPSA1O1xuICAgKiAgICAgY29kZS5ldmFsKHNjb3BlKTsgLy8gMjBcbiAgICpcbiAgICogICAgIHZhciBub2RlcyA9IG1hdGgucGFyc2UoWydhID0gMycsICdiID0gNCcsICdhICogYiddKTtcbiAgICogICAgIG5vZGVzWzJdLmNvbXBpbGUoKS5ldmFsKCk7IC8vIDEyXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgZXZhbCwgY29tcGlsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgTWF0cml4fSBleHByICAgICAgICAgIEV4cHJlc3Npb24gdG8gYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7e25vZGVzOiBPYmplY3Q8c3RyaW5nLCBOb2RlPn19IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgbm9kZXNgIGEgc2V0IG9mIGN1c3RvbSBub2Rlc1xuICAgKiBAcmV0dXJuIHtOb2RlIHwgTm9kZVtdfSBub2RlXG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgcmV0dXJuIHR5cGVkKCdwYXJzZScsIHtcbiAgICAnc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXgnOiBwYXJzZSxcbiAgICAnc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXgsIE9iamVjdCc6IHBhcnNlXG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncGFyc2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICB2YXIgUGFyc2VyID0gbG9hZChyZXF1aXJlKCcuLi9QYXJzZXInKSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBhcnNlci4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgYG1hdGguZXhwcmVzc2lvbi5QYXJzZXJgIG9iamVjdC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnBhcnNlcigpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgdmFyIHBhcnNlciA9IG5ldyBtYXRoLnBhcnNlcigpO1xuICAgKlxuICAgKiAgICAgLy8gZXZhbHVhdGUgZXhwcmVzc2lvbnNcbiAgICogICAgIHZhciBhID0gcGFyc2VyLmV2YWwoJ3NxcnQoM14yICsgNF4yKScpOyAvLyA1XG4gICAqICAgICB2YXIgYiA9IHBhcnNlci5ldmFsKCdzcXJ0KC00KScpOyAgICAgICAgLy8gMmlcbiAgICogICAgIHZhciBjID0gcGFyc2VyLmV2YWwoJzIgaW5jaCBpbiBjbScpOyAgICAvLyA1LjA4IGNtXG4gICAqICAgICB2YXIgZCA9IHBhcnNlci5ldmFsKCdjb3MoNDUgZGVnKScpOyAgICAgLy8gMC43MDcxMDY3ODExODY1NDc2XG4gICAqXG4gICAqICAgICAvLyBkZWZpbmUgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICogICAgIHBhcnNlci5ldmFsKCd4ID0gNyAvIDInKTsgICAgICAgICAgICAgICAvLyAzLjVcbiAgICogICAgIHBhcnNlci5ldmFsKCd4ICsgMycpOyAgICAgICAgICAgICAgICAgICAvLyA2LjVcbiAgICogICAgIHBhcnNlci5ldmFsKCdmdW5jdGlvbiBmKHgsIHkpID0geF55Jyk7ICAvLyBmKHgsIHkpXG4gICAqICAgICBwYXJzZXIuZXZhbCgnZigyLCAzKScpOyAgICAgICAgICAgICAgICAgLy8gOFxuICAgKlxuICAgKiAgICAgLy8gZ2V0IGFuZCBzZXQgdmFyaWFibGVzIGFuZCBmdW5jdGlvbnNcbiAgICogICAgIHZhciB4ID0gcGFyc2VyLmdldCgneCcpOyAgICAgICAgICAgICAgICAvLyA3XG4gICAqICAgICB2YXIgZiA9IHBhcnNlci5nZXQoJ2YnKTsgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25cbiAgICogICAgIHZhciBnID0gZigzLCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyA5XG4gICAqICAgICBwYXJzZXIuc2V0KCdoJywgNTAwKTtcbiAgICogICAgIHZhciBpID0gcGFyc2VyLmV2YWwoJ2ggLyAyJyk7ICAgICAgICAgICAvLyAyNTBcbiAgICogICAgIHBhcnNlci5zZXQoJ2hlbGxvJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICogICAgICAgcmV0dXJuICdoZWxsbywgJyArIG5hbWUgKyAnISc7XG4gICAqICAgICB9KTtcbiAgICogICAgIHBhcnNlci5ldmFsKCdoZWxsbyhcInVzZXJcIiknKTsgICAgICAgICAgIC8vIFwiaGVsbG8sIHVzZXIhXCJcbiAgICpcbiAgICogICAgIC8vIGNsZWFyIGRlZmluZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcbiAgICogICAgIHBhcnNlci5jbGVhcigpO1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXZhbCwgY29tcGlsZSwgcGFyc2VcbiAgICpcbiAgICogQHJldHVybiB7UGFyc2VyfSBQYXJzZXJcbiAgICovXG4gIHJldHVybiB0eXBlZCgncGFyc2VyJywge1xuICAgICcnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBhcnNlcihtYXRoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncGFyc2VyJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLm1hdGggPSB0cnVlOyAvLyByZXF1aXJlcyB0aGUgbWF0aCBuYW1lc3BhY2UgYXMgNXRoIGFyZ3VtZW50XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9kb2NzJyksXG4gIHJlcXVpcmUoJy4vZnVuY3Rpb24nKSxcbiAgcmVxdWlyZSgnLi9ub2RlJyksXG4gIHJlcXVpcmUoJy4vdHJhbnNmb3JtJyksXG5cbiAgcmVxdWlyZSgnLi9IZWxwJyksXG4gIHJlcXVpcmUoJy4vcGFyc2UnKSxcbiAgcmVxdWlyZSgnLi9QYXJzZXInKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gUmVzZXJ2ZWQga2V5d29yZHMgbm90IGFsbG93ZWQgdG8gdXNlIGluIHRoZSBwYXJzZXJcbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmQ6IHRydWVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcbiAgdmFyIGFjY2VzcyA9IGxvYWQocmVxdWlyZSgnLi91dGlscy9hY2Nlc3MnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBBY2Nlc3Nvck5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEFjY2VzcyBhbiBvYmplY3QgcHJvcGVydHkgb3IgZ2V0IGEgbWF0cml4IHN1YnNldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG9iamVjdCAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHByb3BlcnR5IG9yIHN1YnNldC5cbiAgICogQHBhcmFtIHtJbmRleE5vZGV9IGluZGV4ICAgICAgICAgICAgIEluZGV4Tm9kZSBjb250YWluaW5nIHJhbmdlc1xuICAgKi9cbiAgZnVuY3Rpb24gQWNjZXNzb3JOb2RlKG9iamVjdCwgaW5kZXgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWNjZXNzb3JOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICBpZiAoIShvYmplY3QgJiYgb2JqZWN0LmlzTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcIm9iamVjdFwiJyk7XG4gICAgfVxuICAgIGlmICghKGluZGV4ICYmIGluZGV4LmlzSW5kZXhOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXhOb2RlIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJpbmRleFwiJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3QgfHwgbnVsbDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAvLyByZWFkb25seSBwcm9wZXJ0eSBuYW1lXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSlcbiAgICAgICAgICAgICAgPyB0aGlzLmluZGV4LmdldE9iamVjdFByb3BlcnR5KClcbiAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QubmFtZSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFzc2lnbiBhIG5ldyBuYW1lLCBuYW1lIGlzIHJlYWQtb25seScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS50eXBlID0gJ0FjY2Vzc29yTm9kZSc7XG5cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5pc0FjY2Vzc29yTm9kZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30ganNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEFjY2Vzc29yTm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIGRlZnMuYWNjZXNzID0gYWNjZXNzO1xuXG4gICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0Ll9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXguX2NvbXBpbGUoZGVmcywgYXJncyk7XG5cbiAgICBpZiAodGhpcy5pbmRleC5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgKyAnW1wiJyArIHRoaXMuaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKSArICdcIl0nO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmluZGV4Lm5lZWRzU2l6ZSgpKSB7XG4gICAgICAvLyBpZiBzb21lIHBhcmFtZXRlcnMgdXNlIHRoZSAnZW5kJyBwYXJhbWV0ZXIsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBzaXplXG4gICAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7JyArXG4gICAgICAgICAgJyAgdmFyIG9iamVjdCA9ICcgKyBvYmplY3QgKyAnOycgK1xuICAgICAgICAgICcgIHZhciBzaXplID0gbWF0aC5zaXplKG9iamVjdCkudmFsdWVPZigpOycgK1xuICAgICAgICAgICcgIHJldHVybiBhY2Nlc3Mob2JqZWN0LCAnICsgaW5kZXggKyAnKTsnICtcbiAgICAgICAgICAnfSkoKSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICdhY2Nlc3MoJyArIG9iamVjdCArICcsICcgKyBpbmRleCArICcpJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIEFjY2Vzc29yTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRoaXMub2JqZWN0LCAnb2JqZWN0JywgdGhpcyk7XG4gICAgY2FsbGJhY2sodGhpcy5pbmRleCwgJ2luZGV4JywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBY2Nlc3Nvck5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0FjY2Vzc29yTm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIEFjY2Vzc29yTm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBBY2Nlc3Nvck5vZGUoXG4gICAgICAgIHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLm9iamVjdCwgJ29iamVjdCcsIHRoaXMpKSxcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuaW5kZXgsICdpbmRleCcsIHRoaXMpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7QWNjZXNzb3JOb2RlfVxuICAgKi9cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEFjY2Vzc29yTm9kZSh0aGlzLm9iamVjdCwgdGhpcy5pbmRleCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdC50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAobmVlZFBhcmVudGhlc2lzKHRoaXMub2JqZWN0KSkge1xuICAgICAgb2JqZWN0ID0gJygnICsgb2JqZWN0ICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QgKyB0aGlzLmluZGV4LnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgQWNjZXNzb3JOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdC50b1RleChvcHRpb25zKTtcbiAgICBpZiAobmVlZFBhcmVudGhlc2lzKHRoaXMub2JqZWN0KSkge1xuICAgICAgb2JqZWN0ID0gJ1xcXFxsZWZ0KCcgKyBvYmplY3QgKyAnXFxcXHJpZ2h0KSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdCArIHRoaXMuaW5kZXgudG9UZXgob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFyZSBwYXJlbnRoZXNpcyBuZWVkZWQ/XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBuZWVkUGFyZW50aGVzaXMobm9kZSkge1xuICAgIC8vIFRPRE86IG1heWJlIG1ha2UgYSBtZXRob2Qgb24gdGhlIG5vZGVzIHdoaWNoIHRlbGxzIHdoZXRoZXIgdGhleSBuZWVkIHBhcmVudGhlc2lzP1xuICAgIHJldHVybiAhKG5vZGUuaXNBY2Nlc3Nvck5vZGUgfHwgbm9kZS5pc0FycmF5Tm9kZSB8fCBub2RlLmlzQ29uc3RhbnROb2RlXG4gICAgICAgIHx8IG5vZGUuaXNGdW5jdGlvbk5vZGUgfHwgbm9kZS5pc09iamVjdE5vZGUgfHwgbm9kZS5pc1BhcmVudGhlc2lzTm9kZVxuICAgICAgICB8fCBub2RlLmlzU3ltYm9sTm9kZSk7XG4gIH1cblxuICByZXR1cm4gQWNjZXNzb3JOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnQWNjZXNzb3JOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQXJyYXlOb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKiBIb2xkcyBhbiAxLWRpbWVuc2lvbmFsIGFycmF5IHdpdGggaXRlbXNcbiAgICogQHBhcmFtIHtOb2RlW119IFtpdGVtc10gICAxIGRpbWVuc2lvbmFsIGFycmF5IHdpdGggaXRlbXNcbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5Tm9kZShpdGVtcykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcnJheU5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuaXRlbXMpXG4gICAgICAgIHx8ICF0aGlzLml0ZW1zLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7cmV0dXJuIGl0ZW0gJiYgaXRlbS5pc05vZGU7fSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgTm9kZXMgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHYzLCByZW1vdmUgc29tZSBkYXlcbiAgICB2YXIgZGVwcmVjYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgYEFycmF5Tm9kZS5ub2Rlc2AgaXMgZGVwcmVjYXRlZCwgdXNlIGBBcnJheU5vZGUuaXRlbXNgIGluc3RlYWQnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZXMnLCB7IGdldDogZGVwcmVjYXRlZCwgc2V0OiBkZXByZWNhdGVkIH0pO1xuICB9XG5cbiAgQXJyYXlOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbiAgQXJyYXlOb2RlLnByb3RvdHlwZS50eXBlID0gJ0FycmF5Tm9kZSc7XG5cbiAgQXJyYXlOb2RlLnByb3RvdHlwZS5pc0FycmF5Tm9kZSA9IHRydWU7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZzICAgICBPYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgdGhlIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBcnJheU5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICB2YXIgYXNNYXRyaXggPSAoZGVmcy5tYXRoLmNvbmZpZygpLm1hdHJpeCAhPT0gJ0FycmF5Jyk7XG5cbiAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuX2NvbXBpbGUoZGVmcywgYXJncyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKGFzTWF0cml4ID8gJ21hdGgubWF0cml4KFsnIDogJ1snKSArXG4gICAgICAgIGl0ZW1zLmpvaW4oJywnKSArXG4gICAgICAgIChhc01hdHJpeCA/ICddKScgOiAnXScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBBcnJheU5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgIGNhbGxiYWNrKG5vZGUsICdpdGVtc1snICsgaSArICddJywgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQXJyYXlOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtBcnJheU5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBBcnJheU5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbXNbaV0gPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5pdGVtc1tpXSwgJ2l0ZW1zWycgKyBpICsgJ10nLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlOb2RlKGl0ZW1zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtBcnJheU5vZGV9XG4gICAqL1xuICBBcnJheU5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheU5vZGUodGhpcy5pdGVtcy5zbGljZSgwKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheU5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICdbJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgQXJyYXlOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHMgPSAnXFxcXGJlZ2lue2JtYXRyaXh9JztcblxuICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5pdGVtcykge1xuICAgICAgICBzICs9IG5vZGUuaXRlbXMubWFwKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZE5vZGUudG9UZXgob3B0aW9ucyk7XG4gICAgICAgIH0pLmpvaW4oJyYnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzICs9IG5vZGUudG9UZXgob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5ldyBsaW5lXG4gICAgICBzICs9ICdcXFxcXFxcXCc7XG4gICAgfSk7XG4gICAgcyArPSAnXFxcXGVuZHtibWF0cml4fSc7XG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgcmV0dXJuIEFycmF5Tm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0FycmF5Tm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcbiAgdmFyIEFycmF5Tm9kZSA9IGxvYWQocmVxdWlyZSgnLi9BcnJheU5vZGUnKSk7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFzc2lnbiA9IGxvYWQocmVxdWlyZSgnLi91dGlscy9hc3NpZ24nKSk7XG4gIHZhciBhY2Nlc3MgPSBsb2FkKHJlcXVpcmUoJy4vdXRpbHMvYWNjZXNzJykpO1xuXG4gIHZhciBrZXl3b3JkcyA9IHJlcXVpcmUoJy4uL2tleXdvcmRzJyk7XG4gIHZhciBvcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMnKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIEFzc2lnbm1lbnROb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKlxuICAgKiBEZWZpbmUgYSBzeW1ib2wsIGxpa2UgYGE9My4yYCwgdXBkYXRlIGEgcHJvcGVydHkgbGlrZSBgYS5iPTMuMmAsIG9yXG4gICAqIHJlcGxhY2UgYSBzdWJzZXQgb2YgYSBtYXRyaXggbGlrZSBgQVsyLDJdPTQyYC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbmV3IEFzc2lnbm1lbnROb2RlKHN5bWJvbCwgdmFsdWUpXG4gICAqICAgICBuZXcgQXNzaWdubWVudE5vZGUob2JqZWN0LCBpbmRleCwgdmFsdWUpXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKlxuICAgKiAgICBuZXcgQXNzaWdubWVudE5vZGUobmV3IFN5bWJvbE5vZGUoJ2EnKSwgbmV3IENvbnN0YW50Tm9kZSgyKSk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGE9MlxuICAgKiAgICBuZXcgQXNzaWdubWVudE5vZGUobmV3IFN5bWJvbE5vZGUoJ2EnKSwgbmV3IEluZGV4Tm9kZSgnYicpLCBuZXcgQ29uc3RhbnROb2RlKDIpKSAgIC8vIGEuYj0yXG4gICAqICAgIG5ldyBBc3NpZ25tZW50Tm9kZShuZXcgU3ltYm9sTm9kZSgnYScpLCBuZXcgSW5kZXhOb2RlKDEsIDIpLCBuZXcgQ29uc3RhbnROb2RlKDMpKSAgLy8gYVsxLDJdPTNcbiAgICpcbiAgICogQHBhcmFtIHtTeW1ib2xOb2RlIHwgQWNjZXNzb3JOb2RlfSBvYmplY3QgIE9iamVjdCBvbiB3aGljaCB0byBhc3NpZ24gYSB2YWx1ZVxuICAgKiBAcGFyYW0ge0luZGV4Tm9kZX0gW2luZGV4PW51bGxdICAgICAgICAgICAgSW5kZXgsIHByb3BlcnR5IG5hbWUgb3IgbWF0cml4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleC4gT3B0aW9uYWwuIElmIG5vdCBwcm92aWRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBvYmplY3RgIGlzIGEgU3ltYm9sTm9kZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwcm9wZXJ0eSBpcyBhc3NpZ25lZCB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbCBzY29wZS5cbiAgICogQHBhcmFtIHtOb2RlfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBiZSBhc3NpZ25lZFxuICAgKi9cbiAgZnVuY3Rpb24gQXNzaWdubWVudE5vZGUob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXNzaWdubWVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuaW5kZXggPSB2YWx1ZSA/IGluZGV4IDogbnVsbDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgPyB2YWx1ZSA6IGluZGV4O1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBpZiAoIW9iamVjdCB8fCAhKG9iamVjdC5pc1N5bWJvbE5vZGUgfHwgb2JqZWN0LmlzQWNjZXNzb3JOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sTm9kZSBvciBBY2Nlc3Nvck5vZGUgZXhwZWN0ZWQgYXMgXCJvYmplY3RcIicpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5pc1N5bWJvbE5vZGUgJiYgb2JqZWN0Lm5hbWUgPT09ICdlbmQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gdG8gc3ltYm9sIFwiZW5kXCInKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5kZXggJiYgIXRoaXMuaW5kZXguaXNJbmRleE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luZGV4Tm9kZSBleHBlY3RlZCBhcyBcImluZGV4XCInKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8ICF0aGlzLnZhbHVlLmlzTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9kZSBleHBlY3RlZCBhcyBcInZhbHVlXCInKTtcbiAgICB9XG5cbiAgICAvLyByZWFkb25seSBwcm9wZXJ0eSBuYW1lXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSlcbiAgICAgICAgICAgICAgPyB0aGlzLmluZGV4LmdldE9iamVjdFByb3BlcnR5KClcbiAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QubmFtZSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFzc2lnbiBhIG5ldyBuYW1lLCBuYW1lIGlzIHJlYWQtb25seScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUudHlwZSA9ICdBc3NpZ25tZW50Tm9kZSc7XG5cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlLmlzQXNzaWdubWVudE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICBkZWZzLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBkZWZzLmFjY2VzcyA9IGFjY2VzcztcblxuICAgIHZhciBzaXplO1xuICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdC5fY29tcGlsZShkZWZzLCBhcmdzKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4ID8gdGhpcy5pbmRleC5fY29tcGlsZShkZWZzLCBhcmdzKSA6IG51bGw7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZS5fY29tcGlsZShkZWZzLCBhcmdzKTtcblxuICAgIGlmICghdGhpcy5pbmRleCkge1xuICAgICAgLy8gYXBwbHkgYSB2YXJpYWJsZSB0byB0aGUgc2NvcGUsIGZvciBleGFtcGxlIGBhPTJgXG4gICAgICBpZiAoIXRoaXMub2JqZWN0LmlzU3ltYm9sTm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2xOb2RlIGV4cGVjdGVkIGFzIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3Njb3BlW1wiJyArIHRoaXMub2JqZWN0Lm5hbWUgKyAnXCJdID0gJyArIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSkge1xuICAgICAgLy8gYXBwbHkgYW4gb2JqZWN0IHByb3BlcnR5IGZvciBleGFtcGxlIGBhLmI9MmBcbiAgICAgIHJldHVybiBvYmplY3QgKyAnW1wiJyArIHRoaXMuaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKSArICdcIl0gPSAnICsgdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMub2JqZWN0LmlzU3ltYm9sTm9kZSkge1xuICAgICAgLy8gdXBkYXRlIGEgbWF0cml4IHN1YnNldCwgZm9yIGV4YW1wbGUgYGFbMl09M2BcbiAgICAgIHNpemUgPSB0aGlzLmluZGV4Lm5lZWRzU2l6ZSgpID8gJ3ZhciBzaXplID0gbWF0aC5zaXplKG9iamVjdCkudmFsdWVPZigpOycgOiAnJztcblxuICAgICAgLy8gYXBwbHkgdXBkYXRlZCBvYmplY3QgdG8gc2NvcGVcbiAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAnICB2YXIgb2JqZWN0ID0gJyArIG9iamVjdCArICc7JyArXG4gICAgICAgICAgJyAgdmFyIHZhbHVlID0gJyArIHZhbHVlICsgJzsnICtcbiAgICAgICAgICAnICAnICsgc2l6ZSArXG4gICAgICAgICAgJyAgc2NvcGVbXCInICsgdGhpcy5vYmplY3QubmFtZSArICdcIl0gPSBhc3NpZ24ob2JqZWN0LCAnICsgaW5kZXggKyAnLCB2YWx1ZSk7JyArXG4gICAgICAgICAgJyAgcmV0dXJuIHZhbHVlOycgK1xuICAgICAgICAgICd9KSgpJztcbiAgICB9XG4gICAgZWxzZSB7IC8vIHRoaXMub2JqZWN0LmlzQWNjZXNzb3JOb2RlID09PSB0cnVlXG4gICAgICAvLyB1cGRhdGUgYSBtYXRyaXggc3Vic2V0LCBmb3IgZXhhbXBsZSBgYS5iWzJdPTNgXG4gICAgICBzaXplID0gdGhpcy5pbmRleC5uZWVkc1NpemUoKSA/ICd2YXIgc2l6ZSA9IG1hdGguc2l6ZShvYmplY3QpLnZhbHVlT2YoKTsnIDogJyc7XG5cbiAgICAgIC8vIHdlIHdpbGwgbm90IHVzZSB0aGUgX2NvbXBpbGUgb2YgdGhlIEFjY2Vzc29yTm9kZSwgYnV0IGNvbXBpbGUgaXRcbiAgICAgIC8vIG91cnNlbHZlcyBoZXJlIGFzIHdlIG5lZWQgdGhlIHBhcmVudCBvYmplY3Qgb2YgdGhlIEFjY2Vzc29yTm9kZTpcbiAgICAgIC8vIHdlZSBuZWVkIHRvIGFwcGx5IHRoZSB1cGRhdGVkIG9iamVjdCB0byBwYXJlbnQgb2JqZWN0XG4gICAgICB2YXIgcGFyZW50T2JqZWN0ID0gdGhpcy5vYmplY3Qub2JqZWN0Ll9jb21waWxlKGRlZnMsIGFyZ3MpO1xuXG4gICAgICBpZiAodGhpcy5vYmplY3QuaW5kZXguaXNPYmplY3RQcm9wZXJ0eSgpKSB7XG4gICAgICAgIHZhciBwYXJlbnRQcm9wZXJ0eSA9ICdbXCInICsgdGhpcy5vYmplY3QuaW5kZXguZ2V0T2JqZWN0UHJvcGVydHkoKSArICdcIl0nO1xuICAgICAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7JyArXG4gICAgICAgICAgICAnICB2YXIgcGFyZW50ID0gJyArIHBhcmVudE9iamVjdCArICc7JyArXG4gICAgICAgICAgICAnICB2YXIgb2JqZWN0ID0gcGFyZW50JyArIHBhcmVudFByb3BlcnR5ICsgJzsnICsgLy8gcGFyZW50SW5kZXggaXMgYSBwcm9wZXJ0eVxuICAgICAgICAgICAgJyAgdmFyIHZhbHVlID0gJyArIHZhbHVlICsgJzsnICtcbiAgICAgICAgICAgIHNpemUgK1xuICAgICAgICAgICAgJyAgcGFyZW50JyArIHBhcmVudFByb3BlcnR5ICsgJyA9IGFzc2lnbihvYmplY3QsICcgKyBpbmRleCArICcsIHZhbHVlKTsnICtcbiAgICAgICAgICAgICcgIHJldHVybiB2YWx1ZTsnICtcbiAgICAgICAgICAgICd9KSgpJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpZiBzb21lIHBhcmFtZXRlcnMgdXNlIHRoZSAnZW5kJyBwYXJhbWV0ZXIsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBzaXplXG4gICAgICAgIHZhciBwYXJlbnRTaXplID0gdGhpcy5vYmplY3QuaW5kZXgubmVlZHNTaXplKCkgPyAndmFyIHNpemUgPSBtYXRoLnNpemUocGFyZW50KS52YWx1ZU9mKCk7JyA6ICcnO1xuICAgICAgICB2YXIgcGFyZW50SW5kZXggPSB0aGlzLm9iamVjdC5pbmRleC5fY29tcGlsZShkZWZzLCBhcmdzKTtcblxuICAgICAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7JyArXG4gICAgICAgICAgICAnICB2YXIgcGFyZW50ID0gJyArIHBhcmVudE9iamVjdCArICc7JyArXG4gICAgICAgICAgICAnICAnICsgcGFyZW50U2l6ZSArXG4gICAgICAgICAgICAnICB2YXIgcGFyZW50SW5kZXggPSAnICsgcGFyZW50SW5kZXggKyAnOycgK1xuICAgICAgICAgICAgJyAgdmFyIG9iamVjdCA9IGFjY2VzcyhwYXJlbnQsIHBhcmVudEluZGV4KTsnICtcbiAgICAgICAgICAgICcgIHZhciB2YWx1ZSA9ICcgKyB2YWx1ZSArICc7JyArXG4gICAgICAgICAgICAnICAnICsgc2l6ZSArXG4gICAgICAgICAgICAnICBhc3NpZ24ocGFyZW50LCBwYXJlbnRJbmRleCwgYXNzaWduKG9iamVjdCwgJyArIGluZGV4ICsgJywgdmFsdWUpKTsnICtcbiAgICAgICAgICAgICcgIHJldHVybiB2YWx1ZTsnICtcbiAgICAgICAgICAgICd9KSgpJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0aGlzLm9iamVjdCwgJ29iamVjdCcsIHRoaXMpO1xuICAgIGlmICh0aGlzLmluZGV4KSB7XG4gICAgICBjYWxsYmFjayh0aGlzLmluZGV4LCAnaW5kZXgnLCB0aGlzKTtcbiAgICB9XG4gICAgY2FsbGJhY2sodGhpcy52YWx1ZSwgJ3ZhbHVlJywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBc3NpZ25tZW50Tm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7QXNzaWdubWVudE5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBBc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLm9iamVjdCwgJ29iamVjdCcsIHRoaXMpKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4XG4gICAgICAgID8gdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuaW5kZXgsICdpbmRleCcsIHRoaXMpKVxuICAgICAgICA6IG51bGw7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMudmFsdWUsICd2YWx1ZScsIHRoaXMpKTtcblxuICAgIHJldHVybiBuZXcgQXNzaWdubWVudE5vZGUob2JqZWN0LCBpbmRleCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0Fzc2lnbm1lbnROb2RlfVxuICAgKi9cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZSh0aGlzLm9iamVjdCwgdGhpcy5pbmRleCwgdGhpcy52YWx1ZSk7XG4gIH07XG5cbiAgLypcbiAgICogSXMgcGFyZW50aGVzaXMgbmVlZGVkP1xuICAgKiBAcGFyYW0ge25vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJlbnRoZXNpcz0na2VlcCddXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBuZWVkUGFyZW50aGVzaXMobm9kZSwgcGFyZW50aGVzaXMpIHtcbiAgICBpZiAoIXBhcmVudGhlc2lzKSB7XG4gICAgICBwYXJlbnRoZXNpcyA9ICdrZWVwJztcbiAgICB9XG5cbiAgICB2YXIgcHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKG5vZGUsIHBhcmVudGhlc2lzKTtcbiAgICB2YXIgZXhwclByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShub2RlLnZhbHVlLCBwYXJlbnRoZXNpcyk7XG4gICAgcmV0dXJuIChwYXJlbnRoZXNpcyA9PT0gJ2FsbCcpXG4gICAgICB8fCAoKGV4cHJQcmVjZWRlbmNlICE9PSBudWxsKSAmJiAoZXhwclByZWNlZGVuY2UgPD0gcHJlY2VkZW5jZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCA/IHRoaXMuaW5kZXgudG9TdHJpbmcob3B0aW9ucykgOiAnJztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChuZWVkUGFyZW50aGVzaXModGhpcywgb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSkge1xuICAgICAgdmFsdWUgPSAnKCcgKyB2YWx1ZSArICcpJztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0ICsgaW5kZXggKyAnID0gJyArIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgQXNzaWdubWVudE5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5vYmplY3QudG9UZXgob3B0aW9ucyk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCA/IHRoaXMuaW5kZXgudG9UZXgob3B0aW9ucykgOiAnJztcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLnRvVGV4KG9wdGlvbnMpO1xuICAgIGlmIChuZWVkUGFyZW50aGVzaXModGhpcywgb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSkge1xuICAgICAgdmFsdWUgPSAnXFxcXGxlZnQoJyArIHZhbHVlICsgJ1xcXFxyaWdodCknO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QgKyBpbmRleCArICc6PScgKyB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gQXNzaWdubWVudE5vZGU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdBc3NpZ25tZW50Tm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcbiAgdmFyIFJlc3VsdFNldCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9yZXN1bHRzZXQvUmVzdWx0U2V0JykpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgQmxvY2tOb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKiBIb2xkcyBhIHNldCB3aXRoIGJsb2Nrc1xuICAgKiBAcGFyYW0ge0FycmF5Ljx7bm9kZTogTm9kZX0gfCB7bm9kZTogTm9kZSwgdmlzaWJsZTogYm9vbGVhbn0+fSBibG9ja3NcbiAgICogICAgICAgICAgICBBbiBhcnJheSB3aXRoIGJsb2Nrcywgd2hlcmUgYSBibG9jayBpcyBjb25zdHJ1Y3RlZCBhcyBhbiBPYmplY3RcbiAgICogICAgICAgICAgICB3aXRoIHByb3BlcnRpZXMgYmxvY2ssIHdoaWNoIGlzIGEgTm9kZSwgYW5kIHZpc2libGUsIHdoaWNoIGlzXG4gICAqICAgICAgICAgICAgYSBib29sZWFuLiBUaGUgcHJvcGVydHkgdmlzaWJsZSBpcyBvcHRpb25hbCBhbmQgaXMgdHJ1ZSBieSBkZWZhdWx0XG4gICAqL1xuICBmdW5jdGlvbiBCbG9ja05vZGUoYmxvY2tzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsb2NrTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXQsIGNvcHkgYmxvY2tzXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJsb2NrcykpIHRocm93IG5ldyBFcnJvcignQXJyYXkgZXhwZWN0ZWQnKTtcbiAgICB0aGlzLmJsb2NrcyA9IGJsb2Nrcy5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICB2YXIgbm9kZSA9IGJsb2NrICYmIGJsb2NrLm5vZGU7XG4gICAgICB2YXIgdmlzaWJsZSA9IGJsb2NrICYmIGJsb2NrLnZpc2libGUgIT09IHVuZGVmaW5lZCA/IGJsb2NrLnZpc2libGUgOiB0cnVlO1xuXG4gICAgICBpZiAoIShub2RlICYmIG5vZGUuaXNOb2RlKSkgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9wZXJ0eSBcIm5vZGVcIiBtdXN0IGJlIGEgTm9kZScpO1xuICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3BlcnR5IFwidmlzaWJsZVwiIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUudHlwZSA9ICdCbG9ja05vZGUnO1xuXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUuaXNCbG9ja05vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBCbG9ja05vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICBkZWZzLlJlc3VsdFNldCA9IFJlc3VsdFNldDtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGpzID0gcGFyYW0ubm9kZS5fY29tcGlsZShkZWZzLCBhcmdzKTtcbiAgICAgIGlmIChwYXJhbS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiAncmVzdWx0cy5wdXNoKCcgKyBqcyArICcpOyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGpzICsgJzsnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICcoZnVuY3Rpb24gKCkgeycgK1xuICAgICAgICAndmFyIHJlc3VsdHMgPSBbXTsnICtcbiAgICAgICAgYmxvY2tzLmpvaW4oJycpICtcbiAgICAgICAgJ3JldHVybiBuZXcgUmVzdWx0U2V0KHJlc3VsdHMpOycgK1xuICAgICAgICAnfSkoKSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgYmxvY2tzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBCbG9ja05vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLmJsb2Nrc1tpXS5ub2RlLCAnYmxvY2tzWycgKyBpICsgJ10ubm9kZScsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEJsb2NrTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7QmxvY2tOb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQmxvY2tOb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgYmxvY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJsb2NrID0gdGhpcy5ibG9ja3NbaV07XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayhibG9jay5ub2RlLCAnYmxvY2tzWycgKyBpICsgJ10ubm9kZScsIHRoaXMpKTtcbiAgICAgIGJsb2Nrc1tpXSA9IHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgdmlzaWJsZTogYmxvY2sudmlzaWJsZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9ja05vZGUoYmxvY2tzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtCbG9ja05vZGV9XG4gICAqL1xuICBCbG9ja05vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2Nrcy5tYXAoZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBibG9jay5ub2RlLFxuICAgICAgICB2aXNpYmxlOiBibG9jay52aXNpYmxlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBCbG9ja05vZGUoYmxvY2tzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEJsb2NrTm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgcmV0dXJuIHBhcmFtLm5vZGUudG9TdHJpbmcob3B0aW9ucykgKyAocGFyYW0udmlzaWJsZSA/ICcnIDogJzsnKTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBCbG9ja05vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHJldHVybiBwYXJhbS5ub2RlLnRvVGV4KG9wdGlvbnMpICsgKHBhcmFtLnZpc2libGUgPyAnJyA6ICc7Jyk7XG4gICAgfSkuam9pbignXFxcXDtcXFxcO1xcbicpO1xuICB9O1xuXG4gIHJldHVybiBCbG9ja05vZGU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdCbG9ja05vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xudmFyIG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBOb2RlID0gbG9hZChyZXF1aXJlKCcuL05vZGUnKSk7XG5cbiAgLyoqXG4gICAqIEEgbGF6eSBldmFsdWF0aW5nIGNvbmRpdGlvbmFsIG9wZXJhdG9yOiAnY29uZGl0aW9uID8gdHJ1ZUV4cHIgOiBmYWxzZUV4cHInXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gY29uZGl0aW9uICAgQ29uZGl0aW9uLCBtdXN0IHJlc3VsdCBpbiBhIGJvb2xlYW5cbiAgICogQHBhcmFtIHtOb2RlfSB0cnVlRXhwciAgICBFeHByZXNzaW9uIGV2YWx1YXRlZCB3aGVuIGNvbmRpdGlvbiBpcyB0cnVlXG4gICAqIEBwYXJhbSB7Tm9kZX0gZmFsc2VFeHByICAgRXhwcmVzc2lvbiBldmFsdWF0ZWQgd2hlbiBjb25kaXRpb24gaXMgdHJ1ZVxuICAgKlxuICAgKiBAY29uc3RydWN0b3IgQ29uZGl0aW9uYWxOb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxOb2RlKGNvbmRpdGlvbiwgdHJ1ZUV4cHIsIGZhbHNlRXhwcikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb25kaXRpb25hbE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cbiAgICBpZiAoIShjb25kaXRpb24gJiYgY29uZGl0aW9uLmlzTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBjb25kaXRpb24gbXVzdCBiZSBhIE5vZGUnKTtcbiAgICBpZiAoISh0cnVlRXhwciAmJiB0cnVlRXhwci5pc05vZGUpKSAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIHRydWVFeHByIG11c3QgYmUgYSBOb2RlJyk7XG4gICAgaWYgKCEoZmFsc2VFeHByICYmIGZhbHNlRXhwci5pc05vZGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgZmFsc2VFeHByIG11c3QgYmUgYSBOb2RlJyk7XG5cbiAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB0aGlzLnRydWVFeHByID0gdHJ1ZUV4cHI7XG4gICAgdGhpcy5mYWxzZUV4cHIgPSBmYWxzZUV4cHI7XG4gIH1cblxuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlLnR5cGUgPSAnQ29uZGl0aW9uYWxOb2RlJztcblxuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlLmlzQ29uZGl0aW9uYWxOb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGEgY29uZGl0aW9uIGlzIG1ldFxuICAgICAqIEBwYXJhbSB7Kn0gY29uZGl0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgY29uZGl0aW9uIGlzIHRydWUgb3Igbm9uLXplcm8sIGVsc2UgZmFsc2VcbiAgICAgKi9cbiAgICBkZWZzLnRlc3RDb25kaXRpb24gPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gJ251bWJlcidcbiAgICAgICAgICB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnYm9vbGVhbidcbiAgICAgICAgICB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24uaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gY29uZGl0aW9uLmlzWmVybygpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbi5pc0NvbXBsZXggPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gKGNvbmRpdGlvbi5yZSB8fCBjb25kaXRpb24uaW0pID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbi5pc1VuaXQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gY29uZGl0aW9uLnZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25kaXRpb24gPT09IG51bGwgfHwgY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIG9mIGNvbmRpdGlvbiBcIicgKyBkZWZzLm1hdGhbJ3R5cGVvZiddKGNvbmRpdGlvbikgKyAnXCInKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICd0ZXN0Q29uZGl0aW9uKCcgKyB0aGlzLmNvbmRpdGlvbi5fY29tcGlsZShkZWZzLCBhcmdzKSArICcpID8gJyArXG4gICAgICAnKCAnICsgdGhpcy50cnVlRXhwci5fY29tcGlsZShkZWZzLCBhcmdzKSArICcpIDogJyArXG4gICAgICAnKCAnICsgdGhpcy5mYWxzZUV4cHIuX2NvbXBpbGUoZGVmcywgYXJncykgKyAnKSdcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0aGlzLmNvbmRpdGlvbiwgJ2NvbmRpdGlvbicsIHRoaXMpO1xuICAgIGNhbGxiYWNrKHRoaXMudHJ1ZUV4cHIsICd0cnVlRXhwcicsIHRoaXMpO1xuICAgIGNhbGxiYWNrKHRoaXMuZmFsc2VFeHByLCAnZmFsc2VFeHByJywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBDb25kaXRpb25hbE5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0NvbmRpdGlvbmFsTm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbE5vZGUoXG4gICAgICAgIHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLmNvbmRpdGlvbiwgJ2NvbmRpdGlvbicsIHRoaXMpKSxcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMudHJ1ZUV4cHIsICd0cnVlRXhwcicsIHRoaXMpKSxcbiAgICAgICAgdGhpcy5faWZOb2RlKGNhbGxiYWNrKHRoaXMuZmFsc2VFeHByLCAnZmFsc2VFeHByJywgdGhpcykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtDb25kaXRpb25hbE5vZGV9XG4gICAqL1xuICBDb25kaXRpb25hbE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxOb2RlKHRoaXMuY29uZGl0aW9uLCB0aGlzLnRydWVFeHByLCB0aGlzLmZhbHNlRXhwcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIENvbmRpdGlvbmFsTm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50aGVzaXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSA/IG9wdGlvbnMucGFyZW50aGVzaXMgOiAna2VlcCc7XG4gICAgdmFyIHByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZSh0aGlzLCBwYXJlbnRoZXNpcyk7XG5cbiAgICAvL0VuY2xvc2UgQXJndW1lbnRzIGluIHBhcmVudGhlc2VzIGlmIHRoZXkgYXJlIGFuIE9wZXJhdG9yTm9kZVxuICAgIC8vb3IgaGF2ZSBsb3dlciBvciBlcXVhbCBwcmVjZWRlbmNlXG4gICAgLy9OT1RFOiBlbmNsb3NpbmcgYWxsIE9wZXJhdG9yTm9kZXMgaW4gcGFyZW50aGVzZXMgaXMgYSBkZWNpc2lvblxuICAgIC8vcHVyZWx5IGJhc2VkIG9uIGFlc3RoZXRpY3MgYW5kIHJlYWRhYmlsaXR5XG4gICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIHZhciBjb25kaXRpb25QcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UodGhpcy5jb25kaXRpb24sIHBhcmVudGhlc2lzKTtcbiAgICBpZiAoKHBhcmVudGhlc2lzID09PSAnYWxsJylcbiAgICAgICAgfHwgKHRoaXMuY29uZGl0aW9uLnR5cGUgPT09ICdPcGVyYXRvck5vZGUnKVxuICAgICAgICB8fCAoKGNvbmRpdGlvblByZWNlZGVuY2UgIT09IG51bGwpICYmIChjb25kaXRpb25QcmVjZWRlbmNlIDw9IHByZWNlZGVuY2UpKSkge1xuICAgICAgY29uZGl0aW9uID0gJygnICsgY29uZGl0aW9uICsgJyknO1xuICAgIH1cblxuICAgIHZhciB0cnVlRXhwciA9IHRoaXMudHJ1ZUV4cHIudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgdmFyIHRydWVQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UodGhpcy50cnVlRXhwciwgcGFyZW50aGVzaXMpO1xuICAgIGlmICgocGFyZW50aGVzaXMgPT09ICdhbGwnKVxuICAgICAgICB8fCAodGhpcy50cnVlRXhwci50eXBlID09PSAnT3BlcmF0b3JOb2RlJylcbiAgICAgICAgfHwgKCh0cnVlUHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKHRydWVQcmVjZWRlbmNlIDw9IHByZWNlZGVuY2UpKSkge1xuICAgICAgdHJ1ZUV4cHIgPSAnKCcgKyB0cnVlRXhwciArICcpJztcbiAgICB9XG5cbiAgICB2YXIgZmFsc2VFeHByID0gdGhpcy5mYWxzZUV4cHIudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgdmFyIGZhbHNlUHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKHRoaXMuZmFsc2VFeHByLCBwYXJlbnRoZXNpcyk7XG4gICAgaWYgKChwYXJlbnRoZXNpcyA9PT0gJ2FsbCcpXG4gICAgICAgIHx8ICh0aGlzLmZhbHNlRXhwci50eXBlID09PSAnT3BlcmF0b3JOb2RlJylcbiAgICAgICAgfHwgKChmYWxzZVByZWNlZGVuY2UgIT09IG51bGwpICYmIChmYWxzZVByZWNlZGVuY2UgPD0gcHJlY2VkZW5jZSkpKSB7XG4gICAgICBmYWxzZUV4cHIgPSAnKCcgKyBmYWxzZUV4cHIgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24gKyAnID8gJyArIHRydWVFeHByICsgJyA6ICcgKyBmYWxzZUV4cHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgQ29uZGl0aW9uYWxOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiAnXFxcXGJlZ2lue2Nhc2VzfSB7J1xuICAgICAgICArIHRoaXMudHJ1ZUV4cHIudG9UZXgob3B0aW9ucykgKyAnfSwgJlxcXFxxdWFke1xcXFx0ZXh0e2lmIH1cXFxcOydcbiAgICAgICAgKyB0aGlzLmNvbmRpdGlvbi50b1RleChvcHRpb25zKVxuICAgICAgICArICd9XFxcXFxcXFx7JyArIHRoaXMuZmFsc2VFeHByLnRvVGV4KG9wdGlvbnMpXG4gICAgICAgICsgJ30sICZcXFxccXVhZHtcXFxcdGV4dHtvdGhlcndpc2V9fVxcXFxlbmR7Y2FzZXN9JztcbiAgfTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnQ29uZGl0aW9uYWxOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi8uLi91dGlscy90eXBlcycpLnR5cGU7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICAvKipcbiAgICogQSBDb25zdGFudE5vZGUgaG9sZHMgYSBjb25zdGFudCB2YWx1ZSBsaWtlIGEgbnVtYmVyIG9yIHN0cmluZy4gQSBDb25zdGFudE5vZGVcbiAgICogc3RvcmVzIGEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUgYW5kIHVzZXMgdGhpcyB0byBjb21waWxlIHRvXG4gICAqIEphdmFTY3JpcHQuXG4gICAqXG4gICAqIEluIGNhc2Ugb2YgYSBzdHJpbmdpZmllZCBudW1iZXIgYXMgaW5wdXQsIHRoaXMgbWF5IGJlIGNvbXBpbGVkIHRvIGEgQmlnTnVtYmVyXG4gICAqIHdoZW4gdGhlIG1hdGggaW5zdGFuY2UgaXMgY29uZmlndXJlZCBmb3IgQmlnTnVtYmVycy5cbiAgICpcbiAgICogVXNhZ2U6XG4gICAqXG4gICAqICAgICAvLyBzdHJpbmdpZmllZCB2YWx1ZXMgd2l0aCB0eXBlXG4gICAqICAgICBuZXcgQ29uc3RhbnROb2RlKCcyLjMnLCAnbnVtYmVyJyk7XG4gICAqICAgICBuZXcgQ29uc3RhbnROb2RlKCd0cnVlJywgJ2Jvb2xlYW4nKTtcbiAgICogICAgIG5ldyBDb25zdGFudE5vZGUoJ2hlbGxvJywgJ3N0cmluZycpO1xuICAgKlxuICAgKiAgICAgLy8gbm9uLXN0cmluZ2lmaWVkIHZhbHVlcywgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWRcbiAgICogICAgIG5ldyBDb25zdGFudE5vZGUoMi4zKTtcbiAgICogICAgIG5ldyBDb25zdGFudE5vZGUoJ2hlbGxvJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IHZhbHVlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gdmFsdWVUeXBlIGlzIHByb3ZpZGVkLCB2YWx1ZSBtdXN0IGNvbnRhaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gdW5pbnRlcnByZXRlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB2YWx1ZVR5cGUgaXMgdW5kZWZpbmVkLCB2YWx1ZSBjYW4gYmUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIsIHN0cmluZywgYm9vbGVhbiwgbnVsbCwgb3IgdW5kZWZpbmVkLCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHR5cGUgd2lsbCBiZSBkZXRlcm1pbmVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVUeXBlXSAgVGhlIHR5cGUgb2YgdmFsdWUuIENob29zZSBmcm9tICdudW1iZXInLCAnc3RyaW5nJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsICd1bmRlZmluZWQnLCAnbnVsbCdcbiAgICogQGNvbnN0cnVjdG9yIENvbnN0YW50Tm9kZVxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICovXG4gIGZ1bmN0aW9uIENvbnN0YW50Tm9kZSh2YWx1ZSwgdmFsdWVUeXBlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbnN0YW50Tm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlVHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwidmFsdWVUeXBlXCInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0cmluZyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwidmFsdWVcIicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBzdHJpbmdpZnkgdGhlIHZhbHVlIGFuZCBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSArICcnO1xuICAgICAgdGhpcy52YWx1ZVR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIVNVUFBPUlRFRF9UWVBFU1t0aGlzLnZhbHVlVHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUgb2YgdmFsdWUgXCInICsgdGhpcy52YWx1ZVR5cGUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICB2YXIgU1VQUE9SVEVEX1RZUEVTID0ge1xuICAgICdudW1iZXInOiB0cnVlLFxuICAgICdzdHJpbmcnOiB0cnVlLFxuICAgICdib29sZWFuJzogdHJ1ZSxcbiAgICAndW5kZWZpbmVkJzogdHJ1ZSxcbiAgICAnbnVsbCc6IHRydWVcbiAgfTtcblxuICBDb25zdGFudE5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBDb25zdGFudE5vZGUucHJvdG90eXBlLnR5cGUgPSAnQ29uc3RhbnROb2RlJztcblxuICBDb25zdGFudE5vZGUucHJvdG90eXBlLmlzQ29uc3RhbnROb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29uc3RhbnROb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB0aGlzIHdpdGggdXNpbmcgY29uZmlnLm51bWJlclxuICAgICAgICB2YXIgbnVtQ29uZmlnID0gZGVmcy5tYXRoLmNvbmZpZygpLm51bWJlcjtcbiAgICAgICAgaWYgKG51bUNvbmZpZyA9PT0gJ0JpZ051bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gJ21hdGguYmlnbnVtYmVyKFwiJyArIHRoaXMudmFsdWUgKyAnXCIpJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1Db25maWcgPT09ICdGcmFjdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gJ21hdGguZnJhY3Rpb24oXCInICsgdGhpcy52YWx1ZSArICdcIiknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIHplcm9zIGxpa2UgJzAwMy4yJyB3aGljaCBhcmUgbm90IGFsbG93ZWQgYnkgSmF2YVNjcmlwdFxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnJlcGxhY2UoL14oMCopWzAtOV0vLCBmdW5jdGlvbiAobWF0Y2gsIHplcm9zKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guc3Vic3RyaW5nKHplcm9zLmxlbmd0aCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuICdcIicgKyB0aGlzLnZhbHVlICsgJ1wiJztcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblxuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgZXJyb3IgdG8gdGhlIGNvbnN0cnVjdG9yP1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCB0eXBlIG9mIGNvbnN0YW50IFwiJyArIHRoaXMudmFsdWVUeXBlICsgJ1wiJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBDb25zdGFudE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBub3RoaW5nIHRvIGRvLCB3ZSBkb24ndCBoYXZlIGNoaWxkc1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBDb25zdGFudE5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKSA6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtDb25zdGFudE5vZGV9IFJldHVybnMgYSBjbG9uZSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ29uc3RhbnROb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0NvbnN0YW50Tm9kZX1cbiAgICovXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdGFudE5vZGUodGhpcy52YWx1ZSwgdGhpcy52YWx1ZVR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBDb25zdGFudE5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgc3dpdGNoICh0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuICdcIicgKyB0aGlzLnZhbHVlICsgJ1wiJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIENvbnN0YW50Tm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICAgICAgICBpbmRleDtcbiAgICBzd2l0Y2ggKHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gJ1xcXFxtYXRodHR7XCInICsgdmFsdWUgKyAnXCJ9JztcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW5kZXggPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2UnKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJ1xcXFxjZG90MTBeeycgK1xuICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoaW5kZXggKyAxKSArICd9JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbnN0YW50Tm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0NvbnN0YW50Tm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXl3b3JkcyA9IHJlcXVpcmUoJy4uL2tleXdvcmRzJyk7XG52YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xudmFyIG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG5mdW5jdGlvbiBpc1N0cmluZyAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBOb2RlID0gbG9hZChyZXF1aXJlKCcuL05vZGUnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvbkFzc2lnbm1lbnROb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKiBGdW5jdGlvbiBhc3NpZ25tZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgICAgICBGdW5jdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBBcnJheS48e25hbWU6IHN0cmluZywgdHlwZTogc3RyaW5nfT59IHBhcmFtc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkgd2l0aCBmdW5jdGlvbiBwYXJhbWV0ZXIgbmFtZXMsIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSB3aXRoIG9iamVjdHMgY29udGFpbmluZyB0aGUgbmFtZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHR5cGUgb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge05vZGV9IGV4cHIgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUobmFtZSwgcGFyYW1zLCBleHByKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJuYW1lXCInKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgc3RyaW5ncyBvciBvYmplY3RzIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJwYXJhbXNcIicpO1xuICAgIGlmICghKGV4cHIgJiYgZXhwci5pc05vZGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJleHByXCInKTtcbiAgICBpZiAobmFtZSBpbiBrZXl3b3JkcykgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGZ1bmN0aW9uIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIgaXMgYSByZXNlcnZlZCBrZXl3b3JkJyk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHJldHVybiBwYXJhbSAmJiBwYXJhbS5uYW1lIHx8IHBhcmFtO1xuICAgIH0pO1xuICAgIHRoaXMudHlwZXMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgcmV0dXJuIHBhcmFtICYmIHBhcmFtLnR5cGUgfHwgJ2FueSdcbiAgICB9KTtcbiAgICB0aGlzLmV4cHIgPSBleHByO1xuICB9XG5cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUucHJvdG90eXBlLnR5cGUgPSAnRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZSc7XG5cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuaXNGdW5jdGlvbkFzc2lnbm1lbnROb2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIGRlZnMudHlwZWQgPSB0eXBlZDtcblxuICAgIC8vIHdlIGV4dGVuZCB0aGUgb3JpZ2luYWwgYXJncyBhbmQgYWRkIHRoZSBhcmdzIHRvIHRoZSBjaGlsZCBvYmplY3RcbiAgICB2YXIgY2hpbGRBcmdzID0gT2JqZWN0LmNyZWF0ZShhcmdzKTtcbiAgICB0aGlzLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICAgICAgY2hpbGRBcmdzW3ZhcmlhYmxlXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBjb21waWxlIHRoZSBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggdGhlIGNoaWxkIGFyZ3NcbiAgICB2YXIganNFeHByID0gdGhpcy5leHByLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncyk7XG5cbiAgICByZXR1cm4gJ3Njb3BlW1wiJyArIHRoaXMubmFtZSArICdcIl0gPSAnICtcbiAgICAgICAgJyAgKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgJyAgICB2YXIgZm4gPSB0eXBlZChcIicgKyB0aGlzLm5hbWUgKyAnXCIsIHsnICtcbiAgICAgICAgJyAgICAgIFwiJyArIHRoaXMudHlwZXMuam9pbignLCcpICsgJ1wiOiBmdW5jdGlvbiAoJyArIHRoaXMucGFyYW1zLmpvaW4oJywnKSArICcpIHsnICtcbiAgICAgICAgJyAgICAgICAgcmV0dXJuICcgKyBqc0V4cHIgKyAnJyArXG4gICAgICAgICcgICAgICB9JyArXG4gICAgICAgICcgICAgfSk7JyArXG4gICAgICAgICcgICAgZm4uc3ludGF4ID0gXCInICsgdGhpcy5uYW1lICsgJygnICsgdGhpcy5wYXJhbXMuam9pbignLCAnKSArICcpXCI7JyArXG4gICAgICAgICcgICAgcmV0dXJuIGZuOycgK1xuICAgICAgICAnICB9KSgpJztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRoaXMuZXhwciwgJ2V4cHInLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEZ1bmN0aW9uQXNzaWdubWVudE5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0Z1bmN0aW9uQXNzaWdubWVudE5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBGdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgZXhwciA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLmV4cHIsICdleHByJywgdGhpcykpO1xuXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkFzc2lnbm1lbnROb2RlKHRoaXMubmFtZSwgdGhpcy5wYXJhbXMuc2xpY2UoMCksIGV4cHIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9uQXNzaWdubWVudE5vZGV9XG4gICAqL1xuICBGdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQXNzaWdubWVudE5vZGUodGhpcy5uYW1lLCB0aGlzLnBhcmFtcy5zbGljZSgwKSwgdGhpcy5leHByKTtcbiAgfTtcblxuICAvKipcbiAgICogSXMgcGFyZW50aGVzaXMgbmVlZGVkP1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudGhlc2lzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBuZWVkUGFyZW50aGVzaXMobm9kZSwgcGFyZW50aGVzaXMpIHtcbiAgICB2YXIgcHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKG5vZGUsIHBhcmVudGhlc2lzKTtcbiAgICB2YXIgZXhwclByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShub2RlLmV4cHIsIHBhcmVudGhlc2lzKTtcblxuICAgIHJldHVybiAocGFyZW50aGVzaXMgPT09ICdhbGwnKVxuICAgICAgfHwgKChleHByUHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKGV4cHJQcmVjZWRlbmNlIDw9IHByZWNlZGVuY2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBGdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgZXhwciA9IHRoaXMuZXhwci50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAobmVlZFBhcmVudGhlc2lzKHRoaXMsIHBhcmVudGhlc2lzKSkge1xuICAgICAgZXhwciA9ICcoJyArIGV4cHIgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWUgKyAnKCcgKyB0aGlzLnBhcmFtcy5qb2luKCcsICcpICsgJykgPSAnICsgZXhwcjtcbiAgfTtcblxuICAvKipcbiAgICogZ2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBGdW5jdGlvbkFzc2lnbm1lbnROb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgZXhwciA9IHRoaXMuZXhwci50b1RleChvcHRpb25zKTtcbiAgICBpZiAobmVlZFBhcmVudGhlc2lzKHRoaXMsIHBhcmVudGhlc2lzKSkge1xuICAgICAgZXhwciA9ICdcXFxcbGVmdCgnICsgZXhwciArICdcXFxccmlnaHQpJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1xcXFxtYXRocm17JyArIHRoaXMubmFtZVxuICAgICAgICArICd9XFxcXGxlZnQoJyArIHRoaXMucGFyYW1zLm1hcChsYXRleC50b1N5bWJvbCkuam9pbignLCcpICsgJ1xcXFxyaWdodCk6PScgKyBleHByO1xuICB9O1xuXG4gIHJldHVybiBGdW5jdGlvbkFzc2lnbm1lbnROb2RlO1xufVxuZXhwb3J0cy5uYW1lID0gJ0Z1bmN0aW9uQXNzaWdubWVudE5vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBOb2RlID0gbG9hZChyZXF1aXJlKCcuL05vZGUnKSk7XG4gIHZhciBTeW1ib2xOb2RlID0gbG9hZChyZXF1aXJlKCcuL1N5bWJvbE5vZGUnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvbk5vZGVcbiAgICogQGV4dGVuZHMgey4vTm9kZX1cbiAgICogaW52b2tlIGEgbGlzdCB3aXRoIGFyZ3VtZW50cyBvbiBhIG5vZGVcbiAgICogQHBhcmFtIHsuL05vZGUgfCBzdHJpbmd9IGZuIE5vZGUgcmVzb2x2aW5nIHdpdGggYSBmdW5jdGlvbiBvbiB3aGljaCB0byBpbnZva2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhcmd1bWVudHMsIHR5cGljYWxseSBhIFN5bWJvTm9kZSBvciBBY2Nlc3Nvck5vZGVcbiAgICogQHBhcmFtIHsuL05vZGVbXX0gYXJnc1xuICAgKi9cbiAgZnVuY3Rpb24gRnVuY3Rpb25Ob2RlKGZuLCBhcmdzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZuID0gbmV3IFN5bWJvbE5vZGUoZm4pO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKCFmbiB8fCAhZm4uaXNOb2RlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkIGFzIHBhcmFtZXRlciBcImZuXCInKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncylcbiAgICAgICAgfHwgIWFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge3JldHVybiBhcmcgJiYgYXJnLmlzTm9kZTt9KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkgY29udGFpbmluZyBOb2RlcyBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwiYXJnc1wiJyk7XG4gICAgfVxuXG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuYXJncyA9IGFyZ3MgfHwgW107XG5cbiAgICAvLyByZWFkb25seSBwcm9wZXJ0eSBuYW1lXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZuLm5hbWUgfHwgJyc7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIGEgbmV3IG5hbWUsIG5hbWUgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHYzLCByZW1vdmUgc29tZSBkYXlcbiAgICB2YXIgZGVwcmVjYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgYEZ1bmN0aW9uTm9kZS5vYmplY3RgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgRnVuY3Rpb25Ob2RlLmZuYCBpbnN0ZWFkJyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ29iamVjdCcsIHsgZ2V0OiBkZXByZWNhdGVkLCBzZXQ6IGRlcHJlY2F0ZWQgfSk7XG4gIH1cblxuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlID0gbmV3IE5vZGUoKTtcblxuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLnR5cGUgPSAnRnVuY3Rpb25Ob2RlJztcblxuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLmlzRnVuY3Rpb25Ob2RlID0gdHJ1ZTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgLy8gY29tcGlsZSBmbiBhbmQgYXJndW1lbnRzXG4gICAgdmFyIGpzRm4gPSB0aGlzLmZuLl9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICAgIHZhciBqc0FyZ3MgPSB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcuX2NvbXBpbGUoZGVmcywgYXJncyk7XG4gICAgfSk7XG4gICAgdmFyIGFyZ3NOYW1lO1xuXG4gICAgaWYgKHRoaXMuZm4uaXNTeW1ib2xOb2RlKSB7XG4gICAgICAvLyB3ZSBjYW4gc3RhdGljYWxseSBkZXRlcm1pbmUgd2hldGhlciB0aGUgZnVuY3Rpb24gaGFzIGFuIHJhd0FyZ3MgcHJvcGVydHlcbiAgICAgIHZhciBuYW1lID0gdGhpcy5mbi5uYW1lO1xuICAgICAgdmFyIGZuID0gZGVmcy5tYXRoW25hbWVdO1xuICAgICAgdmFyIGlzUmF3ID0gKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgJiYgKGZuLnJhd0FyZ3MgPT0gdHJ1ZSk7XG5cbiAgICAgIGlmIChpc1Jhdykge1xuICAgICAgICAvLyBwYXNzIHVuZXZhbHVhdGVkIHBhcmFtZXRlcnMgKG5vZGVzKSB0byB0aGUgZnVuY3Rpb25cbiAgICAgICAgYXJnc05hbWUgPSB0aGlzLl9nZXRVbmlxdWVBcmd1bWVudHNOYW1lKGRlZnMpO1xuICAgICAgICBkZWZzW2FyZ3NOYW1lXSA9IHRoaXMuYXJncztcblxuICAgICAgICByZXR1cm4ganNGbiArICcoJyArIGFyZ3NOYW1lICsgJywgbWF0aCwgc2NvcGUpJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJlZ3VsYXJcIiBldmFsdWF0aW9uXG4gICAgICAgIHJldHVybiBqc0ZuICsgJygnICsganNBcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZm4uaXNBY2Nlc3Nvck5vZGUgJiYgdGhpcy5mbi5pbmRleC5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgIC8vIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IGNvbnRleHQ6IHRoZSBvYmplY3Qgb2YgdGhlIEFjY2Vzc29yTm9kZVxuICAgICAgYXJnc05hbWUgPSB0aGlzLl9nZXRVbmlxdWVBcmd1bWVudHNOYW1lKGRlZnMpO1xuICAgICAgZGVmc1thcmdzTmFtZV0gPSB0aGlzLmFyZ3M7XG5cbiAgICAgIHZhciBqc09iamVjdCA9IHRoaXMuZm4ub2JqZWN0Ll9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmZuLmluZGV4LmdldE9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAndmFyIG9iamVjdCA9ICcgKyBqc09iamVjdCArICc7JyArXG4gICAgICAgICAgJ3JldHVybiAob2JqZWN0W1wiJyArIHByb3AgKyAnXCJdICYmIG9iamVjdFtcIicgKyBwcm9wICsgJ1wiXS5yYXdBcmdzKSAnICtcbiAgICAgICAgICAnID8gb2JqZWN0W1wiJyArIHByb3AgKyAnXCJdKCcgKyBhcmdzTmFtZSArICcsIG1hdGgsIHNjb3BlKScgK1xuICAgICAgICAgICcgOiBvYmplY3RbXCInICsgcHJvcCArICdcIl0oJyArIGpzQXJncy5qb2luKCcsICcpICsgJyknICtcbiAgICAgICAgICAnfSkoKSc7XG4gICAgfVxuICAgIGVsc2UgeyAvLyB0aGlzLmZuLmlzQWNjZXNzb3JOb2RlICYmICF0aGlzLmZuLmluZGV4LmlzT2JqZWN0UHJvcGVydHkoKVxuICAgICAgLy8gd2UgaGF2ZSB0byBkeW5hbWljYWxseSBkZXRlcm1pbmUgd2hldGhlciB0aGUgZnVuY3Rpb24gaGFzIGEgcmF3QXJncyBwcm9wZXJ0eVxuICAgICAgYXJnc05hbWUgPSB0aGlzLl9nZXRVbmlxdWVBcmd1bWVudHNOYW1lKGRlZnMpO1xuICAgICAgZGVmc1thcmdzTmFtZV0gPSB0aGlzLmFyZ3M7XG5cbiAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAndmFyIGZuID0gJyArIGpzRm4gKyAnOycgK1xuICAgICAgICAgICdyZXR1cm4gKGZuICYmIGZuLnJhd0FyZ3MpICcgK1xuICAgICAgICAgICcgPyBmbignICsgYXJnc05hbWUgKyAnLCBtYXRoLCBzY29wZSknICtcbiAgICAgICAgICAnIDogZm4oJyArIGpzQXJncy5qb2luKCcsICcpICsgJyknICtcbiAgICAgICAgICAnfSkoKSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSB1bmlxdWUgbmFtZSBmb3IgYSBhcmd1bWVudHMgdG8gc3RvcmUgaW4gZGVmc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIGxpa2UgJ2FyZ3MxJywgJ2FyZ3MyJywgLi4uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLl9nZXRVbmlxdWVBcmd1bWVudHNOYW1lID0gZnVuY3Rpb24gKGRlZnMpIHtcbiAgICB2YXIgYXJnc05hbWU7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgYXJnc05hbWUgPSAnYXJncycgKyBpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICB3aGlsZSAoYXJnc05hbWUgaW4gZGVmcyk7XG5cbiAgICByZXR1cm4gYXJnc05hbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLmFyZ3NbaV0sICdhcmdzWycgKyBpICsgJ10nLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBGdW5jdGlvbk5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0Z1bmN0aW9uTm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGZuID0gdGhpcy5mbi5tYXAoY2FsbGJhY2spO1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5hcmdzW2ldLCAnYXJnc1snICsgaSArICddJywgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTm9kZShmbiwgYXJncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7RnVuY3Rpb25Ob2RlfVxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTm9kZSh0aGlzLmZuLCB0aGlzLmFyZ3Muc2xpY2UoMCkpO1xuICB9O1xuXG4gIC8vYmFja3VwIE5vZGUncyB0b1N0cmluZyBmdW5jdGlvblxuICAvL0Bwcml2YXRlXG4gIHZhciBub2RlVG9TdHJpbmcgPSBGdW5jdGlvbk5vZGUucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAod3JhcHBlciBmdW5jdGlvbilcbiAgICogVGhpcyBvdmVycmlkZXMgcGFydHMgb2YgTm9kZSdzIHRvU3RyaW5nIGZ1bmN0aW9uLlxuICAgKiBJZiBjYWxsYmFjayBpcyBhbiBvYmplY3QgY29udGFpbmluZyBjYWxsYmFja3MsIGl0XG4gICAqIGNhbGxzIHRoZSBjb3JyZWN0IGNhbGxiYWNrIGZvciB0aGUgY3VycmVudCBub2RlLFxuICAgKiBvdGhlcndpc2UgaXQgZmFsbHMgYmFjayB0byBjYWxsaW5nIE5vZGUncyB0b1N0cmluZ1xuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY3VzdG9tU3RyaW5nO1xuICAgIHZhciBuYW1lID0gdGhpcy5mbi50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMuaGFuZGxlciA9PT0gJ29iamVjdCcpICYmIG9wdGlvbnMuaGFuZGxlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgLy9jYWxsYmFjayBpcyBhIG1hcCBvZiBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICAgIGN1c3RvbVN0cmluZyA9IG9wdGlvbnMuaGFuZGxlcltuYW1lXSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbVN0cmluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjdXN0b21TdHJpbmc7XG4gICAgfVxuXG4gICAgLy9mYWxsIGJhY2sgdG8gTm9kZSdzIHRvU3RyaW5nXG4gICAgcmV0dXJuIG5vZGVUb1N0cmluZy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBmb3JtYXQgdGhlIGFyZ3VtZW50cyBsaWtlIFwiYWRkKDIsIDQuMilcIlxuICAgIHJldHVybiB0aGlzLmZuLnRvU3RyaW5nKG9wdGlvbnMpICsgJygnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuICB9O1xuXG4gIC8qXG4gICAqIEV4cGFuZCBhIExhVGVYIHRlbXBsYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICoqL1xuICBmdW5jdGlvbiBleHBhbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciBsYXRleCA9ICcnO1xuXG4gICAgLy8gTWF0Y2ggZXZlcnl0aGluZyBvZiB0aGUgZm9ybSAke2lkZW50aWZpZXJ9IG9yICR7aWRlbnRpZmllclsyXX0gb3IgJCRcbiAgICAvLyB3aGlsZSBzdWJtYXRjaGluZyBpZGVudGlmaWVyIGFuZCAyIChpbiB0aGUgc2Vjb25kIGNhc2UpXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXCQoPzpcXFxceyhbYS16X11bYS16XzAtOV0qKSg/OlxcXFxbKFswLTldKylcXFxcXSk/XFxcXH18XFxcXCQpJywgJ2lnJyk7XG5cbiAgICB2YXIgaW5wdXRQb3MgPSAwOyAgIC8vcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmluZ1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyh0ZW1wbGF0ZSkpICE9PSBudWxsKSB7ICAgLy9nbyB0aHJvdWdoIGFsbCBtYXRjaGVzXG4gICAgICAvLyBhZGQgZXZlcnl0aGluZyBpbiBmcm9udCBvZiB0aGUgbWF0Y2ggdG8gdGhlIExhVGVYIHN0cmluZ1xuICAgICAgbGF0ZXggKz0gdGVtcGxhdGUuc3Vic3RyaW5nKGlucHV0UG9zLCBtYXRjaC5pbmRleCk7XG4gICAgICBpbnB1dFBvcyA9IG1hdGNoLmluZGV4O1xuXG4gICAgICBpZiAobWF0Y2hbMF0gPT09ICckJCcpIHsgLy8gZXNjYXBlZCBkb2xsYXIgc2lnblxuICAgICAgICBsYXRleCArPSAnJCc7XG4gICAgICAgIGlucHV0UG9zKys7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gdGVtcGxhdGUgcGFyYW1ldGVyXG4gICAgICAgIGlucHV0UG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gbm9kZVttYXRjaFsxXV07XG4gICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1RlbXBsYXRlOiBQcm9wZXJ0eSAnICsgbWF0Y2hbMV0gKyAnIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFsyXSA9PT0gdW5kZWZpbmVkKSB7IC8vbm8gc3F1YXJlIGJyYWNrZXRzXG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgIGxhdGV4ICs9IHByb3BlcnR5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5pc05vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXRleCArPSBwcm9wZXJ0eS50b1RleChvcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIC8vbWFrZSBhcnJheSBvZiBOb2RlcyBpbnRvIGNvbW1hIHNlcGFyYXRlZCBsaXN0XG4gICAgICAgICAgICAgICAgbGF0ZXggKz0gcHJvcGVydHkubWFwKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy5pc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1RleChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbXBsYXRlOiAnICsgbWF0Y2hbMV0gKyAnWycgKyBpbmRleCArICddIGlzIG5vdCBhIE5vZGUuJyk7XG4gICAgICAgICAgICAgICAgfSkuam9pbignLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbXBsYXRlOiAnICsgbWF0Y2hbMV0gKyAnIGhhcyB0byBiZSBhIE5vZGUsIFN0cmluZyBvciBhcnJheSBvZiBOb2RlcycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVtcGxhdGU6ICcgKyBtYXRjaFsxXSArICcgaGFzIHRvIGJlIGEgTm9kZSwgU3RyaW5nIG9yIGFycmF5IG9mIE5vZGVzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL3dpdGggc3F1YXJlIGJyYWNrZXRzXG4gICAgICAgICAgaWYgKHByb3BlcnR5W21hdGNoWzJdXSAmJiBwcm9wZXJ0eVttYXRjaFsyXV0uaXNOb2RlKSB7XG4gICAgICAgICAgICBsYXRleCArPSBwcm9wZXJ0eVttYXRjaFsyXV0udG9UZXgob3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVtcGxhdGU6ICcgKyBtYXRjaFsxXSArICdbJyArIG1hdGNoWzJdICsgJ10gaXMgbm90IGEgTm9kZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGF0ZXggKz0gdGVtcGxhdGUuc2xpY2UoaW5wdXRQb3MpOyAgLy9hcHBlbmQgcmVzdCBvZiB0aGUgdGVtcGxhdGVcblxuICAgIHJldHVybiBsYXRleDtcbiAgfVxuXG4gIC8vYmFja3VwIE5vZGUncyB0b1RleCBmdW5jdGlvblxuICAvL0Bwcml2YXRlXG4gIHZhciBub2RlVG9UZXggPSBGdW5jdGlvbk5vZGUucHJvdG90eXBlLnRvVGV4O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb24uICh3cmFwcGVyIGZ1bmN0aW9uKVxuICAgKiBUaGlzIG92ZXJyaWRlcyBwYXJ0cyBvZiBOb2RlJ3MgdG9UZXggZnVuY3Rpb24uXG4gICAqIElmIGNhbGxiYWNrIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGNhbGxiYWNrcywgaXRcbiAgICogY2FsbHMgdGhlIGNvcnJlY3QgY2FsbGJhY2sgZm9yIHRoZSBjdXJyZW50IG5vZGUsXG4gICAqIG90aGVyd2lzZSBpdCBmYWxscyBiYWNrIHRvIGNhbGxpbmcgTm9kZSdzIHRvVGV4XG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBGdW5jdGlvbk5vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY3VzdG9tVGV4O1xuICAgIGlmIChvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucy5oYW5kbGVyID09PSAnb2JqZWN0JykgJiYgb3B0aW9ucy5oYW5kbGVyLmhhc093blByb3BlcnR5KHRoaXMubmFtZSkpIHtcbiAgICAgIC8vY2FsbGJhY2sgaXMgYSBtYXAgb2YgY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICBjdXN0b21UZXggPSBvcHRpb25zLmhhbmRsZXJbdGhpcy5uYW1lXSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbVRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjdXN0b21UZXg7XG4gICAgfVxuXG4gICAgLy9mYWxsIGJhY2sgdG8gTm9kZSdzIHRvVGV4XG4gICAgcmV0dXJuIG5vZGVUb1RleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIEZ1bmN0aW9uTm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYXJncyA9IHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyAvL2dldCBMYVRlWCBvZiB0aGUgYXJndW1lbnRzXG4gICAgICByZXR1cm4gYXJnLnRvVGV4KG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgdmFyIGxhdGV4Q29udmVydGVyO1xuXG4gICAgaWYgKG1hdGhbdGhpcy5uYW1lXSAmJiAoKHR5cGVvZiBtYXRoW3RoaXMubmFtZV0udG9UZXggPT09ICdmdW5jdGlvbicpIHx8ICh0eXBlb2YgbWF0aFt0aGlzLm5hbWVdLnRvVGV4ID09PSAnb2JqZWN0JykgfHwgKHR5cGVvZiBtYXRoW3RoaXMubmFtZV0udG9UZXggPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgIC8vLnRvVGV4IGlzIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgIGxhdGV4Q29udmVydGVyID0gbWF0aFt0aGlzLm5hbWVdLnRvVGV4O1xuICAgIH1cblxuICAgIHZhciBjdXN0b21Ub1RleDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBsYXRleENvbnZlcnRlcikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOiAvL2EgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY3VzdG9tVG9UZXggPSBsYXRleENvbnZlcnRlcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOiAvL2EgdGVtcGxhdGUgc3RyaW5nXG4gICAgICAgIGN1c3RvbVRvVGV4ID0gZXhwYW5kVGVtcGxhdGUobGF0ZXhDb252ZXJ0ZXIsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vYW4gb2JqZWN0IHdpdGggZGlmZmVyZW50IFwiY29udmVydGVyc1wiIGZvciBkaWZmZXJlbnQgbnVtYmVycyBvZiBhcmd1bWVudHNcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgbGF0ZXhDb252ZXJ0ZXJbYXJncy5sZW5ndGhdKSB7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgY3VzdG9tVG9UZXggPSBsYXRleENvbnZlcnRlclthcmdzLmxlbmd0aF0odGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY3VzdG9tVG9UZXggPSBleHBhbmRUZW1wbGF0ZShsYXRleENvbnZlcnRlclthcmdzLmxlbmd0aF0sIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbVRvVGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGN1c3RvbVRvVGV4O1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRUZW1wbGF0ZShsYXRleC5kZWZhdWx0VGVtcGxhdGUsIHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgRnVuY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgKyAnOicgKyB0aGlzLm5hbWU7XG4gIH07XG5cbiAgcmV0dXJuIEZ1bmN0aW9uTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ0Z1bmN0aW9uTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMubWF0aCA9IHRydWU7IC8vIHJlcXVlc3QgYWNjZXNzIHRvIHRoZSBtYXRoIG5hbWVzcGFjZSBhcyA1dGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcbiAgdmFyIFJhbmdlTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9SYW5nZU5vZGUnKSk7XG4gIHZhciBTeW1ib2xOb2RlID0gbG9hZChyZXF1aXJlKCcuL1N5bWJvbE5vZGUnKSk7XG5cbiAgdmFyIFJhbmdlID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9SYW5nZScpKTtcblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBJbmRleE5vZGVcbiAgICogQGV4dGVuZHMgTm9kZVxuICAgKlxuICAgKiBEZXNjcmliZXMgYSBzdWJzZXQgb2YgYSBtYXRyaXggb3IgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBDYW5ub3QgYmUgdXNlZCBvbiBpdHMgb3duLCBuZWVkcyB0byBiZSB1c2VkIHdpdGhpbiBhbiBBY2Nlc3Nvck5vZGUgb3JcbiAgICogQXNzaWdubWVudE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZVtdfSBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvdE5vdGF0aW9uPWZhbHNlXSAgT3B0aW9uYWwgcHJvcGVydHkgZGVzY3JpYmluZyB3aGV0aGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBpbmRleCB3YXMgd3JpdHRlbiB1c2luZyBkb3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RhdGlvbiBsaWtlIGBhLmJgLCBvciB1c2luZyBicmFja2V0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90YXRpb24gbGlrZSBgYVtcImJcIl1gIChkZWZhdWx0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVc2VkIHRvIHN0cmluZ2lmeSBhbiBJbmRleE5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBJbmRleE5vZGUoZGltZW5zaW9ucywgZG90Tm90YXRpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5kZXhOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMuZG90Tm90YXRpb24gPSBkb3ROb3RhdGlvbiB8fCBmYWxzZTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0XG4gICAgaWYgKCFpc0FycmF5KGRpbWVuc2lvbnMpXG4gICAgICAgIHx8ICFkaW1lbnNpb25zLmV2ZXJ5KGZ1bmN0aW9uIChyYW5nZSkge3JldHVybiByYW5nZSAmJiByYW5nZS5pc05vZGU7fSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgTm9kZXMgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImRpbWVuc2lvbnNcIicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb3ROb3RhdGlvbiAmJiAhdGhpcy5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZG90Tm90YXRpb24gb25seSBhcHBsaWNhYmxlIGZvciBvYmplY3QgcHJvcGVydGllcycpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdjMsIHJlbW92ZSBzb21lIGRheVxuICAgIHZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBgSW5kZXhOb2RlLm9iamVjdGAgaXMgZGVwcmVjYXRlZCwgdXNlIGBJbmRleE5vZGUuZm5gIGluc3RlYWQnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnb2JqZWN0JywgeyBnZXQ6IGRlcHJlY2F0ZWQsIHNldDogZGVwcmVjYXRlZCB9KTtcbiAgfVxuXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUudHlwZSA9ICdJbmRleE5vZGUnO1xuXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuaXNJbmRleE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIGFsbCByYW5nZSBub2Rlc1xuICAgKlxuICAgKiBXaGVuIHNvbWUgb2YgdGhlIGRpbWVuc2lvbnMgaGFzIGBlbmRgIGRlZmluZWQsIHRoZSBJbmRleE5vZGUgcmVxdWlyZXNcbiAgICogYSB2YXJpYWJsZSBgc2l6ZWAgdG8gYmUgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBjbG9zdXJlLCBhbmQgbXVzdCBjb250YWluXG4gICAqIHRoZSBzaXplIG9mIHRoZSBtYXRyaXggdGhhdCdzIGJlaW5nIGhhbmRsZWQuIFRvIGNoZWNrIHdoZXRoZXIgdGhlIGBzaXplYFxuICAgKiB2YXJpYWJsZSBpcyBuZWVkZWQsIGNhbGwgSW5kZXhOb2RlLm5lZWRzU2l6ZSgpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgICAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgICAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvZGVcbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoZGVmcywgYXJncykge1xuICAgIC8vIGFyZ3MgY2FuIGJlIG11dGF0ZWQgYnkgSW5kZXhOb2RlLCB3aGVuIGRpbWVuc2lvbnMgdXNlIGBlbmRgXG4gICAgdmFyIGNoaWxkQXJncyA9IE9iamVjdC5jcmVhdGUoYXJncyk7XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgUmFuZ2UgZnJvbSBzdGFydCwgc3RlcCBhbmQgZW5kXG4gICAgZGVmcy5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKFxuICAgICAgICAgIChzdGFydCAmJiBzdGFydC5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgPyBzdGFydC50b051bWJlcigpIDogc3RhcnQsXG4gICAgICAgICAgKGVuZCAgICYmIGVuZC5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgICA/IGVuZC50b051bWJlcigpICAgOiBlbmQsXG4gICAgICAgICAgKHN0ZXAgICYmIHN0ZXAuaXNCaWdOdW1iZXIgPT09IHRydWUpICA/IHN0ZXAudG9OdW1iZXIoKSAgOiBzdGVwXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYmlnbnVtYmVyIChjdXJyZW50bHkgYmlnbnVtYmVycyBhcmUgc2lsZW50bHlcbiAgICAvLyAgICAgICByZWR1Y2VkIHRvIG51bWJlcnMgd2hlbiBjaGFuZ2luZyB0aGUgdmFsdWUgdG8gemVyby1iYXNlZClcblxuICAgIC8vIFRPRE86IE9wdGltaXphdGlvbjogd2hlbiB0aGUgcmFuZ2UgdmFsdWVzIGFyZSBDb25zdGFudE5vZGVzLFxuICAgIC8vICAgICAgIHdlIGNhbiBiZWZvcmVoYW5kIHJlc29sdmUgdGhlIHplcm8tYmFzZWQgdmFsdWVcblxuICAgIC8vIG9wdGltaXphdGlvbiBmb3IgYSBzaW1wbGUgb2JqZWN0IHByb3BlcnR5XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChyYW5nZSwgaSkge1xuICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmlzUmFuZ2VOb2RlKSB7XG4gICAgICAgIGlmIChyYW5nZS5uZWVkc0VuZCgpKSB7XG4gICAgICAgICAgY2hpbGRBcmdzLmVuZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyByZXNvbHZlIGVuZCBhbmQgY3JlYXRlIHJhbmdlXG4gICAgICAgICAgcmV0dXJuICcoZnVuY3Rpb24gKCkgeycgK1xuICAgICAgICAgICAgICAndmFyIGVuZCA9IHNpemVbJyArIGkgKyAnXTsgJyArXG4gICAgICAgICAgICAgICdyZXR1cm4gcmFuZ2UoJyArXG4gICAgICAgICAgICAgIHJhbmdlLnN0YXJ0Ll9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgKyAnLCAnICtcbiAgICAgICAgICAgICAgcmFuZ2UuZW5kLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgKyAnLCAnICtcbiAgICAgICAgICAgICAgKHJhbmdlLnN0ZXAgPyByYW5nZS5zdGVwLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgOiAnMScpICtcbiAgICAgICAgICAgICAgJyk7ICcgK1xuICAgICAgICAgICAgICAnfSkoKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHJhbmdlXG4gICAgICAgICAgcmV0dXJuICdyYW5nZSgnICtcbiAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKSArICcsICcgK1xuICAgICAgICAgICAgICByYW5nZS5lbmQuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKSArICcsICcgK1xuICAgICAgICAgICAgICAocmFuZ2Uuc3RlcCA/IHJhbmdlLnN0ZXAuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKSA6ICcxJykgK1xuICAgICAgICAgICAgICAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZS5pc1N5bWJvbE5vZGUgJiYgcmFuZ2UubmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgY2hpbGRBcmdzLmVuZCA9IHRydWU7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSB0aGUgcGFyYW1ldGVyICdlbmQnXG4gICAgICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsnICtcbiAgICAgICAgICAgICd2YXIgZW5kID0gc2l6ZVsnICsgaSArICddOyAnICtcbiAgICAgICAgICAgICdyZXR1cm4gJyArIHJhbmdlLl9jb21waWxlKGRlZnMsIGNoaWxkQXJncykgKyAnOyAnICtcbiAgICAgICAgICAgICd9KSgpJ1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIENvbnN0YW50Tm9kZVxuICAgICAgICByZXR1cm4gcmFuZ2UuX2NvbXBpbGUoZGVmcywgY2hpbGRBcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAnbWF0aC5pbmRleCgnICsgZGltZW5zaW9ucy5qb2luKCcsICcpICsgJyknO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBJbmRleE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2sodGhpcy5kaW1lbnNpb25zW2ldLCAnZGltZW5zaW9uc1snICsgaSArICddJywgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSW5kZXhOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtJbmRleE5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBJbmRleE5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBkaW1lbnNpb25zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpbWVuc2lvbnNbaV0gPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5kaW1lbnNpb25zW2ldLCAnZGltZW5zaW9uc1snICsgaSArICddJywgdGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW5kZXhOb2RlKGRpbWVuc2lvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge0luZGV4Tm9kZX1cbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJbmRleE5vZGUodGhpcy5kaW1lbnNpb25zLnNsaWNlKDApKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoaXMgSW5kZXhOb2RlIGNvbnRhaW5zIGEgc2luZ2xlIHByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUuaXNPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0aGlzLmRpbWVuc2lvbnNbMF0uaXNDb25zdGFudE5vZGUgJiZcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zWzBdLnZhbHVlVHlwZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3BlcnR5IG5hbWUgaWYgSW5kZXhOb2RlIGNvbnRhaW5zIGEgcHJvcGVydHkuXG4gICAqIElmIG5vdCwgcmV0dXJucyBudWxsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgSW5kZXhOb2RlLnByb3RvdHlwZS5nZXRPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc09iamVjdFByb3BlcnR5KCkgPyB0aGlzLmRpbWVuc2lvbnNbMF0udmFsdWUgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBJbmRleE5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gZm9ybWF0IHRoZSBwYXJhbWV0ZXJzIGxpa2UgXCJbMSwgMDo1XVwiXG4gICAgcmV0dXJuIHRoaXMuZG90Tm90YXRpb25cbiAgICAgICAgPyAoJy4nICsgdGhpcy5nZXRPYmplY3RQcm9wZXJ0eSgpKVxuICAgICAgICA6ICgnWycgKyB0aGlzLmRpbWVuc2lvbnMuam9pbignLCAnKSArICddJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgSW5kZXhOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZS50b1RleChvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmRvdE5vdGF0aW9uXG4gICAgICAgID8gKCcuJyArIHRoaXMuZ2V0T2JqZWN0UHJvcGVydHkoKSArICcnKVxuICAgICAgICA6ICgnX3snICsgZGltZW5zaW9ucy5qb2luKCcsJykgKyAnfScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhpcyBJbmRleE5vZGUgbmVlZHMgdGhlIG9iamVjdCBzaXplLCBzaXplIG9mIHRoZSBNYXRyaXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIEluZGV4Tm9kZS5wcm90b3R5cGUubmVlZHNTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHJldHVybiAocmFuZ2UuaXNSYW5nZU5vZGUgJiYgcmFuZ2UubmVlZHNFbmQoKSkgfHxcbiAgICAgICAgICAocmFuZ2UuaXNTeW1ib2xOb2RlICYmIHJhbmdlLm5hbWUgPT09ICdlbmQnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSW5kZXhOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnSW5kZXhOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXdvcmRzID0gcmVxdWlyZSgnLi4va2V5d29yZHMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5leHRlbmQ7XG52YXIgZGVlcEVxdWFsPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5kZWVwRXF1YWw7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQsIG1hdGgpIHtcbiAgLyoqXG4gICAqIE5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAgU2NvcGUgdG8gcmVhZC93cml0ZSB2YXJpYWJsZXNcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgIFJldHVybnMgdGhlIHJlc3VsdFxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZSgpLmV2YWwoc2NvcGUpO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLnR5cGUgPSAnTm9kZSc7XG5cbiAgTm9kZS5wcm90b3R5cGUuaXNOb2RlID0gdHJ1ZTtcblxuICBOb2RlLnByb3RvdHlwZS5jb21tZW50ID0gJyc7XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqIEByZXR1cm4ge3tldmFsOiBmdW5jdGlvbn19IGV4cHIgIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBmdW5jdGlvbiAnZXZhbCcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGNhbiBiZSBpbnZva2VkIGFzIGV4cHIuZXZhbChbc2NvcGVdKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUgc2NvcGUgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzLlxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBjYWxsaW5nIGNvbXBpbGUobWF0aCkgaXMgZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMC4wLiBSZW1vdmUgdGhpcyB3YXJuaW5nIHNvbWUgZGF5XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgY29tcGlsZShtYXRoKSBpcyBkZXByZWNhdGVkLiBDYWxsIHRoZSBmdW5jdGlvbiBhcyBjb21waWxlKCkgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICAvLyBkZWZpbml0aW9ucyBnbG9iYWxseSBhdmFpbGFibGUgaW5zaWRlIHRoZSBjbG9zdXJlIG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uc1xuICAgIHZhciBkZWZzID0ge1xuICAgICAgbWF0aDogbWF0aC5leHByZXNzaW9uLnRyYW5zZm9ybSxcbiAgICAgIGFyZ3M6IHt9LCAvLyBjYW4gYmUgZmlsbGVkIHdpdGggbmFtZXMgb2YgRnVuY3Rpb25Bc3NpZ25tZW50IGFyZ3VtZW50c1xuICAgICAgX3ZhbGlkYXRlU2NvcGU6IF92YWxpZGF0ZVNjb3BlXG4gICAgfTtcblxuICAgIC8vIHdpbGwgYmUgdXNlZCB0byBwdXQgbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgdmFyIGFyZ3MgPSB7fTtcblxuICAgIHZhciBjb2RlID0gdGhpcy5fY29tcGlsZShkZWZzLCBhcmdzKTtcblxuICAgIHZhciBkZWZzQ29kZSA9IE9iamVjdC5rZXlzKGRlZnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgICAgdmFyICcgKyBuYW1lICsgJyA9IGRlZnNbXCInICsgbmFtZSArICdcIl07JztcbiAgICB9KTtcblxuICAgIHZhciBmYWN0b3J5Q29kZSA9XG4gICAgICAgIGRlZnNDb2RlLmpvaW4oJyAnKSArXG4gICAgICAgICdyZXR1cm4geycgK1xuICAgICAgICAnICBcImV2YWxcIjogZnVuY3Rpb24gKHNjb3BlKSB7JyArXG4gICAgICAgICcgICAgaWYgKHNjb3BlKSBfdmFsaWRhdGVTY29wZShzY29wZSk7JyArXG4gICAgICAgICcgICAgc2NvcGUgPSBzY29wZSB8fCB7fTsnICtcbiAgICAgICAgJyAgICByZXR1cm4gJyArIGNvZGUgKyAnOycgK1xuICAgICAgICAnICB9JyArXG4gICAgICAgICd9Oyc7XG5cbiAgICB2YXIgZmFjdG9yeSA9IG5ldyBGdW5jdGlvbignZGVmcycsIGZhY3RvcnlDb2RlKTtcbiAgICByZXR1cm4gZmFjdG9yeShkZWZzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGUgbm9kZSB0byBqYXZhc2NyaXB0IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29uc3RhbnRzIGdsb2JhbGx5IGF2YWlsYWJsZSBpbnNpZGUgdGhlIGNsb3N1cmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzICAgICBPYmplY3Qgd2l0aCBsb2NhbCBmdW5jdGlvbiBhcmd1bWVudHMsIHRoZSBrZXkgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCwgYW5kIHRoZSB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IG1heSBub3QgYmUgbXV0YXRlZCwgYnV0IG11c3QgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30ganNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIE5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE5vZGUgaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGlsZSBhIE5vZGUgaW50ZXJmYWNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIE5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE5vZGUgaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcnVuIGZvckVhY2ggb24gYSBOb2RlIGludGVyZmFjZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpOiBOb2RlfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfSBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgY29weSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBOb2RlIGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJ1biBtYXAgb24gYSBOb2RlIGludGVyZmFjZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIE5vZGUsIGZvciB1c2Ugd2l0aCBtYXBcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm5zIHtOb2RlfSBSZXR1cm5zIHRoZSBpbnB1dCBpZiBpdCdzIGEgbm9kZSwgZWxzZSB0aHJvd3MgYW4gRXJyb3JcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuX2lmTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCEobm9kZSAmJiBub2RlLmlzTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhbGxiYWNrIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgTm9kZScpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbGwgbm9kZXMgaW4gYSBub2RlIHRyZWUuIEV4ZWN1dGVzIGdpdmVuIGNhbGxiYWNrIGZvclxuICAgKiB0aGlzIG5vZGUgYW5kIGVhY2ggb2YgaXRzIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5vZGU6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICogICAgICAgICAgQSBjYWxsYmFjayBjYWxsZWQgZm9yIGV2ZXJ5IG5vZGUgaW4gdGhlIG5vZGUgdHJlZS5cbiAgICovXG4gIE5vZGUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gZXhlY3V0ZSBjYWxsYmFjayBmb3IgaXRzZWxmXG4gICAgY2FsbGJhY2sodGhpcywgbnVsbCwgbnVsbCk7XG5cbiAgICAvLyByZWN1cnNpdmVseSB0cmF2ZXJzZSBvdmVyIGFsbCBjaGlsZHMgb2YgYSBub2RlXG4gICAgZnVuY3Rpb24gX3RyYXZlcnNlKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBwYXRoLCBwYXJlbnQpIHtcbiAgICAgICAgY2FsbGJhY2soY2hpbGQsIHBhdGgsIHBhcmVudCk7XG4gICAgICAgIF90cmF2ZXJzZShjaGlsZCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3RyYXZlcnNlKHRoaXMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgdHJhbnNmb3JtIGEgbm9kZSB0cmVlIHZpYSBhIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHRvIHJlcGxhY2UgYWxsIG5vZGVzIG9mIHR5cGUgU3ltYm9sTm9kZSBoYXZpbmcgbmFtZSAneCcgd2l0aCBhXG4gICAqIENvbnN0YW50Tm9kZSB3aXRoIHZhbHVlIDI6XG4gICAqXG4gICAqICAgICB2YXIgcmVzID0gTm9kZS50cmFuc2Zvcm0oZnVuY3Rpb24gKG5vZGUsIHBhdGgsIHBhcmVudCkge1xuICAgKiAgICAgICBpZiAobm9kZSAmJiBub2RlLmlzU3ltYm9sTm9kZSkgJiYgKG5vZGUubmFtZSA9PSAneCcpKSB7XG4gICAqICAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudE5vZGUoMik7XG4gICAqICAgICAgIH1cbiAgICogICAgICAgZWxzZSB7XG4gICAqICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5vZGU6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKSA6IE5vZGV9IGNhbGxiYWNrXG4gICAqICAgICAgICAgIEEgbWFwcGluZyBmdW5jdGlvbiBhY2NlcHRpbmcgYSBub2RlLCBhbmQgcmV0dXJuaW5nXG4gICAqICAgICAgICAgIGEgcmVwbGFjZW1lbnQgZm9yIHRoZSBub2RlIG9yIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiAgICAgICAgICBTaWduYXR1cmU6IGNhbGxiYWNrKG5vZGU6IE5vZGUsIGluZGV4OiBzdHJpbmcsIHBhcmVudDogTm9kZSkgOiBOb2RlXG4gICAqIEByZXR1cm4ge05vZGV9IFJldHVybnMgdGhlIG9yaWdpbmFsIG5vZGUgb3IgaXRzIHJlcGxhY2VtZW50XG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyB0cmF2ZXJzZSBvdmVyIGFsbCBjaGlsZHNcbiAgICBmdW5jdGlvbiBfdHJhbnNmb3JtIChub2RlLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5vZGUubWFwKGZ1bmN0aW9uKGNoaWxkLCBwYXRoLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gY2FsbGJhY2soY2hpbGQsIHBhdGgsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiBfdHJhbnNmb3JtKHJlcGxhY2VtZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBjYWxsYmFjayh0aGlzLCBudWxsLCBudWxsKTtcbiAgICByZXR1cm4gX3RyYW5zZm9ybShyZXBsYWNlbWVudCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGFueSBub2RlIGluIHRoZSBub2RlIHRyZWUgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgdG9cbiAgICogZmluZCBhbGwgbm9kZXMgb2YgdHlwZSBTeW1ib2xOb2RlIGhhdmluZyBuYW1lICd4JzpcbiAgICpcbiAgICogICAgIHZhciByZXN1bHRzID0gTm9kZS5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICogICAgICAgcmV0dXJuIChub2RlICYmIG5vZGUuaXNTeW1ib2xOb2RlKSAmJiAobm9kZS5uYW1lID09ICd4Jyk7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihub2RlOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSkgOiBOb2RlfSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgIEEgdGVzdCBmdW5jdGlvbiByZXR1cm5pbmcgdHJ1ZSB3aGVuIGEgbm9kZSBtYXRjaGVzLCBhbmQgZmFsc2VcbiAgICogICAgICAgICAgICBvdGhlcndpc2UuIEZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICogICAgICAgICAgICBjYWxsYmFjayhub2RlOiBOb2RlLCBpbmRleDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpIDogYm9vbGVhblxuICAgKiBAcmV0dXJuIHtOb2RlW119IG5vZGVzICAgICAgIEFuIGFycmF5IHdpdGggbm9kZXMgbWF0Y2hpbmcgZ2l2ZW4gZmlsdGVyIGNyaXRlcmlhXG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcblxuICAgIHRoaXMudHJhdmVyc2UoZnVuY3Rpb24gKG5vZGUsIHBhdGgsIHBhcmVudCkge1xuICAgICAgaWYgKGNhbGxiYWNrKG5vZGUsIHBhdGgsIHBhcmVudCkpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfTtcblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjAsIHJlbW92ZSB0aGlzIHNvbWUgZGF5XG4gIE5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBOb2RlLmZpbmQgaXMgZGVwcmVjYXRlZC4gVXNlIE5vZGUuZmlsdGVyIGluc3RlYWQuJyk7XG4gIH07XG5cbiAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMS4wLCByZW1vdmUgdGhpcyBzb21lIGRheVxuICBOb2RlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIE5vZGUubWF0Y2ggaXMgZGVwcmVjYXRlZC4gU2VlIGZ1bmN0aW9ucyBOb2RlLmZpbHRlciwgTm9kZS50cmFuc2Zvcm0sIE5vZGUudHJhdmVyc2UuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgdGhpcyBub2RlXG4gICAqIEByZXR1cm4ge05vZGV9XG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE5vZGUgaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2xvbmUgYSBOb2RlIGludGVyZmFjZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkZWVwIGNsb25lIG9mIHRoaXMgbm9kZVxuICAgKiBAcmV0dXJuIHtOb2RlfVxuICAgKi9cbiAgTm9kZS5wcm90b3R5cGUuY2xvbmVEZWVwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xvbmVEZWVwKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZXAgY29tcGFyZSB0aGlzIG5vZGUgd2l0aCBhbm90aGVyIG5vZGUuXG4gICAqIEBwYXJhbSB7Tm9kZX0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gYm90aCBub2RlcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgY29udGFpbiB0aGUgc2FtZSB2YWx1ZXMgKGFzIGRvIHRoZWlyIGNoaWxkcylcbiAgICovXG4gIE5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlclxuICAgICAgICA/IGRlZXBFcXVhbCh0aGlzLCBvdGhlcilcbiAgICAgICAgOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAod3JhcHBlciBmdW5jdGlvbilcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gZ2V0IGFuIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAqIHtcbiAgICogICAgaGFuZGxlcjogLy9UaGlzIGNhbiBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIG9mIHRoZSBmb3JtXG4gICAqICAgICAgICAgICAgIC8vIFwiZnVuY3Rpb24gY2FsbGJhY2sobm9kZSwgb3B0aW9ucylcIm9yXG4gICAqICAgICAgICAgICAgIC8vIGEgbWFwIHRoYXQgbWFwcyBmdW5jdGlvbiBuYW1lcyAodXNlZCBpbiBGdW5jdGlvbk5vZGVzKVxuICAgKiAgICAgICAgICAgICAvLyB0byBjYWxsYmFja3NcbiAgICogICAgcGFyZW50aGVzaXM6IFwia2VlcFwiIC8vdGhlIHBhcmVudGhlc2lzIG9wdGlvbiAoVGhpcyBpcyBvcHRpb25hbClcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY3VzdG9tU3RyaW5nO1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucy5oYW5kbGVyKSB7XG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgY3VzdG9tU3RyaW5nID0gb3B0aW9ucy5oYW5kbGVyKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBvciBmdW5jdGlvbiBleHBlY3RlZCBhcyBjYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21TdHJpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY3VzdG9tU3RyaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90b1N0cmluZyhvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHN0cmluZyBvdXRwdXQuXG4gICAqIFRoaXMgaGFzIHRvIGJlIGltcGxlbWVudGVkIGJ5IGV2ZXJ5IE5vZGVcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9tdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggb2YgdGhlIE5vZGUgaW1wbGVtZW50YXRpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKCdfdG9TdHJpbmcgbm90IGltcGxlbWVudGVkIGZvciAnICsgdGhpcy50eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uLiAod3JhcHBlciBmdW5jdGlvbilcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gZ2V0IGFuIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAqIHtcbiAgICogICAgaGFuZGxlcjogLy9UaGlzIGNhbiBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIG9mIHRoZSBmb3JtXG4gICAqICAgICAgICAgICAgIC8vIFwiZnVuY3Rpb24gY2FsbGJhY2sobm9kZSwgb3B0aW9ucylcIm9yXG4gICAqICAgICAgICAgICAgIC8vIGEgbWFwIHRoYXQgbWFwcyBmdW5jdGlvbiBuYW1lcyAodXNlZCBpbiBGdW5jdGlvbk5vZGVzKVxuICAgKiAgICAgICAgICAgICAvLyB0byBjYWxsYmFja3NcbiAgICogICAgcGFyZW50aGVzaXM6IFwia2VlcFwiIC8vdGhlIHBhcmVudGhlc2lzIG9wdGlvbiAoVGhpcyBpcyBvcHRpb25hbClcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIE5vZGUucHJvdG90eXBlLnRvVGV4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY3VzdG9tVGV4O1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBvcHRpb25zLmhhbmRsZXIpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgIGN1c3RvbVRleCA9IG9wdGlvbnMuaGFuZGxlcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qgb3IgZnVuY3Rpb24gZXhwZWN0ZWQgYXMgY2FsbGJhY2snKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbVRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBjdXN0b21UZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RvVGV4KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgTGFUZVggb3V0cHV0LlxuICAgKiBUaGlzIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBldmVyeSBOb2RlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIG9mIHRoZSBOb2RlIGltcGxlbWVudGF0aW9uc1xuICAgIHRocm93IG5ldyBFcnJvcignX3RvVGV4IG5vdCBpbXBsZW1lbnRlZCBmb3IgJyArIHRoaXMudHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBOb2RlLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudCBOb2RlLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqKi9cbiAgTm9kZS5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIHN5bWJvbCBuYW1lcyBvZiBhIHNjb3BlLlxuICAgKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiB0aGUgc2NvcGUgY29udGFpbnMgYW4gaWxsZWdhbCBzeW1ib2wuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgKi9cbiAgZnVuY3Rpb24gX3ZhbGlkYXRlU2NvcGUoc2NvcGUpIHtcbiAgICBmb3IgKHZhciBzeW1ib2wgaW4gc2NvcGUpIHtcbiAgICAgIGlmIChzY29wZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2wpKSB7XG4gICAgICAgIGlmIChzeW1ib2wgaW4ga2V5d29yZHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Njb3BlIGNvbnRhaW5zIGFuIGlsbGVnYWwgc3ltYm9sLCBcIicgKyBzeW1ib2wgKyAnXCIgaXMgYSByZXNlcnZlZCBrZXl3b3JkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ05vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLm1hdGggPSB0cnVlOyAvLyByZXF1ZXN0IGFjY2VzcyB0byB0aGUgbWF0aCBuYW1lc3BhY2UgYXMgNXRoIGFyZ3VtZW50IG9mIHRoZSBmYWN0b3J5IGZ1bmN0aW9uXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvc3RyaW5nJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIE5vZGUgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIE9iamVjdE5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEhvbGRzIGFuIG9iamVjdCB3aXRoIGtleXMvdmFsdWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIE5vZGU+fSBbcHJvcGVydGllc10gICBhcnJheSB3aXRoIGtleS92YWx1ZSBwYWlyc1xuICAgKi9cbiAgZnVuY3Rpb24gT2JqZWN0Tm9kZShwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9iamVjdE5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoISh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ29iamVjdCcpIHx8IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICFwcm9wZXJ0aWVzW2tleV0gfHwgIXByb3BlcnRpZXNba2V5XS5pc05vZGU7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IGNvbnRhaW5pbmcgTm9kZXMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBPYmplY3ROb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbiAgT2JqZWN0Tm9kZS5wcm90b3R5cGUudHlwZSA9ICdPYmplY3ROb2RlJztcblxuICBPYmplY3ROb2RlLnByb3RvdHlwZS5pc09iamVjdE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIE9iamVjdE5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBlbnRyaWVzLnB1c2goJ1wiJyArIGtleSArICdcIjogJyArIHRoaXMucHJvcGVydGllc1trZXldLl9jb21waWxlKGRlZnMsIGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICd7JyArIGVudHJpZXMuam9pbignLCAnKSArICd9JztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgT2JqZWN0Tm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnByb3BlcnRpZXNba2V5XSwgJ3Byb3BlcnRpZXNbXCInICsga2V5ICsgJ1wiXScsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IE9iamVjdE5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdE5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBPYmplY3ROb2RlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5wcm9wZXJ0aWVzW2tleV0sICdwcm9wZXJ0aWVzW1wiJyArIGtleSArICdcIl0nLCB0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JqZWN0Tm9kZShwcm9wZXJ0aWVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtPYmplY3ROb2RlfVxuICAgKi9cbiAgT2JqZWN0Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB0aGlzLnByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYmplY3ROb2RlKHByb3BlcnRpZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgT2JqZWN0Tm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcykge1xuICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCgnXCInICsga2V5ICsgJ1wiOiAnICsgdGhpcy5wcm9wZXJ0aWVzW2tleV0udG9TdHJpbmcob3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3snICsgZW50cmllcy5qb2luKCcsICcpICsgJ30nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIE9iamVjdE5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBlbnRyaWVzLnB1c2goXCJcXFxcbWF0aGJme1wiICsga2V5ICsgJzp9ICYgJyArIHRoaXMucHJvcGVydGllc1trZXldLnRvVGV4KG9wdGlvbnMpICsgXCJcXFxcXFxcXFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdcXFxcbGVmdFxcXFx7XFxcXGJlZ2lue2FycmF5fXtsbH0nICsgZW50cmllcy5qb2luKCdcXG4nKSArICdcXFxcZW5ke2FycmF5fVxcXFxyaWdodFxcXFx9JztcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0Tm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ09iamVjdE5vZGUnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24ubm9kZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xudmFyIG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL29wZXJhdG9ycycpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBOb2RlICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vTm9kZScpKTtcbiAgdmFyIENvbnN0YW50Tm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Db25zdGFudE5vZGUnKSk7XG4gIHZhciBTeW1ib2xOb2RlICAgPSBsb2FkKHJlcXVpcmUoJy4vU3ltYm9sTm9kZScpKTtcbiAgdmFyIEZ1bmN0aW9uTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9GdW5jdGlvbk5vZGUnKSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBPcGVyYXRvck5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEFuIG9wZXJhdG9yIHdpdGggdHdvIGFyZ3VtZW50cywgbGlrZSAyKzNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wICAgICAgICAgICBPcGVyYXRvciBuYW1lLCBmb3IgZXhhbXBsZSAnKydcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuICAgICAgICAgICBGdW5jdGlvbiBuYW1lLCBmb3IgZXhhbXBsZSAnYWRkJ1xuICAgKiBAcGFyYW0ge05vZGVbXX0gYXJncyAgICAgICAgIE9wZXJhdG9yIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbXBsaWNpdF0gIElzIHRoaXMgYW4gaW1wbGljaXQgbXVsdGlwbGljYXRpb24/XG4gICAqL1xuICBmdW5jdGlvbiBPcGVyYXRvck5vZGUob3AsIGZuLCBhcmdzLCBpbXBsaWNpdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRvck5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vdmFsaWRhdGUgaW5wdXRcbiAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJvcFwiJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImZuXCInKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpXG4gICAgICAgIHx8ICFhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChub2RlKSB7cmV0dXJuIG5vZGUgJiYgbm9kZS5pc05vZGU7fSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGNvbnRhaW5pbmcgTm9kZXMgZXhwZWN0ZWQgZm9yIHBhcmFtZXRlciBcImFyZ3NcIicpO1xuICAgIH1cblxuICAgIHRoaXMuaW1wbGljaXQgPSAoaW1wbGljaXQgPT09IHRydWUpO1xuICAgIHRoaXMub3AgPSBvcDtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5hcmdzID0gYXJncyB8fCBbXTtcbiAgfVxuXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUudHlwZSA9ICdPcGVyYXRvck5vZGUnO1xuXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUuaXNPcGVyYXRvck5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBPcGVyYXRvck5vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICBpZiAoIWRlZnMubWF0aFt0aGlzLmZuXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgdGhpcy5mbiArICcgbWlzc2luZyBpbiBwcm92aWRlZCBuYW1lc3BhY2UgXCJtYXRoXCInKTtcbiAgICB9XG5cbiAgICB2YXIganNBcmdzID0gdGhpcy5hcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnLl9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICdtYXRoLicgKyB0aGlzLmZuICsgJygnICsganNBcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLmFyZ3NbaV0sICdhcmdzWycgKyBpICsgJ10nLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBPcGVyYXRvck5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKTogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09wZXJhdG9yTm9kZX0gUmV0dXJucyBhIHRyYW5zZm9ybWVkIGNvcHkgb2YgdGhlIG5vZGVcbiAgICovXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IHRoaXMuX2lmTm9kZShjYWxsYmFjayh0aGlzLmFyZ3NbaV0sICdhcmdzWycgKyBpICsgJ10nLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3BlcmF0b3JOb2RlKHRoaXMub3AsIHRoaXMuZm4sIGFyZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge09wZXJhdG9yTm9kZX1cbiAgICovXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvck5vZGUodGhpcy5vcCwgdGhpcy5mbiwgdGhpcy5hcmdzLnNsaWNlKDApLCB0aGlzLmltcGxpY2l0KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHdoaWNoIHBhcmVudGhlc2VzIGFyZSBuZWNlc3NhcnkuIEdldHMgYW4gT3BlcmF0b3JOb2RlXG4gICAqICh3aGljaCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSkgYW5kIGFuIEFycmF5IG9mIE5vZGVzXG4gICAqICh0aGlzLmFyZ3MpIGFuZCByZXR1cm5zIGFuIGFycmF5IHdoZXJlICd0cnVlJyBtZWFucyB0aGF0IGFuIGFyZ3VtZW50XG4gICAqIGhhcyB0byBiZSBlbmNsb3NlZCBpbiBwYXJlbnRoZXNlcyB3aGVyZWFzICdmYWxzZScgbWVhbnMgdGhlIG9wcG9zaXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09wZXJhdG9yTm9kZX0gcm9vdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50aGVzaXNcbiAgICogQHBhcmFtIHtOb2RlW119IGFyZ3NcbiAgICogQHBhcmFtIHtib29sZWFufSBsYXRleFxuICAgKiBAcmV0dXJuIHtib29sZWFuW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVOZWNlc3NhcnlQYXJlbnRoZXNlcyhyb290LCBwYXJlbnRoZXNpcywgYXJncywgbGF0ZXgpIHtcbiAgICAvL3ByZWNlZGVuY2Ugb2YgdGhlIHJvb3QgT3BlcmF0b3JOb2RlXG4gICAgdmFyIHByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShyb290LCBwYXJlbnRoZXNpcyk7XG4gICAgdmFyIGFzc29jaWF0aXZpdHkgPSBvcGVyYXRvcnMuZ2V0QXNzb2NpYXRpdml0eShyb290LCBwYXJlbnRoZXNpcyk7XG5cbiAgICBpZiAoKHBhcmVudGhlc2lzID09PSAnYWxsJykgfHwgKChhcmdzLmxlbmd0aCA+IDIpICYmIChyb290LmdldElkZW50aWZpZXIoKSAhPT0gJ09wZXJhdG9yTm9kZTphZGQnKSAmJiAocm9vdC5nZXRJZGVudGlmaWVyKCkgIT09ICdPcGVyYXRvck5vZGU6bXVsdGlwbHknKSkpIHtcbiAgICAgIHZhciBwYXJlbnMgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHN3aXRjaCAoYXJnLmdldENvbnRlbnQoKS50eXBlKSB7IC8vTm9kZXMgdGhhdCBkb24ndCBuZWVkIGV4dHJhIHBhcmVudGhlc2VzXG4gICAgICAgICAgY2FzZSAnQXJyYXlOb2RlJzpcbiAgICAgICAgICBjYXNlICdDb25zdGFudE5vZGUnOlxuICAgICAgICAgIGNhc2UgJ1N5bWJvbE5vZGUnOlxuICAgICAgICAgIGNhc2UgJ1BhcmVudGhlc2lzTm9kZSc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmVucztcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7IC8vdW5hcnkgb3BlcmF0b3JzXG4gICAgICAvL3ByZWNlZGVuY2Ugb2YgdGhlIG9wZXJhbmRcbiAgICAgIHZhciBvcGVyYW5kUHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKGFyZ3NbMF0sIHBhcmVudGhlc2lzKTtcblxuICAgICAgLy9oYW5kbGUgc3BlY2lhbCBjYXNlcyBmb3IgTGFUZVgsIHdoZXJlIHNvbWUgb2YgdGhlIHBhcmVudGhlc2VzIGFyZW4ndCBuZWVkZWRcbiAgICAgIGlmIChsYXRleCAmJiAob3BlcmFuZFByZWNlZGVuY2UgIT09IG51bGwpKSB7XG4gICAgICAgIHZhciBvcGVyYW5kSWRlbnRpZmllcjtcbiAgICAgICAgdmFyIHJvb3RJZGVudGlmaWVyO1xuICAgICAgICBpZiAocGFyZW50aGVzaXMgPT09ICdrZWVwJykge1xuICAgICAgICAgIG9wZXJhbmRJZGVudGlmaWVyID0gYXJnc1swXS5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgcm9vdElkZW50aWZpZXIgPSByb290LmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvL0lnbm9yZSBQYXJlbnRoZXNpcyBOb2RlcyB3aGVuIG5vdCBpbiAna2VlcCcgbW9kZVxuICAgICAgICAgIG9wZXJhbmRJZGVudGlmaWVyID0gYXJnc1swXS5nZXRDb250ZW50KCkuZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICAgIHJvb3RJZGVudGlmaWVyID0gcm9vdC5nZXRDb250ZW50KCkuZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVyYXRvcnMucHJvcGVydGllc1twcmVjZWRlbmNlXVtyb290SWRlbnRpZmllcl0ubGF0ZXhMZWZ0UGFyZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBbZmFsc2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZXJhdG9ycy5wcm9wZXJ0aWVzW29wZXJhbmRQcmVjZWRlbmNlXVtvcGVyYW5kSWRlbnRpZmllcl0ubGF0ZXhQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIFtmYWxzZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wZXJhbmRQcmVjZWRlbmNlID09PSBudWxsKSB7XG4gICAgICAgIC8vaWYgdGhlIG9wZXJhbmQgaGFzIG5vIGRlZmluZWQgcHJlY2VkZW5jZSwgbm8gcGFyZW5zIGFyZSBuZWVkZWRcbiAgICAgICAgcmV0dXJuIFtmYWxzZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYW5kUHJlY2VkZW5jZSA8PSBwcmVjZWRlbmNlKSB7XG4gICAgICAgIC8vaWYgdGhlIG9wZXJhbmRzIHByZWNlZGVuY2UgaXMgbG93ZXIsIHBhcmVucyBhcmUgbmVlZGVkXG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9XG5cbiAgICAgIC8vb3RoZXJ3aXNlLCBubyBwYXJlbnMgbmVlZGVkXG4gICAgICByZXR1cm4gW2ZhbHNlXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7IC8vYmluYXJ5IG9wZXJhdG9yc1xuICAgICAgdmFyIGxoc1BhcmVuczsgLy9sZWZ0IGhhbmQgc2lkZSBuZWVkcyBwYXJlbnRoZXNpcz9cbiAgICAgIC8vcHJlY2VkZW5jZSBvZiB0aGUgbGVmdCBoYW5kIHNpZGVcbiAgICAgIHZhciBsaHNQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UoYXJnc1swXSwgcGFyZW50aGVzaXMpO1xuICAgICAgLy9pcyB0aGUgcm9vdCBub2RlIGFzc29jaWF0aXZlIHdpdGggdGhlIGxlZnQgaGFuZCBzaWRlXG4gICAgICB2YXIgYXNzb2NXaXRoTGhzID0gb3BlcmF0b3JzLmlzQXNzb2NpYXRpdmVXaXRoKHJvb3QsIGFyZ3NbMF0sIHBhcmVudGhlc2lzKTtcblxuICAgICAgaWYgKGxoc1ByZWNlZGVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgLy9pZiB0aGUgbGVmdCBoYW5kIHNpZGUgaGFzIG5vIGRlZmluZWQgcHJlY2VkZW5jZSwgbm8gcGFyZW5zIGFyZSBuZWVkZWRcbiAgICAgICAgLy9GdW5jdGlvbk5vZGUgZm9yIGV4YW1wbGVcbiAgICAgICAgbGhzUGFyZW5zID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgobGhzUHJlY2VkZW5jZSA9PT0gcHJlY2VkZW5jZSkgJiYgKGFzc29jaWF0aXZpdHkgPT09ICdyaWdodCcpICYmICFhc3NvY1dpdGhMaHMpIHtcbiAgICAgICAgLy9JbiBjYXNlIG9mIGVxdWFsIHByZWNlZGVuY2UsIGlmIHRoZSByb290IG5vZGUgaXMgbGVmdCBhc3NvY2lhdGl2ZVxuICAgICAgICAvLyBwYXJlbnMgYXJlICoqbmV2ZXIqKiBuZWNlc3NhcnkgZm9yIHRoZSBsZWZ0IGhhbmQgc2lkZS5cbiAgICAgICAgLy9JZiBpdCBpcyByaWdodCBhc3NvY2lhdGl2ZSBob3dldmVyLCBwYXJlbnMgYXJlIG5lY2Vzc2FyeVxuICAgICAgICAvL2lmIHRoZSByb290IG5vZGUgaXNuJ3QgYXNzb2NpYXRpdmUgd2l0aCB0aGUgbGVmdCBoYW5kIHNpZGVcbiAgICAgICAgbGhzUGFyZW5zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxoc1ByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgIGxoc1BhcmVucyA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGhzUGFyZW5zID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByaHNQYXJlbnM7IC8vcmlnaHQgaGFuZCBzaWRlIG5lZWRzIHBhcmVudGhlc2lzP1xuICAgICAgLy9wcmVjZWRlbmNlIG9mIHRoZSByaWdodCBoYW5kIHNpZGVcbiAgICAgIHZhciByaHNQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2UoYXJnc1sxXSwgcGFyZW50aGVzaXMpO1xuICAgICAgLy9pcyB0aGUgcm9vdCBub2RlIGFzc29jaWF0aXZlIHdpdGggdGhlIHJpZ2h0IGhhbmQgc2lkZT9cbiAgICAgIHZhciBhc3NvY1dpdGhSaHMgPSBvcGVyYXRvcnMuaXNBc3NvY2lhdGl2ZVdpdGgocm9vdCwgYXJnc1sxXSwgcGFyZW50aGVzaXMpO1xuXG4gICAgICBpZiAocmhzUHJlY2VkZW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAvL2lmIHRoZSByaWdodCBoYW5kIHNpZGUgaGFzIG5vIGRlZmluZWQgcHJlY2VkZW5jZSwgbm8gcGFyZW5zIGFyZSBuZWVkZWRcbiAgICAgICAgLy9GdW5jdGlvbk5vZGUgZm9yIGV4YW1wbGVcbiAgICAgICAgcmhzUGFyZW5zID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgocmhzUHJlY2VkZW5jZSA9PT0gcHJlY2VkZW5jZSkgJiYgKGFzc29jaWF0aXZpdHkgPT09ICdsZWZ0JykgJiYgIWFzc29jV2l0aFJocykge1xuICAgICAgICAvL0luIGNhc2Ugb2YgZXF1YWwgcHJlY2VkZW5jZSwgaWYgdGhlIHJvb3Qgbm9kZSBpcyByaWdodCBhc3NvY2lhdGl2ZVxuICAgICAgICAvLyBwYXJlbnMgYXJlICoqbmV2ZXIqKiBuZWNlc3NhcnkgZm9yIHRoZSByaWdodCBoYW5kIHNpZGUuXG4gICAgICAgIC8vSWYgaXQgaXMgbGVmdCBhc3NvY2lhdGl2ZSBob3dldmVyLCBwYXJlbnMgYXJlIG5lY2Vzc2FyeVxuICAgICAgICAvL2lmIHRoZSByb290IG5vZGUgaXNuJ3QgYXNzb2NpYXRpdmUgd2l0aCB0aGUgcmlnaHQgaGFuZCBzaWRlXG4gICAgICAgIHJoc1BhcmVucyA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyaHNQcmVjZWRlbmNlIDwgcHJlY2VkZW5jZSkge1xuICAgICAgICByaHNQYXJlbnMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJoc1BhcmVucyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2hhbmRsZSBzcGVjaWFsIGNhc2VzIGZvciBMYVRlWCwgd2hlcmUgc29tZSBvZiB0aGUgcGFyZW50aGVzZXMgYXJlbid0IG5lZWRlZFxuICAgICAgaWYgKGxhdGV4KSB7XG4gICAgICAgIHZhciByb290SWRlbnRpZmllcjtcbiAgICAgICAgdmFyIGxoc0lkZW50aWZpZXI7XG4gICAgICAgIHZhciByaHNJZGVudGlmaWVyO1xuICAgICAgICBpZiAocGFyZW50aGVzaXMgPT09ICdrZWVwJykge1xuICAgICAgICAgIHJvb3RJZGVudGlmaWVyID0gcm9vdC5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgbGhzSWRlbnRpZmllciA9IHJvb3QuYXJnc1swXS5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgcmhzSWRlbnRpZmllciA9IHJvb3QuYXJnc1sxXS5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy9JZ25vcmUgUGFyZW50aGVzaXNOb2RlcyB3aGVuIG5vdCBpbiAna2VlcCcgbW9kZVxuICAgICAgICAgIHJvb3RJZGVudGlmaWVyID0gcm9vdC5nZXRDb250ZW50KCkuZ2V0SWRlbnRpZmllcigpO1xuICAgICAgICAgIGxoc0lkZW50aWZpZXIgPSByb290LmFyZ3NbMF0uZ2V0Q29udGVudCgpLmdldElkZW50aWZpZXIoKTtcbiAgICAgICAgICByaHNJZGVudGlmaWVyID0gcm9vdC5hcmdzWzFdLmdldENvbnRlbnQoKS5nZXRJZGVudGlmaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGhzUHJlY2VkZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChvcGVyYXRvcnMucHJvcGVydGllc1twcmVjZWRlbmNlXVtyb290SWRlbnRpZmllcl0ubGF0ZXhMZWZ0UGFyZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbGhzUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wZXJhdG9ycy5wcm9wZXJ0aWVzW2xoc1ByZWNlZGVuY2VdW2xoc0lkZW50aWZpZXJdLmxhdGV4UGFyZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbGhzUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJoc1ByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAob3BlcmF0b3JzLnByb3BlcnRpZXNbcHJlY2VkZW5jZV1bcm9vdElkZW50aWZpZXJdLmxhdGV4UmlnaHRQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByaHNQYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3BlcmF0b3JzLnByb3BlcnRpZXNbcmhzUHJlY2VkZW5jZV1bcmhzSWRlbnRpZmllcl0ubGF0ZXhQYXJlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByaHNQYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtsaHNQYXJlbnMsIHJoc1BhcmVuc107XG4gICAgfSBlbHNlIGlmICgoYXJncy5sZW5ndGggPiAyKSAmJiAoKHJvb3QuZ2V0SWRlbnRpZmllcigpID09PSAnT3BlcmF0b3JOb2RlOmFkZCcpIHx8IChyb290LmdldElkZW50aWZpZXIoKSA9PT0gJ09wZXJhdG9yTm9kZTptdWx0aXBseScpKSkge1xuICAgICAgdmFyIHBhcmVuc0FycmF5ID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgYXJnUHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKGFyZywgcGFyZW50aGVzaXMpO1xuICAgICAgICB2YXIgYXNzb2NXaXRoQXJnID0gb3BlcmF0b3JzLmlzQXNzb2NpYXRpdmVXaXRoKHJvb3QsIGFyZywgcGFyZW50aGVzaXMpO1xuICAgICAgICB2YXIgYXJnQXNzb2NpYXRpdml0eSA9IG9wZXJhdG9ycy5nZXRBc3NvY2lhdGl2aXR5KGFyZywgcGFyZW50aGVzaXMpO1xuICAgICAgICBpZiAoYXJnUHJlY2VkZW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vaWYgdGhlIGFyZ3VtZW50IGhhcyBubyBkZWZpbmVkIHByZWNlZGVuY2UsIG5vIHBhcmVucyBhcmUgbmVlZGVkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKChwcmVjZWRlbmNlID09PSBhcmdQcmVjZWRlbmNlKSAmJiAoYXNzb2NpYXRpdml0eSA9PT0gYXJnQXNzb2NpYXRpdml0eSkgJiYgIWFzc29jV2l0aEFyZykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ1ByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJlbnNBcnJheTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50aGVzaXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSA/IG9wdGlvbnMucGFyZW50aGVzaXMgOiAna2VlcCc7XG4gICAgdmFyIGltcGxpY2l0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5pbXBsaWNpdCkgPyBvcHRpb25zLmltcGxpY2l0IDogJ2hpZGUnO1xuICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xuICAgIHZhciBwYXJlbnMgPSBjYWxjdWxhdGVOZWNlc3NhcnlQYXJlbnRoZXNlcyh0aGlzLCBwYXJlbnRoZXNpcywgYXJncywgZmFsc2UpO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7IC8vdW5hcnkgb3BlcmF0b3JzXG4gICAgICB2YXIgYXNzb2MgPSBvcGVyYXRvcnMuZ2V0QXNzb2NpYXRpdml0eSh0aGlzLCBwYXJlbnRoZXNpcyk7XG5cbiAgICAgIHZhciBvcGVyYW5kID0gYXJnc1swXS50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIGlmIChwYXJlbnNbMF0pIHtcbiAgICAgICAgb3BlcmFuZCA9ICcoJyArIG9wZXJhbmQgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChhc3NvYyA9PT0gJ3JpZ2h0JykgeyAvL3ByZWZpeCBvcGVyYXRvclxuICAgICAgICByZXR1cm4gdGhpcy5vcCArIG9wZXJhbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhc3NvYyA9PT0gJ2xlZnQnKSB7IC8vcG9zdGZpeFxuICAgICAgICByZXR1cm4gb3BlcmFuZCArIHRoaXMub3A7XG4gICAgICB9XG5cbiAgICAgIC8vZmFsbCBiYWNrIHRvIHBvc3RmaXhcbiAgICAgIHJldHVybiBvcGVyYW5kICsgdGhpcy5vcDtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09IDIpIHtcbiAgICAgIHZhciBsaHMgPSBhcmdzWzBdLnRvU3RyaW5nKG9wdGlvbnMpOyAvL2xlZnQgaGFuZCBzaWRlXG4gICAgICB2YXIgcmhzID0gYXJnc1sxXS50b1N0cmluZyhvcHRpb25zKTsgLy9yaWdodCBoYW5kIHNpZGVcbiAgICAgIGlmIChwYXJlbnNbMF0pIHsgLy9sZWZ0IGhhbmQgc2lkZSBpbiBwYXJlbnRoZXNpcz9cbiAgICAgICAgbGhzID0gJygnICsgbGhzICsgJyknO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVuc1sxXSkgeyAvL3JpZ2h0IGhhbmQgc2lkZSBpbiBwYXJlbnRoZXNpcz9cbiAgICAgICAgcmhzID0gJygnICsgcmhzICsgJyknO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbXBsaWNpdCAmJiAodGhpcy5nZXRJZGVudGlmaWVyKCkgPT09ICdPcGVyYXRvck5vZGU6bXVsdGlwbHknKSAmJiAoaW1wbGljaXQgPT0gJ2hpZGUnKSkge1xuICAgICAgICByZXR1cm4gbGhzICsgJyAnICsgcmhzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGhzICsgJyAnICsgdGhpcy5vcCArICcgJyArIHJocztcbiAgICB9IGVsc2UgaWYgKChhcmdzLmxlbmd0aCA+IDIpICYmICgodGhpcy5nZXRJZGVudGlmaWVyKCkgPT09ICdPcGVyYXRvck5vZGU6YWRkJykgfHwgKHRoaXMuZ2V0SWRlbnRpZmllcigpID09PSAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JykpKSB7XG4gICAgICB2YXIgc3RyaW5naWZpZWRBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgYXJnID0gYXJnLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgICBpZiAocGFyZW5zW2luZGV4XSkgeyAvL3B1dCBpbiBwYXJlbnRoZXNpcz9cbiAgICAgICAgICBhcmcgPSAnKCcgKyBhcmcgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmltcGxpY2l0ICYmICh0aGlzLmdldElkZW50aWZpZXIoKSA9PT0gJ09wZXJhdG9yTm9kZTptdWx0aXBseScpICYmIChpbXBsaWNpdCA9PT0gJ2hpZGUnKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZpZWRBcmdzLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkQXJncy5qb2luKCcgJyArIHRoaXMub3AgKyAnICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL2ZhbGxiYWNrIHRvIGZvcm1hdHRpbmcgYXMgYSBmdW5jdGlvbiBjYWxsXG4gICAgICByZXR1cm4gdGhpcy5mbiArICcoJyArIHRoaXMuYXJncy5qb2luKCcsICcpICsgJyknO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IExhVGVYIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBPcGVyYXRvck5vZGUucHJvdG90eXBlLl90b1RleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHBhcmVudGhlc2lzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRoZXNpcykgPyBvcHRpb25zLnBhcmVudGhlc2lzIDogJ2tlZXAnO1xuICAgIHZhciBpbXBsaWNpdCA9IChvcHRpb25zICYmIG9wdGlvbnMuaW1wbGljaXQpID8gb3B0aW9ucy5pbXBsaWNpdCA6ICdoaWRlJztcbiAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICB2YXIgcGFyZW5zID0gY2FsY3VsYXRlTmVjZXNzYXJ5UGFyZW50aGVzZXModGhpcywgcGFyZW50aGVzaXMsIGFyZ3MsIHRydWUpO1xuICAgIHZhciBvcCA9IGxhdGV4Lm9wZXJhdG9yc1t0aGlzLmZuXTtcbiAgICBvcCA9IHR5cGVvZiBvcCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wIDogb3A7IC8vZmFsbCBiYWNrIHRvIHVzaW5nIHRoaXMub3BcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkgeyAvL3VuYXJ5IG9wZXJhdG9yc1xuICAgICAgdmFyIGFzc29jID0gb3BlcmF0b3JzLmdldEFzc29jaWF0aXZpdHkodGhpcywgcGFyZW50aGVzaXMpO1xuXG4gICAgICB2YXIgb3BlcmFuZCA9IGFyZ3NbMF0udG9UZXgob3B0aW9ucyk7XG4gICAgICBpZiAocGFyZW5zWzBdKSB7XG4gICAgICAgIG9wZXJhbmQgPSAnXFxcXGxlZnQoJyArIG9wZXJhbmQgKyAnXFxcXHJpZ2h0KSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChhc3NvYyA9PT0gJ3JpZ2h0JykgeyAvL3ByZWZpeCBvcGVyYXRvclxuICAgICAgICByZXR1cm4gb3AgKyBvcGVyYW5kO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXNzb2MgPT09ICdsZWZ0JykgeyAvL3Bvc3RmaXggb3BlcmF0b3JcbiAgICAgICAgcmV0dXJuIG9wZXJhbmQgKyBvcDtcbiAgICAgIH1cblxuICAgICAgLy9mYWxsIGJhY2sgdG8gcG9zdGZpeFxuICAgICAgcmV0dXJuIG9wZXJhbmQgKyBvcDtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7IC8vYmluYXJ5IG9wZXJhdG9yc1xuICAgICAgdmFyIGxocyA9IGFyZ3NbMF07IC8vbGVmdCBoYW5kIHNpZGVcbiAgICAgIHZhciBsaHNUZXggPSBsaHMudG9UZXgob3B0aW9ucyk7XG4gICAgICBpZiAocGFyZW5zWzBdKSB7XG4gICAgICAgIGxoc1RleCA9ICdcXFxcbGVmdCgnICsgbGhzVGV4ICsgJ1xcXFxyaWdodCknO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmhzID0gYXJnc1sxXTsgLy9yaWdodCBoYW5kIHNpZGVcbiAgICAgIHZhciByaHNUZXggPSByaHMudG9UZXgob3B0aW9ucyk7XG4gICAgICBpZiAocGFyZW5zWzFdKSB7XG4gICAgICAgIHJoc1RleCA9ICdcXFxcbGVmdCgnICsgcmhzVGV4ICsgJ1xcXFxyaWdodCknO1xuICAgICAgfVxuXG4gICAgICAvL2hhbmRsZSBzb21lIGV4Y2VwdGlvbnMgKGR1ZSB0byB0aGUgd2F5IExhVGVYIHdvcmtzKVxuICAgICAgdmFyIGxoc0lkZW50aWZpZXI7XG4gICAgICBpZiAocGFyZW50aGVzaXMgPT09ICdrZWVwJykge1xuICAgICAgICBsaHNJZGVudGlmaWVyID0gbGhzLmdldElkZW50aWZpZXIoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvL0lnbm9yZSBQYXJlbnRoZXNpc05vZGVzIGlmIGluICdrZWVwJyBtb2RlXG4gICAgICAgIGxoc0lkZW50aWZpZXIgPSBsaHMuZ2V0Q29udGVudCgpLmdldElkZW50aWZpZXIoKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5nZXRJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgY2FzZSAnT3BlcmF0b3JOb2RlOmRpdmlkZSc6XG4gICAgICAgICAgLy9vcCBjb250YWlucyAnXFxcXGZyYWMnIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICByZXR1cm4gb3AgKyAneycgKyBsaHNUZXggKyAnfScgKyAneycgKyByaHNUZXggKyAnfSc7XG4gICAgICAgIGNhc2UgJ09wZXJhdG9yTm9kZTpwb3cnOlxuICAgICAgICAgIGxoc1RleCA9ICd7JyArIGxoc1RleCArICd9JztcbiAgICAgICAgICByaHNUZXggPSAneycgKyByaHNUZXggKyAnfSc7XG4gICAgICAgICAgc3dpdGNoIChsaHNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBjYXNlICdDb25kaXRpb25hbE5vZGUnOiAvL1xuICAgICAgICAgICAgY2FzZSAnT3BlcmF0b3JOb2RlOmRpdmlkZSc6XG4gICAgICAgICAgICAgIGxoc1RleCA9ICdcXFxcbGVmdCgnICsgbGhzVGV4ICsgJ1xcXFxyaWdodCknO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JzpcbiAgICAgICAgICBpZiAodGhpcy5pbXBsaWNpdCAmJiAoaW1wbGljaXQgPT09ICdoaWRlJykpIHtcbiAgICAgICAgICAgIHJldHVybiBsaHNUZXggKyAnficgKyByaHNUZXg7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxoc1RleCArIG9wICsgcmhzVGV4O1xuICAgIH0gZWxzZSBpZiAoKGFyZ3MubGVuZ3RoID4gMikgJiYgKCh0aGlzLmdldElkZW50aWZpZXIoKSA9PT0gJ09wZXJhdG9yTm9kZTphZGQnKSB8fCAodGhpcy5nZXRJZGVudGlmaWVyKCkgPT09ICdPcGVyYXRvck5vZGU6bXVsdGlwbHknKSkpIHtcbiAgICAgIHZhciB0ZXhpZmllZEFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnLCBpbmRleCkge1xuICAgICAgICBhcmcgPSBhcmcudG9UZXgob3B0aW9ucyk7XG4gICAgICAgIGlmIChwYXJlbnNbaW5kZXhdKSB7XG4gICAgICAgICAgYXJnID0gJ1xcXFxsZWZ0KCcgKyBhcmcgKyAnXFxcXHJpZ2h0KSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoKHRoaXMuZ2V0SWRlbnRpZmllcigpID09PSAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JykgJiYgdGhpcy5pbXBsaWNpdCkge1xuICAgICAgICByZXR1cm4gdGV4aWZpZWRBcmdzLmpvaW4oJ34nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleGlmaWVkQXJncy5qb2luKG9wKVxuICAgIH0gZWxzZSB7XG4gICAgICAvL2ZhbGwgYmFjayB0byBmb3JtYXR0aW5nIGFzIGEgZnVuY3Rpb24gY2FsbFxuICAgICAgLy9hcyB0aGlzIGlzIGEgZmFsbGJhY2ssIGl0IGRvZXNuJ3QgdXNlXG4gICAgICAvL2ZhbmN5IGZ1bmN0aW9uIG5hbWVzXG4gICAgICByZXR1cm4gJ1xcXFxtYXRocm17JyArIHRoaXMuZm4gKyAnfVxcXFxsZWZ0KCdcbiAgICAgICAgICArIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcudG9UZXgob3B0aW9ucyk7XG4gICAgICAgICAgfSkuam9pbignLCcpICsgJ1xcXFxyaWdodCknO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIE9wZXJhdG9yTm9kZS5wcm90b3R5cGUuZ2V0SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlICsgJzonICsgdGhpcy5mbjtcbiAgfTtcblxuICByZXR1cm4gT3BlcmF0b3JOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnT3BlcmF0b3JOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgLy8gcmVxdWVzdCBhY2Nlc3MgdG8gdGhlIG1hdGggbmFtZXNwYWNlIGFzIDV0aCBhcmd1bWVudCBvZiB0aGUgZmFjdG9yeSBmdW5jdGlvblxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgUGFyZW50aGVzaXNOb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKiBBIHBhcmVudGhlc2lzIG5vZGUgZGVzY3JpYmVzIG1hbnVhbCBwYXJlbnRoZXNpcyBmcm9tIHRoZSB1c2VyIGlucHV0XG4gICAqIEBwYXJhbSB7Tm9kZX0gY29udGVudFxuICAgKiBAZXh0ZW5kcyB7Tm9kZX1cbiAgICovXG4gIGZ1bmN0aW9uIFBhcmVudGhlc2lzTm9kZShjb250ZW50KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhcmVudGhlc2lzTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBpZiAoIShjb250ZW50ICYmIGNvbnRlbnQuaXNOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9kZSBleHBlY3RlZCBmb3IgcGFyYW1ldGVyIFwiY29udGVudFwiJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUudHlwZSA9ICdQYXJlbnRoZXNpc05vZGUnO1xuXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUuaXNQYXJlbnRoZXNpc05vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKGRlZnMsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Ll9jb21waWxlKGRlZnMsIGFyZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgTm9kZS5cbiAgICogQHJldHVybiB7Tm9kZX0gY29udGVudFxuICAgKiBAb3ZlcnJpZGVcbiAgICoqL1xuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5nZXRDb250ZW50KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZWFjaCBvZiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKX0gY2FsbGJhY2tcbiAgICovXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRoaXMuY29udGVudCwgJ2NvbnRlbnQnLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBhcmVudGhlc2lzTm9kZSBoYXZpbmcgaXQncyBjaGlsZHMgYmUgdGhlIHJlc3VsdHMgb2YgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGNoaWxkcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpIDogTm9kZX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1BhcmVudGhlc2lzTm9kZX0gUmV0dXJucyBhIGNsb25lIG9mIHRoZSBub2RlXG4gICAqL1xuICBQYXJlbnRoZXNpc05vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBjb250ZW50ID0gY2FsbGJhY2sodGhpcy5jb250ZW50LCAnY29udGVudCcsIHRoaXMpO1xuICAgIHJldHVybiBuZXcgUGFyZW50aGVzaXNOb2RlKGNvbnRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIG5vZGUsIGEgc2hhbGxvdyBjb3B5XG4gICAqIEByZXR1cm4ge1BhcmVudGhlc2lzTm9kZX1cbiAgICovXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFBhcmVudGhlc2lzTm9kZSh0aGlzLmNvbnRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgUGFyZW50aGVzaXNOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCghb3B0aW9ucykgfHwgKG9wdGlvbnMgJiYgIW9wdGlvbnMucGFyZW50aGVzaXMpIHx8IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMgPT09ICdrZWVwJykpIHtcbiAgICAgIHJldHVybiAnKCcgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmcob3B0aW9ucykgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIFBhcmVudGhlc2lzTm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMpIHx8IChvcHRpb25zICYmICFvcHRpb25zLnBhcmVudGhlc2lzKSB8fCAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzID09PSAna2VlcCcpKSB7XG4gICAgICByZXR1cm4gJ1xcXFxsZWZ0KCcgKyB0aGlzLmNvbnRlbnQudG9UZXgob3B0aW9ucykgKyAnXFxcXHJpZ2h0KSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQudG9UZXgob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcmVudGhlc2lzTm9kZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ1BhcmVudGhlc2lzTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9vcGVyYXRvcnMnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgUmFuZ2VOb2RlXG4gICAqIEBleHRlbmRzIHtOb2RlfVxuICAgKiBjcmVhdGUgYSByYW5nZVxuICAgKiBAcGFyYW0ge05vZGV9IHN0YXJ0ICBpbmNsdWRlZCBsb3dlci1ib3VuZFxuICAgKiBAcGFyYW0ge05vZGV9IGVuZCAgICBpbmNsdWRlZCB1cHBlci1ib3VuZFxuICAgKiBAcGFyYW0ge05vZGV9IFtzdGVwXSBvcHRpb25hbCBzdGVwXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZU5vZGUoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZU5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIGlmICghKHN0YXJ0ICYmIHN0YXJ0LmlzTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQnKTtcbiAgICBpZiAoIShlbmQgJiYgZW5kLmlzTm9kZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vZGUgZXhwZWN0ZWQnKTtcbiAgICBpZiAoc3RlcCAmJiAhKHN0ZXAgJiYgc3RlcC5pc05vZGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb2RlIGV4cGVjdGVkJyk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cycpO1xuXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0OyAgICAgICAgIC8vIGluY2x1ZGVkIGxvd2VyLWJvdW5kXG4gICAgdGhpcy5lbmQgPSBlbmQ7ICAgICAgICAgICAvLyBpbmNsdWRlZCB1cHBlci1ib3VuZFxuICAgIHRoaXMuc3RlcCA9IHN0ZXAgfHwgbnVsbDsgIC8vIG9wdGlvbmFsIHN0ZXBcbiAgfVxuXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUgPSBuZXcgTm9kZSgpO1xuXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUudHlwZSA9ICdSYW5nZU5vZGUnO1xuXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUuaXNSYW5nZU5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBSYW5nZU5vZGUgbmVlZHMgdGhlIGBlbmRgIHN5bWJvbCB0byBiZSBkZWZpbmVkLlxuICAgKiBUaGlzIGVuZCBpcyB0aGUgc2l6ZSBvZiB0aGUgTWF0cml4IGluIGN1cnJlbnQgZGltZW5zaW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgUmFuZ2VOb2RlLnByb3RvdHlwZS5uZWVkc0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBmaW5kIGFsbCBgZW5kYCBzeW1ib2xzIGluIHRoaXMgUmFuZ2VOb2RlXG4gICAgdmFyIGVuZFN5bWJvbHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIChub2RlICYmIG5vZGUuaXNTeW1ib2xOb2RlKSAmJiAobm9kZS5uYW1lID09ICdlbmQnKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbmRTeW1ib2xzLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhlIG5vZGUgdG8gamF2YXNjcmlwdCBjb2RlXG4gICAqXG4gICAqIFdoZW4gdGhlIHJhbmdlIGhhcyBhIHN5bWJvbCBgZW5kYCBkZWZpbmVkLCB0aGUgUmFuZ2VOb2RlIHJlcXVpcmVzXG4gICAqIGEgdmFyaWFibGUgYGVuZGAgdG8gYmUgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBjbG9zdXJlLCB3aGljaCBtdXN0IGNvbnRhaW5cbiAgICogdGhlIGxlbmd0aCBvZiB0aGUgb2YgdGhlIG1hdHJpeCB0aGF0J3MgYmVpbmcgaGFuZGxlZCBpbiB0aGUgcmFuZ2Unc1xuICAgKiBkaW1lbnNpb24uIFRvIGNoZWNrIHdoZXRoZXIgdGhlIGBlbmRgIHZhcmlhYmxlIGlzIG5lZWRlZCwgY2FsbFxuICAgKiBSYW5nZU5vZGUubmVlZHNFbmQoKS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZnMgICAgIE9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgZnVuY3Rpb25zXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBjb25zdGFudHMgZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciB0aGUgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgICAgIE9iamVjdCB3aXRoIGxvY2FsIGZ1bmN0aW9uIGFyZ3VtZW50cywgdGhlIGtleSBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50LCBhbmQgdGhlIHZhbHVlIGlzIGB0cnVlYC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgbWF5IG5vdCBiZSBtdXRhdGVkLCBidXQgbXVzdCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQgaW5zdGVhZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBqc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmFuZ2VOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgcmV0dXJuICdtYXRoLnJhbmdlKCcgK1xuICAgICAgICB0aGlzLnN0YXJ0Ll9jb21waWxlKGRlZnMsIGFyZ3MpICsgJywgJyArXG4gICAgICAgIHRoaXMuZW5kLl9jb21waWxlKGRlZnMsIGFyZ3MpICtcbiAgICAgICAgKHRoaXMuc3RlcCA/ICgnLCAnICsgdGhpcy5zdGVwLl9jb21waWxlKGRlZnMsIGFyZ3MpKSA6ICcnKSArXG4gICAgICAgICcpJztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBlYWNoIG9mIHRoZSBjaGlsZCBub2RlcyBvZiB0aGlzIG5vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjaGlsZDogTm9kZSwgcGF0aDogc3RyaW5nLCBwYXJlbnQ6IE5vZGUpfSBjYWxsYmFja1xuICAgKi9cbiAgUmFuZ2VOb2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGhpcy5zdGFydCwgJ3N0YXJ0JywgdGhpcyk7XG4gICAgY2FsbGJhY2sodGhpcy5lbmQsICdlbmQnLCB0aGlzKTtcbiAgICBpZiAodGhpcy5zdGVwKSB7XG4gICAgICBjYWxsYmFjayh0aGlzLnN0ZXAsICdzdGVwJywgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUmFuZ2VOb2RlIGhhdmluZyBpdCdzIGNoaWxkcyBiZSB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nXG4gICAqIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBvZiB0aGUgY2hpbGRzIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSk6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtSYW5nZU5vZGV9IFJldHVybnMgYSB0cmFuc2Zvcm1lZCBjb3B5IG9mIHRoZSBub2RlXG4gICAqL1xuICBSYW5nZU5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgUmFuZ2VOb2RlKFxuICAgICAgICB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5zdGFydCwgJ3N0YXJ0JywgdGhpcykpLFxuICAgICAgICB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5lbmQsICdlbmQnLCB0aGlzKSksXG4gICAgICAgIHRoaXMuc3RlcCAmJiB0aGlzLl9pZk5vZGUoY2FsbGJhY2sodGhpcy5zdGVwLCAnc3RlcCcsIHRoaXMpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoaXMgbm9kZSwgYSBzaGFsbG93IGNvcHlcbiAgICogQHJldHVybiB7UmFuZ2VOb2RlfVxuICAgKi9cbiAgUmFuZ2VOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlTm9kZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5zdGVwICYmIHRoaXMuc3RlcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbmVjZXNzYXJ5IHBhcmVudGhlc2VzXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50aGVzaXNcbiAgICogQHJldHVybiB7T2JqZWN0fSBwYXJlbnRoZXNlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlTmVjZXNzYXJ5UGFyZW50aGVzZXMobm9kZSwgcGFyZW50aGVzaXMpIHtcbiAgICB2YXIgcHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKG5vZGUsIHBhcmVudGhlc2lzKTtcbiAgICB2YXIgcGFyZW5zID0ge307XG5cbiAgICB2YXIgc3RhcnRQcmVjZWRlbmNlID0gb3BlcmF0b3JzLmdldFByZWNlZGVuY2Uobm9kZS5zdGFydCwgcGFyZW50aGVzaXMpO1xuICAgIHBhcmVucy5zdGFydCA9ICgoc3RhcnRQcmVjZWRlbmNlICE9PSBudWxsKSAmJiAoc3RhcnRQcmVjZWRlbmNlIDw9IHByZWNlZGVuY2UpKVxuICAgICAgfHwgKHBhcmVudGhlc2lzID09PSAnYWxsJyk7XG5cbiAgICBpZiAobm9kZS5zdGVwKSB7XG4gICAgICB2YXIgc3RlcFByZWNlZGVuY2UgPSBvcGVyYXRvcnMuZ2V0UHJlY2VkZW5jZShub2RlLnN0ZXAsIHBhcmVudGhlc2lzKTtcbiAgICAgIHBhcmVucy5zdGVwID0gKChzdGVwUHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKHN0ZXBQcmVjZWRlbmNlIDw9IHByZWNlZGVuY2UpKVxuICAgICAgICB8fCAocGFyZW50aGVzaXMgPT09ICdhbGwnKTtcbiAgICB9XG5cbiAgICB2YXIgZW5kUHJlY2VkZW5jZSA9IG9wZXJhdG9ycy5nZXRQcmVjZWRlbmNlKG5vZGUuZW5kLCBwYXJlbnRoZXNpcyk7XG4gICAgcGFyZW5zLmVuZCA9ICgoZW5kUHJlY2VkZW5jZSAhPT0gbnVsbCkgJiYgKGVuZFByZWNlZGVuY2UgPD0gcHJlY2VkZW5jZSkpXG4gICAgICB8fCAocGFyZW50aGVzaXMgPT09ICdhbGwnKTtcblxuICAgIHJldHVybiBwYXJlbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgUmFuZ2VOb2RlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBwYXJlbnRoZXNpcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50aGVzaXMpID8gb3B0aW9ucy5wYXJlbnRoZXNpcyA6ICdrZWVwJztcbiAgICB2YXIgcGFyZW5zID0gY2FsY3VsYXRlTmVjZXNzYXJ5UGFyZW50aGVzZXModGhpcywgcGFyZW50aGVzaXMpO1xuXG4gICAgLy9mb3JtYXQgc3RyaW5nIGFzIHN0YXJ0OnN0ZXA6c3RvcFxuICAgIHZhciBzdHI7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChwYXJlbnMuc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gJygnICsgc3RhcnQgKyAnKSc7XG4gICAgfVxuICAgIHN0ciA9IHN0YXJ0O1xuXG4gICAgaWYgKHRoaXMuc3RlcCkge1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXAudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICBpZiAocGFyZW5zLnN0ZXApIHtcbiAgICAgICAgc3RlcCA9ICcoJyArIHN0ZXAgKyAnKSc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gJzonICsgc3RlcDtcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gdGhpcy5lbmQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKHBhcmVucy5lbmQpIHtcbiAgICAgIGVuZCA9ICcoJyArIGVuZCArICcpJztcbiAgICB9XG4gICAgc3RyICs9ICc6JyArIGVuZDtcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBMYVRlWCByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICovXG4gIFJhbmdlTm9kZS5wcm90b3R5cGUuX3RvVGV4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50aGVzaXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudGhlc2lzKSA/IG9wdGlvbnMucGFyZW50aGVzaXMgOiAna2VlcCc7XG4gICAgdmFyIHBhcmVucyA9IGNhbGN1bGF0ZU5lY2Vzc2FyeVBhcmVudGhlc2VzKHRoaXMsIHBhcmVudGhlc2lzKTtcblxuICAgIHZhciBzdHIgPSB0aGlzLnN0YXJ0LnRvVGV4KG9wdGlvbnMpO1xuICAgIGlmIChwYXJlbnMuc3RhcnQpIHtcbiAgICAgIHN0ciA9ICdcXFxcbGVmdCgnICsgc3RyICsgJ1xcXFxyaWdodCknO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0ZXApIHtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwLnRvVGV4KG9wdGlvbnMpO1xuICAgICAgaWYgKHBhcmVucy5zdGVwKSB7XG4gICAgICAgIHN0ZXAgPSAnXFxcXGxlZnQoJyArIHN0ZXAgKyAnXFxcXHJpZ2h0KSc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gJzonICsgc3RlcDtcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gdGhpcy5lbmQudG9UZXgob3B0aW9ucyk7XG4gICAgaWYgKHBhcmVucy5lbmQpIHtcbiAgICAgIGVuZCA9ICdcXFxcbGVmdCgnICsgZW5kICsgJ1xcXFxyaWdodCknO1xuICAgIH1cbiAgICBzdHIgKz0gJzonICsgZW5kO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICByZXR1cm4gUmFuZ2VOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnUmFuZ2VOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuICB2YXIgTm9kZSA9IGxvYWQocmVxdWlyZSgnLi9Ob2RlJykpO1xuXG4gIHZhciBVbml0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL3VuaXQvVW5pdCcpKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFN5bWJvbE5vZGVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqIEEgc3ltYm9sIG5vZGUgY2FuIGhvbGQgYW5kIHJlc29sdmUgYSBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQGV4dGVuZHMge05vZGV9XG4gICAqL1xuICBmdW5jdGlvbiBTeW1ib2xOb2RlKG5hbWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGZvciBwYXJhbWV0ZXIgXCJuYW1lXCInKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBTeW1ib2xOb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XG5cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUudHlwZSA9ICdTeW1ib2xOb2RlJztcblxuICBTeW1ib2xOb2RlLnByb3RvdHlwZS5pc1N5bWJvbE5vZGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoZSBub2RlIHRvIGphdmFzY3JpcHQgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyAgICAgT2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBmdW5jdGlvbnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGNvbnN0YW50cyBnbG9iYWxseSBhdmFpbGFibGUgZm9yIHRoZSBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAgICAgT2JqZWN0IHdpdGggbG9jYWwgZnVuY3Rpb24gYXJndW1lbnRzLCB0aGUga2V5IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmFtZSBvZiB0aGUgYXJndW1lbnQsIGFuZCB0aGUgdmFsdWUgaXMgYHRydWVgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9iamVjdCBtYXkgbm90IGJlIG11dGF0ZWQsIGJ1dCBtdXN0IGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTeW1ib2xOb2RlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChkZWZzLCBhcmdzKSB7XG4gICAgLy8gYWRkIGEgZnVuY3Rpb24gdG8gdGhlIGRlZmluaXRpb25zXG4gICAgZGVmc1sndW5kZWYnXSA9IHVuZGVmO1xuICAgIGRlZnNbJ1VuaXQnXSA9IFVuaXQ7XG5cbiAgICBpZiAoYXJnc1t0aGlzLm5hbWVdKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgRnVuY3Rpb25Bc3NpZ25tZW50IGFyZ3VtZW50XG4gICAgICAvLyAobGlrZSBhbiB4IHdoZW4gaW5zaWRlIHRoZSBleHByZXNzaW9uIG9mIGEgZnVuY3Rpb24gYXNzaWdubWVudCBgZih4KSA9IC4uLmApXG4gICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm5hbWUgaW4gZGVmcy5tYXRoKSB7XG4gICAgICByZXR1cm4gJyhcIicgKyB0aGlzLm5hbWUgKyAnXCIgaW4gc2NvcGUgPyBzY29wZVtcIicgKyB0aGlzLm5hbWUgKyAnXCJdIDogbWF0aFtcIicgKyB0aGlzLm5hbWUgKyAnXCJdKSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICcoJyArXG4gICAgICAgICAgJ1wiJyArIHRoaXMubmFtZSArICdcIiBpbiBzY29wZSA/IHNjb3BlW1wiJyArIHRoaXMubmFtZSArICdcIl0gOiAnICtcbiAgICAgICAgICAoVW5pdC5pc1ZhbHVlbGVzc1VuaXQodGhpcy5uYW1lKSA/XG4gICAgICAgICAgJ25ldyBVbml0KG51bGwsIFwiJyArIHRoaXMubmFtZSArICdcIiknIDpcbiAgICAgICAgICAndW5kZWYoXCInICsgdGhpcy5uYW1lICsgJ1wiKScpICtcbiAgICAgICAgICAnKSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggb2YgdGhlIGNoaWxkIG5vZGVzIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGNoaWxkOiBOb2RlLCBwYXRoOiBzdHJpbmcsIHBhcmVudDogTm9kZSl9IGNhbGxiYWNrXG4gICAqL1xuICBTeW1ib2xOb2RlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gbm90aGluZyB0byBkbywgd2UgZG9uJ3QgaGF2ZSBjaGlsZHNcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFN5bWJvbE5vZGUgaGF2aW5nIGl0J3MgY2hpbGRzIGJlIHRoZSByZXN1bHRzIG9mIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIG9mIHRoZSBjaGlsZHMgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY2hpbGQ6IE5vZGUsIHBhdGg6IHN0cmluZywgcGFyZW50OiBOb2RlKSA6IE5vZGV9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtTeW1ib2xOb2RlfSBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG5vZGVcbiAgICovXG4gIFN5bWJvbE5vZGUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRocm93cyBhbiBlcnJvciAnVW5kZWZpbmVkIHN5bWJvbCB7bmFtZX0nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiB1bmRlZiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIHN5bWJvbCAnICsgbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBub2RlLCBhIHNoYWxsb3cgY29weVxuICAgKiBAcmV0dXJuIHtTeW1ib2xOb2RlfVxuICAgKi9cbiAgU3ltYm9sTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFN5bWJvbE5vZGUodGhpcy5uYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIFN5bWJvbE5vZGUucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgTGFUZVggcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBTeW1ib2xOb2RlLnByb3RvdHlwZS5fdG9UZXggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGlzVW5pdCA9IGZhbHNlO1xuICAgIGlmICgodHlwZW9mIG1hdGhbdGhpcy5uYW1lXSA9PT0gJ3VuZGVmaW5lZCcpICYmIFVuaXQuaXNWYWx1ZWxlc3NVbml0KHRoaXMubmFtZSkpIHtcbiAgICAgIGlzVW5pdCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBzeW1ib2wgPSBsYXRleC50b1N5bWJvbCh0aGlzLm5hbWUsIGlzVW5pdCk7XG4gICAgaWYgKHN5bWJvbFswXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAvL25vIHNwYWNlIG5lZWRlZCBpZiB0aGUgc3ltYm9sIHN0YXJ0cyB3aXRoICdcXCdcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfVxuICAgIC8vdGhlIHNwYWNlIHByZXZlbnRzIHN5bWJvbHMgZnJvbSBicmVha2luZyBzdHVmZiBsaWtlICdcXGNkb3QnIGlmIGl0J3Mgd3JpdHRlbiByaWdodCBiZWZvcmUgdGhlIHN5bWJvbFxuICAgIHJldHVybiAnICcgKyBzeW1ib2w7XG4gIH07XG5cbiAgcmV0dXJuIFN5bWJvbE5vZGU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdTeW1ib2xOb2RlJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLm5vZGUnO1xuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgLy8gcmVxdWVzdCBhY2Nlc3MgdG8gdGhlIG1hdGggbmFtZXNwYWNlIGFzIDV0aCBhcmd1bWVudCBvZiB0aGUgZmFjdG9yeSBmdW5jdGlvblxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFVwZGF0ZU5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIFVwZGF0ZU5vZGUoKSB7XG4gICAgLy8gVE9ETzogZGVwcmVjYXRlZCBzaW5jZSB2My4gQ2xlYW51cCBzb21lIGRheVxuICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlTm9kZSBpcyBkZXByZWNhdGVkLiBVc2UgQXNzaWdubWVudE5vZGUgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIHJldHVybiBVcGRhdGVOb2RlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnVXBkYXRlTm9kZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi5ub2RlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9BY2Nlc3Nvck5vZGUnKSxcbiAgcmVxdWlyZSgnLi9BcnJheU5vZGUnKSxcbiAgcmVxdWlyZSgnLi9Bc3NpZ25tZW50Tm9kZScpLFxuICByZXF1aXJlKCcuL0Jsb2NrTm9kZScpLFxuICByZXF1aXJlKCcuL0NvbmRpdGlvbmFsTm9kZScpLFxuICByZXF1aXJlKCcuL0NvbnN0YW50Tm9kZScpLFxuICByZXF1aXJlKCcuL0luZGV4Tm9kZScpLFxuICByZXF1aXJlKCcuL0Z1bmN0aW9uQXNzaWdubWVudE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9GdW5jdGlvbk5vZGUnKSxcbiAgcmVxdWlyZSgnLi9Ob2RlJyksXG4gIHJlcXVpcmUoJy4vT2JqZWN0Tm9kZScpLFxuICByZXF1aXJlKCcuL09wZXJhdG9yTm9kZScpLFxuICByZXF1aXJlKCcuL1BhcmVudGhlc2lzTm9kZScpLFxuICByZXF1aXJlKCcuL1JhbmdlTm9kZScpLFxuICByZXF1aXJlKCcuL1N5bWJvbE5vZGUnKSxcbiAgcmVxdWlyZSgnLi9VcGRhdGVOb2RlJylcbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zZm9ybS9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHN1YnNldCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vbWF0cml4L3N1YnNldCcpKTtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBwYXJ0IG9mIGFuIG9iamVjdDpcbiAgICpcbiAgICogLSBSZXRyaWV2ZSBhIHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG4gICAqIC0gUmV0cmlldmUgYSBwYXJ0IG9mIGEgc3RyaW5nXG4gICAqIC0gUmV0cmlldmUgYSBtYXRyaXggc3Vic2V0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXkgfCBNYXRyaXggfCBzdHJpbmd9IG9iamVjdFxuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleFxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBBcnJheSB8IE1hdHJpeCB8IHN0cmluZ30gUmV0dXJucyB0aGUgc3Vic2V0XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gYWNjZXNzKG9iamVjdCwgaW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbWF0cml4KG9iamVjdCkuc3Vic2V0KGluZGV4KS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5zdWJzZXQgPT09ICdmdW5jdGlvbicpIHsgLy8gTWF0cml4XG4gICAgICAgIHJldHVybiBvYmplY3Quc3Vic2V0KGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFRPRE86IG1vdmUgZ2V0U3RyaW5nU3Vic2V0IGludG8gYSBzZXBhcmF0ZSB1dGlsIGZpbGUsIHVzZSB0aGF0XG4gICAgICAgIHJldHVybiBzdWJzZXQob2JqZWN0LCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoIWluZGV4LmlzT2JqZWN0UHJvcGVydHkoKSkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGFwcGx5IGEgbnVtZXJpYyBpbmRleCBhcyBvYmplY3QgcHJvcGVydHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2luZGV4LmdldE9iamVjdFByb3BlcnR5KCldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhcHBseSBpbmRleDogdW5zdXBwb3J0ZWQgdHlwZSBvZiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNmb3JtL2Vycm9yLnRyYW5zZm9ybScpLnRyYW5zZm9ybTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgc3Vic2V0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi9mdW5jdGlvbi9tYXRyaXgvc3Vic2V0JykpO1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgcGFydCBvZiBhbiBvYmplY3Q6XG4gICAqXG4gICAqIC0gQXNzaWduIGEgcHJvcGVydHkgdG8gYW4gb2JqZWN0XG4gICAqIC0gUmVwbGFjZSBhIHBhcnQgb2YgYSBzdHJpbmdcbiAgICogLSBSZXBsYWNlIGEgbWF0cml4IHN1YnNldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFycmF5IHwgTWF0cml4IHwgc3RyaW5nfSBvYmplY3RcbiAgICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtPYmplY3QgfCBBcnJheSB8IE1hdHJpeCB8IHN0cmluZ30gUmV0dXJucyB0aGUgb3JpZ2luYWwgb2JqZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgaW4gY2FzZSBvZiBhIHN0cmluZ1xuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGFzc2lnbihvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXgob2JqZWN0KS5zdWJzZXQoaW5kZXgsIHZhbHVlKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5zdWJzZXQgPT09ICdmdW5jdGlvbicpIHsgLy8gTWF0cml4XG4gICAgICAgIHJldHVybiBvYmplY3Quc3Vic2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBUT0RPOiBtb3ZlIHNldFN0cmluZ1N1YnNldCBpbnRvIGEgc2VwYXJhdGUgdXRpbCBmaWxlLCB1c2UgdGhhdFxuICAgICAgICByZXR1cm4gc3Vic2V0KG9iamVjdCwgaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghaW5kZXguaXNPYmplY3RQcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgYXBwbHkgYSBudW1lcmljIGluZGV4IGFzIG9iamVjdCBwcm9wZXJ0eScpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtpbmRleC5nZXRPYmplY3RQcm9wZXJ0eSgpXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhcHBseSBpbmRleDogdW5zdXBwb3J0ZWQgdHlwZSBvZiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnJvclRyYW5zZm9ybShlcnIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vbGlzdCBvZiBpZGVudGlmaWVycyBvZiBub2RlcyBpbiBvcmRlciBvZiB0aGVpciBwcmVjZWRlbmNlXG4vL2Fsc28gY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgbGVmdC9yaWdodCBhc3NvY2lhdGl2aXR5XG4vL2FuZCB3aGljaCBvdGhlciBvcGVyYXRvciB0aGUgb3BlcmF0b3IgaXMgYXNzb2NpYXRpdmUgd2l0aFxuLy9FeGFtcGxlOlxuLy8gYWRkaXRpb24gaXMgYXNzb2NpYXRpdmUgd2l0aCBhZGRpdGlvbiBhbmQgc3VidHJhY3Rpb24sIGJlY2F1c2U6XG4vLyAoYStiKStjPWErKGIrYylcbi8vIChhK2IpLWM9YSsoYi1jKVxuLy9cbi8vIHBvc3RmaXggb3BlcmF0b3JzIGFyZSBsZWZ0IGFzc29jaWF0aXZlLCBwcmVmaXggb3BlcmF0b3JzIFxuLy8gYXJlIHJpZ2h0IGFzc29jaWF0aXZlXG4vL1xuLy9JdCdzIGFsc28gcG9zc2libGUgdG8gc2V0IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vIGxhdGV4UGFyZW5zOiBpZiBzZXQgdG8gZmFsc2UsIHRoaXMgbm9kZSBkb2Vzbid0IG5lZWQgdG8gYmUgZW5jbG9zZWRcbi8vICAgICAgICAgICAgICBpbiBwYXJlbnRoZXNlcyB3aGVuIHVzaW5nIExhVGVYXG4vLyBsYXRleExlZnRQYXJlbnM6IGlmIHNldCB0byBmYWxzZSwgdGhpcyAhT3BlcmF0b3JOb2RlJ3MhIFxuLy8gICAgICAgICAgICAgICAgICBsZWZ0IGFyZ3VtZW50IGRvZXNuJ3QgbmVlZCB0byBiZSBlbmNsb3NlZFxuLy8gICAgICAgICAgICAgICAgICBpbiBwYXJlbnRoZXNlc1xuLy8gbGF0ZXhSaWdodFBhcmVuczogdGhlIHNhbWUgZm9yIHRoZSByaWdodCBhcmd1bWVudFxudmFyIHByb3BlcnRpZXMgPSBbXG4gIHsgLy9hc3NpZ25tZW50XG4gICAgJ0Fzc2lnbm1lbnROb2RlJzoge30sXG4gICAgJ0Z1bmN0aW9uQXNzaWdubWVudE5vZGUnOiB7fVxuICB9LFxuICB7IC8vY29uZGl0aW9uYWwgZXhwcmVzc2lvblxuICAgICdDb25kaXRpb25hbE5vZGUnOiB7XG4gICAgICBsYXRleExlZnRQYXJlbnM6IGZhbHNlLFxuICAgICAgbGF0ZXhSaWdodFBhcmVuczogZmFsc2UsXG4gICAgICBsYXRleFBhcmVuczogZmFsc2VcbiAgICAgIC8vY29uZGl0aW9uYWxzIGRvbid0IG5lZWQgcGFyZW50aGVzZXMgaW4gTGFUZVggYmVjYXVzZVxuICAgICAgLy90aGV5IGFyZSAyIGRpbWVuc2lvbmFsXG4gICAgfVxuICB9LFxuICB7IC8vbG9naWNhbCBvclxuICAgICdPcGVyYXRvck5vZGU6b3InOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuXG4gIH0sXG4gIHsgLy9sb2dpY2FsIHhvclxuICAgICdPcGVyYXRvck5vZGU6eG9yJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL2xvZ2ljYWwgYW5kXG4gICAgJ09wZXJhdG9yTm9kZTphbmQnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vYml0d2lzZSBvclxuICAgICdPcGVyYXRvck5vZGU6Yml0T3InOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vYml0d2lzZSB4b3JcbiAgICAnT3BlcmF0b3JOb2RlOmJpdFhvcic6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9iaXR3aXNlIGFuZFxuICAgICdPcGVyYXRvck5vZGU6Yml0QW5kJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL3JlbGF0aW9uYWwgb3BlcmF0b3JzXG4gICAgJ09wZXJhdG9yTm9kZTplcXVhbCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6dW5lcXVhbCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6c21hbGxlcic6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6bGFyZ2VyJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpzbWFsbGVyRXEnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOmxhcmdlckVxJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH1cbiAgfSxcbiAgeyAvL2JpdHNoaWZ0IG9wZXJhdG9yc1xuICAgICdPcGVyYXRvck5vZGU6bGVmdFNoaWZ0Jzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpyaWdodEFyaXRoU2hpZnQnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOnJpZ2h0TG9nU2hpZnQnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vdW5pdCBjb252ZXJzaW9uXG4gICAgJ09wZXJhdG9yTm9kZTp0byc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9yYW5nZVxuICAgICdSYW5nZU5vZGUnOiB7fVxuICB9LFxuICB7IC8vYWRkaXRpb24sIHN1YnRyYWN0aW9uXG4gICAgJ09wZXJhdG9yTm9kZTphZGQnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFsnT3BlcmF0b3JOb2RlOmFkZCcsICdPcGVyYXRvck5vZGU6c3VidHJhY3QnXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpzdWJ0cmFjdCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9tdWx0aXBseSwgZGl2aWRlLCBtb2R1bHVzXG4gICAgJ09wZXJhdG9yTm9kZTptdWx0aXBseSc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW1xuICAgICAgICAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JyxcbiAgICAgICAgJ09wZXJhdG9yTm9kZTpkaXZpZGUnLFxuICAgICAgICAnT3BlcmF0b3I6ZG90TXVsdGlwbHknLFxuICAgICAgICAnT3BlcmF0b3I6ZG90RGl2aWRlJ1xuICAgICAgXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpkaXZpZGUnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdLFxuICAgICAgbGF0ZXhMZWZ0UGFyZW5zOiBmYWxzZSxcbiAgICAgIGxhdGV4UmlnaHRQYXJlbnM6IGZhbHNlLFxuICAgICAgbGF0ZXhQYXJlbnM6IGZhbHNlXG4gICAgICAvL2ZyYWN0aW9ucyBkb24ndCByZXF1aXJlIHBhcmVudGhlc2VzIGJlY2F1c2VcbiAgICAgIC8vdGhleSdyZSAyIGRpbWVuc2lvbmFsLCBzbyBwYXJlbnMgYXJlbid0IG5lZWRlZFxuICAgICAgLy9pbiBMYVRlWFxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpkb3RNdWx0aXBseSc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW1xuICAgICAgICAnT3BlcmF0b3JOb2RlOm11bHRpcGx5JyxcbiAgICAgICAgJ09wZXJhdG9yTm9kZTpkaXZpZGUnLFxuICAgICAgICAnT3BlcmF0b3JOb2RlOmRvdE11bHRpcGx5JyxcbiAgICAgICAgJ09wZXJhdG9yTm9kZTpkb0RpdmlkZSdcbiAgICAgIF1cbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6ZG90RGl2aWRlJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ2xlZnQnLFxuICAgICAgYXNzb2NpYXRpdmVXaXRoOiBbXVxuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTptb2QnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAnbGVmdCcsXG4gICAgICBhc3NvY2lhdGl2ZVdpdGg6IFtdXG4gICAgfVxuICB9LFxuICB7IC8vdW5hcnkgcHJlZml4IG9wZXJhdG9yc1xuICAgICdPcGVyYXRvck5vZGU6dW5hcnlQbHVzJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ3JpZ2h0J1xuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTp1bmFyeU1pbnVzJzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ3JpZ2h0J1xuICAgIH0sXG4gICAgJ09wZXJhdG9yTm9kZTpiaXROb3QnOiB7XG4gICAgICBhc3NvY2lhdGl2aXR5OiAncmlnaHQnXG4gICAgfSxcbiAgICAnT3BlcmF0b3JOb2RlOm5vdCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdyaWdodCdcbiAgICB9XG4gIH0sXG4gIHsgLy9leHBvbmVudGlhdGlvblxuICAgICdPcGVyYXRvck5vZGU6cG93Jzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ3JpZ2h0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW10sXG4gICAgICBsYXRleFJpZ2h0UGFyZW5zOiBmYWxzZVxuICAgICAgLy90aGUgZXhwb25lbnQgZG9lc24ndCBuZWVkIHBhcmVudGhlc2VzIGluXG4gICAgICAvL0xhVGVYIGJlY2F1c2UgaXQncyAyIGRpbWVuc2lvbmFsXG4gICAgICAvLyhpdCdzIG9uIHRvcClcbiAgICB9LFxuICAgICdPcGVyYXRvck5vZGU6ZG90UG93Jzoge1xuICAgICAgYXNzb2NpYXRpdml0eTogJ3JpZ2h0JyxcbiAgICAgIGFzc29jaWF0aXZlV2l0aDogW11cbiAgICB9XG4gIH0sXG4gIHsgLy9mYWN0b3JpYWxcbiAgICAnT3BlcmF0b3JOb2RlOmZhY3RvcmlhbCc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0J1xuICAgIH1cbiAgfSxcbiAgeyAvL21hdHJpeCB0cmFuc3Bvc2VcbiAgICAnT3BlcmF0b3JOb2RlOnRyYW5zcG9zZSc6IHtcbiAgICAgIGFzc29jaWF0aXZpdHk6ICdsZWZ0J1xuICAgIH1cbiAgfVxuXTtcblxuLyoqXG4gKiBHZXQgdGhlIHByZWNlZGVuY2Ugb2YgYSBOb2RlLlxuICogSGlnaGVyIG51bWJlciBmb3IgaGlnaGVyIHByZWNlZGVuY2UsIHN0YXJ0aW5nIHdpdGggMC5cbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcHJlY2VkZW5jZSBpcyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtOb2RlfVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudGhlc2lzXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0UHJlY2VkZW5jZSAoX25vZGUsIHBhcmVudGhlc2lzKSB7XG4gIHZhciBub2RlID0gX25vZGU7XG4gIGlmIChwYXJlbnRoZXNpcyAhPT0gJ2tlZXAnKSB7XG4gICAgLy9QYXJlbnRoZXNpc05vZGVzIGFyZSBvbmx5IGlnbm9yZWQgd2hlbiBub3QgaW4gJ2tlZXAnIG1vZGVcbiAgICBub2RlID0gX25vZGUuZ2V0Q29udGVudCgpO1xuICB9XG4gIHZhciBpZGVudGlmaWVyID0gbm9kZS5nZXRJZGVudGlmaWVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpZGVudGlmaWVyIGluIHByb3BlcnRpZXNbaV0pIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFzc29jaWF0aXZpdHkgb2YgYW4gb3BlcmF0b3IgKGxlZnQgb3IgcmlnaHQpLlxuICogUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nICdsZWZ0JyBvciAncmlnaHQnIG9yIG51bGwgaWZcbiAqIHRoZSBhc3NvY2lhdGl2aXR5IGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRoZXNpc1xuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QXNzb2NpYXRpdml0eSAoX25vZGUsIHBhcmVudGhlc2lzKSB7XG4gIHZhciBub2RlID0gX25vZGU7XG4gIGlmIChwYXJlbnRoZXNpcyAhPT0gJ2tlZXAnKSB7XG4gICAgLy9QYXJlbnRoZXNpc05vZGVzIGFyZSBvbmx5IGlnbm9yZWQgd2hlbiBub3QgaW4gJ2tlZXAnIG1vZGVcbiAgICBub2RlID0gX25vZGUuZ2V0Q29udGVudCgpO1xuICB9XG4gIHZhciBpZGVudGlmaWVyID0gbm9kZS5nZXRJZGVudGlmaWVyKCk7XG4gIHZhciBpbmRleCA9IGdldFByZWNlZGVuY2Uobm9kZSwgcGFyZW50aGVzaXMpO1xuICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAvL25vZGUgaXNuJ3QgaW4gdGhlIGxpc3RcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XVtpZGVudGlmaWVyXTtcblxuICBpZiAocHJvcGVydHkuaGFzT3duUHJvcGVydHkoJ2Fzc29jaWF0aXZpdHknKSkge1xuICAgIGlmIChwcm9wZXJ0eS5hc3NvY2lhdGl2aXR5ID09PSAnbGVmdCcpIHtcbiAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS5hc3NvY2lhdGl2aXR5ID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG4gICAgLy9hc3NvY2lhdGl2aXR5IGlzIGludmFsaWRcbiAgICB0aHJvdyBFcnJvcignXFwnJyArIGlkZW50aWZpZXIgKyAnXFwnIGhhcyB0aGUgaW52YWxpZCBhc3NvY2lhdGl2aXR5IFxcJydcbiAgICAgICAgICAgICAgICArIHByb3BlcnR5LmFzc29jaWF0aXZpdHkgKyAnXFwnLicpO1xuICB9XG5cbiAgLy9hc3NvY2lhdGl2aXR5IGlzIHVuZGVmaW5lZFxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvcGVyYXRvciBpcyBhc3NvY2lhdGl2ZSB3aXRoIGFub3RoZXIgb3BlcmF0b3IuXG4gKiBSZXR1cm5zIGVpdGhlciB0cnVlIG9yIGZhbHNlIG9yIG51bGwgaWYgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlQVxuICogQHBhcmFtIHtOb2RlfSBub2RlQlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudGhlc2lzXG4gKiBAcmV0dXJuIHtib29sfG51bGx9XG4gKi9cbmZ1bmN0aW9uIGlzQXNzb2NpYXRpdmVXaXRoIChub2RlQSwgbm9kZUIsIHBhcmVudGhlc2lzKSB7XG4gIHZhciBhID0gbm9kZUE7XG4gIHZhciBiID0gbm9kZUI7XG4gIGlmIChwYXJlbnRoZXNpcyAhPT0gJ2tlZXAnKSB7XG4gICAgLy9QYXJlbnRoZXNpc05vZGVzIGFyZSBvbmx5IGlnbm9yZWQgd2hlbiBub3QgaW4gJ2tlZXAnIG1vZGVcbiAgICB2YXIgYSA9IG5vZGVBLmdldENvbnRlbnQoKTtcbiAgICB2YXIgYiA9IG5vZGVCLmdldENvbnRlbnQoKTtcbiAgfVxuICB2YXIgaWRlbnRpZmllckEgPSBhLmdldElkZW50aWZpZXIoKTtcbiAgdmFyIGlkZW50aWZpZXJCID0gYi5nZXRJZGVudGlmaWVyKCk7XG4gIHZhciBpbmRleCA9IGdldFByZWNlZGVuY2UoYSwgcGFyZW50aGVzaXMpO1xuICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAvL25vZGUgaXNuJ3QgaW4gdGhlIGxpc3RcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XVtpZGVudGlmaWVyQV07XG5cbiAgaWYgKHByb3BlcnR5Lmhhc093blByb3BlcnR5KCdhc3NvY2lhdGl2ZVdpdGgnKVxuICAgICAgJiYgKHByb3BlcnR5LmFzc29jaWF0aXZlV2l0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkuYXNzb2NpYXRpdmVXaXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcGVydHkuYXNzb2NpYXRpdmVXaXRoW2ldID09PSBpZGVudGlmaWVyQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy9hc3NvY2lhdGl2ZVdpdGggaXMgbm90IGRlZmluZWRcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xubW9kdWxlLmV4cG9ydHMuZ2V0UHJlY2VkZW5jZSA9IGdldFByZWNlZGVuY2U7XG5tb2R1bGUuZXhwb3J0cy5nZXRBc3NvY2lhdGl2aXR5ID0gZ2V0QXNzb2NpYXRpdml0eTtcbm1vZHVsZS5leHBvcnRzLmlzQXNzb2NpYXRpdmVXaXRoID0gaXNBc3NvY2lhdGl2ZVdpdGg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBcmd1bWVudHNFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL0FyZ3VtZW50c0Vycm9yJyk7XG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBBY2Nlc3Nvck5vZGUgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0FjY2Vzc29yTm9kZScpKTtcbiAgdmFyIEFycmF5Tm9kZSAgICAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvQXJyYXlOb2RlJykpO1xuICB2YXIgQXNzaWdubWVudE5vZGUgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9Bc3NpZ25tZW50Tm9kZScpKTtcbiAgdmFyIEJsb2NrTm9kZSAgICAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvQmxvY2tOb2RlJykpO1xuICB2YXIgQ29uZGl0aW9uYWxOb2RlICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9Db25kaXRpb25hbE5vZGUnKSk7XG4gIHZhciBDb25zdGFudE5vZGUgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL0NvbnN0YW50Tm9kZScpKTtcbiAgdmFyIEZ1bmN0aW9uQXNzaWdubWVudE5vZGUgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZScpKTtcbiAgdmFyIEluZGV4Tm9kZSAgICAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvSW5kZXhOb2RlJykpO1xuICB2YXIgT2JqZWN0Tm9kZSAgICAgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9PYmplY3ROb2RlJykpO1xuICB2YXIgT3BlcmF0b3JOb2RlICAgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9PcGVyYXRvck5vZGUnKSk7XG4gIHZhciBQYXJlbnRoZXNpc05vZGUgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL1BhcmVudGhlc2lzTm9kZScpKTtcbiAgdmFyIEZ1bmN0aW9uTm9kZSAgICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL25vZGUvRnVuY3Rpb25Ob2RlJykpO1xuICB2YXIgUmFuZ2VOb2RlICAgICAgICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4vbm9kZS9SYW5nZU5vZGUnKSk7XG4gIHZhciBTeW1ib2xOb2RlICAgICAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi9ub2RlL1N5bWJvbE5vZGUnKSk7XG5cblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbi4gUmV0dXJucyBhIG5vZGUgdHJlZSwgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZCBieVxuICAgKiBpbnZva2luZyBub2RlLmV2YWwoKTtcbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgcGFyc2UoZXhwcilcbiAgICogICAgIHBhcnNlKGV4cHIsIG9wdGlvbnMpXG4gICAqICAgICBwYXJzZShbZXhwcjEsIGV4cHIyLCBleHByMywgLi4uXSlcbiAgICogICAgIHBhcnNlKFtleHByMSwgZXhwcjIsIGV4cHIzLCAuLi5dLCBvcHRpb25zKVxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgdmFyIG5vZGUgPSBwYXJzZSgnc3FydCgzXjIgKyA0XjIpJyk7XG4gICAqICAgICBub2RlLmNvbXBpbGUobWF0aCkuZXZhbCgpOyAvLyA1XG4gICAqXG4gICAqICAgICB2YXIgc2NvcGUgPSB7YTozLCBiOjR9XG4gICAqICAgICB2YXIgbm9kZSA9IHBhcnNlKCdhICogYicpOyAvLyAxMlxuICAgKiAgICAgdmFyIGNvZGUgPSBub2RlLmNvbXBpbGUobWF0aCk7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAxMlxuICAgKiAgICAgc2NvcGUuYSA9IDU7XG4gICAqICAgICBjb2RlLmV2YWwoc2NvcGUpOyAvLyAyMFxuICAgKlxuICAgKiAgICAgdmFyIG5vZGVzID0gbWF0aC5wYXJzZShbJ2EgPSAzJywgJ2IgPSA0JywgJ2EgKiBiJ10pO1xuICAgKiAgICAgbm9kZXNbMl0uY29tcGlsZShtYXRoKS5ldmFsKCk7IC8vIDEyXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW10gfCBNYXRyaXh9IGV4cHJcbiAgICogQHBhcmFtIHt7bm9kZXM6IE9iamVjdDxzdHJpbmcsIE5vZGU+fX0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGBub2Rlc2AgYSBzZXQgb2YgY3VzdG9tIG5vZGVzXG4gICAqIEByZXR1cm4ge05vZGUgfCBOb2RlW119IG5vZGVcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSAoZXhwciwgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDEgJiYgYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgQXJndW1lbnRzRXJyb3IoJ3BhcnNlJywgYXJndW1lbnRzLmxlbmd0aCwgMSwgMik7XG4gICAgfVxuXG4gICAgLy8gcGFzcyBleHRyYSBub2Rlc1xuICAgIGV4dHJhX25vZGVzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2RlcykgPyBvcHRpb25zLm5vZGVzIDoge307XG5cbiAgICBpZiAodHlwZW9mIGV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBwYXJzZSBhIHNpbmdsZSBleHByZXNzaW9uXG4gICAgICBleHByZXNzaW9uID0gZXhwcjtcbiAgICAgIHJldHVybiBwYXJzZVN0YXJ0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXhwcikgfHwgZXhwciBpbnN0YW5jZW9mIHR5cGUuTWF0cml4KSB7XG4gICAgICAvLyBwYXJzZSBhbiBhcnJheSBvciBtYXRyaXggd2l0aCBleHByZXNzaW9uc1xuICAgICAgcmV0dXJuIGRlZXBNYXAoZXhwciwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG5cbiAgICAgICAgZXhwcmVzc2lvbiA9IGVsZW07XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXJ0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBvb3BzXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgb3IgbWF0cml4IGV4cGVjdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gdG9rZW4gdHlwZXMgZW51bWVyYXRpb25cbiAgdmFyIFRPS0VOVFlQRSA9IHtcbiAgICBOVUxMIDogMCxcbiAgICBERUxJTUlURVIgOiAxLFxuICAgIE5VTUJFUiA6IDIsXG4gICAgU1lNQk9MIDogMyxcbiAgICBVTktOT1dOIDogNFxuICB9O1xuXG4gIC8vIG1hcCB3aXRoIGFsbCBkZWxpbWl0ZXJzXG4gIHZhciBERUxJTUlURVJTID0ge1xuICAgICcsJzogdHJ1ZSxcbiAgICAnKCc6IHRydWUsXG4gICAgJyknOiB0cnVlLFxuICAgICdbJzogdHJ1ZSxcbiAgICAnXSc6IHRydWUsXG4gICAgJ3snOiB0cnVlLFxuICAgICd9JzogdHJ1ZSxcbiAgICAnXFxcIic6IHRydWUsXG4gICAgJzsnOiB0cnVlLFxuXG4gICAgJysnOiB0cnVlLFxuICAgICctJzogdHJ1ZSxcbiAgICAnKic6IHRydWUsXG4gICAgJy4qJzogdHJ1ZSxcbiAgICAnLyc6IHRydWUsXG4gICAgJy4vJzogdHJ1ZSxcbiAgICAnJSc6IHRydWUsXG4gICAgJ14nOiB0cnVlLFxuICAgICcuXic6IHRydWUsXG4gICAgJ34nOiB0cnVlLFxuICAgICchJzogdHJ1ZSxcbiAgICAnJic6IHRydWUsXG4gICAgJ3wnOiB0cnVlLFxuICAgICdefCc6IHRydWUsXG4gICAgJ1xcJyc6IHRydWUsXG4gICAgJz0nOiB0cnVlLFxuICAgICc6JzogdHJ1ZSxcbiAgICAnPyc6IHRydWUsXG5cbiAgICAnPT0nOiB0cnVlLFxuICAgICchPSc6IHRydWUsXG4gICAgJzwnOiB0cnVlLFxuICAgICc+JzogdHJ1ZSxcbiAgICAnPD0nOiB0cnVlLFxuICAgICc+PSc6IHRydWUsXG5cbiAgICAnPDwnOiB0cnVlLFxuICAgICc+Pic6IHRydWUsXG4gICAgJz4+Pic6IHRydWVcbiAgfTtcblxuICAvLyBtYXAgd2l0aCBhbGwgbmFtZWQgZGVsaW1pdGVyc1xuICB2YXIgTkFNRURfREVMSU1JVEVSUyA9IHtcbiAgICAnbW9kJzogdHJ1ZSxcbiAgICAndG8nOiB0cnVlLFxuICAgICdpbic6IHRydWUsXG4gICAgJ2FuZCc6IHRydWUsXG4gICAgJ3hvcic6IHRydWUsXG4gICAgJ29yJzogdHJ1ZSxcbiAgICAnbm90JzogdHJ1ZVxuICB9O1xuXG4gIHZhciBleHRyYV9ub2RlcyA9IHt9OyAgICAgICAgICAgICAvLyBjdXJyZW50IGV4dHJhIG5vZGVzXG4gIHZhciBleHByZXNzaW9uID0gJyc7ICAgICAgICAgICAgICAvLyBjdXJyZW50IGV4cHJlc3Npb25cbiAgdmFyIGNvbW1lbnQgPSAnJzsgICAgICAgICAgICAgICAgIC8vIGxhc3QgcGFyc2VkIGNvbW1lbnRcbiAgdmFyIGluZGV4ID0gMDsgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5kZXggaW4gZXhwclxuICB2YXIgYyA9ICcnOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB0b2tlbiBjaGFyYWN0ZXIgaW4gZXhwclxuICB2YXIgdG9rZW4gPSAnJzsgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB0b2tlblxuICB2YXIgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5OVUxMOyAgLy8gdHlwZSBvZiB0aGUgdG9rZW5cbiAgdmFyIG5lc3RpbmdfbGV2ZWwgPSAwOyAgICAgICAgICAgIC8vIGxldmVsIG9mIG5lc3RpbmcgaW5zaWRlIHBhcmFtZXRlcnMsIHVzZWQgdG8gaWdub3JlIG5ld2xpbmUgY2hhcmFjdGVyc1xuICB2YXIgY29uZGl0aW9uYWxfbGV2ZWwgPSBudWxsOyAgICAgLy8gd2hlbiBhIGNvbmRpdGlvbmFsIGlzIGJlaW5nIHBhcnNlZCwgdGhlIGxldmVsIG9mIHRoZSBjb25kaXRpb25hbCBpcyBzdG9yZWQgaGVyZVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGNoYXJhY3RlciBmcm9tIHRoZSBleHByZXNzaW9uLlxuICAgKiBUaGUgY2hhcmFjdGVyIGlzIHN0b3JlZCBpbnRvIHRoZSBjaGFyIGMuIElmIHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb24gaXNcbiAgICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgYyA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgIG5lc3RpbmdfbGV2ZWwgPSAwO1xuICAgIGNvbmRpdGlvbmFsX2xldmVsID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGV4cHJlc3Npb24uXG4gICAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbiBpc1xuICAgKiByZWFjaGVkLCB0aGUgZnVuY3Rpb24gcHV0cyBhbiBlbXB0eSBzdHJpbmcgaW4gYy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gZXhwcmVzc2lvbi5jaGFyQXQoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZpZXcgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBmcm9tIHRoZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNOZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcmV2UHJldmlldygpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi5jaGFyQXQoaW5kZXggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2aWV3IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNOZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBuZXh0UHJldmlldygpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi5jaGFyQXQoaW5kZXggKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2aWV3IHRoZSBzZWNvbmQgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZXhwcmVzc2lvbi5cbiAgICogQHJldHVybiB7c3RyaW5nfSBjTmV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbmV4dE5leHRQcmV2aWV3KCkge1xuICAgIHJldHVybiBleHByZXNzaW9uLmNoYXJBdChpbmRleCArIDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IHN0cmluZyBleHByLlxuICAgKiBUaGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgYXJlIGF2YWlsYWJsZSBhcyB0b2tlbiBhbmQgdG9rZW5fdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5OVUxMO1xuICAgIHRva2VuID0gJyc7XG4gICAgY29tbWVudCA9ICcnO1xuXG4gICAgLy8gc2tpcCBvdmVyIHdoaXRlc3BhY2VzXG4gICAgLy8gc3BhY2UsIHRhYiwgYW5kIG5ld2xpbmUgd2hlbiBpbnNpZGUgcGFyYW1ldGVyc1xuICAgIHdoaWxlIChwYXJzZS5pc1doaXRlc3BhY2UoYywgbmVzdGluZ19sZXZlbCkpIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGNvbW1lbnRcbiAgICBpZiAoYyA9PSAnIycpIHtcbiAgICAgIHdoaWxlIChjICE9ICdcXG4nICYmIGMgIT0gJycpIHtcbiAgICAgICAgY29tbWVudCArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGVuZCBvZiBleHByZXNzaW9uXG4gICAgaWYgKGMgPT0gJycpIHtcbiAgICAgIC8vIHRva2VuIGlzIHN0aWxsIGVtcHR5XG4gICAgICB0b2tlbl90eXBlID0gVE9LRU5UWVBFLkRFTElNSVRFUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgbmV3IGxpbmUgY2hhcmFjdGVyXG4gICAgaWYgKGMgPT0gJ1xcbicgJiYgIW5lc3RpbmdfbGV2ZWwpIHtcbiAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgdG9rZW4gPSBjO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMyBjaGFyYWN0ZXJzXG4gICAgdmFyIGMyID0gYyArIG5leHRQcmV2aWV3KCk7XG4gICAgdmFyIGMzID0gYzIgKyBuZXh0TmV4dFByZXZpZXcoKTtcbiAgICBpZiAoYzMubGVuZ3RoID09IDMgJiYgREVMSU1JVEVSU1tjM10pIHtcbiAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgICAgdG9rZW4gPSBjMztcbiAgICAgIG5leHQoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZGVsaW1pdGVycyBjb25zaXN0aW5nIG9mIDIgY2hhcmFjdGVyc1xuICAgIGlmIChjMi5sZW5ndGggPT0gMiAmJiBERUxJTUlURVJTW2MyXSkge1xuICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB0b2tlbiA9IGMyO1xuICAgICAgbmV4dCgpO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMSBjaGFyYWN0ZXJcbiAgICBpZiAoREVMSU1JVEVSU1tjXSkge1xuICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB0b2tlbiA9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGEgbnVtYmVyXG4gICAgaWYgKHBhcnNlLmlzRGlnaXREb3QoYykpIHtcbiAgICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuTlVNQkVSO1xuXG4gICAgICAvLyBnZXQgbnVtYmVyLCBjYW4gaGF2ZSBhIHNpbmdsZSBkb3RcbiAgICAgIGlmIChjID09ICcuJykge1xuICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgaWYgKCFwYXJzZS5pc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBubyBudW1iZXIsIGl0IGlzIGp1c3QgYSBkb3QgKGNhbiBiZSBkb3Qgbm90YXRpb24pXG4gICAgICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAocGFyc2UuaXNEaWdpdChjKSkge1xuICAgICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZS5pc0RlY2ltYWxNYXJrKGMsIG5leHRQcmV2aWV3KCkpKSB7XG4gICAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChwYXJzZS5pc0RpZ2l0KGMpKSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGV4cG9uZW50aWFsIG5vdGF0aW9uIGxpa2UgXCIyLjNlLTRcIiwgXCIxLjIzZTUwXCIgb3IgXCIyZSs0XCJcbiAgICAgIGMyID0gbmV4dFByZXZpZXcoKTtcbiAgICAgIGlmIChjID09ICdFJyB8fCBjID09ICdlJykge1xuICAgICAgICBpZiAocGFyc2UuaXNEaWdpdChjMikgfHwgYzIgPT0gJy0nIHx8IGMyID09ICcrJykge1xuICAgICAgICAgIHRva2VuICs9IGM7XG4gICAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgICAgaWYgKGMgPT0gJysnIHx8IGMgPT0gJy0nKSB7XG4gICAgICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNjaWVudGlmaWMgbm90YXRpb24gTVVTVCBiZSBmb2xsb3dlZCBieSBhbiBleHBvbmVudFxuICAgICAgICAgIGlmICghcGFyc2UuaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0RpZ2l0IGV4cGVjdGVkLCBnb3QgXCInICsgYyArICdcIicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChwYXJzZS5pc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICB0b2tlbiArPSBjO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJzZS5pc0RlY2ltYWxNYXJrKGMsIG5leHRQcmV2aWV3KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRGlnaXQgZXhwZWN0ZWQsIGdvdCBcIicgKyBjICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMyID09ICcuJykge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRGlnaXQgZXhwZWN0ZWQsIGdvdCBcIicgKyBjICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciB2YXJpYWJsZXMsIGZ1bmN0aW9ucywgbmFtZWQgb3BlcmF0b3JzXG4gICAgaWYgKHBhcnNlLmlzQWxwaGEoYywgcHJldlByZXZpZXcoKSwgbmV4dFByZXZpZXcoKSkpIHtcbiAgICAgIHdoaWxlIChwYXJzZS5pc0FscGhhKGMsIHByZXZQcmV2aWV3KCksIG5leHRQcmV2aWV3KCkpIHx8IHBhcnNlLmlzRGlnaXQoYykpIHtcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTkFNRURfREVMSU1JVEVSUy5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9rZW5fdHlwZSA9IFRPS0VOVFlQRS5TWU1CT0w7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzb21ldGhpbmcgdW5rbm93biBpcyBmb3VuZCwgd3JvbmcgY2hhcmFjdGVycyAtPiBhIHN5bnRheCBlcnJvclxuICAgIHRva2VuX3R5cGUgPSBUT0tFTlRZUEUuVU5LTk9XTjtcbiAgICB3aGlsZSAoYyAhPSAnJykge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIHRva2VuICsgJ1wiJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG5leHQgdG9rZW4gYW5kIHNraXAgbmV3bGluZSB0b2tlbnNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFRva2VuU2tpcE5ld2xpbmUgKCkge1xuICAgIGRvIHtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgfVxuICAgIHdoaWxlICh0b2tlbiA9PSAnXFxuJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiBwYXJhbWV0ZXJzLlxuICAgKiBOZXcgbGluZSBjaGFyYWN0ZXJzIHdpbGwgYmUgaWdub3JlZCB1bnRpbCBjbG9zZVBhcmFtcygpIGlzIGNhbGxlZFxuICAgKi9cbiAgZnVuY3Rpb24gb3BlblBhcmFtcygpIHtcbiAgICBuZXN0aW5nX2xldmVsKys7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgcGFyYW1ldGVycy5cbiAgICogTmV3IGxpbmUgY2hhcmFjdGVycyB3aWxsIG5vIGxvbmdlciBiZSBpZ25vcmVkXG4gICAqL1xuICBmdW5jdGlvbiBjbG9zZVBhcmFtcygpIHtcbiAgICBuZXN0aW5nX2xldmVsLS07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGBjYCBpcyBhIHZhbGlkIGFscGhhIGNoYXJhY3RlcjpcbiAgICpcbiAgICogLSBBIGxhdGluIGxldHRlciAodXBwZXIgb3IgbG93ZXIgY2FzZSkgQXNjaWk6IGEteiwgQS1aXG4gICAqIC0gQW4gdW5kZXJzY29yZSAgICAgICAgICAgICAgICAgICAgICAgICBBc2NpaTogX1xuICAgKiAtIEEgbGF0aW4gbGV0dGVyIHdpdGggYWNjZW50cyAgICAgICAgICBVbmljb2RlOiBcXHUwMEMwIC0gXFx1MDJBRlxuICAgKiAtIEEgZ3JlZWsgbGV0dGVyICAgICAgICAgICAgICAgICAgICAgICBVbmljb2RlOiBcXHUwMzcwIC0gXFx1MDNGRlxuICAgKiAtIEEgbWF0aGVtYXRpY2FsIGFscGhhbnVtZXJpYyBzeW1ib2wgICBVbmljb2RlOiBcXHV7MUQ0MDB9IC0gXFx1ezFEN0ZGfSBleGNsdWRpbmcgaW52YWxpZCBjb2RlIHBvaW50c1xuICAgKlxuICAgKiBUaGUgcHJldmlvdXMgYW5kIG5leHQgY2hhcmFjdGVycyBhcmUgbmVlZGVkIHRvIGRldGVybWluZSB3aGV0aGVyXG4gICAqIHRoaXMgY2hhcmFjdGVyIGlzIHBhcnQgb2YgYSB1bmljb2RlIHN1cnJvZ2F0ZSBwYWlyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYyAgICAgIEN1cnJlbnQgY2hhcmFjdGVyIGluIHRoZSBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjUHJldiAgUHJldmlvdXMgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjTmV4dCAgTmV4dCBjaGFyYWN0ZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHBhcnNlLmlzQWxwaGEgPSBmdW5jdGlvbiBpc0FscGhhIChjLCBjUHJldiwgY05leHQpIHtcbiAgICByZXR1cm4gcGFyc2UuaXNWYWxpZExhdGluT3JHcmVlayhjKVxuICAgICAgICB8fCBwYXJzZS5pc1ZhbGlkTWF0aFN5bWJvbChjLCBjTmV4dClcbiAgICAgICAgfHwgcGFyc2UuaXNWYWxpZE1hdGhTeW1ib2woY1ByZXYsIGMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSBjaGFyYWN0ZXIgaXMgYSB2YWxpZCBsYXRpbiwgZ3JlZWssIG9yIGxldHRlci1saWtlIGNoYXJhY3RlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcGFyc2UuaXNWYWxpZExhdGluT3JHcmVlayA9IGZ1bmN0aW9uIGlzVmFsaWRMYXRpbk9yR3JlZWsgKGMpIHtcbiAgICByZXR1cm4gL15bYS16QS1aX1xcdTAwQzAtXFx1MDJBRlxcdTAzNzAtXFx1MDNGRlxcdTIxMDAtXFx1MjE0Rl0kLy50ZXN0KGMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdHdvIGdpdmVuIDE2IGJpdCBjaGFyYWN0ZXJzIGZvcm0gYSBzdXJyb2dhdGUgcGFpciBvZiBhXG4gICAqIHVuaWNvZGUgbWF0aCBzeW1ib2wuXG4gICAqXG4gICAqIGh0dHA6Ly91bmljb2RlLXRhYmxlLmNvbS9lbi9cbiAgICogaHR0cDovL3d3dy53aWtpd2FuZC5jb20vZW4vTWF0aGVtYXRpY2FsX29wZXJhdG9yc19hbmRfc3ltYm9sc19pbl9Vbmljb2RlXG4gICAqXG4gICAqIE5vdGU6IEluIEVTNiB3aWxsIGJlIHVuaWNvZGUgYXdhcmU6XG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgwNzEyL2phdmFzY3JpcHQtdW5pY29kZS1yZWdleGVzXG4gICAqIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9lczYtdW5pY29kZS1yZWdleFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGlnaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG93XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBwYXJzZS5pc1ZhbGlkTWF0aFN5bWJvbCA9IGZ1bmN0aW9uIGlzVmFsaWRNYXRoU3ltYm9sIChoaWdoLCBsb3cpIHtcbiAgICByZXR1cm4gL15bXFx1RDgzNV0kLy50ZXN0KGhpZ2gpICYmXG4gICAgICAgIC9eW1xcdURDMDAtXFx1REZGRl0kLy50ZXN0KGxvdykgJiZcbiAgICAgICAgL15bXlxcdURDNTVcXHVEQzlEXFx1RENBMFxcdURDQTFcXHVEQ0EzXFx1RENBNFxcdURDQTdcXHVEQ0E4XFx1RENBRFxcdURDQkFcXHVEQ0JDXFx1RENDNFxcdUREMDZcXHVERDBCXFx1REQwQ1xcdUREMTVcXHVERDFEXFx1REQzQVxcdUREM0ZcXHVERDQ1XFx1REQ0Ny1cXHVERDQ5XFx1REQ1MVxcdURFQTZcXHVERUE3XFx1REZDQ1xcdURGQ0RdJC8udGVzdChsb3cpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGdpdmVuIGNoYXJhY3RlciBjIGlzIGEgd2hpdGUgc3BhY2UgY2hhcmFjdGVyOiBzcGFjZSwgdGFiLCBvciBlbnRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY1xuICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZ0xldmVsXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBwYXJzZS5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKGMsIG5lc3RpbmdMZXZlbCkge1xuICAgIC8vIFRPRE86IGFsc28gdGFrZSAnXFxyJyBjYXJyaWFnZSByZXR1cm4gYXMgbmV3bGluZT8gT3IgZG9lcyB0aGF0IGdpdmUgcHJvYmxlbXMgb24gbWFjP1xuICAgIHJldHVybiBjID09ICcgJyB8fCBjID09ICdcXHQnIHx8IChjID09ICdcXG4nICYmIG5lc3RpbmdMZXZlbCA+IDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGNoYXJhY3RlciBjIGlzIGEgZGVjaW1hbCBtYXJrIChkb3QpLlxuICAgKiBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaXQncyBub3QgdGhlIHN0YXJ0IG9mIGEgZGVsaW1pdGVyICcuKicsICcuLycsIG9yICcuXidcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNOZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBwYXJzZS5pc0RlY2ltYWxNYXJrID0gZnVuY3Rpb24gaXNEZWNpbWFsTWFyayAoYywgY05leHQpIHtcbiAgICByZXR1cm4gYyA9PSAnLicgJiYgY05leHQgIT09ICcvJyAmJiBjTmV4dCAhPT0gJyonICYmIGNOZXh0ICE9PSAnXic7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gY2hhciBjIGlzIGEgZGlnaXQgb3IgZG90XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjICAgYSBzdHJpbmcgd2l0aCBvbmUgY2hhcmFjdGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBwYXJzZS5pc0RpZ2l0RG90ID0gZnVuY3Rpb24gaXNEaWdpdERvdCAoYykge1xuICAgIHJldHVybiAoKGMgPj0gJzAnICYmIGMgPD0gJzknKSB8fCBjID09ICcuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gY2hhciBjIGlzIGEgZGlnaXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGMgICBhIHN0cmluZyB3aXRoIG9uZSBjaGFyYWN0ZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHBhcnNlLmlzRGlnaXQgPSBmdW5jdGlvbiBpc0RpZ2l0IChjKSB7XG4gICAgcmV0dXJuIChjID49ICcwJyAmJiBjIDw9ICc5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIHRoZSBwYXJzZSBsZXZlbHMgYmVsb3csIGluIG9yZGVyIG9mIHByZWNlZGVuY2VcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdGFydCAoKSB7XG4gICAgLy8gZ2V0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gZXhwcmVzc2lvblxuICAgIGZpcnN0KCk7XG5cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgdmFyIG5vZGUgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAvLyBjaGVjayBmb3IgZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uXG4gICAgLy8gYW4gZXhwcmVzc2lvbiBlbmRzIHdpdGggYSBlbXB0eSBjaGFyYWN0ZXIgJycgYW5kIHRva2VuX3R5cGUgREVMSU1JVEVSXG4gICAgaWYgKHRva2VuICE9ICcnKSB7XG4gICAgICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuREVMSU1JVEVSKSB7XG4gICAgICAgIC8vIHVzZXIgZW50ZXJlZCBhIG5vdCBleGlzdGluZyBvcGVyYXRvciBsaWtlIFwiLy9cIlxuXG4gICAgICAgIC8vIFRPRE86IGdpdmUgaGludHMgZm9yIGFsaWFzZXMsIGZvciBleGFtcGxlIHdpdGggXCI8PlwiIGdpdmUgYXMgaGludCBcIiBkaWQgeW91IG1lYW4gIT0gP1wiXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdVbmV4cGVjdGVkIG9wZXJhdG9yICcgKyB0b2tlbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgcGFydCBcIicgKyB0b2tlbiArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgYmxvY2sgd2l0aCBleHByZXNzaW9ucy4gRXhwcmVzc2lvbnMgY2FuIGJlIHNlcGFyYXRlZCBieSBhIG5ld2xpbmVcbiAgICogY2hhcmFjdGVyICdcXG4nLCBvciBieSBhIHNlbWljb2xvbiAnOycuIEluIGNhc2Ugb2YgYSBzZW1pY29sb24sIG5vIG91dHB1dFxuICAgKiBvZiB0aGUgcHJlY2VkaW5nIGxpbmUgaXMgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQmxvY2sgKCkge1xuICAgIHZhciBub2RlO1xuICAgIHZhciBibG9ja3MgPSBbXTtcbiAgICB2YXIgdmlzaWJsZTtcblxuICAgIGlmICh0b2tlbiA9PSAnJykge1xuICAgICAgLy8gZW1wdHkgZXhwcmVzc2lvblxuICAgICAgbm9kZSA9IG5ldyBDb25zdGFudE5vZGUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH1cblxuICAgIGlmICh0b2tlbiAhPSAnXFxuJyAmJiB0b2tlbiAhPSAnOycpIHtcbiAgICAgIG5vZGUgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc2ltcGxpZnkgdGhpcyBsb29wXG4gICAgd2hpbGUgKHRva2VuID09ICdcXG4nIHx8IHRva2VuID09ICc7Jykge1xuICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT0gMCAmJiBub2RlKSB7XG4gICAgICAgIHZpc2libGUgPSAodG9rZW4gIT0gJzsnKTtcbiAgICAgICAgYmxvY2tzLnB1c2goe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIGlmICh0b2tlbiAhPSAnXFxuJyAmJiB0b2tlbiAhPSAnOycgJiYgdG9rZW4gIT0gJycpIHtcbiAgICAgICAgbm9kZSA9IHBhcnNlQXNzaWdubWVudCgpO1xuICAgICAgICBub2RlLmNvbW1lbnQgPSBjb21tZW50O1xuXG4gICAgICAgIHZpc2libGUgPSAodG9rZW4gIT0gJzsnKTtcbiAgICAgICAgYmxvY2tzLnB1c2goe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgQmxvY2tOb2RlKGJsb2Nrcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbm1lbnQgb2YgYSBmdW5jdGlvbiBvciB2YXJpYWJsZSxcbiAgICogLSBjYW4gYmUgYSB2YXJpYWJsZSBsaWtlICdhPTIuMydcbiAgICogLSBvciBhIHVwZGF0aW5nIGFuIGV4aXN0aW5nIHZhcmlhYmxlIGxpa2UgJ21hdHJpeCgyLDM6NSk9WzYsNyw4XSdcbiAgICogLSBkZWZpbmluZyBhIGZ1bmN0aW9uIGxpa2UgJ2YoeCkgPSB4XjInXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudCAoKSB7XG4gICAgdmFyIG5hbWUsIGFyZ3MsIHZhbHVlLCB2YWxpZDtcblxuICAgIHZhciBub2RlID0gcGFyc2VDb25kaXRpb25hbCgpO1xuXG4gICAgaWYgKHRva2VuID09ICc9Jykge1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pc1N5bWJvbE5vZGUpIHtcbiAgICAgICAgLy8gcGFyc2UgYSB2YXJpYWJsZSBhc3NpZ25tZW50IGxpa2UgJ2EgPSAyLzMnXG4gICAgICAgIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZShuZXcgU3ltYm9sTm9kZShuYW1lKSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZSAmJiBub2RlLmlzQWNjZXNzb3JOb2RlKSB7XG4gICAgICAgIC8vIHBhcnNlIGEgbWF0cml4IHN1YnNldCBhc3NpZ25tZW50IGxpa2UgJ0FbMSwyXSA9IDQnXG4gICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25tZW50Tm9kZShub2RlLm9iamVjdCwgbm9kZS5pbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZSAmJiBub2RlLmlzRnVuY3Rpb25Ob2RlKSB7XG4gICAgICAgIC8vIHBhcnNlIGZ1bmN0aW9uIGFzc2lnbm1lbnQgbGlrZSAnZih4KSA9IHheMidcbiAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICBhcmdzID0gW107XG5cbiAgICAgICAgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgbm9kZS5hcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoYXJnICYmIGFyZy5pc1N5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJnLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Bc3NpZ25tZW50Tm9kZShuYW1lLCBhcmdzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0ludmFsaWQgbGVmdCBoYW5kIHNpZGUgb2YgYXNzaWdubWVudCBvcGVyYXRvciA9Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogY29uZGl0aW9uYWwgb3BlcmF0aW9uXG4gICAqXG4gICAqICAgICBjb25kaXRpb24gPyB0cnVlUGFydCA6IGZhbHNlUGFydFxuICAgKlxuICAgKiBOb3RlOiBjb25kaXRpb25hbCBvcGVyYXRvciBpcyByaWdodC1hc3NvY2lhdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsICgpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlTG9naWNhbE9yKCk7XG5cbiAgICB3aGlsZSAodG9rZW4gPT0gJz8nKSB7XG4gICAgICAvLyBzZXQgYSBjb25kaXRpb25hbCBsZXZlbCwgdGhlIHJhbmdlIG9wZXJhdG9yIHdpbGwgYmUgaWdub3JlZCBhcyBsb25nXG4gICAgICAvLyBhcyBjb25kaXRpb25hbF9sZXZlbCA9PSBuZXN0aW5nX2xldmVsLlxuICAgICAgdmFyIHByZXYgPSBjb25kaXRpb25hbF9sZXZlbDtcbiAgICAgIGNvbmRpdGlvbmFsX2xldmVsID0gbmVzdGluZ19sZXZlbDtcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcblxuICAgICAgdmFyIGNvbmRpdGlvbiA9IG5vZGU7XG4gICAgICB2YXIgdHJ1ZUV4cHIgPSBwYXJzZUFzc2lnbm1lbnQoKTtcblxuICAgICAgaWYgKHRva2VuICE9ICc6JykgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0ZhbHNlIHBhcnQgb2YgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuXG4gICAgICBjb25kaXRpb25hbF9sZXZlbCA9IG51bGw7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG5cbiAgICAgIHZhciBmYWxzZUV4cHIgPSBwYXJzZUFzc2lnbm1lbnQoKTsgLy8gTm90ZTogY2hlY2sgZm9yIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGFnYWluLCByaWdodCBhc3NvY2lhdGl2aXR5XG5cbiAgICAgIG5vZGUgPSBuZXcgQ29uZGl0aW9uYWxOb2RlKGNvbmRpdGlvbiwgdHJ1ZUV4cHIsIGZhbHNlRXhwcik7XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHByZXZpb3VzIGNvbmRpdGlvbmFsIGxldmVsXG4gICAgICBjb25kaXRpb25hbF9sZXZlbCA9IHByZXY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogbG9naWNhbCBvciwgJ3ggb3IgeSdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsT3IoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJzZUxvZ2ljYWxYb3IoKTtcblxuICAgIHdoaWxlICh0b2tlbiA9PSAnb3InKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgnb3InLCAnb3InLCBbbm9kZSwgcGFyc2VMb2dpY2FsWG9yKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsb2dpY2FsIGV4Y2x1c2l2ZSBvciwgJ3ggeG9yIHknXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTG9naWNhbFhvcigpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlTG9naWNhbEFuZCgpO1xuXG4gICAgd2hpbGUgKHRva2VuID09ICd4b3InKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgneG9yJywgJ3hvcicsIFtub2RlLCBwYXJzZUxvZ2ljYWxBbmQoKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIGxvZ2ljYWwgYW5kLCAneCBhbmQgeSdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsQW5kKCkge1xuICAgIHZhciBub2RlID0gcGFyc2VCaXR3aXNlT3IoKTtcblxuICAgIHdoaWxlICh0b2tlbiA9PSAnYW5kJykge1xuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUoJ2FuZCcsICdhbmQnLCBbbm9kZSwgcGFyc2VCaXR3aXNlT3IoKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIGJpdHdpc2Ugb3IsICd4IHwgeSdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlT3IoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJzZUJpdHdpc2VYb3IoKTtcblxuICAgIHdoaWxlICh0b2tlbiA9PSAnfCcpIHtcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCd8JywgJ2JpdE9yJywgW25vZGUsIHBhcnNlQml0d2lzZVhvcigpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogYml0d2lzZSBleGNsdXNpdmUgb3IgKHhvciksICd4IF58IHknXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQml0d2lzZVhvcigpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlQml0d2lzZUFuZCgpO1xuXG4gICAgd2hpbGUgKHRva2VuID09ICdefCcpIHtcbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCdefCcsICdiaXRYb3InLCBbbm9kZSwgcGFyc2VCaXR3aXNlQW5kKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBiaXR3aXNlIGFuZCwgJ3ggJiB5J1xuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUJpdHdpc2VBbmQgKCkge1xuICAgIHZhciBub2RlID0gcGFyc2VSZWxhdGlvbmFsKCk7XG5cbiAgICB3aGlsZSAodG9rZW4gPT0gJyYnKSB7XG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZSgnJicsICdiaXRBbmQnLCBbbm9kZSwgcGFyc2VSZWxhdGlvbmFsKCldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWxhdGlvbmFsIG9wZXJhdG9yc1xuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVJlbGF0aW9uYWwgKCkge1xuICAgIHZhciBub2RlLCBvcGVyYXRvcnMsIG5hbWUsIGZuLCBwYXJhbXM7XG5cbiAgICBub2RlID0gcGFyc2VTaGlmdCgpO1xuXG4gICAgb3BlcmF0b3JzID0ge1xuICAgICAgJz09JzogJ2VxdWFsJyxcbiAgICAgICchPSc6ICd1bmVxdWFsJyxcbiAgICAgICc8JzogJ3NtYWxsZXInLFxuICAgICAgJz4nOiAnbGFyZ2VyJyxcbiAgICAgICc8PSc6ICdzbWFsbGVyRXEnLFxuICAgICAgJz49JzogJ2xhcmdlckVxJ1xuICAgIH07XG4gICAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgICAgbmFtZSA9IHRva2VuO1xuICAgICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIHBhcmFtcyA9IFtub2RlLCBwYXJzZVNoaWZ0KCldO1xuICAgICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogQml0d2lzZSBsZWZ0IHNoaWZ0LCBiaXR3aXNlIHJpZ2h0IGFyaXRobWV0aWMgc2hpZnQsIGJpdHdpc2UgcmlnaHQgbG9naWNhbCBzaGlmdFxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVNoaWZ0ICgpIHtcbiAgICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gICAgbm9kZSA9IHBhcnNlQ29udmVyc2lvbigpO1xuXG4gICAgb3BlcmF0b3JzID0ge1xuICAgICAgJzw8JyA6ICdsZWZ0U2hpZnQnLFxuICAgICAgJz4+JyA6ICdyaWdodEFyaXRoU2hpZnQnLFxuICAgICAgJz4+PicgOiAncmlnaHRMb2dTaGlmdCdcbiAgICB9O1xuXG4gICAgd2hpbGUgKHRva2VuIGluIG9wZXJhdG9ycykge1xuICAgICAgbmFtZSA9IHRva2VuO1xuICAgICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcbiAgICAgIHBhcmFtcyA9IFtub2RlLCBwYXJzZUNvbnZlcnNpb24oKV07XG4gICAgICBub2RlID0gbmV3IE9wZXJhdG9yTm9kZShuYW1lLCBmbiwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJzaW9uIG9wZXJhdG9ycyAndG8nIGFuZCAnaW4nXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQ29udmVyc2lvbiAoKSB7XG4gICAgdmFyIG5vZGUsIG9wZXJhdG9ycywgbmFtZSwgZm4sIHBhcmFtcztcblxuICAgIG5vZGUgPSBwYXJzZVJhbmdlKCk7XG5cbiAgICBvcGVyYXRvcnMgPSB7XG4gICAgICAndG8nIDogJ3RvJyxcbiAgICAgICdpbicgOiAndG8nICAgLy8gYWxpYXMgb2YgJ3RvJ1xuICAgIH07XG5cbiAgICB3aGlsZSAodG9rZW4gaW4gb3BlcmF0b3JzKSB7XG4gICAgICBuYW1lID0gdG9rZW47XG4gICAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgXG4gICAgICBpZiAobmFtZSA9PT0gJ2luJyAmJiB0b2tlbiA9PT0gJycpIHtcbiAgICAgICAgLy8gZW5kIG9mIGV4cHJlc3Npb24gLT4gdGhpcyBpcyB0aGUgdW5pdCAnaW4nICgnaW5jaCcpXG4gICAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCcqJywgJ211bHRpcGx5JywgW25vZGUsIG5ldyBTeW1ib2xOb2RlKCdpbicpXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gb3BlcmF0b3IgJ2EgdG8gYicgb3IgJ2EgaW4gYidcbiAgICAgICAgcGFyYW1zID0gW25vZGUsIHBhcnNlUmFuZ2UoKV07XG4gICAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIHJhbmdlLCBcInN0YXJ0OmVuZFwiLCBcInN0YXJ0OnN0ZXA6ZW5kXCIsIFwiOlwiLCBcInN0YXJ0OlwiLCBcIjplbmRcIiwgZXRjXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlUmFuZ2UgKCkge1xuICAgIHZhciBub2RlLCBwYXJhbXMgPSBbXTtcblxuICAgIGlmICh0b2tlbiA9PSAnOicpIHtcbiAgICAgIC8vIGltcGxpY2l0IHN0YXJ0PTEgKG9uZS1iYXNlZClcbiAgICAgIG5vZGUgPSBuZXcgQ29uc3RhbnROb2RlKCcxJywgJ251bWJlcicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGV4cGxpY2l0IHN0YXJ0XG4gICAgICBub2RlID0gcGFyc2VBZGRTdWJ0cmFjdCgpO1xuICAgIH1cblxuICAgIGlmICh0b2tlbiA9PSAnOicgJiYgKGNvbmRpdGlvbmFsX2xldmVsICE9PSBuZXN0aW5nX2xldmVsKSkge1xuICAgICAgLy8gd2UgaWdub3JlIHRoZSByYW5nZSBvcGVyYXRvciB3aGVuIGEgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgYmVpbmcgcHJvY2Vzc2VkIG9uIHRoZSBzYW1lIGxldmVsXG4gICAgICBwYXJhbXMucHVzaChub2RlKTtcblxuICAgICAgLy8gcGFyc2Ugc3RlcCBhbmQgZW5kXG4gICAgICB3aGlsZSAodG9rZW4gPT0gJzonICYmIHBhcmFtcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGdldFRva2VuU2tpcE5ld2xpbmUoKTtcblxuICAgICAgICBpZiAodG9rZW4gPT0gJyknIHx8IHRva2VuID09ICddJyB8fCB0b2tlbiA9PSAnLCcgfHwgdG9rZW4gPT0gJycpIHtcbiAgICAgICAgICAvLyBpbXBsaWNpdCBlbmRcbiAgICAgICAgICBwYXJhbXMucHVzaChuZXcgU3ltYm9sTm9kZSgnZW5kJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGV4cGxpY2l0IGVuZFxuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQWRkU3VidHJhY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT0gMykge1xuICAgICAgICAvLyBwYXJhbXMgPSBbc3RhcnQsIHN0ZXAsIGVuZF1cbiAgICAgICAgbm9kZSA9IG5ldyBSYW5nZU5vZGUocGFyYW1zWzBdLCBwYXJhbXNbMl0sIHBhcmFtc1sxXSk7IC8vIHN0YXJ0LCBlbmQsIHN0ZXBcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBsZW5ndGggPT0gMlxuICAgICAgICAvLyBwYXJhbXMgPSBbc3RhcnQsIGVuZF1cbiAgICAgICAgbm9kZSA9IG5ldyBSYW5nZU5vZGUocGFyYW1zWzBdLCBwYXJhbXNbMV0pOyAvLyBzdGFydCwgZW5kXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogYWRkIG9yIHN1YnRyYWN0XG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQWRkU3VidHJhY3QgKCkgIHtcbiAgICB2YXIgbm9kZSwgb3BlcmF0b3JzLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gICAgbm9kZSA9IHBhcnNlTXVsdGlwbHlEaXZpZGUoKTtcblxuICAgIG9wZXJhdG9ycyA9IHtcbiAgICAgICcrJzogJ2FkZCcsXG4gICAgICAnLSc6ICdzdWJ0cmFjdCdcbiAgICB9O1xuICAgIHdoaWxlICh0b2tlbiBpbiBvcGVyYXRvcnMpIHtcbiAgICAgIG5hbWUgPSB0b2tlbjtcbiAgICAgIGZuID0gb3BlcmF0b3JzW25hbWVdO1xuXG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBwYXJhbXMgPSBbbm9kZSwgcGFyc2VNdWx0aXBseURpdmlkZSgpXTtcbiAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIG11bHRpcGx5LCBkaXZpZGUsIG1vZHVsdXNcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VNdWx0aXBseURpdmlkZSAoKSB7XG4gICAgdmFyIG5vZGUsIGxhc3QsIG9wZXJhdG9ycywgbmFtZSwgZm47XG5cbiAgICBub2RlID0gcGFyc2VVbmFyeSgpO1xuICAgIGxhc3QgPSBub2RlO1xuXG4gICAgb3BlcmF0b3JzID0ge1xuICAgICAgJyonOiAnbXVsdGlwbHknLFxuICAgICAgJy4qJzogJ2RvdE11bHRpcGx5JyxcbiAgICAgICcvJzogJ2RpdmlkZScsXG4gICAgICAnLi8nOiAnZG90RGl2aWRlJyxcbiAgICAgICclJzogJ21vZCcsXG4gICAgICAnbW9kJzogJ21vZCdcbiAgICB9O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0b2tlbiBpbiBvcGVyYXRvcnMpIHtcbiAgICAgICAgLy8gZXhwbGljaXQgb3BlcmF0b3JzXG4gICAgICAgIG5hbWUgPSB0b2tlbjtcbiAgICAgICAgZm4gPSBvcGVyYXRvcnNbbmFtZV07XG5cbiAgICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuXG4gICAgICAgIGxhc3QgPSBwYXJzZVVuYXJ5KCk7XG4gICAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKG5hbWUsIGZuLCBbbm9kZSwgbGFzdF0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLlNZTUJPTCkgfHxcbiAgICAgICAgICAodG9rZW4gPT0gJ2luJyAmJiAobm9kZSAmJiBub2RlLmlzQ29uc3RhbnROb2RlKSkgfHxcbiAgICAgICAgICAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuTlVNQkVSICYmXG4gICAgICAgICAgICAgICFsYXN0LmlzQ29uc3RhbnROb2RlICYmXG4gICAgICAgICAgICAgICghbGFzdC5pc09wZXJhdG9yTm9kZSB8fCBsYXN0Lm9wID09PSAnIScpKSB8fFxuICAgICAgICAgICh0b2tlbiA9PSAnKCcpKSB7XG4gICAgICAgIC8vIHBhcnNlIGltcGxpY2l0IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHN5bWJvbDogICAgICBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiBsaWtlICcyYScsICcoMiszKWEnLCAnYSBiJ1xuICAgICAgICAvLyBudW1iZXI6ICAgICAgaW1wbGljaXQgbXVsdGlwbGljYXRpb24gbGlrZSAnKDIrMykyJ1xuICAgICAgICAvLyBwYXJlbnRoZXNpczogaW1wbGljaXQgbXVsdGlwbGljYXRpb24gbGlrZSAnMigzKzQpJywgJygzKzQpKDErMiknXG4gICAgICAgIGxhc3QgPSBwYXJzZVVuYXJ5KCk7XG4gICAgICAgIG5vZGUgPSBuZXcgT3BlcmF0b3JOb2RlKCcqJywgJ211bHRpcGx5JywgW25vZGUsIGxhc3RdLCB0cnVlIC8qaW1wbGljaXQqLyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogVW5hcnkgcGx1cyBhbmQgbWludXMsIGFuZCBsb2dpY2FsIGFuZCBiaXR3aXNlIG5vdFxuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVVuYXJ5ICgpIHtcbiAgICB2YXIgbmFtZSwgcGFyYW1zO1xuICAgIHZhciBmbiA9IHtcbiAgICAgICctJzogJ3VuYXJ5TWludXMnLFxuICAgICAgJysnOiAndW5hcnlQbHVzJyxcbiAgICAgICd+JzogJ2JpdE5vdCcsXG4gICAgICAnbm90JzogJ25vdCdcbiAgICB9W3Rva2VuXTtcblxuICAgIGlmIChmbikge1xuICAgICAgbmFtZSA9IHRva2VuO1xuXG4gICAgICBnZXRUb2tlblNraXBOZXdsaW5lKCk7XG4gICAgICBwYXJhbXMgPSBbcGFyc2VVbmFyeSgpXTtcblxuICAgICAgcmV0dXJuIG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlUG93KCk7XG4gIH1cblxuICAvKipcbiAgICogcG93ZXJcbiAgICogTm90ZTogcG93ZXIgb3BlcmF0b3IgaXMgcmlnaHQgYXNzb2NpYXRpdmVcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VQb3cgKCkge1xuICAgIHZhciBub2RlLCBuYW1lLCBmbiwgcGFyYW1zO1xuXG4gICAgbm9kZSA9IHBhcnNlTGVmdEhhbmRPcGVyYXRvcnMoKTtcblxuICAgIGlmICh0b2tlbiA9PSAnXicgfHwgdG9rZW4gPT0gJy5eJykge1xuICAgICAgbmFtZSA9IHRva2VuO1xuICAgICAgZm4gPSAobmFtZSA9PSAnXicpID8gJ3BvdycgOiAnZG90UG93JztcblxuICAgICAgZ2V0VG9rZW5Ta2lwTmV3bGluZSgpO1xuICAgICAgcGFyYW1zID0gW25vZGUsIHBhcnNlVW5hcnkoKV07IC8vIEdvIGJhY2sgdG8gdW5hcnksIHdlIGNhbiBoYXZlICcyXi0zJ1xuICAgICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogTGVmdCBoYW5kIG9wZXJhdG9yczogZmFjdG9yaWFsIHghLCB0cmFuc3Bvc2UgeCdcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZE9wZXJhdG9ycyAoKSAge1xuICAgIHZhciBub2RlLCBvcGVyYXRvcnMsIG5hbWUsIGZuLCBwYXJhbXM7XG5cbiAgICBub2RlID0gcGFyc2VDdXN0b21Ob2RlcygpO1xuXG4gICAgb3BlcmF0b3JzID0ge1xuICAgICAgJyEnOiAnZmFjdG9yaWFsJyxcbiAgICAgICdcXCcnOiAndHJhbnNwb3NlJ1xuICAgIH07XG5cbiAgICB3aGlsZSAodG9rZW4gaW4gb3BlcmF0b3JzKSB7XG4gICAgICBuYW1lID0gdG9rZW47XG4gICAgICBmbiA9IG9wZXJhdG9yc1tuYW1lXTtcblxuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIHBhcmFtcyA9IFtub2RlXTtcblxuICAgICAgbm9kZSA9IG5ldyBPcGVyYXRvck5vZGUobmFtZSwgZm4sIHBhcmFtcyk7XG4gICAgICBub2RlID0gcGFyc2VBY2Nlc3NvcnMobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBjdXN0b20gbm9kZSBoYW5kbGVyLiBBIG5vZGUgaGFuZGxlciBjYW4gYmUgdXNlZCB0byBwcm9jZXNzXG4gICAqIG5vZGVzIGluIGEgY3VzdG9tIHdheSwgZm9yIGV4YW1wbGUgZm9yIGhhbmRsaW5nIGEgcGxvdC5cbiAgICpcbiAgICogQSBoYW5kbGVyIG11c3QgYmUgcGFzc2VkIGFzIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgcGFyc2UgZnVuY3Rpb24uXG4gICAqIC0gbXVzdCBleHRlbmQgbWF0aC5leHByZXNzaW9uLm5vZGUuTm9kZVxuICAgKiAtIG11c3QgY29udGFpbiBhIGZ1bmN0aW9uIF9jb21waWxlKGRlZnM6IE9iamVjdCkgOiBzdHJpbmdcbiAgICogLSBtdXN0IGNvbnRhaW4gYSBmdW5jdGlvbiBmaW5kKGZpbHRlcjogT2JqZWN0KSA6IE5vZGVbXVxuICAgKiAtIG11c3QgY29udGFpbiBhIGZ1bmN0aW9uIHRvU3RyaW5nKCkgOiBzdHJpbmdcbiAgICogLSB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQgY29udGFpbmluZyBhbGwgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogICAgIG5vZGVzID0ge1xuICAgKiAgICAgICAncGxvdCc6IFBsb3RIYW5kbGVyXG4gICAqICAgICB9O1xuICAgKlxuICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGhhbmRsZXIgaXMgY2FsbGVkIGFzOlxuICAgKlxuICAgKiAgICAgbm9kZSA9IG5ldyBQbG90SGFuZGxlcihwYXJhbXMpO1xuICAgKlxuICAgKiBUaGUgaGFuZGxlciB3aWxsIGJlIGludm9rZWQgd2hlbiBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gbGlrZTpcbiAgICpcbiAgICogICAgIG5vZGUgPSBtYXRoLnBhcnNlKCdwbG90KHNpbih4KSwgeCknLCBub2Rlcyk7XG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQ3VzdG9tTm9kZXMgKCkge1xuICAgIHZhciBwYXJhbXMgPSBbXSwgaGFuZGxlcjtcblxuICAgIGlmICh0b2tlbl90eXBlID09IFRPS0VOVFlQRS5TWU1CT0wgJiYgZXh0cmFfbm9kZXNbdG9rZW5dKSB7XG4gICAgICBoYW5kbGVyID0gZXh0cmFfbm9kZXNbdG9rZW5dO1xuXG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAvLyBwYXJzZSBwYXJhbWV0ZXJzXG4gICAgICBpZiAodG9rZW4gPT0gJygnKSB7XG4gICAgICAgIHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIG9wZW5QYXJhbXMoKTtcbiAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICBpZiAodG9rZW4gIT0gJyknKSB7XG4gICAgICAgICAgcGFyYW1zLnB1c2gocGFyc2VBc3NpZ25tZW50KCkpO1xuXG4gICAgICAgICAgLy8gcGFyc2UgYSBsaXN0IHdpdGggcGFyYW1ldGVyc1xuICAgICAgICAgIHdoaWxlICh0b2tlbiA9PSAnLCcpIHtcbiAgICAgICAgICAgIGdldFRva2VuKCk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUFzc2lnbm1lbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuICE9ICcpJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdQYXJlbnRoZXNpcyApIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VQYXJhbXMoKTtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIGEgbmV3IG5vZGUgaGFuZGxlclxuICAgICAgLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZVR5cGVzXG4gICAgICByZXR1cm4gbmV3IGhhbmRsZXIocGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VTeW1ib2woKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBzeW1ib2xzOiBmdW5jdGlvbnMsIHZhcmlhYmxlcywgY29uc3RhbnRzLCB1bml0c1xuICAgKiBAcmV0dXJuIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN5bWJvbCAoKSB7XG4gICAgdmFyIG5vZGUsIG5hbWU7XG5cbiAgICBpZiAodG9rZW5fdHlwZSA9PSBUT0tFTlRZUEUuU1lNQk9MIHx8XG4gICAgICAgICh0b2tlbl90eXBlID09IFRPS0VOVFlQRS5ERUxJTUlURVIgJiYgdG9rZW4gaW4gTkFNRURfREVMSU1JVEVSUykpIHtcbiAgICAgIG5hbWUgPSB0b2tlbjtcblxuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gcGFyc2UgZnVuY3Rpb24gcGFyYW1ldGVycyBhbmQgbWF0cml4IGluZGV4XG4gICAgICBub2RlID0gbmV3IFN5bWJvbE5vZGUobmFtZSk7XG4gICAgICBub2RlID0gcGFyc2VBY2Nlc3NvcnMobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSBhY2Nlc3NvcnM6XG4gICAqIC0gZnVuY3Rpb24gaW52b2NhdGlvbiBpbiByb3VuZCBicmFja2V0cyAoLi4uKSwgZm9yIGV4YW1wbGUgc3FydCgyKVxuICAgKiAtIGluZGV4IGVuY2xvc2VkIGluIHNxdWFyZSBicmFja2V0cyBbLi4uXSwgZm9yIGV4YW1wbGUgQVsyLDNdXG4gICAqIC0gZG90IG5vdGF0aW9uIGZvciBwcm9wZXJ0aWVzLCBsaWtlIGZvby5iYXJcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICAgIE5vZGUgb24gd2hpY2ggdG8gYXBwbHkgdGhlIHBhcmFtZXRlcnMuIElmIHRoZXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBhcmUgbm8gcGFyYW1ldGVycyBpbiB0aGUgZXhwcmVzc2lvbiwgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGl0c2VsZiBpcyByZXR1cm5lZFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbdHlwZXNdICBGaWx0ZXIgdGhlIHR5cGVzIG9mIG5vdGF0aW9uc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgWycoJywgJ1snLCAnLiddXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQWNjZXNzb3JzIChub2RlLCB0eXBlcykge1xuICAgIHZhciBwYXJhbXM7XG5cbiAgICB3aGlsZSAoKHRva2VuID09ICcoJyB8fCB0b2tlbiA9PSAnWycgfHwgdG9rZW4gPT0gJy4nKSAmJlxuICAgICAgICAoIXR5cGVzIHx8IHR5cGVzLmluZGV4T2YodG9rZW4pICE9PSAtMSkpIHtcbiAgICAgIHBhcmFtcyA9IFtdO1xuXG4gICAgICBpZiAodG9rZW4gPT0gJygnKSB7XG4gICAgICAgIGlmIChub2RlLmlzU3ltYm9sTm9kZSB8fCBub2RlLmlzQWNjZXNzb3JOb2RlIHx8IG5vZGUuaXNGdW5jdGlvbk5vZGUpIHtcbiAgICAgICAgICAvLyBmdW5jdGlvbiBpbnZvY2F0aW9uIGxpa2UgZm4oMiwgMylcbiAgICAgICAgICBvcGVuUGFyYW1zKCk7XG4gICAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICAgIGlmICh0b2tlbiAhPSAnKScpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQXNzaWdubWVudCgpKTtcblxuICAgICAgICAgICAgLy8gcGFyc2UgYSBsaXN0IHdpdGggcGFyYW1ldGVyc1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuID09ICcsJykge1xuICAgICAgICAgICAgICBnZXRUb2tlbigpO1xuICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUFzc2lnbm1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRva2VuICE9ICcpJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1BhcmVudGhlc2lzICkgZXhwZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xvc2VQYXJhbXMoKTtcbiAgICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgICAgbm9kZSA9IG5ldyBGdW5jdGlvbk5vZGUobm9kZSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiBsaWtlICgyKzMpKDQrNSlcbiAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpdCBoZXJlIGJ1dCBsZXQgaXQgYmUgaGFuZGxlZCBieSBwYXJzZU11bHRpcGx5RGl2aWRlXG4gICAgICAgICAgLy8gd2l0aCBjb3JyZWN0IHByZWNlZGVuY2VcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodG9rZW4gPT0gJ1snKSB7XG4gICAgICAgIC8vIGluZGV4IG5vdGF0aW9uIGxpa2UgdmFyaWFibGVbMiwgM11cbiAgICAgICAgb3BlblBhcmFtcygpO1xuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbiAhPSAnXScpIHtcbiAgICAgICAgICBwYXJhbXMucHVzaChwYXJzZUFzc2lnbm1lbnQoKSk7XG5cbiAgICAgICAgICAvLyBwYXJzZSBhIGxpc3Qgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICAgICAgd2hpbGUgKHRva2VuID09ICcsJykge1xuICAgICAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnNlQXNzaWdubWVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4gIT0gJ10nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1BhcmVudGhlc2lzIF0gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIG5vZGUgPSBuZXcgQWNjZXNzb3JOb2RlKG5vZGUsIG5ldyBJbmRleE5vZGUocGFyYW1zKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZG90IG5vdGF0aW9uIGxpa2UgdmFyaWFibGUucHJvcFxuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbl90eXBlICE9IFRPS0VOVFlQRS5TWU1CT0wpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignUHJvcGVydHkgbmFtZSBleHBlY3RlZCBhZnRlciBkb3QnKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaChuZXcgQ29uc3RhbnROb2RlKHRva2VuKSk7XG4gICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgdmFyIGRvdE5vdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IG5ldyBBY2Nlc3Nvck5vZGUobm9kZSwgbmV3IEluZGV4Tm9kZShwYXJhbXMsIGRvdE5vdGF0aW9uKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYSBzdHJpbmcuXG4gICAqIEEgc3RyaW5nIGlzIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcbiAgICogQHJldHVybiB7Tm9kZX0gbm9kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHJpbmcgKCkge1xuICAgIHZhciBub2RlLCBzdHI7XG5cbiAgICBpZiAodG9rZW4gPT0gJ1wiJykge1xuICAgICAgc3RyID0gcGFyc2VTdHJpbmdUb2tlbigpO1xuXG4gICAgICAvLyBjcmVhdGUgY29uc3RhbnRcbiAgICAgIG5vZGUgPSBuZXcgQ29uc3RhbnROb2RlKHN0ciwgJ3N0cmluZycpO1xuXG4gICAgICAvLyBwYXJzZSBpbmRleCBwYXJhbWV0ZXJzXG4gICAgICBub2RlID0gcGFyc2VBY2Nlc3NvcnMobm9kZSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU1hdHJpeCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc3RyaW5nIHN1cnJvdW5kZWQgYnkgZG91YmxlIHF1b3RlcyBcIi4uLlwiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nVG9rZW4gKCkge1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIHdoaWxlIChjICE9ICcnICYmIGMgIT0gJ1xcXCInKSB7XG4gICAgICBpZiAoYyA9PSAnXFxcXCcpIHtcbiAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICBzdHIgKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBnZXRUb2tlbigpO1xuICAgIGlmICh0b2tlbiAhPSAnXCInKSB7XG4gICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRW5kIG9mIHN0cmluZyBcIiBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBnZXRUb2tlbigpO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSB0aGUgbWF0cml4XG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTWF0cml4ICgpIHtcbiAgICB2YXIgYXJyYXksIHBhcmFtcywgcm93cywgY29scztcblxuICAgIGlmICh0b2tlbiA9PSAnWycpIHtcbiAgICAgIC8vIG1hdHJpeCBbLi4uXVxuICAgICAgb3BlblBhcmFtcygpO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuICE9ICddJykge1xuICAgICAgICAvLyB0aGlzIGlzIGEgbm9uLWVtcHR5IG1hdHJpeFxuICAgICAgICB2YXIgcm93ID0gcGFyc2VSb3coKTtcblxuICAgICAgICBpZiAodG9rZW4gPT0gJzsnKSB7XG4gICAgICAgICAgLy8gMiBkaW1lbnNpb25hbCBhcnJheVxuICAgICAgICAgIHJvd3MgPSAxO1xuICAgICAgICAgIHBhcmFtcyA9IFtyb3ddO1xuXG4gICAgICAgICAgLy8gdGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBhcmUgc2VwYXJhdGVkIGJ5IGRvdC1jb21tYSdzXG4gICAgICAgICAgd2hpbGUgKHRva2VuID09ICc7Jykge1xuICAgICAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICAgICAgcGFyYW1zW3Jvd3NdID0gcGFyc2VSb3coKTtcbiAgICAgICAgICAgIHJvd3MrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9rZW4gIT0gJ10nKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignRW5kIG9mIG1hdHJpeCBdIGV4cGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb3NlUGFyYW1zKCk7XG4gICAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBtYXRjaGVzIGluIGFsbCByb3dzXG4gICAgICAgICAgY29scyA9IHBhcmFtc1swXS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbcl0uaXRlbXMubGVuZ3RoICE9IGNvbHMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0NvbHVtbiBkaW1lbnNpb25zIG1pc21hdGNoICcgK1xuICAgICAgICAgICAgICAgICAgJygnICsgcGFyYW1zW3JdLml0ZW1zLmxlbmd0aCArICcgIT0gJyArIGNvbHMgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFycmF5ID0gbmV3IEFycmF5Tm9kZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIDEgZGltZW5zaW9uYWwgdmVjdG9yXG4gICAgICAgICAgaWYgKHRva2VuICE9ICddJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ0VuZCBvZiBtYXRyaXggXSBleHBlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgICAgIGdldFRva2VuKCk7XG5cbiAgICAgICAgICBhcnJheSA9IHJvdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYW4gZW1wdHkgbWF0cml4IFwiWyBdXCJcbiAgICAgICAgY2xvc2VQYXJhbXMoKTtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXlOb2RlKFtdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlQWNjZXNzb3JzKGFycmF5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHNpbmdsZSBjb21tYS1zZXBhcmF0ZWQgcm93IGZyb20gYSBtYXRyaXgsIGxpa2UgJ2EsIGIsIGMnXG4gICAqIEByZXR1cm4ge0FycmF5Tm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VSb3cgKCkge1xuICAgIHZhciBwYXJhbXMgPSBbcGFyc2VBc3NpZ25tZW50KCldO1xuICAgIHZhciBsZW4gPSAxO1xuXG4gICAgd2hpbGUgKHRva2VuID09ICcsJykge1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgLy8gcGFyc2UgZXhwcmVzc2lvblxuICAgICAgcGFyYW1zW2xlbl0gPSBwYXJzZUFzc2lnbm1lbnQoKTtcbiAgICAgIGxlbisrO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXJyYXlOb2RlKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogcGFyc2UgYW4gb2JqZWN0LCBlbmNsb3NlZCBpbiBhbmdsZSBicmFja2V0c3suLi59LCBmb3IgZXhhbXBsZSB7dmFsdWU6IDJ9XG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0ICgpIHtcbiAgICBpZiAodG9rZW4gPT0gJ3snKSB7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgZG8ge1xuICAgICAgICBnZXRUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2tlbiAhPSAnfScpIHtcbiAgICAgICAgICAvLyBwYXJzZSBrZXlcbiAgICAgICAgICBpZiAodG9rZW4gPT0gJ1wiJykge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VTdHJpbmdUb2tlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0b2tlbl90eXBlID09IFRPS0VOVFlQRS5TWU1CT0wpIHtcbiAgICAgICAgICAgIGtleSA9IHRva2VuO1xuICAgICAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignU3ltYm9sIG9yIHN0cmluZyBleHBlY3RlZCBhcyBvYmplY3Qga2V5Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcGFyc2Uga2V5L3ZhbHVlIHNlcGFyYXRvclxuICAgICAgICAgIGlmICh0b2tlbiAhPSAnOicpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdDb2xvbiA6IGV4cGVjdGVkIGFmdGVyIG9iamVjdCBrZXknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgICAgIC8vIHBhcnNlIGtleVxuICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHBhcnNlQXNzaWdubWVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAodG9rZW4gPT0gJywnKTtcblxuICAgICAgaWYgKHRva2VuICE9ICd9Jykge1xuICAgICAgICB0aHJvdyBjcmVhdGVTeW50YXhFcnJvcignQ29tbWEgLCBvciBicmFja2V0IH0gZXhwZWN0ZWQgYWZ0ZXIgb2JqZWN0IHZhbHVlJyk7XG4gICAgICB9XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICB2YXIgbm9kZSA9IG5ldyBPYmplY3ROb2RlKHByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBwYXJzZSBpbmRleCBwYXJhbWV0ZXJzXG4gICAgICBub2RlID0gcGFyc2VBY2Nlc3NvcnMobm9kZSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU51bWJlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcnNlIGEgbnVtYmVyXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlTnVtYmVyICgpIHtcbiAgICB2YXIgbnVtYmVyO1xuXG4gICAgaWYgKHRva2VuX3R5cGUgPT0gVE9LRU5UWVBFLk5VTUJFUikge1xuICAgICAgLy8gdGhpcyBpcyBhIG51bWJlclxuICAgICAgbnVtYmVyID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZShudW1iZXIsICdudW1iZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VQYXJlbnRoZXNlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHBhcmVudGhlc2VzXG4gICAqIEByZXR1cm4ge05vZGV9IG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlUGFyZW50aGVzZXMgKCkge1xuICAgIHZhciBub2RlO1xuXG4gICAgLy8gY2hlY2sgaWYgaXQgaXMgYSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cbiAgICBpZiAodG9rZW4gPT0gJygnKSB7XG4gICAgICAvLyBwYXJlbnRoZXNlcyAoLi4uKVxuICAgICAgb3BlblBhcmFtcygpO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgbm9kZSA9IHBhcnNlQXNzaWdubWVudCgpOyAvLyBzdGFydCBhZ2FpblxuXG4gICAgICBpZiAodG9rZW4gIT0gJyknKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVN5bnRheEVycm9yKCdQYXJlbnRoZXNpcyApIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBjbG9zZVBhcmFtcygpO1xuICAgICAgZ2V0VG9rZW4oKTtcblxuICAgICAgbm9kZSA9IG5ldyBQYXJlbnRoZXNpc05vZGUobm9kZSk7XG4gICAgICBub2RlID0gcGFyc2VBY2Nlc3NvcnMobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VFbmQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiBpcyBub3QgeWV0IGVuZGVkIGJ1dCBleHBlY3RlZCB0byBlbmRcbiAgICogQHJldHVybiB7Tm9kZX0gcmVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUVuZCAoKSB7XG4gICAgaWYgKHRva2VuID09ICcnKSB7XG4gICAgICAvLyBzeW50YXggZXJyb3Igb3IgdW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb24nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgY3JlYXRlU3ludGF4RXJyb3IoJ1ZhbHVlIGV4cGVjdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IHJvdyB2YWx1ZSAob25lIGJhc2VkKVxuICAgKiBSZXR1cm5zIHRoZSBsaW5lIG9mIHRoZSBjdXJyZW50bHkgaGFuZGxlZCBleHByZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBUT0RPOiBpbXBsZW1lbnQga2VlcGluZyB0cmFjayBvbiB0aGUgcm93IG51bWJlclxuICBmdW5jdGlvbiByb3cgKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICovXG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IGNvbCB2YWx1ZSAob25lIGJhc2VkKVxuICAgKiBSZXR1cm5zIHRoZSBjb2x1bW4gKHBvc2l0aW9uKSB3aGVyZSB0aGUgbGFzdCB0b2tlbiBzdGFydHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbCAoKSB7XG4gICAgcmV0dXJuIGluZGV4IC0gdG9rZW4ubGVuZ3RoICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHJldHVybiB7U3ludGF4RXJyb3J9IGluc3RhbnRpYXRlZCBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlU3ludGF4RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICB2YXIgYyA9IGNvbCgpO1xuICAgIHZhciBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlICsgJyAoY2hhciAnICsgYyArICcpJyk7XG4gICAgZXJyb3JbJ2NoYXInXSA9IGM7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVycm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqIEByZXR1cm4ge0Vycm9yfSBpbnN0YW50aWF0ZWQgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUVycm9yIChtZXNzYWdlKSB7XG4gICAgdmFyIGMgPSBjb2woKTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSArICcgKGNoYXIgJyArIGMgKyAnKScpO1xuICAgIGVycm9yWydjaGFyJ10gPSBjO1xuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncGFyc2UnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgucmFuZ2VcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0cmFuc2Zvcm0gY29udGFpbmluZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgdHJhbnNmb3JtIGNoYW5nZWQgdGhlIGxhc3QgYGRpbWAgcGFyYW1ldGVyIG9mIGZ1bmN0aW9uIGNvbmNhdFxuICogZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZFxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBjb25jYXQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9jb25jYXQnKSk7XG5cbiAgLy8gQHNlZTogY29tbWVudCBvZiBjb25jYXQgaXRzZWxmXG4gcmV0dXJuIHR5cGVkKCdjb25jYXQnLCB7XG4gICAgJy4uLmFueSc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAvLyBjaGFuZ2UgbGFzdCBhcmd1bWVudCBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvLWJhc2VkXG4gICAgICB2YXIgbGFzdEluZGV4ID0gYXJncy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3QgPSBhcmdzW2xhc3RJbmRleF07XG4gICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFyZ3NbbGFzdEluZGV4XSA9IGxhc3QgLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGFzdCAmJiBsYXN0LmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgIGFyZ3NbbGFzdEluZGV4XSA9IGxhc3QubWludXMoMSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NvbmNhdCc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsInZhciBJbmRleEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvSW5kZXhFcnJvcicpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB6ZXJvLWJhc2VkIGluZGljZXMgdG8gb25lLWJhc2VkIGluZGljZXMgaW4gZXJyb3JzXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEByZXR1cm5zIHtFcnJvcn0gUmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgZXJyb3JcbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmIChlcnIgJiYgZXJyLmlzSW5kZXhFcnJvcikge1xuICAgIHJldHVybiBuZXcgSW5kZXhFcnJvcihcbiAgICAgICAgZXJyLmluZGV4ICsgMSxcbiAgICAgICAgZXJyLm1pbiArIDEsXG4gICAgICAgIGVyci5tYXggIT09IHVuZGVmaW5lZCA/IGVyci5tYXggKyAxIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLmZpbHRlclxuICogQWRkcyBhIHByb3BlcnR5IHRyYW5zZm9ybSBjb250YWluaW5nIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKlxuICogVGhpcyB0cmFuc2Zvcm0gYWRkcyBzdXBwb3J0IGZvciBlcXVhdGlvbnMgYXMgdGVzdCBmdW5jdGlvbiBmb3IgbWF0aC5maWx0ZXIsXG4gKiBzbyB5b3UgY2FuIGRvIHNvbWV0aGluZyBsaWtlICdmaWx0ZXIoWzMsIC0yLCA1XSwgeCA+IDApJy5cbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZmlsdGVyID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9tYXRyaXgvZmlsdGVyJykpO1xuICB2YXIgU3ltYm9sTm9kZSA9IGxvYWQocmVxdWlyZSgnLi4vbm9kZS9TeW1ib2xOb2RlJykpO1xuXG4gIGZ1bmN0aW9uIGZpbHRlclRyYW5zZm9ybShhcmdzLCBtYXRoLCBzY29wZSkge1xuICAgIHZhciB4LCB0ZXN0O1xuXG4gICAgaWYgKGFyZ3NbMF0pIHtcbiAgICAgIHggPSBhcmdzWzBdLmNvbXBpbGUoKS5ldmFsKHNjb3BlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgaWYgKGFyZ3NbMV0gJiYgYXJnc1sxXS5pc1N5bWJvbE5vZGUpIHtcbiAgICAgICAgLy8gYSBmdW5jdGlvbiBwb2ludGVyLCBsaWtlIGZpbHRlcihbMywgLTIsIDVdLCBteVRlc3RGdW5jdGlvbik7XG4gICAgICAgIHRlc3QgPSBhcmdzWzFdLmNvbXBpbGUoKS5ldmFsKHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBhbiBlcXVhdGlvbiBsaWtlIGZpbHRlcihbMywgLTIsIDVdLCB4ID4gMClcblxuICAgICAgICAvLyBmaW5kIGFuIHVuZGVmaW5lZCBzeW1ib2xcbiAgICAgICAgdmFyIF9zY29wZSA9IHNjb3BlIHx8IHt9O1xuICAgICAgICB2YXIgc3ltYm9sID0gYXJnc1sxXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKG5vZGUgJiYgbm9kZS5pc1N5bWJvbE5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAhKG5vZGUubmFtZSBpbiBtYXRoKSAmJlxuICAgICAgICAgICAgICAgICAgIShub2RlLm5hbWUgaW4gX3Njb3BlKTtcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHRlc3QgZnVuY3Rpb24gZm9yIHRoaXMgZXF1YXRpb25cbiAgICAgICAgdmFyIHN1YiA9IE9iamVjdC5jcmVhdGUoX3Njb3BlKTtcbiAgICAgICAgdmFyIGVxID0gYXJnc1sxXS5jb21waWxlKCk7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHN5bWJvbC5uYW1lO1xuICAgICAgICAgIHRlc3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgc3ViW25hbWVdID0geDtcbiAgICAgICAgICAgIHJldHVybiBlcS5ldmFsKHN1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdW5kZWZpbmVkIHZhcmlhYmxlIGZvdW5kIGluIGZpbHRlciBlcXVhdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcih4LCB0ZXN0KTtcbiAgfVxuXG4gIGZpbHRlclRyYW5zZm9ybS5yYXdBcmdzID0gdHJ1ZTtcblxuICByZXR1cm4gZmlsdGVyVHJhbnNmb3JtO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZmlsdGVyJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF4QXJndW1lbnRDb3VudCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Z1bmN0aW9uJykubWF4QXJndW1lbnRDb3VudDtcblxuLyoqXG4gKiBBdHRhY2ggYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbWF0aC5mb3JFYWNoXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgb25lLWJhc2VkIGluZGV4IGluc3RlYWQgb2YgYSB6ZXJvLWJhc2VkIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGZvckVhY2ggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9mb3JFYWNoJykpO1xuXG4gIHJldHVybiB0eXBlZCgnZm9yRWFjaCcsIHtcbiAgICAnQXJyYXkgfCBNYXRyaXgsIGZ1bmN0aW9uJzogZnVuY3Rpb24gKGFycmF5LCBjYWxsYmFjaykge1xuICAgICAgLy8gZmlndXJlIG91dCB3aGF0IG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4cGVjdHNcbiAgICAgIHZhciBhcmdzID0gbWF4QXJndW1lbnRDb3VudChjYWxsYmFjayk7XG5cbiAgICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgICAgLy8gd2UgY3JlYXRlIGEgY29weSBvZiB0aGUgaW5kZXggYXJyYXkgYW5kIGFwcGVuZCB0aGUgbmV3IGluZGV4IHZhbHVlXG4gICAgICAgICAgICByZWN1cnNlKGNoaWxkLCBpbmRleC5jb25jYXQoaSArIDEpKTsgLy8gb25lIGJhc2VkIGluZGV4LCBoZW5jZSBpKzFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICBpZiAoYXJncyA9PT0gMSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhcmdzID09PSAyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHsgLy8gMyBvciAtMVxuICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVjdXJzZShhcnJheS52YWx1ZU9mKCksIFtdKTsgLy8gcGFzcyBBcnJheVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmb3JFYWNoJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vY29uY2F0LnRyYW5zZm9ybScpLFxuICByZXF1aXJlKCcuL2ZpbHRlci50cmFuc2Zvcm0nKSxcbiAgcmVxdWlyZSgnLi9mb3JFYWNoLnRyYW5zZm9ybScpLFxuICByZXF1aXJlKCcuL2luZGV4LnRyYW5zZm9ybScpLFxuICByZXF1aXJlKCcuL21hcC50cmFuc2Zvcm0nKSxcbiAgcmVxdWlyZSgnLi9tYXgudHJhbnNmb3JtJyksXG4gIHJlcXVpcmUoJy4vbWVhbi50cmFuc2Zvcm0nKSxcbiAgcmVxdWlyZSgnLi9taW4udHJhbnNmb3JtJyksXG4gIHJlcXVpcmUoJy4vcmFuZ2UudHJhbnNmb3JtJyksXG4gIHJlcXVpcmUoJy4vc3Vic2V0LnRyYW5zZm9ybScpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLmluZGV4XG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgb25lLWJhc2VkIGluZGV4IGluc3RlYWQgb2YgYSB6ZXJvLWJhc2VkIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCkge1xuXG4gIHJldHVybiBmdW5jdGlvbiBpbmRleFRyYW5zZm9ybSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAvLyBjaGFuZ2UgZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZCwgYW5kIGNvbnZlcnQgQmlnTnVtYmVyIHRvIG51bWJlclxuICAgICAgaWYgKGFyZyAmJiBhcmcuaXNSYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgICBhcmcuc3RhcnQtLTtcbiAgICAgICAgYXJnLmVuZCAtPSAoYXJnLnN0ZXAgPiAwID8gMCA6IDIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJnICYmIGFyZy5pc1NldCA9PT0gdHJ1ZSkge1xuICAgICAgICBhcmcgPSBhcmcubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IC0gMTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmcgJiYgKGFyZy5pc0FycmF5ID09PSB0cnVlIHx8IGFyZy5pc01hdHJpeCkpIHtcbiAgICAgICAgYXJnID0gYXJnLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdiAtIDE7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXJnLS07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmcgJiYgYXJnLmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgIGFyZyA9IGFyZy50b051bWJlcigpIC0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGxlYXZlIGFzIGlzXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGltZW5zaW9uIG11c3QgYmUgYW4gQXJyYXksIE1hdHJpeCwgbnVtYmVyLCBzdHJpbmcsIG9yIFJhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3NbaV0gPSBhcmc7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IG5ldyB0eXBlLkluZGV4KCk7XG4gICAgdHlwZS5JbmRleC5hcHBseShyZXMsIGFyZ3MpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpbmRleCc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1heEFyZ3VtZW50Q291bnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9mdW5jdGlvbicpLm1heEFyZ3VtZW50Q291bnQ7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgubWFwXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgb25lLWJhc2VkIGluZGV4IGluc3RlYWQgb2YgYSB6ZXJvLWJhc2VkIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hcCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vbWF0cml4L21hcCcpKTtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHJldHVybiB0eXBlZCgnbWF4Jywge1xuICAgICdBcnJheSwgZnVuY3Rpb24nOiBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBfbWFwKHgsIGNhbGxiYWNrLCB4KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgZnVuY3Rpb24nOiBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBtYXRyaXgoX21hcCh4LnZhbHVlT2YoKSwgY2FsbGJhY2ssIHgpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hcCBmb3IgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheS4gT25lLWJhc2VkIGluZGV4ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gb3JpZ1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfbWFwIChhcnJheSwgY2FsbGJhY2ssIG9yaWcpIHtcbiAgLy8gZmlndXJlIG91dCB3aGF0IG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4cGVjdHNcbiAgdmFyIGFyZ3MgPSBtYXhBcmd1bWVudENvdW50KGNhbGxiYWNrKTtcblxuICBmdW5jdGlvbiByZWN1cnNlKHZhbHVlLCBpbmRleCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgY29weSBvZiB0aGUgaW5kZXggYXJyYXkgYW5kIGFwcGVuZCB0aGUgbmV3IGluZGV4IHZhbHVlXG4gICAgICAgIHJldHVybiByZWN1cnNlKGNoaWxkLCBpbmRleC5jb25jYXQoaSArIDEpKTsgLy8gb25lIGJhc2VkIGluZGV4LCBoZW5jZSBpICsgMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gaW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIHRoZSByaWdodCBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICBpZiAoYXJncyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJncyA9PT0gMikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyAzIG9yIC0xXG4gICAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9yaWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWN1cnNlKGFycmF5LCBbXSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtYXAnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24udHJhbnNmb3JtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlcnJvclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZXJyb3IudHJhbnNmb3JtJykudHJhbnNmb3JtO1xudmFyIGlzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vaXNDb2xsZWN0aW9uJyk7XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGgubWF4XG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjaGFuZ2VkIHRoZSBsYXN0IGBkaW1gIHBhcmFtZXRlciBvZiBmdW5jdGlvbiBtYXhcbiAqIGZyb20gb25lLWJhc2VkIHRvIHplcm8gYmFzZWRcbiAqL1xuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9zdGF0aXN0aWNzL21heCcpKTtcblxuICByZXR1cm4gdHlwZWQoJ21heCcsIHtcbiAgICAnLi4uYW55JzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIC8vIGNoYW5nZSBsYXN0IGFyZ3VtZW50IGRpbSBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvLWJhc2VkXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMiAmJiBpc0NvbGxlY3Rpb24oYXJnc1swXSkpIHtcbiAgICAgICAgdmFyIGRpbSA9IGFyZ3NbMV07XG4gICAgICAgIGlmICh0eXBlb2YgZGltID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGFyZ3NbMV0gPSBkaW0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpbSAmJiBkaW0uaXNCaWdOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBhcmdzWzFdID0gZGltLm1pbnVzKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtYXguYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycm9yVHJhbnNmb3JtKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ21heCc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9pc0NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBBdHRhY2ggYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbWF0aC5tZWFuXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjaGFuZ2VkIHRoZSBsYXN0IGBkaW1gIHBhcmFtZXRlciBvZiBmdW5jdGlvbiBtZWFuXG4gKiBmcm9tIG9uZS1iYXNlZCB0byB6ZXJvIGJhc2VkXG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1lYW4gPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWVhbicpKTtcblxuICByZXR1cm4gdHlwZWQoJ21lYW4nLCB7XG4gICAgJy4uLmFueSc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAvLyBjaGFuZ2UgbGFzdCBhcmd1bWVudCBkaW0gZnJvbSBvbmUtYmFzZWQgdG8gemVyby1iYXNlZFxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNDb2xsZWN0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICAgIHZhciBkaW0gPSBhcmdzWzFdO1xuICAgICAgICBpZiAodHlwZW9mIGRpbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhcmdzWzFdID0gZGltIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaW0gJiYgZGltLmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYXJnc1sxXSA9IGRpbS5taW51cygxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbWVhbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbWVhbic7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG52YXIgaXNDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9pc0NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBBdHRhY2ggYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gbWF0aC5taW5cbiAqIEFkZHMgYSBwcm9wZXJ0eSB0cmFuc2Zvcm0gY29udGFpbmluZyB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgdHJhbnNmb3JtIGNoYW5nZWQgdGhlIGxhc3QgYGRpbWAgcGFyYW1ldGVyIG9mIGZ1bmN0aW9uIG1pblxuICogZnJvbSBvbmUtYmFzZWQgdG8gemVybyBiYXNlZFxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtaW4gPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL3N0YXRpc3RpY3MvbWluJykpO1xuXG4gIHJldHVybiB0eXBlZCgnbWluJywge1xuICAgICcuLi5hbnknOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgLy8gY2hhbmdlIGxhc3QgYXJndW1lbnQgZGltIGZyb20gb25lLWJhc2VkIHRvIHplcm8tYmFzZWRcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIGlzQ29sbGVjdGlvbihhcmdzWzBdKSkge1xuICAgICAgICB2YXIgZGltID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYXJnc1sxXSA9IGRpbSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGltICYmIGRpbS5pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFyZ3NbMV0gPSBkaW0ubWludXMoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1pbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JUcmFuc2Zvcm0oZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbWluJztcbmV4cG9ydHMucGF0aCA9ICdleHByZXNzaW9uLnRyYW5zZm9ybSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEF0dGFjaCBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtYXRoLnJhbmdlXG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgcmFuZ2Ugd2hpY2ggaW5jbHVkZXMgdGhlIGVuZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciByYW5nZSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vbWF0cml4L3JhbmdlJykpO1xuXG4gIHJldHVybiB0eXBlZCgncmFuZ2UnLCB7XG4gICAgJy4uLmFueSc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gYXJncy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3QgPSBhcmdzW2xhc3RJbmRleF07XG4gICAgICBpZiAodHlwZW9mIGxhc3QgIT09ICdib29sZWFuJykge1xuICAgICAgICAvLyBhcHBlbmQgYSBwYXJhbWV0ZXIgaW5jbHVkZUVuZD10cnVlXG4gICAgICAgIGFyZ3MucHVzaCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdyYW5nZSc7XG5leHBvcnRzLnBhdGggPSAnZXhwcmVzc2lvbi50cmFuc2Zvcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9lcnJvci50cmFuc2Zvcm0nKS50cmFuc2Zvcm07XG5cbi8qKlxuICogQXR0YWNoIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIG1hdGguc3Vic2V0XG4gKiBBZGRzIGEgcHJvcGVydHkgdHJhbnNmb3JtIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgcmFuZ2Ugd2hpY2ggaW5jbHVkZXMgdGhlIGVuZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBzdWJzZXQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL21hdHJpeC9zdWJzZXQnKSk7XG5cbiAgcmV0dXJuIHR5cGVkKCdzdWJzZXQnLCB7XG4gICAgJy4uLmFueSc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc3Vic2V0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnJvclRyYW5zZm9ybShlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzdWJzZXQnO1xuZXhwb3J0cy5wYXRoID0gJ2V4cHJlc3Npb24udHJhbnNmb3JtJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIuIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzXG4gICAqIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hYnMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYWJzKDMuNSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDMuNVxuICAgKiAgICBtYXRoLmFicygtNC4yKTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA0LjJcbiAgICpcbiAgICogICAgbWF0aC5hYnMoWzMsIC01LCAtMSwgMCwgMl0pOyAgLy8gcmV0dXJucyBBcnJheSBbMywgNSwgMSwgMCwgMl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHNpZ25cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBVbml0fSB4XG4gICAqICAgICAgICAgICAgQSBudW1iZXIgb3IgbWF0cml4IGZvciB3aGljaCB0byBnZXQgdGhlIGFic29sdXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH1cbiAgICogICAgICAgICAgICBBYnNvbHV0ZSB2YWx1ZSBvZiBgeGBcbiAgICovXG4gIHZhciBhYnMgPSB0eXBlZCgnYWJzJywge1xuICAgICdudW1iZXInOiBNYXRoLmFicyxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWJzKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGFicygwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFicywgdHJ1ZSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHguYWJzKCk7XG4gICAgfVxuICB9KTtcblxuICBhYnMudG9UZXggPSB7MTogJ1xcXFxsZWZ0fCR7YXJnc1swXX1cXFxccmlnaHR8J307XG5cbiAgcmV0dXJuIGFicztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Ficyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuZXh0ZW5kO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgYWRkU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL2FkZFNjYWxhcicpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXguanMnKTtcbiAgXG4gIHZhciBhbGdvcml0aG0wMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDEnKSk7XG4gIHZhciBhbGdvcml0aG0wNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDQnKSk7XG4gIHZhciBhbGdvcml0aG0xMCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTAnKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIEFkZCB0d28gb3IgbW9yZSB2YWx1ZXMsIGB4ICsgeWAuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hZGQoeCwgeSlcbiAgICogICAgbWF0aC5hZGQoeCwgeSwgeiwgLi4uKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hZGQoMiwgMyk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNVxuICAgKiAgICBtYXRoLmFkZCgyLCAzLCA0KTsgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA5XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDIsIDMpO1xuICAgKiAgICB2YXIgYiA9IG1hdGguY29tcGxleCgtNCwgMSk7XG4gICAqICAgIG1hdGguYWRkKGEsIGIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAtMiArIDRpXG4gICAqXG4gICAqICAgIG1hdGguYWRkKFsxLCAyLCAzXSwgNCk7ICAgICAgIC8vIHJldHVybnMgQXJyYXkgWzUsIDYsIDddXG4gICAqXG4gICAqICAgIHZhciBjID0gbWF0aC51bml0KCc1IGNtJyk7XG4gICAqICAgIHZhciBkID0gbWF0aC51bml0KCcyLjEgbW0nKTtcbiAgICogICAgbWF0aC5hZGQoYywgZCk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDUyLjEgbW1cbiAgICpcbiAgICogICAgbWF0aC5hZGQoXCIyLjNcIiwgXCI0XCIpOyAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDYuM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc3VidHJhY3QsIHN1bVxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggRmlyc3QgdmFsdWUgdG8gYWRkXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gYWRkXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0gU3VtIG9mIGB4YCBhbmQgYHlgXG4gICAqL1xuICB2YXIgYWRkID0gdHlwZWQoJ2FkZCcsIGV4dGVuZCh7XG4gICAgLy8gd2UgZXh0ZW5kIHRoZSBzaWduYXR1cmVzIG9mIGFkZFNjYWxhciB3aXRoIHNpZ25hdHVyZXMgZGVhbGluZyB3aXRoIG1hdHJpY2VzXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIFxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDQoeCwgeSwgYWRkU2NhbGFyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDEoeSwgeCwgYWRkU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMSh4LCB5LCBhZGRTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBhZGRTY2FsYXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIFxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFkZChtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFkZChtYXRyaXgoeCksIHkpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFkZCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMCh4LCB5LCBhZGRTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgYWRkU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIFxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTAoeSwgeCwgYWRkU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgYWRkU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgYWRkU2NhbGFyLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBhZGRTY2FsYXIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgYW55JzogYWRkU2NhbGFyLFxuXG4gICAgJ2FueSwgYW55LCAuLi5hbnknOiBmdW5jdGlvbiAoeCwgeSwgcmVzdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGFkZCh4LCB5KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGFkZChyZXN1bHQsIHJlc3RbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwgYWRkU2NhbGFyLnNpZ25hdHVyZXMpKTtcblxuICBhZGQudG9UZXggPSB7XG4gICAgMjogJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWydhZGQnXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSdcbiAgfTtcbiAgXG4gIHJldHVybiBhZGQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhZGQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIEFkZCB0d28gc2NhbGFyIHZhbHVlcywgYHggKyB5YC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyBtZWFudCBmb3IgaW50ZXJuYWwgdXNlOiBpdCBpcyB1c2VkIGJ5IHRoZSBwdWJsaWMgZnVuY3Rpb25cbiAgICogYGFkZGBcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGNvbGxlY3Rpb25zIChBcnJheSBvciBNYXRyaXgpLCBhbmQgZG9lc1xuICAgKiBub3QgdmFsaWRhdGUgdGhlIG51bWJlciBvZiBvZiBpbnB1dHMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXR9IHggICBGaXJzdCB2YWx1ZSB0byBhZGRcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4fSB5ICAgICAgICAgIFNlY29uZCB2YWx1ZSB0byBhZGRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdH0gICAgICAgICAgICAgICAgICAgICAgU3VtIG9mIGB4YCBhbmQgYHlgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgYWRkID0gdHlwZWQoJ2FkZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCArIHk7XG4gICAgfSxcblxuICAgICdDb21wbGV4LCBDb21wbGV4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4LmFkZCh5KTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4LnBsdXMoeSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguYWRkKHkpO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeC52YWx1ZSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB4IGNvbnRhaW5zIGEgdW5pdCB3aXRoIHVuZGVmaW5lZCB2YWx1ZScpO1xuICAgICAgaWYgKHkudmFsdWUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgeSBjb250YWlucyBhIHVuaXQgd2l0aCB1bmRlZmluZWQgdmFsdWUnKTtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHRocm93IG5ldyBFcnJvcignVW5pdHMgZG8gbm90IG1hdGNoJyk7XG5cbiAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICByZXMudmFsdWUgPSBhZGQocmVzLnZhbHVlLCB5LnZhbHVlKTtcbiAgICAgIHJlcy5maXhQcmVmaXggPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWRkO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciB1bmFyeU1pbnVzID0gbG9hZChyZXF1aXJlKCcuL3VuYXJ5TWludXMnKSk7XG4gIHZhciBpc05lZ2F0aXZlID0gbG9hZChyZXF1aXJlKCcuLi91dGlscy9pc05lZ2F0aXZlJykpO1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY3ViaWMgcm9vdCBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY2JydCh4KVxuICAgKiAgICBtYXRoLmNicnQoeCwgYWxsUm9vdHMpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmNicnQoMjcpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgM1xuICAgKiAgICBtYXRoLmN1YmUoMyk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMjdcbiAgICogICAgbWF0aC5jYnJ0KC02NCk7ICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIC00XG4gICAqICAgIG1hdGguY2JydChtYXRoLnVuaXQoJzI3IG1eMycpKTsgLy8gcmV0dXJucyBVbml0IDMgbVxuICAgKiAgICBtYXRoLmNicnQoWzI3LCA2NCwgMTI1XSk7ICAgICAgIC8vIHJldHVybnMgWzMsIDQsIDVdXG4gICAqXG4gICAqICAgIHZhciB4ID0gbWF0aC5jb21wbGV4KCc4aScpO1xuICAgKiAgICBtYXRoLmNicnQoeCk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAxLjczMjA1MDgwNzU2ODkgKyBpXG4gICAqICAgIG1hdGguY2JydCh4LCB0cnVlKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBNYXRyaXggW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDEuNzMyMDUwODA3NTY4OSArIGlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIC0xLjczMjA1MDgwNzU2ODkgKyBpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAtMmlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzcXVhcmUsIHNxcnQsIGN1YmVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY3ViaWMgcm9vdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYWxsUm9vdHNdICBPcHRpb25hbCwgZmFsc2UgYnkgZGVmYXVsdC4gT25seSBhcHBsaWNhYmxlXG4gICAqICAgICAgICAgICAgd2hlbiBgeGAgaXMgYSBudW1iZXIgb3IgY29tcGxleCBudW1iZXIuIElmIHRydWUsIGFsbCBjb21wbGV4XG4gICAqICAgICAgICAgICAgcm9vdHMgYXJlIHJldHVybmVkLCBpZiBmYWxzZSAoZGVmYXVsdCkgdGhlIHByaW5jaXBhbCByb290IGlzXG4gICAqICAgICAgICAgICAgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgY3ViaWMgcm9vdCBvZiBgeGBcbiAgICovXG4gIHZhciBjYnJ0ID0gdHlwZWQoJ2NicnQnLCB7XG4gICAgJ251bWJlcic6IF9jYnJ0TnVtYmVyLFxuICAgIC8vIG5vdGU6IHNpZ25hdHVyZSAnbnVtYmVyLCBib29sZWFuJyBpcyBhbHNvIHN1cHBvcnRlZCxcbiAgICAvLyAgICAgICBjcmVhdGVkIGJ5IHR5cGVkIGFzIGl0IGtub3dzIGhvdyB0byBjb252ZXJ0IG51bWJlciB0byBDb21wbGV4XG5cbiAgICAnQ29tcGxleCc6IF9jYnJ0Q29tcGxleCxcblxuICAgICdDb21wbGV4LCBib29sZWFuJzogX2NicnRDb21wbGV4LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jYnJ0KCk7XG4gICAgfSxcblxuICAgICdVbml0JzogX2NicnRVbml0LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgY2JydCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNicnQsIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgY3ViaWMgcm9vdCBmb3IgYSBjb21wbGV4IG51bWJlclxuICAgKiBAcGFyYW0ge0NvbXBsZXh9IHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbYWxsUm9vdHNdICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFuIGFycmF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggYWxsIHRocmVlIHJvb3RzLiBJZiBmYWxzZSBvciB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBwcmluY2lwYWwgcm9vdCBpcyByZXR1cm5lZC5cbiAgICogQHJldHVybnMge0NvbXBsZXggfCBBcnJheS48Q29tcGxleD4gfCBNYXRyaXguPENvbXBsZXg+fSBSZXR1cm5zIHRoZSBjdWJpYyByb290KHMpIG9mIHhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jYnJ0Q29tcGxleCh4LCBhbGxSb290cykge1xuICAgIC8vIGh0dHBzOi8vd3d3Lndpa2l3YW5kLmNvbS9lbi9DdWJlX3Jvb3QjL0NvbXBsZXhfbnVtYmVyc1xuXG4gICAgdmFyIGFyZ18zID0geC5hcmcoKSAvIDM7XG4gICAgdmFyIGFicyA9IHguYWJzKCk7XG5cbiAgICAvLyBwcmluY2lwYWwgcm9vdDpcbiAgICB2YXIgcHJpbmNpcGFsID0gbmV3IHR5cGUuQ29tcGxleChfY2JydE51bWJlcihhYnMpLCAwKS5tdWwoXG4gICAgICAgIG5ldyB0eXBlLkNvbXBsZXgoMCwgYXJnXzMpLmV4cCgpKTtcblxuICAgIGlmIChhbGxSb290cykge1xuICAgICAgdmFyIGFsbCA9IFtcbiAgICAgICAgICBwcmluY2lwYWwsXG4gICAgICAgICAgbmV3IHR5cGUuQ29tcGxleChfY2JydE51bWJlcihhYnMpLCAwKS5tdWwoXG4gICAgICAgICAgICBuZXcgdHlwZS5Db21wbGV4KDAsIGFyZ18zICsgTWF0aC5QSSAqIDIgLyAzKS5leHAoKSksXG4gICAgICAgICAgbmV3IHR5cGUuQ29tcGxleChfY2JydE51bWJlcihhYnMpLCAwKS5tdWwoXG4gICAgICAgICAgICBuZXcgdHlwZS5Db21wbGV4KDAsIGFyZ18zIC0gTWF0aC5QSSAqIDIgLyAzKS5leHAoKSlcbiAgICAgIF07XG5cbiAgICAgIHJldHVybiAoY29uZmlnLm1hdHJpeCA9PT0gJ0FycmF5JykgPyBhbGwgOiBtYXRyaXgoYWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcHJpbmNpcGFsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGN1YmljIHJvb3QgZm9yIGEgVW5pdFxuICAgKiBAcGFyYW0ge1VuaXR9IHhcbiAgICogQHJldHVybiB7VW5pdH0gUmV0dXJucyB0aGUgY3ViaWMgcm9vdCBvZiB4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY2JydFVuaXQoeCkge1xuICAgIGlmKHgudmFsdWUgJiYgeC52YWx1ZS5pc0NvbXBsZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB4LmNsb25lKCk7XG4gICAgICByZXN1bHQudmFsdWUgPSAxLjA7XG4gICAgICByZXN1bHQgPSByZXN1bHQucG93KDEuMC8zKTsgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHVuaXRzXG4gICAgICByZXN1bHQudmFsdWUgPSBfY2JydENvbXBsZXgoeC52YWx1ZSk7IC8vIENvbXB1dGUgdGhlIHZhbHVlXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZWdhdGUgPSBpc05lZ2F0aXZlKHgudmFsdWUpO1xuICAgICAgaWYgKG5lZ2F0ZSkge1xuICAgICAgICB4LnZhbHVlID0gdW5hcnlNaW51cyh4LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogY3JlYXRlIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0aGlzXG4gICAgICB2YXIgdGhpcmQ7XG4gICAgICBpZiAoeC52YWx1ZSAmJiB4LnZhbHVlLmlzQmlnTnVtYmVyKSB7XG4gICAgICAgIHRoaXJkID0gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdigzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHgudmFsdWUgJiYgeC52YWx1ZS5pc0ZyYWN0aW9uKSB7XG4gICAgICAgIHRoaXJkID0gbmV3IHR5cGUuRnJhY3Rpb24oMSwgMyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcmQgPSAxLzM7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB4LnBvdyh0aGlyZCk7XG5cbiAgICAgIGlmIChuZWdhdGUpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdW5hcnlNaW51cyhyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGNicnQudG9UZXggPSB7MTogJ1xcXFxzcXJ0WzNdeyR7YXJnc1swXX19J307XG5cbiAgcmV0dXJuIGNicnQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNicnQgZm9yIGEgbnVtYmVyXG4gKlxuICogQ29kZSBmcm9tIGVzNi1zaGltLmpzOlxuICogICBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2VzNi1zaGltL2Jsb2IvbWFzdGVyL2VzNi1zaGltLmpzI0wxNTY0LUwxNTc3XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBDb21wbGV4fSBSZXR1cm5zIHRoZSBjdWJpYyByb290IG9mIHhcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBfY2JydE51bWJlciA9IE1hdGguY2JydCB8fCBmdW5jdGlvbiAoeCkge1xuICBpZiAoeCA9PT0gMCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgdmFyIG5lZ2F0ZSA9IHggPCAwO1xuICB2YXIgcmVzdWx0O1xuICBpZiAobmVnYXRlKSB7XG4gICAgeCA9IC14O1xuICB9XG5cbiAgaWYgKGlzRmluaXRlKHgpKSB7XG4gICAgcmVzdWx0ID0gTWF0aC5leHAoTWF0aC5sb2coeCkgLyAzKTtcbiAgICAvLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViZV9yb290I051bWVyaWNhbF9tZXRob2RzXG4gICAgcmVzdWx0ID0gKHggLyAocmVzdWx0ICogcmVzdWx0KSArICgyICogcmVzdWx0KSkgLyAzO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHg7XG4gIH1cblxuICByZXR1cm4gbmVnYXRlID8gLXJlc3VsdCA6IHJlc3VsdDtcbn07XG5cbmV4cG9ydHMubmFtZSA9ICdjYnJ0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFJvdW5kIGEgdmFsdWUgdG93YXJkcyBwbHVzIGluZmluaXR5XG4gICAqIElmIGB4YCBpcyBjb21wbGV4LCBib3RoIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0IGFyZSByb3VuZGVkIHRvd2FyZHMgcGx1cyBpbmZpbml0eS5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmNlaWwoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguY2VpbCgzLjIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDRcbiAgICogICAgbWF0aC5jZWlsKDMuOCk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNFxuICAgKiAgICBtYXRoLmNlaWwoLTQuMik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNFxuICAgKiAgICBtYXRoLmNlaWwoLTQuNyk7ICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNFxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGguY29tcGxleCgzLjIsIC0yLjcpO1xuICAgKiAgICBtYXRoLmNlaWwoYyk7ICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggNCAtIDJpXG4gICAqXG4gICAqICAgIG1hdGguY2VpbChbMy4yLCAzLjgsIC00LjddKTsgIC8vIHJldHVybnMgQXJyYXkgWzQsIDQsIC00XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZmxvb3IsIGZpeCwgcm91bmRcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBSb3VuZGVkIHZhbHVlXG4gICAqL1xuICB2YXIgY2VpbCA9IHR5cGVkKCdjZWlsJywge1xuICAgICdudW1iZXInOiBNYXRoLmNlaWwsXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5jZWlsKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguY2VpbCgpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguY2VpbCgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBjZWlsKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY2VpbCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICBjZWlsLnRvVGV4ID0gezE6ICdcXFxcbGVmdFxcXFxsY2VpbCR7YXJnc1swXX1cXFxccmlnaHRcXFxccmNlaWwnfTtcblxuICByZXR1cm4gY2VpbDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NlaWwnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjdWJlIG9mIGEgdmFsdWUsIGB4ICogeCAqIHhgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguY3ViZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jdWJlKDIpOyAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDhcbiAgICogICAgbWF0aC5wb3coMiwgMyk7ICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDhcbiAgICogICAgbWF0aC5jdWJlKDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDY0XG4gICAqICAgIDQgKiA0ICogNDsgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA2NFxuICAgKlxuICAgKiAgICBtYXRoLmN1YmUoWzEsIDIsIDMsIDRdKTsgLy8gcmV0dXJucyBBcnJheSBbMSwgOCwgMjcsIDY0XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHksIHNxdWFyZSwgcG93LCBjYnJ0XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH0geCAgTnVtYmVyIGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGN1YmVcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBVbml0fSBDdWJlIG9mIHhcbiAgICovXG4gIHZhciBjdWJlID0gdHlwZWQoJ2N1YmUnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCAqIHggKiB4O1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5tdWwoeCkubXVsKHgpOyAvLyBJcyBmYXN0ZXIgdGhhbiBwb3coeCwgMylcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC50aW1lcyh4KS50aW1lcyh4KTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnBvdygzKTsgLy8gSXMgZmFzdGVyIHRoYW4gbXVsKCltdWwoKW11bCgpXG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGN1YmUoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBjdWJlLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC5wb3coMyk7XG4gICAgfVxuICB9KTtcblxuICBjdWJlLnRvVGV4ID0gezE6ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KV4zJ307XG5cbiAgcmV0dXJuIGN1YmU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjdWJlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKS5leHRlbmQ7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgZGl2aWRlU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL2RpdmlkZVNjYWxhcicpKTtcbiAgdmFyIG11bHRpcGx5ICAgICA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseScpKTtcbiAgdmFyIGludiAgICAgICAgICA9IGxvYWQocmVxdWlyZSgnLi4vbWF0cml4L2ludicpKTtcbiAgdmFyIG1hdHJpeCAgICAgICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG4gIFxuICAvKipcbiAgICogRGl2aWRlIHR3byB2YWx1ZXMsIGB4IC8geWAuXG4gICAqIFRvIGRpdmlkZSBtYXRyaWNlcywgYHhgIGlzIG11bHRpcGxpZWQgd2l0aCB0aGUgaW52ZXJzZSBvZiBgeWA6IGB4ICogaW52KHkpYC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRpdmlkZSh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kaXZpZGUoMiwgMyk7ICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC42NjY2NjY2NjY2NjY2NjY2XG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC5jb21wbGV4KDUsIDE0KTtcbiAgICogICAgdmFyIGIgPSBtYXRoLmNvbXBsZXgoNCwgMSk7XG4gICAqICAgIG1hdGguZGl2aWRlKGEsIGIpOyAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAyICsgM2lcbiAgICpcbiAgICogICAgdmFyIGMgPSBbWzcsIC02XSwgWzEzLCAtNF1dO1xuICAgKiAgICB2YXIgZCA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGguZGl2aWRlKGMsIGQpOyAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1stOSwgNF0sIFstMTEsIDZdXVxuICAgKlxuICAgKiAgICB2YXIgZSA9IG1hdGgudW5pdCgnMTgga20nKTtcbiAgICogICAgbWF0aC5kaXZpZGUoZSwgNC41KTsgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDQga21cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIG11bHRpcGx5XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgIE51bWVyYXRvclxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geSAgICAgICAgICBEZW5vbWluYXRvclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgIFF1b3RpZW50LCBgeCAvIHlgXG4gICAqL1xuICB2YXIgZGl2aWRlID0gdHlwZWQoJ2RpdmlkZScsIGV4dGVuZCh7XG4gICAgLy8gd2UgZXh0ZW5kIHRoZSBzaWduYXR1cmVzIG9mIGRpdmlkZVNjYWxhciB3aXRoIHNpZ25hdHVyZXMgZGVhbGluZyB3aXRoIG1hdHJpY2VzXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgsIEFycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBtYXRyaXggcmlnaHQgZGl2aXNpb24gdXNpbmcgcHNldWRvIGludmVyc2VcbiAgICAgIC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLm5sL2hlbHAvbWF0bGFiL3JlZi9tcmRpdmlkZS5odG1sXG4gICAgICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvb2N0YXZlL2RvYy9pbnRlcnByZXRlci9Bcml0aG1ldGljLU9wcy5odG1sXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMjYzOTMyL2hvdy1kb2VzLWdudS1vY3RhdmUtbWF0cml4LWRpdmlzaW9uLXdvcmstZ2V0dGluZy11bmV4cGVjdGVkLWJlaGF2aW91clxuICAgICAgcmV0dXJuIG11bHRpcGx5KHgsIGludih5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBkaXZpZGVTY2FsYXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiBtdWx0aXBseSh4LCBpbnYoeSkpO1xuICAgIH1cbiAgfSwgZGl2aWRlU2NhbGFyLnNpZ25hdHVyZXMpKTtcblxuICBkaXZpZGUudG9UZXggPSB7MjogJ1xcXFxmcmFjeyR7YXJnc1swXX19eyR7YXJnc1sxXX19J307XG5cbiAgcmV0dXJuIGRpdmlkZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2RpdmlkZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5KHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG11bHRpcGx5U2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL211bHRpcGx5U2NhbGFyJykpO1xuXG4gIC8qKlxuICAgKiBEaXZpZGUgdHdvIHNjYWxhciB2YWx1ZXMsIGB4IC8geWAuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgZm9yIGludGVybmFsIHVzZTogaXQgaXMgdXNlZCBieSB0aGUgcHVibGljIGZ1bmN0aW9uc1xuICAgKiBgZGl2aWRlYCBhbmQgYGludmAuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBjb2xsZWN0aW9ucyAoQXJyYXkgb3IgTWF0cml4KSwgYW5kIGRvZXNcbiAgICogbm90IHZhbGlkYXRlIHRoZSBudW1iZXIgb2Ygb2YgaW5wdXRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0fSB4ICAgTnVtZXJhdG9yXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleH0geSAgICAgICAgICBEZW5vbWluYXRvclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0fSAgICAgICAgICAgICAgICAgICAgICBRdW90aWVudCwgYHggLyB5YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIGRpdmlkZVNjYWxhciA9IHR5cGVkKCdkaXZpZGUnLCB7XG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IC8geTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZGl2KHkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZGl2KHkpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24sIEZyYWN0aW9uJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4LmRpdih5KTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIG51bWJlciB8IEZyYWN0aW9uIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICAvLyBUT0RPOiBtb3ZlIHRoZSBkaXZpZGUgZnVuY3Rpb24gdG8gVW5pdC5qcywgaXQgdXNlcyBpbnRlcm5hbHMgb2YgVW5pdFxuICAgICAgcmVzLnZhbHVlID0gZGl2aWRlU2NhbGFyKCgocmVzLnZhbHVlID09PSBudWxsKSA/IHJlcy5fbm9ybWFsaXplKDEpIDogcmVzLnZhbHVlKSwgeSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXIsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHJlcyA9IHkucG93KC0xKTtcbiAgICAgIC8vIFRPRE86IG1vdmUgdGhlIGRpdmlkZSBmdW5jdGlvbiB0byBVbml0LmpzLCBpdCB1c2VzIGludGVybmFscyBvZiBVbml0XG4gICAgICByZXMudmFsdWUgPSBtdWx0aXBseVNjYWxhcigoKHJlcy52YWx1ZSA9PT0gbnVsbCkgPyByZXMuX25vcm1hbGl6ZSgxKSA6IHJlcy52YWx1ZSksIHgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZGl2aWRlKHkpO1xuICAgIH1cblxuICB9KTtcblxuICByZXR1cm4gZGl2aWRlU2NhbGFyO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZGl2aWRlU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL2RpdmlkZVNjYWxhcicpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcbiAgXG4gIHZhciBhbGdvcml0aG0wMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDInKSk7XG4gIHZhciBhbGdvcml0aG0wMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMnKSk7XG4gIHZhciBhbGdvcml0aG0wNyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDcnKSk7XG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTInKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIERpdmlkZSB0d28gbWF0cmljZXMgZWxlbWVudCB3aXNlLiBUaGUgZnVuY3Rpb24gYWNjZXB0cyBib3RoIG1hdHJpY2VzIGFuZFxuICAgKiBzY2FsYXIgdmFsdWVzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZG90RGl2aWRlKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmRvdERpdmlkZSgyLCA0KTsgICAvLyByZXR1cm5zIDAuNVxuICAgKlxuICAgKiAgICBhID0gW1s5LCA1XSwgWzYsIDFdXTtcbiAgICogICAgYiA9IFtbMywgMl0sIFs1LCAyXV07XG4gICAqXG4gICAqICAgIG1hdGguZG90RGl2aWRlKGEsIGIpOyAgIC8vIHJldHVybnMgW1szLCAyLjVdLCBbMS4yLCAwLjVdXVxuICAgKiAgICBtYXRoLmRpdmlkZShhLCBiKTsgICAgICAvLyByZXR1cm5zIFtbMS43NSwgMC43NV0sIFstMS43NSwgMi4yNV1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBkaXZpZGUsIG11bHRpcGx5LCBkb3RNdWx0aXBseVxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggTnVtZXJhdG9yXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSBEZW5vbWluYXRvclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBRdW90aWVudCwgYHggLi8geWBcbiAgICovXG4gIHZhciBkb3REaXZpZGUgPSB0eXBlZCgnZG90RGl2aWRlJywge1xuICAgIFxuICAgICdhbnksIGFueSc6IGRpdmlkZVNjYWxhcixcbiAgICBcbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAuLyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA3KHgsIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAuLyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgZGl2aWRlU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC4vIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgZGl2aWRlU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgLi8gZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGRpdmlkZVNjYWxhcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBkb3REaXZpZGUobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdERpdmlkZShtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZG90RGl2aWRlKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgZGl2aWRlU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGRpdmlkZVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgZGl2aWRlU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgZGl2aWRlU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBkaXZpZGVTY2FsYXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGRpdmlkZVNjYWxhciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgZG90RGl2aWRlLnRvVGV4ID0ge1xuICAgIDI6ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snZG90RGl2aWRlJ10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknXG4gIH07XG4gIFxuICByZXR1cm4gZG90RGl2aWRlO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZG90RGl2aWRlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBtdWx0aXBseVNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseVNjYWxhcicpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDkgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA5JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gbWF0cmljZXMgZWxlbWVudCB3aXNlLiBUaGUgZnVuY3Rpb24gYWNjZXB0cyBib3RoIG1hdHJpY2VzIGFuZFxuICAgKiBzY2FsYXIgdmFsdWVzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZG90TXVsdGlwbHkoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZG90TXVsdGlwbHkoMiwgNCk7IC8vIHJldHVybnMgOFxuICAgKlxuICAgKiAgICBhID0gW1s5LCA1XSwgWzYsIDFdXTtcbiAgICogICAgYiA9IFtbMywgMl0sIFs1LCAyXV07XG4gICAqXG4gICAqICAgIG1hdGguZG90TXVsdGlwbHkoYSwgYik7IC8vIHJldHVybnMgW1syNywgMTBdLCBbMzAsIDJdXVxuICAgKiAgICBtYXRoLm11bHRpcGx5KGEsIGIpOyAgICAvLyByZXR1cm5zIFtbNTIsIDI4XSwgWzIzLCAxNF1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtdWx0aXBseSwgZGl2aWRlLCBkb3REaXZpZGVcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4IExlZnQgaGFuZCB2YWx1ZVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHkgUmlnaHQgaGFuZCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBNdWx0aXBsaWNhdGlvbiBvZiBgeGAgYW5kIGB5YFxuICAgKi9cbiAgdmFyIGRvdE11bHRpcGx5ID0gdHlwZWQoJ2RvdE11bHRpcGx5Jywge1xuICAgIFxuICAgICdhbnksIGFueSc6IG11bHRpcGx5U2NhbGFyLFxuICAgIFxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlIC4qIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDkoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLiogZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAyKHksIHgsIG11bHRpcGx5U2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC4qIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSAuKiBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgbXVsdGlwbHlTY2FsYXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIFxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdE11bHRpcGx5KG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZG90TXVsdGlwbHkobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdE11bHRpcGx5KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHksIHgsIG11bHRpcGx5U2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgbXVsdGlwbHlTY2FsYXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeCksIHksIG11bHRpcGx5U2NhbGFyLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBtdWx0aXBseVNjYWxhciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgZG90TXVsdGlwbHkudG9UZXggPSB7XG4gICAgMjogJ1xcXFxsZWZ0KCR7YXJnc1swXX0nICsgbGF0ZXgub3BlcmF0b3JzWydkb3RNdWx0aXBseSddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJ1xuICB9O1xuICBcbiAgcmV0dXJuIGRvdE11bHRpcGx5O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZG90TXVsdGlwbHknO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIHBvdyA9IGxvYWQocmVxdWlyZSgnLi9wb3cnKSk7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcG93ZXIgb2YgeCB0byB5IGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmRvdFBvdyh4LCB5KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5kb3RQb3coMiwgMyk7ICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgOFxuICAgKlxuICAgKiAgICB2YXIgYSA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGguZG90UG93KGEsIDIpOyAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1sxLCA0XSwgWzE2LCA5XV1cbiAgICogICAgbWF0aC5wb3coYSwgMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBBcnJheSBbWzksIDhdLCBbMTYsIDE3XV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHBvdywgc3FydCwgbXVsdGlwbHlcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgVGhlIGJhc2VcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geSAgVGhlIGV4cG9uZW50XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgVGhlIHZhbHVlIG9mIGB4YCB0byB0aGUgcG93ZXIgYHlgXG4gICAqL1xuICB2YXIgZG90UG93ID0gdHlwZWQoJ2RvdFBvdycsIHtcbiAgICBcbiAgICAnYW55LCBhbnknOiBwb3csXG4gICAgXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLl4gc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBwb3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgLl4gZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIHBvdywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSAuXiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHgsIHksIHBvdywgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC5eIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBwb3cpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZG90UG93KG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBkb3RQb3cobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGRvdFBvdyh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGRvdFBvdywgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBkb3RQb3csIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHksIHgsIGRvdFBvdywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGRvdFBvdywgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgZG90UG93LCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBkb3RQb3csIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRvdFBvdy50b1RleCA9IHtcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ2RvdFBvdyddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJ1xuICB9O1xuICBcbiAgcmV0dXJuIGRvdFBvdztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2RvdFBvdyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IG9mIGEgdmFsdWUuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5leHAoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZXhwKDIpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDcuMzg5MDU2MDk4OTMwNjQ5NVxuICAgKiAgICBtYXRoLnBvdyhtYXRoLmUsIDIpOyAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA3LjM4OTA1NjA5ODkzMDY0OTVcbiAgICogICAgbWF0aC5sb2cobWF0aC5leHAoMikpOyAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMlxuICAgKlxuICAgKiAgICBtYXRoLmV4cChbMSwgMiwgM10pO1xuICAgKiAgICAvLyByZXR1cm5zIEFycmF5IFtcbiAgICogICAgLy8gICAyLjcxODI4MTgyODQ1OTA0NSxcbiAgICogICAgLy8gICA3LjM4OTA1NjA5ODkzMDY0OTUsXG4gICAqICAgIC8vICAgMjAuMDg1NTM2OTIzMTg3NjY4XG4gICAqICAgIC8vIF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGxvZywgcG93XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBBIG51bWJlciBvciBtYXRyaXggdG8gZXhwb25lbnRpYXRlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gRXhwb25lbnQgb2YgYHhgXG4gICAqL1xuICB2YXIgZXhwID0gdHlwZWQoJ2V4cCcsIHtcbiAgICAnbnVtYmVyJzogTWF0aC5leHAsXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5leHAoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5leHAoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIFRPRE86IGV4cChzcGFyc2UpIHNob3VsZCByZXR1cm4gYSBkZW5zZSBtYXRyaXggc2luY2UgZXhwKDApPT0xXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBleHApO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwLnRvVGV4ID0gezE6ICdcXFxcZXhwXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gZXhwO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZXhwJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFJvdW5kIGEgdmFsdWUgdG93YXJkcyB6ZXJvLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZml4KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZpeCgzLjIpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAzXG4gICAqICAgIG1hdGguZml4KDMuOCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDNcbiAgICogICAgbWF0aC5maXgoLTQuMik7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgLTRcbiAgICogICAgbWF0aC5maXgoLTQuNyk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgLTRcbiAgICpcbiAgICogICAgdmFyIGMgPSBtYXRoLmNvbXBsZXgoMy4yLCAtMi43KTtcbiAgICogICAgbWF0aC5maXgoYyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDMgLSAyaVxuICAgKlxuICAgKiAgICBtYXRoLmZpeChbMy4yLCAzLjgsIC00LjddKTsgICAvLyByZXR1cm5zIEFycmF5IFszLCAzLCAtNF1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNlaWwsIGZsb29yLCByb3VuZFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4IE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSAgICAgICAgICAgIFJvdW5kZWQgdmFsdWVcbiAgICovXG4gIHZhciBmaXggPSB0eXBlZCgnZml4Jywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuICh4ID4gMCkgPyBNYXRoLmZsb29yKHgpIDogTWF0aC5jZWlsKHgpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleChcbiAgICAgICAgICAoeC5yZSA+IDApID8gTWF0aC5mbG9vcih4LnJlKSA6IE1hdGguY2VpbCh4LnJlKSxcbiAgICAgICAgICAoeC5pbSA+IDApID8gTWF0aC5mbG9vcih4LmltKSA6IE1hdGguY2VpbCh4LmltKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5pc05lZ2F0aXZlKCkgPyB4LmNlaWwoKSA6IHguZmxvb3IoKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnMgPCAwID8geC5jZWlsKCkgOiB4LmZsb29yKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGZpeCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGZpeCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICBmaXgudG9UZXggPSB7MTogJ1xcXFxtYXRocm17JHtuYW1lfX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBmaXg7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmaXgnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogUm91bmQgYSB2YWx1ZSB0b3dhcmRzIG1pbnVzIGluZmluaXR5LlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZmxvb3IoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZmxvb3IoMy4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDNcbiAgICogICAgbWF0aC5mbG9vcigzLjgpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgM1xuICAgKiAgICBtYXRoLmZsb29yKC00LjIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNVxuICAgKiAgICBtYXRoLmZsb29yKC00LjcpOyAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNVxuICAgKlxuICAgKiAgICB2YXIgYyA9IG1hdGguY29tcGxleCgzLjIsIC0yLjcpO1xuICAgKiAgICBtYXRoLmZsb29yKGMpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMyAtIDNpXG4gICAqXG4gICAqICAgIG1hdGguZmxvb3IoWzMuMiwgMy44LCAtNC43XSk7IC8vIHJldHVybnMgQXJyYXkgWzMsIDMsIC01XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY2VpbCwgZml4LCByb3VuZFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgTnVtYmVyIHRvIGJlIHJvdW5kZWRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFJvdW5kZWQgdmFsdWVcbiAgICovXG4gIHZhciBmbG9vciA9IHR5cGVkKCdmbG9vcicsIHtcbiAgICAnbnVtYmVyJzogTWF0aC5mbG9vcixcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmZsb29yKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguZmxvb3IoKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmZsb29yKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGZsb29yKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgZmxvb3IsIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgZmxvb3IudG9UZXggPSB7MTogJ1xcXFxsZWZ0XFxcXGxmbG9vciR7YXJnc1swXX1cXFxccmlnaHRcXFxccmZsb29yJ307XG5cbiAgcmV0dXJuIGZsb29yO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZmxvb3InO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAxJykpO1xuICB2YXIgYWxnb3JpdGhtMDQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA0JykpO1xuICB2YXIgYWxnb3JpdGhtMTAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEwJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIGZvciB0d28gb3IgbW9yZSB2YWx1ZXMgb3IgYXJyYXlzLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZ2NkKGEsIGIpXG4gICAqICAgIG1hdGguZ2NkKGEsIGIsIGMsIC4uLilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZ2NkKDgsIDEyKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLmdjZCgtNCwgNik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIDJcbiAgICogICAgbWF0aC5nY2QoMjUsIDE1LCAtMTApOyAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqXG4gICAqICAgIG1hdGguZ2NkKFs4LCAtNF0sIFsxMiwgNl0pOyAgIC8vIHJldHVybnMgWzQsIDJdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBsY20sIHhnY2RcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gbnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBBcnJheSB8IE1hdHJpeH0gYXJncyAgVHdvIG9yIG1vcmUgaW50ZWdlciBudW1iZXJzXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yXG4gICAqL1xuICB2YXIgZ2NkID0gdHlwZWQoJ2djZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IF9nY2QsXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBfZ2NkQmlnTnVtYmVyLFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5nY2QoeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNCh4LCB5LCBnY2QpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMSh5LCB4LCBnY2QsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAxKHgsIHksIGdjZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGdjZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBnY2QobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGdjZChtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZ2NkKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHgsIHksIGdjZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBnY2QsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEwKHksIHgsIGdjZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGdjZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgZ2NkLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBnY2QsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHNtYXJ0ZXIgbm90YXRpb24gaGVyZVxuICAgICdBcnJheSB8IE1hdHJpeCB8IG51bWJlciB8IEJpZ051bWJlciwgQXJyYXkgfCBNYXRyaXggfCBudW1iZXIgfCBCaWdOdW1iZXIsIC4uLkFycmF5IHwgTWF0cml4IHwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGEsIGIsIGFyZ3MpIHtcbiAgICAgIHZhciByZXMgPSBnY2QoYSwgYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzID0gZ2NkKHJlcywgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG5cbiAgZ2NkLnRvVGV4ID0gJ1xcXFxnY2RcXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIGdjZDtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGdjZCBmb3IgQmlnTnVtYmVyc1xuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYVxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYlxuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIGdyZWF0ZXN0IGNvbW1vbiBkZW5vbWluYXRvciBvZiBhIGFuZCBiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2NkQmlnTnVtYmVyKGEsIGIpIHtcbiAgICBpZiAoIWEuaXNJbnQoKSB8fCAhYi5pc0ludCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlcnMgaW4gZnVuY3Rpb24gZ2NkIG11c3QgYmUgaW50ZWdlciBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gICAgdmFyIHplcm8gPSBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICB2YXIgciA9IGEubW9kKGIpO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gcjtcbiAgICB9XG4gICAgcmV0dXJuIGEubHQoemVybykgPyBhLm5lZygpIDogYTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBnY2QgZm9yIG51bWJlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZ3JlYXRlc3QgY29tbW9uIGRlbm9taW5hdG9yIG9mIGEgYW5kIGJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nY2QoYSwgYikge1xuICBpZiAoIWlzSW50ZWdlcihhKSB8fCAhaXNJbnRlZ2VyKGIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGdjZCBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICB9XG5cbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gIHZhciByO1xuICB3aGlsZSAoYiAhPSAwKSB7XG4gICAgciA9IGEgJSBiO1xuICAgIGEgPSBiO1xuICAgIGIgPSByO1xuICB9XG4gIHJldHVybiAoYSA8IDApID8gLWEgOiBhO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZ2NkJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5mbGF0dGVuO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhYnMgPSBsb2FkKHJlcXVpcmUoJy4vYWJzJykpO1xuICB2YXIgYWRkID0gbG9hZChyZXF1aXJlKCcuL2FkZFNjYWxhcicpKTtcbiAgdmFyIGRpdmlkZSA9IGxvYWQocmVxdWlyZSgnLi9kaXZpZGVTY2FsYXInKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseVNjYWxhcicpKTtcbiAgdmFyIHNxcnQgPSBsb2FkKHJlcXVpcmUoJy4vc3FydCcpKTtcbiAgdmFyIHNtYWxsZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcbiAgdmFyIGlzUG9zaXRpdmUgPSBsb2FkKHJlcXVpcmUoJy4uL3V0aWxzL2lzUG9zaXRpdmUnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwb3RlbnVzYSBvZiBhIGxpc3Qgd2l0aCB2YWx1ZXMuIFRoZSBoeXBvdGVudXNhIGlzIGRlZmluZWQgYXM6XG4gICAqXG4gICAqICAgICBoeXBvdChhLCBiLCBjLCAuLi4pID0gc3FydChhXjIgKyBiXjIgKyBjXjIgKyAuLi4pXG4gICAqXG4gICAqIEZvciBtYXRyaXggaW5wdXQsIHRoZSBoeXBvdGVudXNhIGlzIGNhbGN1bGF0ZWQgZm9yIGFsbCB2YWx1ZXMgaW4gdGhlIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5oeXBvdChhLCBiLCAuLi4pXG4gICAqICAgICBtYXRoLmh5cG90KFthLCBiLCBjLCAuLi5dKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGguaHlwb3QoMywgNCk7ICAgICAgLy8gNVxuICAgKiAgICAgbWF0aC5oeXBvdCgzLCA0LCA1KTsgICAvLyA3LjA3MTA2NzgxMTg2NTQ3NTVcbiAgICogICAgIG1hdGguaHlwb3QoWzMsIDQsIDVdKTsgLy8gNy4wNzEwNjc4MTE4NjU0NzU1XG4gICAqICAgICBtYXRoLmh5cG90KC0yKTsgICAgICAgIC8vIDJcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBhYnMsIG5vcm1cbiAgICpcbiAgICogQHBhcmFtIHsuLi4gbnVtYmVyIHwgQmlnTnVtYmVyfSBhcmdzXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlcn0gUmV0dXJucyB0aGUgaHlwb3RoZW51c2Egb2YgdGhlIGlucHV0IHZhbHVlcy5cbiAgICovXG4gIHZhciBoeXBvdCA9IHR5cGVkKCdoeXBvdCcsIHtcbiAgICAnLi4uIG51bWJlciB8IEJpZ051bWJlcic6IF9oeXBvdCxcblxuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gaHlwb3QuYXBwbHkoaHlwb3QsIGZsYXR0ZW4oeCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBoeXBvdC5hcHBseShoeXBvdCwgZmxhdHRlbih4LnRvQXJyYXkoKSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwb3RlbnVzYSBmb3IgYW4gQXJyYXkgd2l0aCB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyIHwgQmlnTnVtYmVyPn0gYXJnc1xuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXJ9IFJldHVybnMgdGhlIHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2h5cG90IChhcmdzKSB7XG4gICAgLy8gY29kZSBiYXNlZCBvbiBgaHlwb3RgIGZyb20gZXM2LXNoaW06XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9lczYtc2hpbS9ibG9iL21hc3Rlci9lczYtc2hpbS5qcyNMMTYxOS1MMTYzM1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBsYXJnZXN0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYWJzKGFyZ3NbaV0pO1xuICAgICAgaWYgKHNtYWxsZXIobGFyZ2VzdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IG11bHRpcGx5KHJlc3VsdCwgbXVsdGlwbHkoZGl2aWRlKGxhcmdlc3QsIHZhbHVlKSwgZGl2aWRlKGxhcmdlc3QsIHZhbHVlKSkpO1xuICAgICAgICByZXN1bHQgPSBhZGQocmVzdWx0LCAxKTtcbiAgICAgICAgbGFyZ2VzdCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYWRkKHJlc3VsdCwgaXNQb3NpdGl2ZSh2YWx1ZSkgPyBtdWx0aXBseShkaXZpZGUodmFsdWUsIGxhcmdlc3QpLCBkaXZpZGUodmFsdWUsIGxhcmdlc3QpKSA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbXVsdGlwbHkobGFyZ2VzdCwgc3FydChyZXN1bHQpKTtcbiAgfVxuXG4gIGh5cG90LnRvVGV4ID0gJ1xcXFxoeXBvdFxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxuICByZXR1cm4gaHlwb3Q7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdoeXBvdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHJlcXVpcmUoJy4vYWJzJyksXG4gIHJlcXVpcmUoJy4vYWRkJyksXG4gIHJlcXVpcmUoJy4vYWRkU2NhbGFyJyksXG4gIHJlcXVpcmUoJy4vY2JydCcpLFxuICByZXF1aXJlKCcuL2NlaWwnKSxcbiAgcmVxdWlyZSgnLi9jdWJlJyksXG4gIHJlcXVpcmUoJy4vZGl2aWRlJyksXG4gIHJlcXVpcmUoJy4vZG90RGl2aWRlJyksXG4gIHJlcXVpcmUoJy4vZG90TXVsdGlwbHknKSxcbiAgcmVxdWlyZSgnLi9kb3RQb3cnKSxcbiAgcmVxdWlyZSgnLi9leHAnKSxcbiAgcmVxdWlyZSgnLi9maXgnKSxcbiAgcmVxdWlyZSgnLi9mbG9vcicpLFxuICByZXF1aXJlKCcuL2djZCcpLFxuICByZXF1aXJlKCcuL2h5cG90JyksXG4gIHJlcXVpcmUoJy4vbGNtJyksXG4gIHJlcXVpcmUoJy4vbG9nJyksXG4gIHJlcXVpcmUoJy4vbG9nMTAnKSxcbiAgcmVxdWlyZSgnLi9tb2QnKSxcbiAgcmVxdWlyZSgnLi9tdWx0aXBseScpLFxuICByZXF1aXJlKCcuL25vcm0nKSxcbiAgcmVxdWlyZSgnLi9udGhSb290JyksXG4gIHJlcXVpcmUoJy4vcG93JyksXG4gIHJlcXVpcmUoJy4vcm91bmQnKSxcbiAgcmVxdWlyZSgnLi9zaWduJyksXG4gIHJlcXVpcmUoJy4vc3FydCcpLFxuICByZXF1aXJlKCcuL3NxdWFyZScpLFxuICByZXF1aXJlKCcuL3N1YnRyYWN0JyksXG4gIHJlcXVpcmUoJy4vdW5hcnlNaW51cycpLFxuICByZXF1aXJlKCcuL3VuYXJ5UGx1cycpLFxuICByZXF1aXJlKCcuL3hnY2QnKVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0wMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDInKSk7XG4gIHZhciBhbGdvcml0aG0wNiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDYnKSk7XG4gIHZhciBhbGdvcml0aG0xMSA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTEnKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlIGZvciB0d28gb3IgbW9yZSB2YWx1ZXMgb3IgYXJyYXlzLlxuICAgKlxuICAgKiBsY20gaXMgZGVmaW5lZCBhczpcbiAgICpcbiAgICogICAgIGxjbShhLCBiKSA9IGFicyhhICogYikgLyBnY2QoYSwgYilcbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmxjbShhLCBiKVxuICAgKiAgICBtYXRoLmxjbShhLCBiLCBjLCAuLi4pXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmxjbSg0LCA2KTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEyXG4gICAqICAgIG1hdGgubGNtKDYsIDIxKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNDJcbiAgICogICAgbWF0aC5sY20oNiwgMjEsIDUpOyAgICAgICAgICAgLy8gcmV0dXJucyAyMTBcbiAgICpcbiAgICogICAgbWF0aC5sY20oWzQsIDZdLCBbNiwgMjFdKTsgICAgLy8gcmV0dXJucyBbMTIsIDQyXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZ2NkLCB4Z2NkXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uIG51bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4fSBhcmdzICBUd28gb3IgbW9yZSBpbnRlZ2VyIG51bWJlcnNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZVxuICAgKi9cbiAgdmFyIGxjbSA9IHR5cGVkKCdsY20nLCB7XG4gICAgJ251bWJlciwgbnVtYmVyJzogX2xjbSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IF9sY21CaWdOdW1iZXIsXG5cbiAgICAnRnJhY3Rpb24sIEZyYWN0aW9uJzogZnVuY3Rpb24gKHgsIHkpIHtcblxuICAgICAgcmV0dXJuIHgubGNtKHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIHNwYXJzZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDYoeCwgeSwgbGNtKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgbGNtLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih4LCB5LCBsY20sIGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMyh4LCB5LCBsY20pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbGNtKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsY20obWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGxjbSh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIGxjbSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBsY20sIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHksIHgsIGxjbSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGxjbSwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgbGNtLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBsY20sIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHNtYXJ0ZXIgbm90YXRpb24gaGVyZVxuICAgICdBcnJheSB8IE1hdHJpeCB8IG51bWJlciB8IEJpZ051bWJlciwgQXJyYXkgfCBNYXRyaXggfCBudW1iZXIgfCBCaWdOdW1iZXIsIC4uLkFycmF5IHwgTWF0cml4IHwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGEsIGIsIGFyZ3MpIHtcbiAgICAgIHZhciByZXMgPSBsY20oYSwgYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzID0gbGNtKHJlcywgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG5cbiAgbGNtLnRvVGV4ID0gdW5kZWZpbmVkOyAgLy8gdXNlIGRlZmF1bHQgdGVtcGxhdGVcblxuICByZXR1cm4gbGNtO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgbGNtIGZvciB0d28gQmlnTnVtYmVyc1xuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYVxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gYlxuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIHRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGUgb2YgYSBhbmQgYlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2xjbUJpZ051bWJlcihhLCBiKSB7XG4gICAgaWYgKCFhLmlzSW50KCkgfHwgIWIuaXNJbnQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGxjbSBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICAgIH1cblxuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gICAgLy8gZXZhbHVhdGUgbGNtIGhlcmUgaW5saW5lIHRvIHJlZHVjZSBvdmVyaGVhZFxuICAgIHZhciBwcm9kID0gYS50aW1lcyhiKTtcbiAgICB3aGlsZSAoIWIuaXNaZXJvKCkpIHtcbiAgICAgIHZhciB0ID0gYjtcbiAgICAgIGIgPSBhLm1vZCh0KTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvZC5kaXYoYSkuYWJzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbGNtIGZvciB0d28gbnVtYmVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGUgb2YgYSBhbmQgYlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2xjbSAoYSwgYikge1xuICBpZiAoIWlzSW50ZWdlcihhKSB8fCAhaXNJbnRlZ2VyKGIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGxjbSBtdXN0IGJlIGludGVnZXIgbnVtYmVycycpO1xuICB9XG5cbiAgaWYgKGEgPT0gMCB8fCBiID09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2FsZ29yaXRobVxuICAvLyBldmFsdWF0ZSBsY20gaGVyZSBpbmxpbmUgdG8gcmVkdWNlIG92ZXJoZWFkXG4gIHZhciB0O1xuICB2YXIgcHJvZCA9IGEgKiBiO1xuICB3aGlsZSAoYiAhPSAwKSB7XG4gICAgdCA9IGI7XG4gICAgYiA9IGEgJSB0O1xuICAgIGEgPSB0O1xuICB9XG4gIHJldHVybiBNYXRoLmFicyhwcm9kIC8gYSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdsY20nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgZGl2aWRlU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuL2RpdmlkZVNjYWxhcicpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBsb2dhcml0aG0gb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmxvZyh4KVxuICAgKiAgICBtYXRoLmxvZyh4LCBiYXNlKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5sb2coMy41KTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEuMjUyNzYyOTY4NDk1MzY4XG4gICAqICAgIG1hdGguZXhwKG1hdGgubG9nKDIuNCkpOyAgICAgICAgLy8gcmV0dXJucyAyLjRcbiAgICpcbiAgICogICAgbWF0aC5wb3coMTAsIDQpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDEwMDAwXG4gICAqICAgIG1hdGgubG9nKDEwMDAwLCAxMCk7ICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqICAgIG1hdGgubG9nKDEwMDAwKSAvIG1hdGgubG9nKDEwKTsgLy8gcmV0dXJucyA0XG4gICAqXG4gICAqICAgIG1hdGgubG9nKDEwMjQsIDIpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyAxMFxuICAgKiAgICBtYXRoLnBvdygyLCAxMCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTAyNFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZXhwLCBsb2cxMFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geFxuICAgKiAgICAgICAgICAgIFZhbHVlIGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGxvZ2FyaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4fSBbYmFzZT1lXVxuICAgKiAgICAgICAgICAgIE9wdGlvbmFsIGJhc2UgZm9yIHRoZSBsb2dhcml0aG0uIElmIG5vdCBwcm92aWRlZCwgdGhlIG5hdHVyYWxcbiAgICogICAgICAgICAgICBsb2dhcml0aG0gb2YgYHhgIGlzIGNhbGN1bGF0ZWQuXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH1cbiAgICogICAgICAgICAgICBSZXR1cm5zIHRoZSBsb2dhcml0aG0gb2YgYHhgXG4gICAqL1xuICB2YXIgbG9nID0gdHlwZWQoJ2xvZycsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID49IDAgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZWdhdGl2ZSB2YWx1ZSAtPiBjb21wbGV4IHZhbHVlIGNvbXB1dGF0aW9uXG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgsIDApLmxvZygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5sb2coKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaXNOZWdhdGl2ZSgpIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4geC5sbigpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBudW1iZXIsIHJldHVybiBDb21wbGV4IHZhbHVlZCByZXN1bHRcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeC50b051bWJlcigpLCAwKS5sb2coKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGxvZyk7XG4gICAgfSxcblxuICAgICdhbnksIGFueSc6IGZ1bmN0aW9uICh4LCBiYXNlKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgbG9nYXJpdGhtIGZvciBhIHNwZWNpZmllZCBiYXNlLCBsb2coeCwgYmFzZSlcbiAgICAgIHJldHVybiBkaXZpZGVTY2FsYXIobG9nKHgpLCBsb2coYmFzZSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgbG9nLnRvVGV4ID0ge1xuICAgIDE6ICdcXFxcbG5cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KScsXG4gICAgMjogJ1xcXFxsb2dfeyR7YXJnc1sxXX19XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIGxvZztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2xvZyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIDEwLWJhc2UgbG9nYXJpdGhtIG9mIGEgdmFsdWUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsY3VsYXRpbmcgYGxvZyh4LCAxMClgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubG9nMTAoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubG9nMTAoMC4wMDAwMSk7ICAgICAgICAgICAgLy8gcmV0dXJucyAtNVxuICAgKiAgICBtYXRoLmxvZzEwKDEwMDAwKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLmxvZygxMDAwMCkgLyBtYXRoLmxvZygxMCk7IC8vIHJldHVybnMgNFxuICAgKiAgICBtYXRoLnBvdygxMCwgNCk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMTAwMDBcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGV4cCwgbG9nXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4XG4gICAqICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgbG9nYXJpdGhtLlxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgMTAtYmFzZSBsb2dhcml0aG0gb2YgYHhgXG4gICAqL1xuICB2YXIgbG9nMTAgPSB0eXBlZCgnbG9nMTAnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA+PSAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4gX2xvZzEwKHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5lZ2F0aXZlIHZhbHVlIC0+IGNvbXBsZXggdmFsdWUgY29tcHV0YXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkubG9nKCkuZGl2KE1hdGguTE4xMCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgpLmxvZygpLmRpdihNYXRoLkxOMTApO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgheC5pc05lZ2F0aXZlKCkgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB4LmxvZygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGRvd25ncmFkZSB0byBudW1iZXIsIHJldHVybiBDb21wbGV4IHZhbHVlZCByZXN1bHRcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeC50b051bWJlcigpLCAwKS5sb2coKS5kaXYoTWF0aC5MTjEwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGxvZzEwKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxvZzEwLnRvVGV4ID0gezE6ICdcXFxcbG9nX3sxMH1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBsb2cxMDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIDEwLWJhc2UgbG9nYXJpdGhtIG9mIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybiB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIF9sb2cxMCA9IE1hdGgubG9nMTAgfHwgZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xufTtcblxuZXhwb3J0cy5uYW1lID0gJ2xvZzEwJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDUgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA1JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsdXMsIHRoZSByZW1haW5kZXIgb2YgYW4gaW50ZWdlciBkaXZpc2lvbi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogVGhlIG1vZHVsdXMgaXMgZGVmaW5lZCBhczpcbiAgICpcbiAgICogICAgIHggLSB5ICogZmxvb3IoeCAvIHkpXG4gICAqXG4gICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5tb2QoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubW9kKDgsIDMpOyAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDJcbiAgICogICAgbWF0aC5tb2QoMTEsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICBmdW5jdGlvbiBpc09kZCh4KSB7XG4gICAqICAgICAgcmV0dXJuIG1hdGgubW9kKHgsIDIpICE9IDA7XG4gICAqICAgIH1cbiAgICpcbiAgICogICAgaXNPZGQoMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgaXNPZGQoMyk7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGl2aWRlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQXJyYXkgfCBNYXRyaXh9IHggRGl2aWRlbmRcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBBcnJheSB8IE1hdHJpeH0geSBEaXZpc29yXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdGhlIHJlbWFpbmRlciBvZiBgeGAgZGl2aWRlZCBieSBgeWAuXG4gICAqL1xuICB2YXIgbW9kID0gdHlwZWQoJ21vZCcsIHtcblxuICAgICdudW1iZXIsIG51bWJlcic6IF9tb2QsXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHkuaXNaZXJvKCkgPyB4IDogeC5tb2QoeSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubW9kKHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIG1vZChzcGFyc2UsIHNwYXJzZSlcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA1KHgsIHksIG1vZCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIG1vZChzcGFyc2UsIGRlbnNlKVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgbW9kLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIG1vZChkZW5zZSwgc3BhcnNlKVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDMoeCwgeSwgbW9kLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gbW9kKGRlbnNlLCBkZW5zZSlcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIG1vZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbW9kKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBtb2QobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG1vZCh4LCBtYXRyaXgoeSkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIG1vZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBtb2QsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnYW55LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHksIHgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgbW9kLCBmYWxzZSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnYW55LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCBtb2QsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1vZC50b1RleCA9IHtcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ21vZCddICsgJyR7YXJnc1sxXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiBtb2Q7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbW9kdWx1cyBvZiB0d28gbnVtYmVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9tb2QoeCwgeSkge1xuICAgIGlmICh5ID4gMCkge1xuICAgICAgLy8gV2UgZG9uJ3QgdXNlIEphdmFTY3JpcHQncyAlIG9wZXJhdG9yIGhlcmUgYXMgdGhpcyBkb2Vzbid0IHdvcmtcbiAgICAgIC8vIGNvcnJlY3RseSBmb3IgeCA8IDAgYW5kIHggPT0gMFxuICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuICAgICAgcmV0dXJuIHggLSB5ICogTWF0aC5mbG9vcih4IC8geSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHkgPT09IDApIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBlbHNlIHsgLy8geSA8IDBcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBtb2QgZm9yIGEgbmVnYXRpdmUgZGl2aXNvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIG1vZCBmb3IgYSBuZWdhdGl2ZSBkaXZpc29yJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtb2QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmV4dGVuZDtcbnZhciBhcnJheSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5Jyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBhZGRTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vYWRkU2NhbGFyJykpO1xuICB2YXIgbXVsdGlwbHlTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vbXVsdGlwbHlTY2FsYXInKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuICBcbiAgdmFyIERlbnNlTWF0cml4ID0gdHlwZS5EZW5zZU1hdHJpeDtcbiAgdmFyIFNwYXJzZU1hdHJpeCA9IHR5cGUuU3BhcnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0d28gb3IgbW9yZSB2YWx1ZXMsIGB4ICogeWAuXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIG1hdHJpeCBwcm9kdWN0IGlzIGNhbGN1bGF0ZWQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5tdWx0aXBseSh4LCB5KVxuICAgKiAgICBtYXRoLm11bHRpcGx5KHgsIHksIHosIC4uLilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgubXVsdGlwbHkoNCwgNS4yKTsgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDIwLjhcbiAgICogICAgbWF0aC5tdWx0aXBseSgyLCAzLCA0KTsgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMjRcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIHZhciBiID0gbWF0aC5jb21wbGV4KDQsIDEpO1xuICAgKiAgICBtYXRoLm11bHRpcGx5KGEsIGIpOyAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggNSArIDE0aVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIHZhciBkID0gW1sxLCAyLCAzXSwgWzMsIC00LCA3XV07XG4gICAqICAgIG1hdGgubXVsdGlwbHkoYywgZCk7ICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1s3LCAtNiwgMTddLCBbMTMsIC00LCAzM11dXG4gICAqXG4gICAqICAgIHZhciBlID0gbWF0aC51bml0KCcyLjEga20nKTtcbiAgICogICAgbWF0aC5tdWx0aXBseSgzLCBlKTsgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDYuMyBrbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGl2aWRlLCBwcm9kLCBjcm9zcywgZG90XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBtdWx0aXBseVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIG11bHRpcGx5XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0gTXVsdGlwbGljYXRpb24gb2YgYHhgIGFuZCBgeWBcbiAgICovXG4gIHZhciBtdWx0aXBseSA9IHR5cGVkKCdtdWx0aXBseScsIGV4dGVuZCh7XG4gICAgLy8gd2UgZXh0ZW5kIHRoZSBzaWduYXR1cmVzIG9mIG11bHRpcGx5U2NhbGFyIHdpdGggc2lnbmF0dXJlcyBkZWFsaW5nIHdpdGggbWF0cmljZXNcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgZGltZW5zaW9uc1xuICAgICAgX3ZhbGlkYXRlTWF0cml4RGltZW5zaW9ucyhhcnJheS5zaXplKHgpLCBhcnJheS5zaXplKHkpKTtcblxuICAgICAgLy8gdXNlIGRlbnNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgdmFyIG0gPSBtdWx0aXBseShtYXRyaXgoeCksIG1hdHJpeCh5KSk7XG4gICAgICAvLyByZXR1cm4gYXJyYXkgb3Igc2NhbGFyXG4gICAgICByZXR1cm4gKG0gJiYgbS5pc01hdHJpeCA9PT0gdHJ1ZSkgPyBtLnZhbHVlT2YoKSA6IG07XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyBkaW1lbnNpb25zXG4gICAgICB2YXIgeHNpemUgPSB4LnNpemUoKTtcbiAgICAgIHZhciB5c2l6ZSA9IHkuc2l6ZSgpO1xuXG4gICAgICAvLyBjaGVjayBkaW1lbnNpb25zXG4gICAgICBfdmFsaWRhdGVNYXRyaXhEaW1lbnNpb25zKHhzaXplLCB5c2l6ZSk7XG5cbiAgICAgIC8vIHByb2Nlc3MgZGltZW5zaW9uc1xuICAgICAgaWYgKHhzaXplLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBwcm9jZXNzIHkgZGltZW5zaW9uc1xuICAgICAgICBpZiAoeXNpemUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gVmVjdG9yICogVmVjdG9yXG4gICAgICAgICAgcmV0dXJuIF9tdWx0aXBseVZlY3RvclZlY3Rvcih4LCB5LCB4c2l6ZVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVjdG9yICogTWF0cml4XG4gICAgICAgIHJldHVybiBfbXVsdGlwbHlWZWN0b3JNYXRyaXgoeCwgeSk7XG4gICAgICB9XG4gICAgICAvLyBwcm9jZXNzIHkgZGltZW5zaW9uc1xuICAgICAgaWYgKHlzaXplLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBNYXRyaXggKiBWZWN0b3JcbiAgICAgICAgcmV0dXJuIF9tdWx0aXBseU1hdHJpeFZlY3Rvcih4LCB5KTtcbiAgICAgIH1cbiAgICAgIC8vIE1hdHJpeCAqIE1hdHJpeFxuICAgICAgcmV0dXJuIF9tdWx0aXBseU1hdHJpeE1hdHJpeCh4LCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIE1hdHJpeCAqIE1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG11bHRpcGx5KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBNYXRyaXggKiBNYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBtdWx0aXBseShtYXRyaXgoeCwgeS5zdG9yYWdlKCkpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICBcbiAgICAgIC8vIHByb2Nlc3Mgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeCwgeSwgbXVsdGlwbHlTY2FsYXIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVuc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBtdWx0aXBseVNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTEoeSwgeCwgbXVsdGlwbHlTY2FsYXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIG11bHRpcGx5U2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBtdWx0aXBseVNjYWxhciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgbXVsdGlwbHlTY2FsYXIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgYW55JzogbXVsdGlwbHlTY2FsYXIsXG5cbiAgICAnYW55LCBhbnksIC4uLmFueSc6IGZ1bmN0aW9uICh4LCB5LCByZXN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbXVsdGlwbHkoeCwgeSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSBtdWx0aXBseShyZXN1bHQsIHJlc3RbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwgbXVsdGlwbHlTY2FsYXIuc2lnbmF0dXJlcykpO1xuXG4gIHZhciBfdmFsaWRhdGVNYXRyaXhEaW1lbnNpb25zID0gZnVuY3Rpb24gKHNpemUxLCBzaXplMikge1xuICAgIC8vIGNoZWNrIGxlZnQgb3BlcmFuZCBkaW1lbnNpb25zXG4gICAgc3dpdGNoIChzaXplMS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gY2hlY2sgc2l6ZTJcbiAgICAgICAgc3dpdGNoIChzaXplMi5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyBWZWN0b3IgeCBWZWN0b3JcbiAgICAgICAgICAgIGlmIChzaXplMVswXSAhPT0gc2l6ZTJbMF0pIHtcbiAgICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCBpbiBtdWx0aXBsaWNhdGlvbi4gVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBWZWN0b3IgeCBNYXRyaXhcbiAgICAgICAgICAgIGlmIChzaXplMVswXSAhPT0gc2l6ZTJbMF0pIHtcbiAgICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCBpbiBtdWx0aXBsaWNhdGlvbi4gVmVjdG9yIGxlbmd0aCAoJyArIHNpemUxWzBdICsgJykgbXVzdCBtYXRjaCBNYXRyaXggcm93cyAoJyArIHNpemUyWzBdICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IG11bHRpcGx5IGEgMSBvciAyIGRpbWVuc2lvbmFsIG1hdHJpeCAoTWF0cml4IEIgaGFzICcgKyBzaXplMi5sZW5ndGggKyAnIGRpbWVuc2lvbnMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIGNoZWNrIHNpemUyXG4gICAgICAgIHN3aXRjaCAoc2l6ZTIubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gTWF0cml4IHggVmVjdG9yXG4gICAgICAgICAgICBpZiAoc2l6ZTFbMV0gIT09IHNpemUyWzBdKSB7XG4gICAgICAgICAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2ggaW4gbXVsdGlwbGljYXRpb24uIE1hdHJpeCBjb2x1bW5zICgnICsgc2l6ZTFbMV0gKyAnKSBtdXN0IG1hdGNoIFZlY3RvciBsZW5ndGggKCcgKyBzaXplMlswXSArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBNYXRyaXggeCBNYXRyaXhcbiAgICAgICAgICAgIGlmIChzaXplMVsxXSAhPT0gc2l6ZTJbMF0pIHtcbiAgICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCBpbiBtdWx0aXBsaWNhdGlvbi4gTWF0cml4IEEgY29sdW1ucyAoJyArIHNpemUxWzFdICsgJykgbXVzdCBtYXRjaCBNYXRyaXggQiByb3dzICgnICsgc2l6ZTJbMF0gKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgbXVsdGlwbHkgYSAxIG9yIDIgZGltZW5zaW9uYWwgbWF0cml4IChNYXRyaXggQiBoYXMgJyArIHNpemUyLmxlbmd0aCArICcgZGltZW5zaW9ucyknKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgbXVsdGlwbHkgYSAxIG9yIDIgZGltZW5zaW9uYWwgbWF0cml4IChNYXRyaXggQSBoYXMgJyArIHNpemUxLmxlbmd0aCArICcgZGltZW5zaW9ucyknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIERlbnNlIFZlY3RvciAgIChOKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gYiAgICAgICAgICAgIERlbnNlIFZlY3RvciAgIChOKVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgIFNjYWxhciB2YWx1ZVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseVZlY3RvclZlY3RvciA9IGZ1bmN0aW9uIChhLCBiLCBuKSB7XG4gICAgLy8gY2hlY2sgZW1wdHkgdmVjdG9yXG4gICAgaWYgKG4gPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtdWx0aXBseSB0d28gZW1wdHkgdmVjdG9ycycpO1xuXG4gICAgLy8gYSBkZW5zZVxuICAgIHZhciBhZGF0YSA9IGEuX2RhdGE7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIGIgZGVuc2VcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGFkZFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGFmID0gYWRkU2NhbGFyO1xuICAgIC8vIG11bHRpcGx5U2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgbWYgPSBtdWx0aXBseVNjYWxhcjtcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmIChhZHQgJiYgYmR0ICYmIGFkdCA9PT0gYmR0ICYmIHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZXMgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBhZiA9IHR5cGVkLmZpbmQoYWRkU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBtZiA9IHR5cGVkLmZpbmQobXVsdGlwbHlTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gcmVzdWx0IChkbyBub3QgaW5pdGlhbGl6ZSBpdCB3aXRoIHplcm8pXG4gICAgdmFyIGMgPSBtZihhZGF0YVswXSwgYmRhdGFbMF0pO1xuICAgIC8vIGxvb3AgZGF0YVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAvLyBtdWx0aXBseSBhbmQgYWNjdW11bGF0ZVxuICAgICAgYyA9IGFmKGMsIG1mKGFkYXRhW2ldLCBiZGF0YVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgRGVuc2UgVmVjdG9yICAgKE0pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgTWF0cml4ICAgICAgICAgKE14TilcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICBEZW5zZSBWZWN0b3IgICAoTilcbiAgICovXG4gIHZhciBfbXVsdGlwbHlWZWN0b3JNYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIHByb2Nlc3Mgc3RvcmFnZVxuICAgIHN3aXRjaCAoYi5zdG9yYWdlKCkpIHtcbiAgICAgIGNhc2UgJ2RlbnNlJzpcbiAgICAgICAgcmV0dXJuIF9tdWx0aXBseVZlY3RvckRlbnNlTWF0cml4KGEsIGIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBEZW5zZSBWZWN0b3IgICAoTSlcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBEZW5zZSBNYXRyaXggICAoTXhOKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIERlbnNlIFZlY3RvciAgIChOKVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseVZlY3RvckRlbnNlTWF0cml4ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBhIGRlbnNlXG4gICAgdmFyIGFkYXRhID0gYS5fZGF0YTtcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBiIGRlbnNlXG4gICAgdmFyIGJkYXRhID0gYi5fZGF0YTtcbiAgICB2YXIgYnNpemUgPSBiLl9zaXplO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBhbGVuZ3RoID0gYXNpemVbMF07XG4gICAgdmFyIGJjb2x1bW5zID0gYnNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBhZGRTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBhZiA9IGFkZFNjYWxhcjtcbiAgICAvLyBtdWx0aXBseVNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIG1mID0gbXVsdGlwbHlTY2FsYXI7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAoYWR0ICYmIGJkdCAmJiBhZHQgPT09IGJkdCAmJiB0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmVzIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgYWYgPSB0eXBlZC5maW5kKGFkZFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgbWYgPSB0eXBlZC5maW5kKG11bHRpcGx5U2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gcmVzdWx0XG4gICAgdmFyIGMgPSBbXTtcblxuICAgIC8vIGxvb3AgbWF0cml4IGNvbHVtbnNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIHN1bSAoZG8gbm90IGluaXRpYWxpemUgaXQgd2l0aCB6ZXJvKVxuICAgICAgdmFyIHN1bSA9IG1mKGFkYXRhWzBdLCBiZGF0YVswXVtqXSk7ICAgICAgXG4gICAgICAvLyBsb29wIHZlY3RvclxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gbXVsdGlwbHkgJiBhY2N1bXVsYXRlXG4gICAgICAgIHN1bSA9IGFmKHN1bSwgbWYoYWRhdGFbaV0sIGJkYXRhW2ldW2pdKSk7XG4gICAgICB9XG4gICAgICBjW2pdID0gc3VtO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBtYXRyaXhcbiAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGMsXG4gICAgICBzaXplOiBbYmNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIE1hdHJpeCAgICAgICAgIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgRGVuc2UgVmVjdG9yICAgKE4pXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgRGVuc2UgVmVjdG9yICAgKE0pXG4gICAqL1xuICB2YXIgX211bHRpcGx5TWF0cml4VmVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBwcm9jZXNzIHN0b3JhZ2VcbiAgICBzd2l0Y2ggKGEuc3RvcmFnZSgpKSB7XG4gICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgIHJldHVybiBfbXVsdGlwbHlEZW5zZU1hdHJpeFZlY3RvcihhLCBiKTtcbiAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgIHJldHVybiBfbXVsdGlwbHlTcGFyc2VNYXRyaXhWZWN0b3IoYSwgYik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBNYXRyaXggICAgICAgICAoTXhOKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gYiAgICAgICAgICAgIE1hdHJpeCAgICAgICAgIChOeEMpXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgTWF0cml4ICAgICAgICAgKE14QylcbiAgICovXG4gIHZhciBfbXVsdGlwbHlNYXRyaXhNYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIHByb2Nlc3Mgc3RvcmFnZVxuICAgIHN3aXRjaCAoYS5zdG9yYWdlKCkpIHtcbiAgICAgIGNhc2UgJ2RlbnNlJzpcbiAgICAgICAgLy8gcHJvY2VzcyBzdG9yYWdlXG4gICAgICAgIHN3aXRjaCAoYi5zdG9yYWdlKCkpIHtcbiAgICAgICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgICAgICByZXR1cm4gX211bHRpcGx5RGVuc2VNYXRyaXhEZW5zZU1hdHJpeChhLCBiKTtcbiAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgcmV0dXJuIF9tdWx0aXBseURlbnNlTWF0cml4U3BhcnNlTWF0cml4KGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgLy8gcHJvY2VzcyBzdG9yYWdlXG4gICAgICAgIHN3aXRjaCAoYi5zdG9yYWdlKCkpIHtcbiAgICAgICAgICBjYXNlICdkZW5zZSc6XG4gICAgICAgICAgICByZXR1cm4gX211bHRpcGx5U3BhcnNlTWF0cml4RGVuc2VNYXRyaXgoYSwgYik7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIHJldHVybiBfbXVsdGlwbHlTcGFyc2VNYXRyaXhTcGFyc2VNYXRyaXgoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBEZW5zZU1hdHJpeCAgKE14TilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBEZW5zZSBWZWN0b3IgKE4pXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgRGVuc2UgVmVjdG9yIChNKSBcbiAgICovIFxuICB2YXIgX211bHRpcGx5RGVuc2VNYXRyaXhWZWN0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGEgZGVuc2VcbiAgICB2YXIgYWRhdGEgPSBhLl9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIGIgZGVuc2VcbiAgICB2YXIgYmRhdGEgPSBiLl9kYXRhO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBhcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBhY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gYWRkU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgYWYgPSBhZGRTY2FsYXI7XG4gICAgLy8gbXVsdGlwbHlTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBtZiA9IG11bHRpcGx5U2NhbGFyO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKGFkdCAmJiBiZHQgJiYgYWR0ID09PSBiZHQgJiYgdHlwZW9mIGFkdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlcyB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGFmID0gdHlwZWQuZmluZChhZGRTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIG1mID0gdHlwZWQuZmluZChtdWx0aXBseVNjYWxhciwgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjID0gW107XG5cbiAgICAvLyBsb29wIG1hdHJpeCBhIHJvd3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyb3dzOyBpKyspIHtcbiAgICAgIC8vIGN1cnJlbnQgcm93XG4gICAgICB2YXIgcm93ID0gYWRhdGFbaV07XG4gICAgICAvLyBzdW0gKGRvIG5vdCBpbml0aWFsaXplIGl0IHdpdGggemVybylcbiAgICAgIHZhciBzdW0gPSBtZihyb3dbMF0sIGJkYXRhWzBdKTtcbiAgICAgIC8vIGxvb3AgbWF0cml4IGEgY29sdW1uc1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhY29sdW1uczsgaisrKSB7XG4gICAgICAgIC8vIG11bHRpcGx5ICYgYWNjdW11bGF0ZVxuICAgICAgICBzdW0gPSBhZihzdW0sIG1mKHJvd1tqXSwgYmRhdGFbal0pKTtcbiAgICAgIH1cbiAgICAgIGNbaV0gPSBzdW07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIG1hdHJpeFxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogYyxcbiAgICAgIHNpemU6IFthcm93c10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgRGVuc2VNYXRyaXggICAgKE14TilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBEZW5zZU1hdHJpeCAgICAoTnhDKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIERlbnNlTWF0cml4ICAgIChNeEMpXG4gICAqL1xuICB2YXIgX211bHRpcGx5RGVuc2VNYXRyaXhEZW5zZU1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gYSBkZW5zZVxuICAgIHZhciBhZGF0YSA9IGEuX2RhdGE7XG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gYiBkZW5zZVxuICAgIHZhciBiZGF0YSA9IGIuX2RhdGE7XG4gICAgdmFyIGJzaXplID0gYi5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgYXJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgYWNvbHVtbnMgPSBhc2l6ZVsxXTtcbiAgICB2YXIgYmNvbHVtbnMgPSBic2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGFkZFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGFmID0gYWRkU2NhbGFyO1xuICAgIC8vIG11bHRpcGx5U2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgbWYgPSBtdWx0aXBseVNjYWxhcjtcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmIChhZHQgJiYgYmR0ICYmIGFkdCA9PT0gYmR0ICYmIHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZXMgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBhZiA9IHR5cGVkLmZpbmQoYWRkU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBtZiA9IHR5cGVkLmZpbmQobXVsdGlwbHlTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICB9XG4gICAgXG4gICAgLy8gcmVzdWx0XG4gICAgdmFyIGMgPSBbXTtcblxuICAgIC8vIGxvb3AgbWF0cml4IGEgcm93c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJvd3M7IGkrKykge1xuICAgICAgLy8gY3VycmVudCByb3dcbiAgICAgIHZhciByb3cgPSBhZGF0YVtpXTtcbiAgICAgIC8vIGluaXRpYWxpemUgcm93IGFycmF5XG4gICAgICBjW2ldID0gW107XG4gICAgICAvLyBsb29wIG1hdHJpeCBiIGNvbHVtbnNcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmNvbHVtbnM7IGorKykge1xuICAgICAgICAvLyBzdW0gKGF2b2lkIGluaXRpYWxpemluZyBzdW0gdG8gemVybylcbiAgICAgICAgdmFyIHN1bSA9IG1mKHJvd1swXSwgYmRhdGFbMF1bal0pO1xuICAgICAgICAvLyBsb29wIG1hdHJpeCBhIGNvbHVtbnNcbiAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCBhY29sdW1uczsgeCsrKSB7XG4gICAgICAgICAgLy8gbXVsdGlwbHkgJiBhY2N1bXVsYXRlXG4gICAgICAgICAgc3VtID0gYWYoc3VtLCBtZihyb3dbeF0sIGJkYXRhW3hdW2pdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY1tpXVtqXSA9IHN1bTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjLFxuICAgICAgc2l6ZTogW2Fyb3dzLCBiY29sdW1uc10sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgRGVuc2VNYXRyaXggICAgKE14TilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBTcGFyc2VNYXRyaXggICAoTnhDKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAgIChNeEMpXG4gICAqL1xuICB2YXIgX211bHRpcGx5RGVuc2VNYXRyaXhTcGFyc2VNYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGEgZGVuc2VcbiAgICB2YXIgYWRhdGEgPSBhLl9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIGIgc3BhcnNlXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IGIuX2luZGV4O1xuICAgIHZhciBicHRyID0gYi5fcHRyO1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuICAgIC8vIHZhbGlkYXRlIGIgbWF0cml4XG4gICAgaWYgKCFidmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbXVsdGlwbHkgRGVuc2UgTWF0cml4IHRpbWVzIFBhdHRlcm4gb25seSBNYXRyaXgnKTtcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBhcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBiY29sdW1ucyA9IGJzaXplWzFdO1xuICAgIFxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGFkZFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGFmID0gYWRkU2NhbGFyO1xuICAgIC8vIG11bHRpcGx5U2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgbWYgPSBtdWx0aXBseVNjYWxhcjtcbiAgICAvLyBlcXVhbFNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmIChhZHQgJiYgYmR0ICYmIGFkdCA9PT0gYmR0ICYmIHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZXMgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBhZiA9IHR5cGVkLmZpbmQoYWRkU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBtZiA9IHR5cGVkLmZpbmQobXVsdGlwbHlTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgfVxuXG4gICAgLy8gcmVzdWx0XG4gICAgdmFyIGN2YWx1ZXMgPSBbXTtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyBjIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXMgOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFthcm93cywgYmNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyBsb29wIGIgY29sdW1uc1xuICAgIGZvciAodmFyIGpiID0gMDsgamIgPCBiY29sdW1uczsgamIrKykge1xuICAgICAgLy8gdXBkYXRlIHB0clxuICAgICAgY3B0cltqYl0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gaW5kZWNlcyBpbiBjb2x1bW4gamJcbiAgICAgIHZhciBrYjAgPSBicHRyW2piXTtcbiAgICAgIHZhciBrYjEgPSBicHRyW2piICsgMV07XG4gICAgICAvLyBkbyBub3QgcHJvY2VzcyBjb2x1bW4gamIgaWYgbm8gZGF0YSBleGlzdHNcbiAgICAgIGlmIChrYjEgPiBrYjApIHtcbiAgICAgICAgLy8gbGFzdCByb3cgbWFyayBwcm9jZXNzZWRcbiAgICAgICAgdmFyIGxhc3QgPSAwO1xuICAgICAgICAvLyBsb29wIGEgcm93c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyb3dzOyBpKyspIHtcbiAgICAgICAgICAvLyBjb2x1bW4gbWFya1xuICAgICAgICAgIHZhciBtYXJrID0gaSArIDE7XG4gICAgICAgICAgLy8gQ1tpLCBqYl1cbiAgICAgICAgICB2YXIgY2lqO1xuICAgICAgICAgIC8vIHZhbHVlcyBpbiBiIGNvbHVtbiBqXG4gICAgICAgICAgZm9yICh2YXIga2IgPSBrYjA7IGtiIDwga2IxOyBrYisrKSB7XG4gICAgICAgICAgICAvLyByb3dcbiAgICAgICAgICAgIHZhciBpYiA9IGJpbmRleFtrYl07XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZSBoYXMgYmVlbiBpbml0aWFsaXplZFxuICAgICAgICAgICAgaWYgKGxhc3QgIT09IG1hcmspIHtcbiAgICAgICAgICAgICAgLy8gZmlyc3QgdmFsdWUgaW4gY29sdW1uIGpiXG4gICAgICAgICAgICAgIGNpaiA9IG1mKGFkYXRhW2ldW2liXSwgYnZhbHVlc1trYl0pO1xuICAgICAgICAgICAgICAvLyB1cGRhdGUgbWFya1xuICAgICAgICAgICAgICBsYXN0ID0gbWFyaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHZhbHVlXG4gICAgICAgICAgICAgIGNpaiA9IGFmKGNpaiwgbWYoYWRhdGFbaV1baWJdLCBidmFsdWVzW2tiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBjb2x1bW4gaGFzIGJlZW4gcHJvY2Vzc2VkIGFuZCB2YWx1ZSAhPSAwXG4gICAgICAgICAgaWYgKGxhc3QgPT09IG1hcmsgJiYgIWVxKGNpaiwgemVybykpIHtcbiAgICAgICAgICAgIC8vIHB1c2ggcm93ICYgdmFsdWVcbiAgICAgICAgICAgIGNpbmRleC5wdXNoKGkpO1xuICAgICAgICAgICAgY3ZhbHVlcy5wdXNoKGNpaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBwdHJcbiAgICBjcHRyW2Jjb2x1bW5zXSA9IGNpbmRleC5sZW5ndGg7XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDID0gQSAqIEJcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9IGEgICAgICAgICAgICBTcGFyc2VNYXRyaXggICAgKE14TilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBEZW5zZSBWZWN0b3IgKE4pXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgU3BhcnNlTWF0cml4ICAgIChNLCAxKSBcbiAgICovXG4gIHZhciBfbXVsdGlwbHlTcGFyc2VNYXRyaXhWZWN0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGEgc3BhcnNlXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyB2YWxpZGF0ZSBhIG1hdHJpeFxuICAgIGlmICghYXZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11bHRpcGx5IFBhdHRlcm4gb25seSBNYXRyaXggdGltZXMgRGVuc2UgTWF0cml4Jyk7XG4gICAgLy8gYiBkZW5zZVxuICAgIHZhciBiZGF0YSA9IGIuX2RhdGE7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIGFyb3dzID0gYS5fc2l6ZVswXTtcbiAgICB2YXIgYnJvd3MgPSBiLl9zaXplWzBdO1xuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjdmFsdWVzID0gW107XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG4gICAgXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gYWRkU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgYWYgPSBhZGRTY2FsYXI7XG4gICAgLy8gbXVsdGlwbHlTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBtZiA9IG11bHRpcGx5U2NhbGFyO1xuICAgIC8vIGVxdWFsU2NhbGFyIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKGFkdCAmJiBiZHQgJiYgYWR0ID09PSBiZHQgJiYgdHlwZW9mIGFkdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlcyB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGFmID0gdHlwZWQuZmluZChhZGRTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIG1mID0gdHlwZWQuZmluZChtdWx0aXBseVNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICB9XG5cbiAgICAvLyB3b3Jrc3BhY2VcbiAgICB2YXIgeCA9IFtdO1xuICAgIC8vIHZlY3RvciB3aXRoIG1hcmtzIGluZGljYXRpbmcgYSB2YWx1ZSB4W2ldIGV4aXN0cyBpbiBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG5cbiAgICAvLyB1cGRhdGUgcHRyXG4gICAgY3B0clswXSA9IDA7XG4gICAgLy8gcm93cyBpbiBiXG4gICAgZm9yICh2YXIgaWIgPSAwOyBpYiA8IGJyb3dzOyBpYisrKSB7XG4gICAgICAvLyBiW2liXVxuICAgICAgdmFyIHZiaSA9IGJkYXRhW2liXTtcbiAgICAgIC8vIGNoZWNrIGJbaWJdICE9IDAsIGF2b2lkIGxvb3BzXG4gICAgICBpZiAoIWVxKHZiaSwgemVybykpIHtcbiAgICAgICAgLy8gQSB2YWx1ZXMgJiBpbmRleCBpbiBpYiBjb2x1bW5cbiAgICAgICAgZm9yICh2YXIga2EwID0gYXB0cltpYl0sIGthMSA9IGFwdHJbaWIgKyAxXSwga2EgPSBrYTA7IGthIDwga2ExOyBrYSsrKSB7XG4gICAgICAgICAgLy8gYSByb3dcbiAgICAgICAgICB2YXIgaWEgPSBhaW5kZXhba2FdO1xuICAgICAgICAgIC8vIGNoZWNrIHZhbHVlIGV4aXN0cyBpbiBjdXJyZW50IGpcbiAgICAgICAgICBpZiAoIXdbaWFdKSB7XG4gICAgICAgICAgICAvLyBpYSBpcyBuZXcgZW50cnkgaW4galxuICAgICAgICAgICAgd1tpYV0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gYWRkIGkgdG8gcGF0dGVybiBvZiBDXG4gICAgICAgICAgICBjaW5kZXgucHVzaChpYSk7XG4gICAgICAgICAgICAvLyB4KGlhKSA9IEFcbiAgICAgICAgICAgIHhbaWFdID0gbWYodmJpLCBhdmFsdWVzW2thXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaSBleGlzdHMgaW4gQyBhbHJlYWR5XG4gICAgICAgICAgICB4W2lhXSA9IGFmKHhbaWFdLCBtZih2YmksIGF2YWx1ZXNba2FdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvcHkgdmFsdWVzIGZyb20geCB0byBjb2x1bW4gamIgb2YgY1xuICAgIGZvciAodmFyIHAxID0gY2luZGV4Lmxlbmd0aCwgcCA9IDA7IHAgPCBwMTsgcCsrKSB7XG4gICAgICAvLyByb3dcbiAgICAgIHZhciBpYyA9IGNpbmRleFtwXTtcbiAgICAgIC8vIGNvcHkgdmFsdWVcbiAgICAgIGN2YWx1ZXNbcF0gPSB4W2ljXTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIHB0clxuICAgIGNwdHJbMV0gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXMgOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFthcm93cywgMV0sXG4gICAgICBkYXRhdHlwZTogZHRcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQyA9IEEgKiBCXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSBhICAgICAgICAgICAgU3BhcnNlTWF0cml4ICAgICAgKE14TilcbiAgICogQHBhcmFtIHtNYXRyaXh9IGIgICAgICAgICAgICBEZW5zZU1hdHJpeCAgICAgICAoTnhDKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAgICAgIChNeEMpXG4gICAqL1xuICB2YXIgX211bHRpcGx5U3BhcnNlTWF0cml4RGVuc2VNYXRyaXggPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGEgc3BhcnNlXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyB2YWxpZGF0ZSBhIG1hdHJpeFxuICAgIGlmICghYXZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11bHRpcGx5IFBhdHRlcm4gb25seSBNYXRyaXggdGltZXMgRGVuc2UgTWF0cml4Jyk7XG4gICAgLy8gYiBkZW5zZVxuICAgIHZhciBiZGF0YSA9IGIuX2RhdGE7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIGFyb3dzID0gYS5fc2l6ZVswXTtcbiAgICB2YXIgYnJvd3MgPSBiLl9zaXplWzBdO1xuICAgIHZhciBiY29sdW1ucyA9IGIuX3NpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBhZGRTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBhZiA9IGFkZFNjYWxhcjtcbiAgICAvLyBtdWx0aXBseVNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIG1mID0gbXVsdGlwbHlTY2FsYXI7XG4gICAgLy8gZXF1YWxTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAoYWR0ICYmIGJkdCAmJiBhZHQgPT09IGJkdCAmJiB0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmVzIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgYWYgPSB0eXBlZC5maW5kKGFkZFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgbWYgPSB0eXBlZC5maW5kKG11bHRpcGx5U2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjdmFsdWVzID0gW107XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG4gICAgLy8gYyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzIDogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbYXJvd3MsIGJjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gd29ya3NwYWNlXG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyB2ZWN0b3Igd2l0aCBtYXJrcyBpbmRpY2F0aW5nIGEgdmFsdWUgeFtpXSBleGlzdHMgaW4gYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuXG4gICAgLy8gbG9vcCBiIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqYiA9IDA7IGpiIDwgYmNvbHVtbnM7IGpiKyspIHtcbiAgICAgIC8vIHVwZGF0ZSBwdHJcbiAgICAgIGNwdHJbamJdID0gY2luZGV4Lmxlbmd0aDtcbiAgICAgIC8vIG1hcmsgaW4gd29ya3NwYWNlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAgdmFyIG1hcmsgPSBqYiArIDE7XG4gICAgICAvLyByb3dzIGluIGpiXG4gICAgICBmb3IgKHZhciBpYiA9IDA7IGliIDwgYnJvd3M7IGliKyspIHtcbiAgICAgICAgLy8gYltpYiwgamJdXG4gICAgICAgIHZhciB2YmlqID0gYmRhdGFbaWJdW2piXTtcbiAgICAgICAgLy8gY2hlY2sgYltpYiwgamJdICE9IDAsIGF2b2lkIGxvb3BzXG4gICAgICAgIGlmICghZXEodmJpaiwgemVybykpIHtcbiAgICAgICAgICAvLyBBIHZhbHVlcyAmIGluZGV4IGluIGliIGNvbHVtblxuICAgICAgICAgIGZvciAodmFyIGthMCA9IGFwdHJbaWJdLCBrYTEgPSBhcHRyW2liICsgMV0sIGthID0ga2EwOyBrYSA8IGthMTsga2ErKykge1xuICAgICAgICAgICAgLy8gYSByb3dcbiAgICAgICAgICAgIHZhciBpYSA9IGFpbmRleFtrYV07XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZSBleGlzdHMgaW4gY3VycmVudCBqXG4gICAgICAgICAgICBpZiAod1tpYV0gIT09IG1hcmspIHtcbiAgICAgICAgICAgICAgLy8gaWEgaXMgbmV3IGVudHJ5IGluIGpcbiAgICAgICAgICAgICAgd1tpYV0gPSBtYXJrO1xuICAgICAgICAgICAgICAvLyBhZGQgaSB0byBwYXR0ZXJuIG9mIENcbiAgICAgICAgICAgICAgY2luZGV4LnB1c2goaWEpO1xuICAgICAgICAgICAgICAvLyB4KGlhKSA9IEFcbiAgICAgICAgICAgICAgeFtpYV0gPSBtZih2YmlqLCBhdmFsdWVzW2thXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaSBleGlzdHMgaW4gQyBhbHJlYWR5XG4gICAgICAgICAgICAgIHhbaWFdID0gYWYoeFtpYV0sIG1mKHZiaWosIGF2YWx1ZXNba2FdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb3B5IHZhbHVlcyBmcm9tIHggdG8gY29sdW1uIGpiIG9mIGNcbiAgICAgIGZvciAodmFyIHAwID0gY3B0cltqYl0sIHAxID0gY2luZGV4Lmxlbmd0aCwgcCA9IHAwOyBwIDwgcDE7IHArKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIGljID0gY2luZGV4W3BdO1xuICAgICAgICAvLyBjb3B5IHZhbHVlXG4gICAgICAgIGN2YWx1ZXNbcF0gPSB4W2ljXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIHB0clxuICAgIGNwdHJbYmNvbHVtbnNdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEMgPSBBICogQlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gYSAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAgICAgIChNeE4pXG4gICAqIEBwYXJhbSB7TWF0cml4fSBiICAgICAgICAgICAgU3BhcnNlTWF0cml4ICAgICAgKE54QylcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICBTcGFyc2VNYXRyaXggICAgICAoTXhDKVxuICAgKi9cbiAgdmFyIF9tdWx0aXBseVNwYXJzZU1hdHJpeFNwYXJzZU1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gYSBzcGFyc2VcbiAgICB2YXIgYXZhbHVlcyA9IGEuX3ZhbHVlcztcbiAgICB2YXIgYWluZGV4ID0gYS5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBhLl9wdHI7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIGIgc3BhcnNlXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IGIuX2luZGV4O1xuICAgIHZhciBicHRyID0gYi5fcHRyO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcbiAgICBcbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBhcm93cyA9IGEuX3NpemVbMF07XG4gICAgdmFyIGJjb2x1bW5zID0gYi5fc2l6ZVsxXTtcbiAgICAvLyBmbGFnIGluZGljYXRpbmcgYm90aCBtYXRyaWNlcyAoYSAmIGIpIGNvbnRhaW4gZGF0YVxuICAgIHZhciB2YWx1ZXMgPSBhdmFsdWVzICYmIGJ2YWx1ZXM7XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBhZGRTY2FsYXIgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBhZiA9IGFkZFNjYWxhcjtcbiAgICAvLyBtdWx0aXBseVNjYWxhciBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIG1mID0gbXVsdGlwbHlTY2FsYXI7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAoYWR0ICYmIGJkdCAmJiBhZHQgPT09IGJkdCAmJiB0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmVzIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgYWYgPSB0eXBlZC5maW5kKGFkZFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgbWYgPSB0eXBlZC5maW5kKG11bHRpcGx5U2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgfVxuICAgIFxuICAgIC8vIHJlc3VsdFxuICAgIHZhciBjdmFsdWVzID0gdmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGNpbmRleCA9IFtdO1xuICAgIHZhciBjcHRyID0gW107XG4gICAgLy8gYyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzIDogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbYXJvd3MsIGJjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gd29ya3NwYWNlXG4gICAgdmFyIHggPSB2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAvLyB2ZWN0b3Igd2l0aCBtYXJrcyBpbmRpY2F0aW5nIGEgdmFsdWUgeFtpXSBleGlzdHMgaW4gYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuICAgIC8vIHZhcmlhYmxlc1xuICAgIHZhciBrYSwga2EwLCBrYTEsIGtiLCBrYjAsIGtiMSwgaWEsIGliO1xuICAgIC8vIGxvb3AgYiBjb2x1bW5zXG4gICAgZm9yICh2YXIgamIgPSAwOyBqYiA8IGJjb2x1bW5zOyBqYisrKSB7XG4gICAgICAvLyB1cGRhdGUgcHRyXG4gICAgICBjcHRyW2piXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBtYXJrIGluIHdvcmtzcGFjZSBmb3IgY3VycmVudCBjb2x1bW5cbiAgICAgIHZhciBtYXJrID0gamIgKyAxO1xuICAgICAgLy8gQiB2YWx1ZXMgJiBpbmRleCBpbiBqXG4gICAgICBmb3IgKGtiMCA9IGJwdHJbamJdLCBrYjEgPSBicHRyW2piICsgMV0sIGtiID0ga2IwOyBrYiA8IGtiMTsga2IrKykge1xuICAgICAgICAvLyBiIHJvd1xuICAgICAgICBpYiA9IGJpbmRleFtrYl07XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXNcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIC8vIGxvb3AgdmFsdWVzIGluIGFbOixpYl1cbiAgICAgICAgICBmb3IgKGthMCA9IGFwdHJbaWJdLCBrYTEgPSBhcHRyW2liICsgMV0sIGthID0ga2EwOyBrYSA8IGthMTsga2ErKykge1xuICAgICAgICAgICAgLy8gcm93XG4gICAgICAgICAgICBpYSA9IGFpbmRleFtrYV07XG4gICAgICAgICAgICAvLyBjaGVjayB2YWx1ZSBleGlzdHMgaW4gY3VycmVudCBqXG4gICAgICAgICAgICBpZiAod1tpYV0gIT09IG1hcmspIHtcbiAgICAgICAgICAgICAgLy8gaWEgaXMgbmV3IGVudHJ5IGluIGpcbiAgICAgICAgICAgICAgd1tpYV0gPSBtYXJrO1xuICAgICAgICAgICAgICAvLyBhZGQgaSB0byBwYXR0ZXJuIG9mIENcbiAgICAgICAgICAgICAgY2luZGV4LnB1c2goaWEpO1xuICAgICAgICAgICAgICAvLyB4KGlhKSA9IEFcbiAgICAgICAgICAgICAgeFtpYV0gPSBtZihidmFsdWVzW2tiXSwgYXZhbHVlc1trYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGkgZXhpc3RzIGluIEMgYWxyZWFkeVxuICAgICAgICAgICAgICB4W2lhXSA9IGFmKHhbaWFdLCBtZihidmFsdWVzW2tiXSwgYXZhbHVlc1trYV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gbG9vcCB2YWx1ZXMgaW4gYVs6LGliXVxuICAgICAgICAgIGZvciAoa2EwID0gYXB0cltpYl0sIGthMSA9IGFwdHJbaWIgKyAxXSwga2EgPSBrYTA7IGthIDwga2ExOyBrYSsrKSB7XG4gICAgICAgICAgICAvLyByb3dcbiAgICAgICAgICAgIGlhID0gYWluZGV4W2thXTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHZhbHVlIGV4aXN0cyBpbiBjdXJyZW50IGpcbiAgICAgICAgICAgIGlmICh3W2lhXSAhPT0gbWFyaykge1xuICAgICAgICAgICAgICAvLyBpYSBpcyBuZXcgZW50cnkgaW4galxuICAgICAgICAgICAgICB3W2lhXSA9IG1hcms7XG4gICAgICAgICAgICAgIC8vIGFkZCBpIHRvIHBhdHRlcm4gb2YgQ1xuICAgICAgICAgICAgICBjaW5kZXgucHVzaChpYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgbWF0cml4IHZhbHVlcyAocGF0dGVybiBtYXRyaXgpXG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGZyb20geCB0byBjb2x1bW4gamIgb2YgY1xuICAgICAgICBmb3IgKHZhciBwMCA9IGNwdHJbamJdLCBwMSA9IGNpbmRleC5sZW5ndGgsIHAgPSBwMDsgcCA8IHAxOyBwKyspIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICB2YXIgaWMgPSBjaW5kZXhbcF07XG4gICAgICAgICAgLy8gY29weSB2YWx1ZVxuICAgICAgICAgIGN2YWx1ZXNbcF0gPSB4W2ljXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgcHRyXG4gICAgY3B0cltiY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcblxuICBtdWx0aXBseS50b1RleCA9IHtcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ211bHRpcGx5J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIG11bHRpcGx5O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnbXVsdGlwbHknO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICAvKipcbiAgICogTXVsdGlwbHkgdHdvIHNjYWxhciB2YWx1ZXMsIGB4ICogeWAuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgZm9yIGludGVybmFsIHVzZTogaXQgaXMgdXNlZCBieSB0aGUgcHVibGljIGZ1bmN0aW9uXG4gICAqIGBtdWx0aXBseWBcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGNvbGxlY3Rpb25zIChBcnJheSBvciBNYXRyaXgpLCBhbmQgZG9lc1xuICAgKiBub3QgdmFsaWRhdGUgdGhlIG51bWJlciBvZiBvZiBpbnB1dHMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXR9IHggICBGaXJzdCB2YWx1ZSB0byBtdWx0aXBseVxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXh9IHkgICAgICAgICAgU2Vjb25kIHZhbHVlIHRvIG11bHRpcGx5XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXR9ICAgICAgICAgICAgICAgICAgICAgIE11bHRpcGxpY2F0aW9uIG9mIGB4YCBhbmQgYHlgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgbXVsdGlwbHlTY2FsYXIgPSB0eXBlZCgnbXVsdGlwbHlTY2FsYXInLCB7XG5cbiAgICAnbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggKiB5O1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCwgQ29tcGxleCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5tdWwoeSk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC50aW1lcyh5KTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5tdWwoeSk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBGcmFjdGlvbiB8IEJpZ051bWJlciB8IENvbXBsZXgsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdmFyIHJlcyA9IHkuY2xvbmUoKTtcbiAgICAgIHJlcy52YWx1ZSA9IChyZXMudmFsdWUgPT09IG51bGwpID8gcmVzLl9ub3JtYWxpemUoeCkgOiBtdWx0aXBseVNjYWxhcihyZXMudmFsdWUsIHgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgJ1VuaXQsIG51bWJlciB8IEZyYWN0aW9uIHwgQmlnTnVtYmVyIHwgQ29tcGxleCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB2YXIgcmVzID0geC5jbG9uZSgpO1xuICAgICAgcmVzLnZhbHVlID0gKHJlcy52YWx1ZSA9PT0gbnVsbCkgPyByZXMuX25vcm1hbGl6ZSh5KSA6IG11bHRpcGx5U2NhbGFyKHJlcy52YWx1ZSwgeSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAnVW5pdCwgVW5pdCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5tdWx0aXBseSh5KTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgcmV0dXJuIG11bHRpcGx5U2NhbGFyO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICB2YXIgYWJzICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWJzJykpO1xuICB2YXIgYWRkICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvYWRkJykpO1xuICB2YXIgcG93ICAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvcG93JykpO1xuICB2YXIgc3FydCAgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvc3FydCcpKTtcbiAgdmFyIG11bHRpcGx5ICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG4gIHZhciBsYXJnZXIgICAgICA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9sYXJnZXInKSk7XG4gIHZhciBzbWFsbGVyICAgICA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9zbWFsbGVyJykpO1xuICB2YXIgbWF0cml4ICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIHRyYWNlICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvdHJhY2UnKSk7XG4gIHZhciB0cmFuc3Bvc2UgICA9IGxvYWQocmVxdWlyZSgnLi4vbWF0cml4L3RyYW5zcG9zZScpKTtcblxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG5vcm0gb2YgYSBudW1iZXIsIHZlY3RvciBvciBtYXRyaXguXG4gICAqXG4gICAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyIHAgaXMgb3B0aW9uYWwuIElmIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gMi5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLm5vcm0oeClcbiAgICogICAgbWF0aC5ub3JtKHgsIHApXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFicygtMy41KTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAzLjVcbiAgICogICAgbWF0aC5ub3JtKC0zLjUpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMy41XG4gICAqXG4gICAqICAgIG1hdGgubm9ybShtYXRoLmNvbXBsZXgoMywgLTQpKTsgICAgICAgICAvLyByZXR1cm5zIDVcbiAgICpcbiAgICogICAgbWF0aC5ub3JtKFsxLCAyLCAtM10sIEluZmluaXR5KTsgICAgICAgIC8vIHJldHVybnMgM1xuICAgKiAgICBtYXRoLm5vcm0oWzEsIDIsIC0zXSwgLUluZmluaXR5KTsgICAgICAgLy8gcmV0dXJucyAxXG4gICAqXG4gICAqICAgIG1hdGgubm9ybShbMywgNF0sIDIpOyAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDVcbiAgICpcbiAgICogICAgbWF0aC5ub3JtKFtbMSwgMl0sIFszLCA0XV0sIDEpICAgICAgICAgIC8vIHJldHVybnMgNlxuICAgKiAgICBtYXRoLm5vcm0oW1sxLCAyXSwgWzMsIDRdXSwgJ2luZicpOyAgICAgLy8gcmV0dXJucyA3XG4gICAqICAgIG1hdGgubm9ybShbWzEsIDJdLCBbMywgNF1dLCAnZnJvJyk7ICAgICAvLyByZXR1cm5zIDUuNDc3MjI1NTc1MDUxNjYxXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBhYnMsIGh5cG90XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geFxuICAgKiAgICAgICAgICAgIFZhbHVlIGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIG5vcm1cbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgc3RyaW5nfSBbcD0yXVxuICAgKiAgICAgICAgICAgIFZlY3RvciBzcGFjZS5cbiAgICogICAgICAgICAgICBTdXBwb3J0ZWQgbnVtYmVycyBpbmNsdWRlIEluZmluaXR5IGFuZCAtSW5maW5pdHkuXG4gICAqICAgICAgICAgICAgU3VwcG9ydGVkIHN0cmluZ3MgYXJlOiAnaW5mJywgJy1pbmYnLCBhbmQgJ2ZybycgKFRoZSBGcm9iZW5pdXMgbm9ybSlcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyfSB0aGUgcC1ub3JtXG4gICAqL1xuICB2YXIgbm9ybSA9IHR5cGVkKCdub3JtJywge1xuICAgICdudW1iZXInOiBNYXRoLmFicyxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIG5vcm0oeCkgPSBhYnMoeClcbiAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH0sXG4gICAgXG4gICAgJ2Jvb2xlYW4gfCBudWxsJyA6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBub3JtKHgpID0gYWJzKHgpXG4gICAgICByZXR1cm4gTWF0aC5hYnMoeCk7XG4gICAgfSxcblxuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gX25vcm0obWF0cml4KHgpLCAyKTtcbiAgICB9LFxuICAgIFxuICAgICdNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9ub3JtKHgsIDIpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQ29tcGxleCB8IEJpZ051bWJlciB8IGJvb2xlYW4gfCBudWxsLCBudW1iZXIgfCBCaWdOdW1iZXIgfCBzdHJpbmcnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gaWdub3JlIHNlY29uZCBwYXJhbWV0ZXIsIFRPRE86IHJlbW92ZSB0aGUgb3B0aW9uIG9mIHNlY29uZCBwYXJhbWV0ZXIgZm9yIHRoZXNlIHR5cGVzXG4gICAgICByZXR1cm4gbm9ybSh4KTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXIgfCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgcCkge1xuICAgICAgcmV0dXJuIF9ub3JtKG1hdHJpeCh4KSwgcCk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXIgfCBzdHJpbmcnOiBmdW5jdGlvbiAoeCwgcCkge1xuICAgICAgcmV0dXJuIF9ub3JtKHgsIHApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbm9ybSBmb3IgYW4gYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0geFxuICAgKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gcFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBub3JtXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfbm9ybSAoeCwgcCkge1xuICAgIC8vIHNpemVcbiAgICB2YXIgc2l6ZVggPSB4LnNpemUoKTtcbiAgICBcbiAgICAvLyBjaGVjayBpZiBpdCBpcyBhIHZlY3RvclxuICAgIGlmIChzaXplWC5sZW5ndGggPT0gMSkge1xuICAgICAgLy8gY2hlY2sgcFxuICAgICAgaWYgKHAgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCBwID09PSAnaW5mJykge1xuICAgICAgICAvLyBub3JtKHgsIEluZmluaXR5KSA9IG1heChhYnMoeCkpXG4gICAgICAgIHZhciBwaW5mID0gMDtcbiAgICAgICAgLy8gc2tpcCB6ZXJvcyBzaW5jZSBhYnMoMCkgPT0gMFxuICAgICAgICB4LmZvckVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFicyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobGFyZ2VyKHYsIHBpbmYpKVxuICAgICAgICAgICAgICBwaW5mID0gdjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUpO1xuICAgICAgICByZXR1cm4gcGluZjtcbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgfHwgcCA9PT0gJy1pbmYnKSB7XG4gICAgICAgIC8vIG5vcm0oeCwgLUluZmluaXR5KSA9IG1pbihhYnMoeCkpXG4gICAgICAgIHZhciBuaW5mO1xuICAgICAgICAvLyBza2lwIHplcm9zIHNpbmNlIGFicygwKSA9PSAwXG4gICAgICAgIHguZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2ID0gYWJzKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghbmluZiB8fCBzbWFsbGVyKHYsIG5pbmYpKVxuICAgICAgICAgICAgICBuaW5mID0gdjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUpO1xuICAgICAgICByZXR1cm4gbmluZiB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHAgPT09ICdmcm8nKSB7XG4gICAgICAgIHJldHVybiBfbm9ybSh4LCAyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHApKSB7XG4gICAgICAgIC8vIGNoZWNrIHAgIT0gMFxuICAgICAgICBpZiAoIWVxdWFsU2NhbGFyKHAsIDApKSB7XG4gICAgICAgICAgLy8gbm9ybSh4LCBwKSA9IHN1bShhYnMoeGkpIF4gcCkgXiAxL3BcbiAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgLy8gc2tpcCB6ZXJvcyBzaW5jZSBhYnMoMCkgPT0gMFxuICAgICAgICAgIHguZm9yRWFjaChcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBuID0gYWRkKHBvdyhhYnModmFsdWUpLCBwKSwgbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHBvdyhuLCAxIC8gcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH1cbiAgICAgIC8vIGludmFsaWQgcGFyYW1ldGVyIHZhbHVlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICAvLyBNeE4gbWF0cml4XG4gICAgaWYgKHNpemVYLmxlbmd0aCA9PSAyKSB7XG4gICAgICAvLyBjaGVjayBwXG4gICAgICBpZiAocCA9PT0gMSkge1xuICAgICAgICAvLyBub3JtKHgpID0gdGhlIGxhcmdlc3QgY29sdW1uIHN1bVxuICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICAvLyByZXN1bHRcbiAgICAgICAgdmFyIG1heGMgPSAwO1xuICAgICAgICAvLyBza2lwIHplcm9zIHNpbmNlIGFicygwKSA9PSAwXG4gICAgICAgIHguZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaiA9IGluZGV4WzFdO1xuICAgICAgICAgICAgdmFyIGNqID0gYWRkKGNbal0gfHwgMCwgYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICBpZiAobGFyZ2VyKGNqLCBtYXhjKSlcbiAgICAgICAgICAgICAgbWF4YyA9IGNqO1xuICAgICAgICAgICAgY1tqXSA9IGNqO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBtYXhjO1xuICAgICAgfVxuICAgICAgaWYgKHAgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCBwID09PSAnaW5mJykge1xuICAgICAgICAvLyBub3JtKHgpID0gdGhlIGxhcmdlc3Qgcm93IHN1bVxuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAvLyByZXN1bHRcbiAgICAgICAgdmFyIG1heHIgPSAwO1xuICAgICAgICAvLyBza2lwIHplcm9zIHNpbmNlIGFicygwKSA9PSAwXG4gICAgICAgIHguZm9yRWFjaChcbiAgICAgICAgICBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaSA9IGluZGV4WzBdO1xuICAgICAgICAgICAgdmFyIHJpID0gYWRkKHJbaV0gfHwgMCwgYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICBpZiAobGFyZ2VyKHJpLCBtYXhyKSlcbiAgICAgICAgICAgICAgbWF4ciA9IHJpO1xuICAgICAgICAgICAgcltpXSA9IHJpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBtYXhyO1xuICAgICAgfVxuICAgICAgaWYgKHAgPT09ICdmcm8nKSB7XG4gICAgICAgIC8vIG5vcm0oeCkgPSBzcXJ0KHN1bShkaWFnKHgneCkpKVxuICAgICAgICByZXR1cm4gc3FydCh0cmFjZShtdWx0aXBseSh0cmFuc3Bvc2UoeCksIHgpKSk7XG4gICAgICB9XG4gICAgICBpZiAocCA9PT0gMikge1xuICAgICAgICAvLyBub3QgaW1wbGVtZW50ZWRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXIgdmFsdWUsIG1pc3NpbmcgaW1wbGVtZW50YXRpb24gb2YgbWF0cml4IHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24nKTtcbiAgICAgIH1cbiAgICAgIC8vIGludmFsaWQgcGFyYW1ldGVyIHZhbHVlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgfVxuXG4gIG5vcm0udG9UZXggPSB7XG4gICAgMTogJ1xcXFxsZWZ0XFxcXHwke2FyZ3NbMF19XFxcXHJpZ2h0XFxcXHwnLFxuICAgIDI6IHVuZGVmaW5lZCAgLy8gdXNlIGRlZmF1bHQgdGVtcGxhdGVcbiAgfTtcblxuICByZXR1cm4gbm9ybTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ25vcm0nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAxJykpO1xuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDYgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA2JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG50aCByb290IG9mIGEgdmFsdWUuXG4gICAqIFRoZSBwcmluY2lwYWwgbnRoIHJvb3Qgb2YgYSBwb3NpdGl2ZSByZWFsIG51bWJlciBBLCBpcyB0aGUgcG9zaXRpdmUgcmVhbFxuICAgKiBzb2x1dGlvbiBvZiB0aGUgZXF1YXRpb25cbiAgICpcbiAgICogICAgIHhecm9vdCA9IEFcbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5udGhSb290KGEpXG4gICAqICAgICBtYXRoLm50aFJvb3QoYSwgcm9vdClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLm50aFJvb3QoOSwgMik7ICAgIC8vIHJldHVybnMgMywgYXMgM14yID09IDlcbiAgICogICAgIG1hdGguc3FydCg5KTsgICAgICAgICAgLy8gcmV0dXJucyAzLCBhcyAzXjIgPT0gOVxuICAgKiAgICAgbWF0aC5udGhSb290KDY0LCAzKTsgICAvLyByZXR1cm5zIDQsIGFzIDReMyA9PSA2NFxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIHNxcnQsIHBvd1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5IHwgTWF0cml4IHwgQ29tcGxleH0gYVxuICAgKiAgICAgICAgICAgICAgVmFsdWUgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgbnRoIHJvb3RcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IFtyb290PTJdICAgIFRoZSByb290LlxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdGhlIG50aCByb290IG9mIGBhYFxuICAgKi9cbiAgdmFyIG50aFJvb3QgPSB0eXBlZCgnbnRoUm9vdCcsIHtcbiAgICBcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBfbnRoUm9vdCh4LCAyKTtcbiAgICB9LFxuICAgICdudW1iZXIsIG51bWJlcic6IF9udGhSb290LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gX2JpZ050aFJvb3QoeCwgbmV3IHR5cGUuQmlnTnVtYmVyKDIpKTtcbiAgICB9LFxuICAgICdDb21wbGV4JyA6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBfbnRoQ29tcGxleFJvb3QoeCwgMik7XG4gICAgfSwgXG4gICAgJ0NvbXBsZXgsIG51bWJlcicgOiBfbnRoQ29tcGxleFJvb3QsXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogX2JpZ050aFJvb3QsXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG50aFJvb3QoeCwgMik7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNpdHkgbXVzdCBiZSBvbmUgKG5vIHplcm9zIGluIG1hdHJpeClcbiAgICAgICAgICAgICAgaWYgKHkuZGVuc2l0eSgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA2KHgsIHksIG50aFJvb3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIG5vbi16ZXJvJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMDIoeSwgeCwgbnRoUm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zaXR5IG11c3QgYmUgb25lIChubyB6ZXJvcyBpbiBtYXRyaXgpXG4gICAgICAgICAgICAgIGlmICh5LmRlbnNpdHkoKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAxKHgsIHksIG50aFJvb3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBleGNlcHRpb25cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBub24temVybycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgbnRoUm9vdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBudGhSb290KG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBudGhSb290KG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBudGhSb290KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTExKHgsIHksIG50aFJvb3QsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgbnRoUm9vdCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAvLyBkZW5zaXR5IG11c3QgYmUgb25lIChubyB6ZXJvcyBpbiBtYXRyaXgpXG4gICAgICAgICAgaWYgKHkuZGVuc2l0eSgpID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzcGFyc2UgLSBzY2FsYXJcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh5LCB4LCBudGhSb290LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBleGNlcHRpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIG5vbi16ZXJvJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBudGhSb290LCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbnRoUm9vdChtYXRyaXgoeCksIHkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIG50aFJvb3QoeCwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBudGhSb290LnRvVGV4ID0gezI6ICdcXFxcc3FydFske2FyZ3NbMV19XXske2FyZ3NbMF19fSd9O1xuXG4gIHJldHVybiBudGhSb290O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG50aCByb290IG9mIGEgZm9yIEJpZ051bWJlcnMsIHNvbHZlIHhecm9vdCA9PSBhXG4gICAqIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9OdGhfcm9vdCNKYXZhU2NyaXB0XG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSByb290XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnTnRoUm9vdChhLCByb290KSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IHR5cGUuQmlnTnVtYmVyLnByZWNpc2lvbjtcbiAgICB2YXIgQmlnID0gdHlwZS5CaWdOdW1iZXIuY2xvbmUoe3ByZWNpc2lvbjogcHJlY2lzaW9uICsgMn0pO1xuICAgIHZhciB6ZXJvID0gbmV3IHR5cGUuQmlnTnVtYmVyKDApO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCaWcoMSk7XG4gICAgdmFyIGludiA9IHJvb3QuaXNOZWdhdGl2ZSgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIHJvb3QgPSByb290Lm5lZygpO1xuICAgIH1cblxuICAgIGlmIChyb290LmlzWmVybygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBub24temVybycpO1xuICAgIH1cbiAgICBpZiAoYS5pc05lZ2F0aXZlKCkgJiYgIXJvb3QuYWJzKCkubW9kKDIpLmVxdWFscygxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IG11c3QgYmUgb2RkIHdoZW4gYSBpcyBuZWdhdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBlZGdlIGNhc2VzIHplcm8gYW5kIGluZmluaXR5XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBpbnYgPyBuZXcgQmlnKEluZmluaXR5KSA6IDA7XG4gICAgfVxuICAgIGlmICghYS5pc0Zpbml0ZSgpKSB7XG4gICAgICByZXR1cm4gaW52ID8gemVybyA6IGE7XG4gICAgfVxuXG4gICAgdmFyIHggPSBhLmFicygpLnBvdyhvbmUuZGl2KHJvb3QpKTtcbiAgICAvLyBJZiBhIDwgMCwgd2UgcmVxdWlyZSB0aGF0IHJvb3QgaXMgYW4gb2RkIGludGVnZXIsXG4gICAgLy8gc28gKC0xKSBeICgxL3Jvb3QpID0gLTFcbiAgICB4ID0gYS5pc05lZygpID8geC5uZWcoKSA6IHg7XG4gICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigoaW52ID8gb25lLmRpdih4KSA6IHgpLnRvUHJlY2lzaW9uKHByZWNpc2lvbikpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBudGggcm9vdCBvZiBhLCBzb2x2ZSB4XnJvb3QgPT0gYVxuICogaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL050aF9yb290I0phdmFTY3JpcHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcm9vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX250aFJvb3QoYSwgcm9vdCkge1xuICB2YXIgaW52ID0gcm9vdCA8IDA7XG4gIGlmIChpbnYpIHtcbiAgICByb290ID0gLXJvb3Q7XG4gIH1cblxuICBpZiAocm9vdCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIG5vbi16ZXJvJyk7XG4gIH1cbiAgaWYgKGEgPCAwICYmIChNYXRoLmFicyhyb290KSAlIDIgIT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBvZGQgd2hlbiBhIGlzIG5lZ2F0aXZlLicpO1xuICB9XG5cbiAgLy8gZWRnZSBjYXNlcyB6ZXJvIGFuZCBpbmZpbml0eVxuICBpZiAoYSA9PSAwKSB7XG4gICAgcmV0dXJuIGludiA/IEluZmluaXR5IDogMDtcbiAgfVxuICBpZiAoIWlzRmluaXRlKGEpKSB7XG4gICAgcmV0dXJuIGludiA/IDAgOiBhO1xuICB9XG5cbiAgdmFyIHggPSBNYXRoLnBvdyhNYXRoLmFicyhhKSwgMS9yb290KTtcbiAgLy8gSWYgYSA8IDAsIHdlIHJlcXVpcmUgdGhhdCByb290IGlzIGFuIG9kZCBpbnRlZ2VyLFxuICAvLyBzbyAoLTEpIF4gKDEvcm9vdCkgPSAtMVxuICB4ID0gYSA8IDAgPyAteCA6IHg7XG4gIHJldHVybiBpbnYgPyAxIC8geCA6IHg7XG5cbiAgLy8gVmVyeSBuaWNlIGFsZ29yaXRobSwgYnV0IGZhaWxzIHdpdGggbnRoUm9vdCgtMiwgMykuXG4gIC8vIE5ld3RvbidzIG1ldGhvZCBoYXMgc29tZSB3ZWxsLWtub3duIHByb2JsZW1zIGF0IHRpbWVzOlxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OZXd0b24lMjdzX21ldGhvZCNGYWlsdXJlX2FuYWx5c2lzXG4gIC8qXG4gIHZhciB4ID0gMTsgLy8gSW5pdGlhbCBndWVzc1xuICB2YXIgeFByZXYgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHZhciBpTWF4ID0gMTAwMDA7XG4gIGRvIHtcbiAgICB2YXIgZGVsdGEgPSAoYSAvIE1hdGgucG93KHgsIHJvb3QgLSAxKSAtIHgpIC8gcm9vdDtcbiAgICB4UHJldiA9IHg7XG4gICAgeCA9IHggKyBkZWx0YTtcbiAgICBpKys7XG4gIH1cbiAgd2hpbGUgKHhQcmV2ICE9PSB4ICYmIGkgPCBpTWF4KTtcblxuICBpZiAoeFByZXYgIT09IHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIG50aFJvb3QgZmFpbGVkIHRvIGNvbnZlcmdlJyk7XG4gIH1cblxuICByZXR1cm4gaW52ID8gMSAvIHggOiB4O1xuICAqL1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbnRoIHJvb3Qgb2YgYSBDb21wbGV4IE51bWJlciBhIHVzaW5nIERlIE1vdmllcnMgVGhlb3JlbS5cbiAqIEBwYXJhbSAge0NvbXBsZXh9IGFcbiAqIEBwYXJhbSAge251bWJlcn0gcm9vdFxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9yIG4gQ29tcGxleCBSb290cyBpbiBQb2xhciBGb3JtLlxuICovXG5mdW5jdGlvbiBfbnRoQ29tcGxleFJvb3QoYSwgcm9vdCkge1xuICBpZiAocm9vdCA8IDApIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gIGlmIChyb290ID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgbXVzdCBiZSBub24temVybycpO1xuICBpZiAocm9vdCAlIDEgIT09IDApIHRocm93IG5ldyBFcnJvcignUm9vdCBtdXN0IGJlIGFuIGludGVnZXInKTsgIFxuICB2YXIgYXJnID0gYS5hcmcoKTtcbiAgdmFyIGFicyA9IGEuYWJzKCk7XG4gIHZhciByb290cyA9IFtdO1xuICB2YXIgciA9IE1hdGgucG93KGFicywgMS9yb290KTtcbiAgZm9yKHZhciBrID0gMDsgayA8IHJvb3Q7IGsrKykge1xuICAgIHJvb3RzLnB1c2goe3I6IHIsIHBoaTogKGFyZyArIDIgKiBNYXRoLlBJICogaykvcm9vdH0pO1xuICB9XG4gIHJldHVybiByb290cztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ250aFJvb3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciBzaXplID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKS5zaXplO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG4gIHZhciBleWUgPSBsb2FkKHJlcXVpcmUoJy4uL21hdHJpeC9leWUnKSk7XG4gIHZhciBtdWx0aXBseSA9IGxvYWQocmVxdWlyZSgnLi9tdWx0aXBseScpKTtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZnJhY3Rpb24gPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvZnJhY3Rpb24vZnVuY3Rpb24vZnJhY3Rpb24nKSk7XG4gIHZhciBudW1iZXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbnVtYmVyJykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIGB4IF4geWAuXG4gICAqIE1hdHJpeCBleHBvbmVudGlhdGlvbiBpcyBzdXBwb3J0ZWQgZm9yIHNxdWFyZSBtYXRyaWNlcyBgeGAsIGFuZCBwb3NpdGl2ZVxuICAgKiBpbnRlZ2VyIGV4cG9uZW50cyBgeWAuXG4gICAqXG4gICAqIEZvciBjdWJpYyByb290cyBvZiBuZWdhdGl2ZSBudW1iZXJzLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcHJpbmNpcGFsXG4gICAqIHJvb3QgYnkgZGVmYXVsdC4gSW4gb3JkZXIgdG8gbGV0IHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHJlYWwgcm9vdCxcbiAgICogbWF0aC5qcyBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGBtYXRoLmNvbmZpZyh7cHJlZGljdGFibGU6IHRydWV9KWAuXG4gICAqIFRvIHJldHJpZXZlIGFsbCBjdWJpYyByb290cyBvZiBhIHZhbHVlLCB1c2UgYG1hdGguY2JydCh4LCB0cnVlKWAuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5wb3coeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgucG93KDIsIDMpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDhcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLmNvbXBsZXgoMiwgMyk7XG4gICAqICAgIG1hdGgucG93KGEsIDIpICAgICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAtNSArIDEyaVxuICAgKlxuICAgKiAgICB2YXIgYiA9IFtbMSwgMl0sIFs0LCAzXV07XG4gICAqICAgIG1hdGgucG93KGIsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgQXJyYXkgW1s5LCA4XSwgWzE2LCAxN11dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtdWx0aXBseSwgc3FydCwgY2JydCwgbnRoUm9vdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIFRoZSBiYXNlXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXh9IHkgICAgICAgICAgICAgICAgICAgVGhlIGV4cG9uZW50XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGhlIHZhbHVlIG9mIGB4YCB0byB0aGUgcG93ZXIgYHlgXG4gICAqL1xuICB2YXIgcG93ID0gdHlwZWQoJ3BvdycsIHtcbiAgICAnbnVtYmVyLCBudW1iZXInOiBfcG93LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgucG93KHkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHkuaXNJbnRlZ2VyKCkgfHwgeCA+PSAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeC50b051bWJlcigpLCAwKS5wb3coeS50b051bWJlcigpLCAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeS5kICE9PSAxKSB7XG4gICAgICAgIGlmIChjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHBvdyBkb2VzIG5vdCBzdXBwb3J0IG5vbi1pbnRlZ2VyIGV4cG9uZW50cyBmb3IgZnJhY3Rpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcG93KHgudmFsdWVPZigpLCB5LnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgIH1cbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXInOiBfcG93QXJyYXksXG5cbiAgICAnQXJyYXksIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gX3Bvd0FycmF5KHgsIHkudG9OdW1iZXIoKSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIG51bWJlcic6IF9wb3dNYXRyaXgsXG5cbiAgICAnTWF0cml4LCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIF9wb3dNYXRyaXgoeCwgeS50b051bWJlcigpKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5wb3coeSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBwb3dlciBvZiB4IHRvIHksIHheeSwgZm9yIHR3byBudW1iZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4fSByZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3coeCwgeSkge1xuXG4gICAgLy8gQWx0ZXJuYXRpdmVseSBjb3VsZCBkZWZpbmUgYSAncmVhbG1vZGUnIGNvbmZpZyBvcHRpb24gb3Igc29tZXRoaW5nLCBidXRcbiAgICAvLyAncHJlZGljdGFibGUnIHdpbGwgd29yayBmb3Igbm93XG4gICAgaWYgKGNvbmZpZy5wcmVkaWN0YWJsZSAmJiAhaXNJbnRlZ2VyKHkpICYmIHggPCAwKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgeSBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBmcmFjdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHlGcmFjID0gZnJhY3Rpb24oeSk7XG4gICAgICAgIHZhciB5TnVtID0gbnVtYmVyKHlGcmFjKTtcbiAgICAgICAgaWYoeSA9PT0geU51bSB8fCBNYXRoLmFicygoeSAtIHlOdW0pIC8geSkgPCAxZS0xNCkge1xuICAgICAgICAgIGlmKHlGcmFjLmQgJSAyID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlGcmFjLm4gJSAyID09PSAwID8gMSA6IC0xKSAqIE1hdGgucG93KC14LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAvLyBmcmFjdGlvbigpIHRocm93cyBhbiBlcnJvciBpZiB5IGlzIEluZmluaXR5LCBldGMuXG4gICAgICB9XG5cbiAgICAgIC8vIFVuYWJsZSB0byBleHByZXNzIHkgYXMgYSBmcmFjdGlvbiwgc28gY29udGludWUgb25cbiAgICB9XG5cbiAgICBpZiAoaXNJbnRlZ2VyKHkpIHx8IHggPj0gMCB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyh4LCB5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5wb3coeSwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG93ZXIgb2YgYSAyZCBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSB4ICAgICBtdXN0IGJlIGEgMiBkaW1lbnNpb25hbCwgc3F1YXJlIG1hdHJpeFxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgICBhIHBvc2l0aXZlLCBpbnRlZ2VyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3dBcnJheSh4LCB5KSB7XG4gICAgaWYgKCFpc0ludGVnZXIoeSkgfHwgeSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZvciBBXmIsIGIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgKHZhbHVlIGlzICcgKyB5ICsgJyknKTtcbiAgICB9XG4gICAgLy8gdmVyaWZ5IHRoYXQgQSBpcyBhIDIgZGltZW5zaW9uYWwgc3F1YXJlIG1hdHJpeFxuICAgIHZhciBzID0gc2l6ZSh4KTtcbiAgICBpZiAocy5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgQV5iLCBBIG11c3QgYmUgMiBkaW1lbnNpb25hbCAoQSBoYXMgJyArIHMubGVuZ3RoICsgJyBkaW1lbnNpb25zKScpO1xuICAgIH1cbiAgICBpZiAoc1swXSAhPSBzWzFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBBXmIsIEEgbXVzdCBiZSBzcXVhcmUgKHNpemUgaXMgJyArIHNbMF0gKyAneCcgKyBzWzFdICsgJyknKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gZXllKHNbMF0pLnZhbHVlT2YoKTtcbiAgICB2YXIgcHggPSB4O1xuICAgIHdoaWxlICh5ID49IDEpIHtcbiAgICAgIGlmICgoeSAmIDEpID09IDEpIHtcbiAgICAgICAgcmVzID0gbXVsdGlwbHkocHgsIHJlcyk7XG4gICAgICB9XG4gICAgICB5ID4+PSAxO1xuICAgICAgcHggPSBtdWx0aXBseShweCwgcHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgcG93ZXIgb2YgYSAyZCBtYXRyaXhcbiAgICogQHBhcmFtIHtNYXRyaXh9IHggICAgIG11c3QgYmUgYSAyIGRpbWVuc2lvbmFsLCBzcXVhcmUgbWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgIGEgcG9zaXRpdmUsIGludGVnZXIgdmFsdWVcbiAgICogQHJldHVybnMge01hdHJpeH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9wb3dNYXRyaXggKHgsIHkpIHtcbiAgICByZXR1cm4gbWF0cml4KF9wb3dBcnJheSh4LnZhbHVlT2YoKSwgeSkpO1xuICB9XG5cblxuXG4gIHBvdy50b1RleCA9IHtcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknICsgbGF0ZXgub3BlcmF0b3JzWydwb3cnXSArICd7JHthcmdzWzFdfX0nXG4gIH07XG5cbiAgcmV0dXJuIHBvdztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3Bvdyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNJbnRlZ2VyO1xudmFyIHRvRml4ZWQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS50b0ZpeGVkO1xudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxudmFyIE5PX0lOVCA9ICdOdW1iZXIgb2YgZGVjaW1hbHMgaW4gZnVuY3Rpb24gcm91bmQgbXVzdCBiZSBhbiBpbnRlZ2VyJztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcbiAgdmFyIHplcm9zID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvemVyb3MnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTExID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMScpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcbiAgXG4gIC8qKlxuICAgKiBSb3VuZCBhIHZhbHVlIHRvd2FyZHMgdGhlIG5lYXJlc3QgaW50ZWdlci5cbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnJvdW5kKHgpXG4gICAqICAgIG1hdGgucm91bmQoeCwgbilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgucm91bmQoMy4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDNcbiAgICogICAgbWF0aC5yb3VuZCgzLjgpOyAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgNFxuICAgKiAgICBtYXRoLnJvdW5kKC00LjIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNFxuICAgKiAgICBtYXRoLnJvdW5kKC00LjcpOyAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAtNVxuICAgKiAgICBtYXRoLnJvdW5kKG1hdGgucGksIDMpOyAgICAgICAvLyByZXR1cm5zIG51bWJlciAzLjE0MlxuICAgKiAgICBtYXRoLnJvdW5kKDEyMy40NTY3OCwgMik7ICAgICAvLyByZXR1cm5zIG51bWJlciAxMjMuNDZcbiAgICpcbiAgICogICAgdmFyIGMgPSBtYXRoLmNvbXBsZXgoMy4yLCAtMi43KTtcbiAgICogICAgbWF0aC5yb3VuZChjKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDMgLSAzaVxuICAgKlxuICAgKiAgICBtYXRoLnJvdW5kKFszLjIsIDMuOCwgLTQuN10pOyAvLyByZXR1cm5zIEFycmF5IFszLCA0LCAtNV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGNlaWwsIGZpeCwgZmxvb3JcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIE51bWJlciB0byBiZSByb3VuZGVkXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEFycmF5fSBbbj0wXSAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIgb2YgZGVjaW1hbHNcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFJvdW5kZWQgdmFsdWVcbiAgICovXG4gIHZhciByb3VuZCA9IHR5cGVkKCdyb3VuZCcsIHtcblxuICAgICdudW1iZXInOiBNYXRoLnJvdW5kLFxuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIG4pIHtcbiAgICAgIGlmICghaXNJbnRlZ2VyKG4pKSAgIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuICAgICAgaWYgKG4gPCAwIHx8IG4gPiAxNSkge3Rocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIGRlY2ltYWxzIGluIGZ1bmN0aW9uIHJvdW5kIG11c3QgYmUgaW4gdGUgcmFuZ2Ugb2YgMC0xNScpO31cblxuICAgICAgcmV0dXJuIF9yb3VuZCh4LCBuKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucm91bmQoKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIG51bWJlcic6IGZ1bmN0aW9uICh4LCBuKSB7XG4gICAgICBpZiAobiAlIDEpIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuICAgICAgXG4gICAgICByZXR1cm4geC5yb3VuZChuKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCBuKSB7XG4gICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkpIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuXG4gICAgICB2YXIgX24gPSBuLnRvTnVtYmVyKCk7XG4gICAgICByZXR1cm4geC5yb3VuZChfbik7XG4gICAgfSxcblxuICAgICdudW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCBuKSB7XG4gICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkpIHt0aHJvdyBuZXcgVHlwZUVycm9yKE5PX0lOVCk7fVxuXG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKHgpLnRvRGVjaW1hbFBsYWNlcyhuLnRvTnVtYmVyKCkpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRvRGVjaW1hbFBsYWNlcygwKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIG4pIHtcbiAgICAgIGlmICghbi5pc0ludGVnZXIoKSkge3Rocm93IG5ldyBUeXBlRXJyb3IoTk9fSU5UKTt9XG5cbiAgICAgIHJldHVybiB4LnRvRGVjaW1hbFBsYWNlcyhuLnRvTnVtYmVyKCkpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucm91bmQoKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBudW1iZXInOiBmdW5jdGlvbiAoeCwgbikge1xuICAgICAgaWYgKG4gJSAxKSB7dGhyb3cgbmV3IFR5cGVFcnJvcihOT19JTlQpO31cbiAgICAgIHJldHVybiB4LnJvdW5kKG4pO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSByb3VuZCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHJvdW5kLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh4LCB5LCByb3VuZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCByb3VuZCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBDb21wbGV4IHwgQmlnTnVtYmVyLCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gY2hlY2sgc2NhbGFyIGlzIHplcm9cbiAgICAgIGlmICghZXF1YWxTY2FsYXIoeCwgMCkpIHtcbiAgICAgICAgLy8gcmVzdWx0XG4gICAgICAgIHZhciBjO1xuICAgICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCByb3VuZCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIHJvdW5kLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgLy8gZG8gbm90IGV4ZWN1dGUgYWxnb3JpdGhtLCByZXN1bHQgd2lsbCBiZSBhIHplcm8gbWF0cml4XG4gICAgICByZXR1cm4gemVyb3MoeS5zaXplKCksIHkuc3RvcmFnZSgpKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgcm91bmQsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBDb21wbGV4IHwgQmlnTnVtYmVyLCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHkpLCB4LCByb3VuZCwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgcm91bmQudG9UZXggPSB7XG4gICAgMTogJ1xcXFxsZWZ0XFxcXGxmbG9vciR7YXJnc1swXX1cXFxccmlnaHRcXFxccmNlaWwnLFxuICAgIDI6IHVuZGVmaW5lZCAgLy8gdXNlIGRlZmF1bHQgdGVtcGxhdGVcbiAgfTtcblxuICByZXR1cm4gcm91bmQ7XG59XG5cbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gdGhlIGdpdmVuIG51bWJlciBvZiBkZWNpbWFscywgb3IgdG8gemVybyBpZiBkZWNpbWFscyBpc1xuICogbm90IHByb3ZpZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyAgICAgICBudW1iZXIgb2YgZGVjaW1hbHMsIGJldHdlZW4gMCBhbmQgMTUgKDAgYnkgZGVmYXVsdClcbiAqIEByZXR1cm4ge251bWJlcn0gcm91bmRlZFZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcm91bmQgKHZhbHVlLCBkZWNpbWFscykge1xuICByZXR1cm4gcGFyc2VGbG9hdCh0b0ZpeGVkKHZhbHVlLCBkZWNpbWFscykpO1xufVxuXG5leHBvcnRzLm5hbWUgPSAncm91bmQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpO1xudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgc2lnbiBvZiBhIHZhbHVlLiBUaGUgc2lnbiBvZiBhIHZhbHVlIHggaXM6XG4gICAqXG4gICAqIC0gIDEgd2hlbiB4ID4gMVxuICAgKiAtIC0xIHdoZW4geCA8IDBcbiAgICogLSAgMCB3aGVuIHggPT0gMFxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc2lnbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zaWduKDMuNSk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyAxXG4gICAqICAgIG1hdGguc2lnbigtNC4yKTsgICAgICAgICAgICAgIC8vIHJldHVybnMgLTFcbiAgICogICAgbWF0aC5zaWduKDApOyAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwXG4gICAqXG4gICAqICAgIG1hdGguc2lnbihbMywgNSwgLTIsIDAsIDJdKTsgIC8vIHJldHVybnMgWzEsIDEsIC0xLCAwLCAxXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWJzXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH0geFxuICAgKiAgICAgICAgICAgIFRoZSBudW1iZXIgZm9yIHdoaWNoIHRvIGRldGVybWluZSB0aGUgc2lnblxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IFVuaXR9ZVxuICAgKiAgICAgICAgICAgIFRoZSBzaWduIG9mIGB4YFxuICAgKi9cbiAgdmFyIHNpZ24gPSB0eXBlZCgnc2lnbicsIHtcbiAgICAnbnVtYmVyJzogbnVtYmVyLnNpZ24sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zaWduKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcih4LmNtcCgwKSk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oeC5zLCAxKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2Ugc2lnbigwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHNpZ24sIHRydWUpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBzaWduKHgudmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2lnbi50b1RleCA9IHsxOiAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XG5cbiAgcmV0dXJuIHNpZ247XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzaWduJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzcXVhcmUgcm9vdCBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3FydCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5zcXJ0KDI1KTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA1XG4gICAqICAgIG1hdGguc3F1YXJlKDUpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMjVcbiAgICogICAgbWF0aC5zcXJ0KC00KTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBDb21wbGV4IDJpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzcXVhcmUsIG11bHRpcGx5LCBjdWJlLCBjYnJ0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH0geFxuICAgKiAgICAgICAgICAgIFZhbHVlIGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIHNxdWFyZSByb290LlxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXggfCBVbml0fVxuICAgKiAgICAgICAgICAgIFJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIGB4YFxuICAgKi9cbiAgdmFyIHNxcnQgPSB0eXBlZCgnc3FydCcsIHtcbiAgICAnbnVtYmVyJzogX3NxcnROdW1iZXIsXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnNxcnQoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaXNOZWdhdGl2ZSgpIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4geC5zcXJ0KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgdmFsdWUgLT4gZG93bmdyYWRlIHRvIG51bWJlciB0byBkbyBjb21wbGV4IHZhbHVlIGNvbXB1dGF0aW9uXG4gICAgICAgIHJldHVybiBfc3FydE51bWJlcih4LnRvTnVtYmVyKCkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBzcXJ0KDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgc3FydCwgdHJ1ZSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIFNvbWVkYXkgd2lsbCB3b3JrIGZvciBjb21wbGV4IHVuaXRzIHdoZW4gdGhleSBhcmUgaW1wbGVtZW50ZWRcbiAgICAgIHJldHVybiB4LnBvdygwLjUpO1xuICAgIH1cblxuICB9KTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHNxcnQgZm9yIGEgbnVtYmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCBDb21wbGV4fSBSZXR1cm5zIHRoZSBzcXVhcmUgcm9vdCBvZiB4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc3FydE51bWJlcih4KSB7XG4gICAgaWYgKHggPj0gMCB8fCBjb25maWcucHJlZGljdGFibGUpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuc3FydCgpO1xuICAgIH1cbiAgfVxuXG4gIHNxcnQudG9UZXggPSB7MTogJ1xcXFxzcXJ0eyR7YXJnc1swXX19J307XG5cbiAgcmV0dXJuIHNxcnQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzcXJ0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIHNxdWFyZSBvZiBhIHZhbHVlLCBgeCAqIHhgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3F1YXJlKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLnNxdWFyZSgyKTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDRcbiAgICogICAgbWF0aC5zcXVhcmUoMyk7ICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciA5XG4gICAqICAgIG1hdGgucG93KDMsIDIpOyAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgOVxuICAgKiAgICBtYXRoLm11bHRpcGx5KDMsIDMpOyAgICAgIC8vIHJldHVybnMgbnVtYmVyIDlcbiAgICpcbiAgICogICAgbWF0aC5zcXVhcmUoWzEsIDIsIDMsIDRdKTsgIC8vIHJldHVybnMgQXJyYXkgWzEsIDQsIDksIDE2XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbXVsdGlwbHksIGN1YmUsIHNxcnQsIHBvd1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeCB8IFVuaXR9IHhcbiAgICogICAgICAgICAgICBOdW1iZXIgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc3F1YXJlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4IHwgVW5pdH1cbiAgICogICAgICAgICAgICBTcXVhcmVkIHZhbHVlXG4gICAqL1xuICB2YXIgc3F1YXJlID0gdHlwZWQoJ3NxdWFyZScsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4ICogeDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubXVsKHgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRpbWVzKHgpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubXVsKHgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBzcXVhcmUoMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzcXVhcmUsIHRydWUpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnBvdygyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNxdWFyZS50b1RleCA9IHsxOiAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCleMid9O1xuXG4gIHJldHVybiBzcXVhcmU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdzcXVhcmUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFkZFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi9hZGRTY2FsYXInKSk7XG4gIHZhciB1bmFyeU1pbnVzID0gbG9hZChyZXF1aXJlKCcuL3VuYXJ5TWludXMnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAxID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMScpKTtcbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA1ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNScpKTtcbiAgdmFyIGFsZ29yaXRobTEwID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMCcpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICAvLyBUT0RPOiBzcGxpdCBmdW5jdGlvbiBzdWJ0cmFjdCBpbiB0d286IHN1YnRyYWN0IGFuZCBzdWJ0cmFjdFNjYWxhclxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCB0d28gdmFsdWVzLCBgeCAtIHlgLlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguc3VidHJhY3QoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc3VidHJhY3QoNS4zLCAyKTsgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDMuM1xuICAgKlxuICAgKiAgICB2YXIgYSA9IG1hdGguY29tcGxleCgyLCAzKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLmNvbXBsZXgoNCwgMSk7XG4gICAqICAgIG1hdGguc3VidHJhY3QoYSwgYik7ICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAtMiArIDJpXG4gICAqXG4gICAqICAgIG1hdGguc3VidHJhY3QoWzUsIDcsIDRdLCA0KTsgIC8vIHJldHVybnMgQXJyYXkgWzEsIDMsIDBdXG4gICAqXG4gICAqICAgIHZhciBjID0gbWF0aC51bml0KCcyLjEga20nKTtcbiAgICogICAgdmFyIGQgPSBtYXRoLnVuaXQoJzUwMG0nKTtcbiAgICogICAgbWF0aC5zdWJ0cmFjdChjLCBkKTsgICAgICAgICAgLy8gcmV0dXJucyBVbml0IDEuNiBrbVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWRkXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geFxuICAgKiAgICAgICAgICAgIEluaXRpYWwgdmFsdWVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB5XG4gICAqICAgICAgICAgICAgVmFsdWUgdG8gc3VidHJhY3QgZnJvbSBgeGBcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fVxuICAgKiAgICAgICAgICAgIFN1YnRyYWN0aW9uIG9mIGB4YCBhbmQgYHlgXG4gICAqL1xuICB2YXIgc3VidHJhY3QgPSB0eXBlZCgnc3VidHJhY3QnLCB7XG5cbiAgICAnbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggLSB5O1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCwgQ29tcGxleCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5zdWIoeSk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5taW51cyh5KTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5zdWIoeSk7XG4gICAgfSxcblxuICAgICdVbml0LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgeCBjb250YWlucyBhIHVuaXQgd2l0aCB1bmRlZmluZWQgdmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB5IGNvbnRhaW5zIGEgdW5pdCB3aXRoIHVuZGVmaW5lZCB2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXguZXF1YWxCYXNlKHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pdHMgZG8gbm90IG1hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXMgPSB4LmNsb25lKCk7XG4gICAgICByZXMudmFsdWUgPSBzdWJ0cmFjdChyZXMudmFsdWUsIHkudmFsdWUpO1xuICAgICAgcmVzLmZpeFByZWZpeCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIG1hdHJpeCBzaXplc1xuICAgICAgdmFyIHhzaXplID0geC5zaXplKCk7XG4gICAgICB2YXIgeXNpemUgPSB5LnNpemUoKTtcblxuICAgICAgLy8gY2hlY2sgZGltZW5zaW9uc1xuICAgICAgaWYgKHhzaXplLmxlbmd0aCAhPT0geXNpemUubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoeHNpemUubGVuZ3RoLCB5c2l6ZS5sZW5ndGgpO1xuXG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlIC0gc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNSh4LCB5LCBzdWJ0cmFjdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlIC0gZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIHN1YnRyYWN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC0gc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMSh4LCB5LCBzdWJ0cmFjdCwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlIC0gZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIHN1YnRyYWN0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBzdWJ0cmFjdChtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gc3VidHJhY3QobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIHN1YnRyYWN0KHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgLy8gYWxnb3JpdGhtIDcgaXMgZmFzdGVyIHRoYW4gOSBzaW5jZSBpdCBjYWxscyBmKCkgZm9yIG5vbnplcm8gaXRlbXMgb25seSFcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTAoeCwgdW5hcnlNaW51cyh5KSwgYWRkU2NhbGFyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeCwgeSwgc3VidHJhY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTAoeSwgeCwgc3VidHJhY3QsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBzdWJ0cmFjdCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgc3VidHJhY3QsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIHN1YnRyYWN0LCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBzdWJ0cmFjdC50b1RleCA9IHtcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ3N1YnRyYWN0J10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIHN1YnRyYWN0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc3VidHJhY3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBJbnZlcnNlIHRoZSBzaWduIG9mIGEgdmFsdWUsIGFwcGx5IGEgdW5hcnkgbWludXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLiBCb29sZWFuIHZhbHVlcyBhbmRcbiAgICogc3RyaW5ncyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlci4gRm9yIGNvbXBsZXggbnVtYmVycywgYm90aCByZWFsIGFuZFxuICAgKiBjb21wbGV4IHZhbHVlIGFyZSBpbnZlcnRlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnVuYXJ5TWludXMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgudW5hcnlNaW51cygzLjUpOyAgICAgIC8vIHJldHVybnMgLTMuNVxuICAgKiAgICBtYXRoLnVuYXJ5TWludXMoLTQuMik7ICAgICAvLyByZXR1cm5zIDQuMlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWRkLCBzdWJ0cmFjdCwgdW5hcnlQbHVzXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCBOdW1iZXIgdG8gYmUgaW52ZXJ0ZWQuXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0aGUgdmFsdWUgd2l0aCBpbnZlcnRlZCBzaWduLlxuICAgKi9cbiAgdmFyIHVuYXJ5TWludXMgPSB0eXBlZCgndW5hcnlNaW51cycsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAteDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubmVnKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgubmVnKCk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5uZWcoKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIHJlcyA9IHguY2xvbmUoKTtcbiAgICAgIHJlcy52YWx1ZSA9IHVuYXJ5TWludXMoeC52YWx1ZSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSB1bmFyeU1pbnVzKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgdW5hcnlNaW51cywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIHN0cmluZ1xuICB9KTtcblxuICB1bmFyeU1pbnVzLnRvVGV4ID0ge1xuICAgIDE6IGxhdGV4Lm9wZXJhdG9yc1sndW5hcnlNaW51cyddICsgJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiB1bmFyeU1pbnVzO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndW5hcnlNaW51cyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2xhdGV4Jyk7XG5cbiAgLyoqXG4gICAqIFVuYXJ5IHBsdXMgb3BlcmF0aW9uLlxuICAgKiBCb29sZWFuIHZhbHVlcyBhbmQgc3RyaW5ncyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgbnVtZXJpYyB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBpcy5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnVuYXJ5UGx1cyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC51bmFyeVBsdXMoMy41KTsgICAgICAvLyByZXR1cm5zIDMuNVxuICAgKiAgICBtYXRoLnVuYXJ5UGx1cygxKTsgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgdW5hcnlNaW51cywgYWRkLCBzdWJ0cmFjdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IHN0cmluZyB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHhcbiAgICogICAgICAgICAgICBJbnB1dCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9XG4gICAqICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5wdXQgdmFsdWUgd2hlbiBudW1lcmljLCBjb252ZXJ0cyB0byBhIG51bWJlciB3aGVuIGlucHV0IGlzIG5vbi1udW1lcmljLlxuICAgKi9cbiAgdmFyIHVuYXJ5UGx1cyA9IHR5cGVkKCd1bmFyeVBsdXMnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7IC8vIGNvbXBsZXggbnVtYmVycyBhcmUgaW1tdXRhYmxlXG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7IC8vIGJpZ251bWJlcnMgYXJlIGltbXV0YWJsZVxuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7IC8vIGZyYWN0aW9ucyBhcmUgaW1tdXRhYmxlXG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNsb25lKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIHVuYXJ5UGx1cygwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHVuYXJ5UGx1cywgdHJ1ZSk7XG4gICAgfSxcblxuICAgICdib29sZWFuIHwgc3RyaW5nIHwgbnVsbCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBjb252ZXJ0IHRvIGEgbnVtYmVyIG9yIGJpZ251bWJlclxuICAgICAgcmV0dXJuIChjb25maWcubnVtYmVyID09ICdCaWdOdW1iZXInKSA/IG5ldyB0eXBlLkJpZ051bWJlcigreCk6ICt4O1xuICAgIH1cbiAgfSk7XG5cbiAgdW5hcnlQbHVzLnRvVGV4ID0ge1xuICAgIDE6IGxhdGV4Lm9wZXJhdG9yc1sndW5hcnlQbHVzJ10gKyAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIHVuYXJ5UGx1cztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3VuYXJ5UGx1cyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNJbnRlZ2VyO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHRlbmRlZCBncmVhdGVzdCBjb21tb24gZGl2aXNvciBmb3IgdHdvIHZhbHVlcy5cbiAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5kZWRfRXVjbGlkZWFuX2FsZ29yaXRobS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnhnY2QoYSwgYilcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgueGdjZCg4LCAxMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgWzQsIC0xLCAxXVxuICAgKiAgICBtYXRoLmdjZCg4LCAxMik7ICAgICAgICAgICAgICAvLyByZXR1cm5zIDRcbiAgICogICAgbWF0aC54Z2NkKDM2MTYzLCAyMTE5OSk7ICAgICAgLy8gcmV0dXJucyBbMTI0NywgLTcsIDEyXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZ2NkLCBsY21cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IGEgIEFuIGludGVnZXIgbnVtYmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyfSBiICBBbiBpbnRlZ2VyIG51bWJlclxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyAzIGludGVnZXJzIGBbZGl2LCBtLCBuXWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSBgZGl2ID0gZ2NkKGEsIGIpYCBhbmQgYGEqbSArIGIqbiA9IGRpdmBcbiAgICovXG4gIHZhciB4Z2NkID0gdHlwZWQoJ3hnY2QnLCB7XG4gICAgJ251bWJlciwgbnVtYmVyJzogX3hnY2QsXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogX3hnY2RCaWdOdW1iZXJcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgRnJhY3Rpb25cbiAgfSk7XG5cbiAgeGdjZC50b1RleCA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdGVtcGxhdGVcblxuICByZXR1cm4geGdjZDtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHhnY2QgZm9yIHR3byBudW1iZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gICAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfeGdjZCAoYSwgYikge1xuICAgIC8vIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHRlbmRlZF9FdWNsaWRlYW5fYWxnb3JpdGhtXG4gICAgdmFyIHQsIC8vIHVzZWQgdG8gc3dhcCB0d28gdmFyaWFibGVzXG4gICAgICAgIHEsIC8vIHF1b3RpZW50XG4gICAgICAgIHIsIC8vIHJlbWFpbmRlclxuICAgICAgICB4ID0gMCwgbGFzdHggPSAxLFxuICAgICAgICB5ID0gMSwgbGFzdHkgPSAwO1xuXG4gICAgaWYgKCFpc0ludGVnZXIoYSkgfHwgIWlzSW50ZWdlcihiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIHhnY2QgbXVzdCBiZSBpbnRlZ2VyIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoYikge1xuICAgICAgcSA9IE1hdGguZmxvb3IoYSAvIGIpO1xuICAgICAgciA9IGEgJSBiO1xuXG4gICAgICB0ID0geDtcbiAgICAgIHggPSBsYXN0eCAtIHEgKiB4O1xuICAgICAgbGFzdHggPSB0O1xuXG4gICAgICB0ID0geTtcbiAgICAgIHkgPSBsYXN0eSAtIHEgKiB5O1xuICAgICAgbGFzdHkgPSB0O1xuXG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByO1xuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEgPCAwKSB7XG4gICAgICByZXMgPSBbLWEsIC1sYXN0eCwgLWxhc3R5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXMgPSBbYSwgYSA/IGxhc3R4IDogMCwgbGFzdHldO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdBcnJheScpID8gcmVzIDogbWF0cml4KHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHhnY2QgZm9yIHR3byBCaWdOdW1iZXJzXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBiXG4gICAqIEByZXR1cm4ge0JpZ051bWJlcltdfSByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF94Z2NkQmlnTnVtYmVyKGEsIGIpIHtcbiAgICAvLyBzb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5kZWRfRXVjbGlkZWFuX2FsZ29yaXRobVxuICAgIHZhciB0LCAvLyB1c2VkIHRvIHN3YXAgdHdvIHZhcmlhYmxlc1xuICAgICAgICBxLCAvLyBxdW90aWVudFxuICAgICAgICByLCAvLyByZW1haW5kZXJcbiAgICAgICAgemVybyA9IG5ldyB0eXBlLkJpZ051bWJlcigwKSxcbiAgICAgICAgb25lID0gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLFxuICAgICAgICB4ID0gemVybyxcbiAgICAgICAgbGFzdHggPSBvbmUsXG4gICAgICAgIHkgPSBvbmUsXG4gICAgICAgIGxhc3R5ID0gemVybztcblxuICAgIGlmICghYS5pc0ludCgpIHx8ICFiLmlzSW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVycyBpbiBmdW5jdGlvbiB4Z2NkIG11c3QgYmUgaW50ZWdlciBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFiLmlzWmVybygpKSB7XG4gICAgICBxID0gYS5kaXYoYikuZmxvb3IoKTtcbiAgICAgIHIgPSBhLm1vZChiKTtcblxuICAgICAgdCA9IHg7XG4gICAgICB4ID0gbGFzdHgubWludXMocS50aW1lcyh4KSk7XG4gICAgICBsYXN0eCA9IHQ7XG5cbiAgICAgIHQgPSB5O1xuICAgICAgeSA9IGxhc3R5Lm1pbnVzKHEudGltZXMoeSkpO1xuICAgICAgbGFzdHkgPSB0O1xuXG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByO1xuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEubHQoemVybykpIHtcbiAgICAgIHJlcyA9IFthLm5lZygpLCBsYXN0eC5uZWcoKSwgbGFzdHkubmVnKCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlcyA9IFthLCAhYS5pc1plcm8oKSA/IGxhc3R4IDogMCwgbGFzdHldO1xuICAgIH1cbiAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdBcnJheScpID8gcmVzIDogbWF0cml4KHJlcyk7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ3hnY2QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsb25lID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuY2xvbmU7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJykuaXNJbnRlZ2VyO1xudmFyIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKTtcbnZhciBJbmRleEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvSW5kZXhFcnJvcicpO1xudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlIHR3byBvciBtb3JlIG1hdHJpY2VzLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmNvbmNhdChBLCBCLCBDLCAuLi4pXG4gICAqICAgICBtYXRoLmNvbmNhdChBLCBCLCBDLCAuLi4sIGRpbSlcbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIC0gYGRpbTogbnVtYmVyYCBpcyBhIHplcm8tYmFzZWQgZGltZW5zaW9uIG92ZXIgd2hpY2ggdG8gY29uY2F0ZW5hdGUgdGhlIG1hdHJpY2VzLlxuICAgKiAgIEJ5IGRlZmF1bHQgdGhlIGxhc3QgZGltZW5zaW9uIG9mIHRoZSBtYXRyaWNlcy5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIHZhciBBID0gW1sxLCAyXSwgWzUsIDZdXTtcbiAgICogICAgdmFyIEIgPSBbWzMsIDRdLCBbNywgOF1dO1xuICAgKlxuICAgKiAgICBtYXRoLmNvbmNhdChBLCBCKTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtbMSwgMiwgMywgNF0sIFs1LCA2LCA3LCA4XV1cbiAgICogICAgbWF0aC5jb25jYXQoQSwgQiwgMCk7ICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbWzEsIDJdLCBbNSwgNl0sIFszLCA0XSwgWzcsIDhdXVxuICAgKiAgICBtYXRoLmNvbmNhdCgnaGVsbG8nLCAnICcsICd3b3JsZCcpOyAvLyByZXR1cm5zICdoZWxsbyB3b3JsZCdcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHNpemUsIHNxdWVlemUsIHN1YnNldCwgdHJhbnNwb3NlXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uIEFycmF5IHwgTWF0cml4fSBhcmdzICAgICBUd28gb3IgbW9yZSBtYXRyaWNlc1xuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gQ29uY2F0ZW5hdGVkIG1hdHJpeFxuICAgKi9cbiAgdmFyIGNvbmNhdCA9IHR5cGVkKCdjb25jYXQnLCB7XG4gICAgLy8gVE9ETzogY2hhbmdlIHNpZ25hdHVyZSB0byAnLi4uQXJyYXkgfCBNYXRyaXgsIGRpbT8nIHdoZW4gc3VwcG9ydGVkXG4gICAgJy4uLkFycmF5IHwgTWF0cml4IHwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGRpbSA9IC0xOyAgLy8gemVyby1iYXNlZCBkaW1lbnNpb25cbiAgICAgIHZhciBwcmV2RGltO1xuICAgICAgdmFyIGFzTWF0cml4ID0gZmFsc2U7XG4gICAgICB2YXIgbWF0cmljZXMgPSBbXTsgIC8vIGNvbnRhaW5zIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5c1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgLy8gdGVzdCB3aGV0aGVyIHdlIG5lZWQgdG8gcmV0dXJuIGEgTWF0cml4IChpZiBub3Qgd2UgcmV0dXJuIGFuIEFycmF5KVxuICAgICAgICBpZiAoYXJnICYmIGFyZy5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFzTWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCAoYXJnICYmIGFyZy5pc0JpZ051bWJlciA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICBpZiAoaSAhPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gbXVzdCBiZSBzcGVjaWZpZWQgYXMgbGFzdCBhcmd1bWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGxhc3QgYXJndW1lbnQgY29udGFpbnMgdGhlIGRpbWVuc2lvbiBvbiB3aGljaCB0byBjb25jYXRlbmF0ZVxuICAgICAgICAgIHByZXZEaW0gPSBkaW07XG4gICAgICAgICAgZGltID0gYXJnLnZhbHVlT2YoKTsgLy8gY2hhbmdlIEJpZ051bWJlciB0byBudW1iZXJcblxuICAgICAgICAgIGlmICghaXNJbnRlZ2VyKGRpbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGVnZXIgbnVtYmVyIGV4cGVjdGVkIGZvciBkaW1lbnNpb24nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGltIDwgMCB8fCAoaSA+IDAgJiYgZGltID4gcHJldkRpbSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHdvdWxkIGJlIG1vcmUgY2xlYXIgd2hlbiB0aHJvd2luZyBhIERpbWVuc2lvbkVycm9yIGhlcmVcbiAgICAgICAgICAgIHRocm93IG5ldyBJbmRleEVycm9yKGRpbSwgcHJldkRpbSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgbWF0cml4IG9yIGFycmF5XG4gICAgICAgICAgdmFyIG0gPSBjbG9uZShhcmcpLnZhbHVlT2YoKTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGFycmF5LnNpemUobSk7XG4gICAgICAgICAgbWF0cmljZXNbaV0gPSBtO1xuICAgICAgICAgIHByZXZEaW0gPSBkaW07XG4gICAgICAgICAgZGltID0gc2l6ZS5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgLy8gdmVyaWZ5IHdoZXRoZXIgZWFjaCBvZiB0aGUgbWF0cmljZXMgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBkaW1lbnNpb25zXG4gICAgICAgICAgaWYgKGkgPiAwICYmIGRpbSAhPSBwcmV2RGltKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IocHJldkRpbSArIDEsIGRpbSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0cmljZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBdCBsZWFzdCBvbmUgbWF0cml4IGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXMgPSBtYXRyaWNlcy5zaGlmdCgpO1xuICAgICAgd2hpbGUgKG1hdHJpY2VzLmxlbmd0aCkge1xuICAgICAgICByZXMgPSBfY29uY2F0KHJlcywgbWF0cmljZXMuc2hpZnQoKSwgZGltLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzTWF0cml4ID8gbWF0cml4KHJlcykgOiByZXM7XG4gICAgfSxcblxuICAgICcuLi5zdHJpbmcnOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJyk7XG4gICAgfVxuICB9KTtcblxuICBjb25jYXQudG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIGNvbmNhdDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb25jYXRlbmF0ZSB0d28gbWF0cmljZXMuXG4gKiBUaGUgY29udGVudHMgb2YgdGhlIG1hdHJpY2VzIGlzIG5vdCBjbG9uZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBhICAgICAgICAgICAgIE11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBiICAgICAgICAgICAgIE11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gY29uY2F0RGltICAgIFRoZSBkaW1lbnNpb24gb24gd2hpY2ggdG8gY29uY2F0ZW5hdGUgKHplcm8tYmFzZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICAgICAgICAgIFRoZSBjdXJyZW50IGRpbSAoemVyby1iYXNlZClcbiAqIEByZXR1cm4ge0FycmF5fSBjICAgICAgICAgICAgVGhlIGNvbmNhdGVuYXRlZCBtYXRyaXhcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9jb25jYXQoYSwgYiwgY29uY2F0RGltLCBkaW0pIHtcbiAgaWYgKGRpbSA8IGNvbmNhdERpbSkge1xuICAgIC8vIHJlY3Vyc2UgaW50byBuZXh0IGRpbWVuc2lvblxuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNbaV0gPSBfY29uY2F0KGFbaV0sIGJbaV0sIGNvbmNhdERpbSwgZGltICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGNvbmNhdGVuYXRlIHRoaXMgZGltZW5zaW9uXG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdjb25jYXQnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pbmRleCcpO1xudmFyIG9iamVjdCA9IHV0aWwub2JqZWN0O1xudmFyIHN0cmluZyA9IHV0aWwuc3RyaW5nO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGQnKSk7XG4gIHZhciBzdWJ0cmFjdCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9zdWJ0cmFjdCcpKTtcbiAgdmFyIG11bHRpcGx5ID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL211bHRpcGx5JykpO1xuICB2YXIgdW5hcnlNaW51cyA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy91bmFyeU1pbnVzJykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZGV0KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmRldChbWzEsIDJdLCBbMywgNF1dKTsgLy8gcmV0dXJucyAtMlxuICAgKlxuICAgKiAgICB2YXIgQSA9IFtcbiAgICogICAgICBbLTIsIDIsIDNdLFxuICAgKiAgICAgIFstMSwgMSwgM10sXG4gICAqICAgICAgWzIsIDAsIC0xXVxuICAgKiAgICBdXG4gICAqICAgIG1hdGguZGV0KEEpOyAvLyByZXR1cm5zIDZcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGludlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSB4ICBBIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkZXRlcm1pbmFudCBvZiBgeGBcbiAgICovXG4gIHZhciBkZXQgPSB0eXBlZCgnZGV0Jywge1xuICAgICdhbnknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG9iamVjdC5jbG9uZSh4KTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gZGV0ICh4KSB7XG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIGlmICh4ICYmIHguaXNNYXRyaXggPT09IHRydWUpIHtcbiAgICAgICAgc2l6ZSA9IHguc2l6ZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICB4ID0gbWF0cml4KHgpO1xuICAgICAgICBzaXplID0geC5zaXplKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gYSBzY2FsYXJcbiAgICAgICAgc2l6ZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHNpemUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvLyBzY2FsYXJcbiAgICAgICAgICByZXR1cm4gb2JqZWN0LmNsb25lKHgpO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyB2ZWN0b3JcbiAgICAgICAgICBpZiAoc2l6ZVswXSA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LmNsb25lKHgudmFsdWVPZigpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IG11c3QgYmUgc3F1YXJlICcgK1xuICAgICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyB0d28gZGltZW5zaW9uYWwgYXJyYXlcbiAgICAgICAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgICAgICAgdmFyIGNvbHMgPSBzaXplWzFdO1xuICAgICAgICAgIGlmIChyb3dzID09IGNvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGV0KHguY2xvbmUoKS52YWx1ZU9mKCksIHJvd3MsIGNvbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAnKHNpemU6ICcgKyBzdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSB0d28gZGltZW5zaW9uYWwgJyArXG4gICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBkZXQudG9UZXggPSB7MTogJ1xcXFxkZXRcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBkZXQ7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheVtdfSBtYXRyaXggIEEgc3F1YXJlLCB0d28gZGltZW5zaW9uYWwgbWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzICAgICBOdW1iZXIgb2Ygcm93cyBvZiB0aGUgbWF0cml4ICh6ZXJvLWJhc2VkKVxuICAgKiBAcGFyYW0ge251bWJlcn0gY29scyAgICAgTnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIG1hdHJpeCAoemVyby1iYXNlZClcbiAgICogQHJldHVybnMge251bWJlcn0gZGV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZGV0IChtYXRyaXgsIHJvd3MsIGNvbHMpIHtcbiAgICBpZiAocm93cyA9PSAxKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgMSB4IDEgbWF0cml4XG4gICAgICByZXR1cm4gb2JqZWN0LmNsb25lKG1hdHJpeFswXVswXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvd3MgPT0gMikge1xuICAgICAgLy8gdGhpcyBpcyBhIDIgeCAyIG1hdHJpeFxuICAgICAgLy8gdGhlIGRldGVybWluYW50IG9mIFthMTEsYTEyO2EyMSxhMjJdIGlzIGRldCA9IGExMSphMjItYTIxKmExMlxuICAgICAgcmV0dXJuIHN1YnRyYWN0KFxuICAgICAgICAgIG11bHRpcGx5KG1hdHJpeFswXVswXSwgbWF0cml4WzFdWzFdKSxcbiAgICAgICAgICBtdWx0aXBseShtYXRyaXhbMV1bMF0sIG1hdHJpeFswXVsxXSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyBhbiBuIHggbiBtYXRyaXhcbiAgICAgIHZhciBjb21wdXRlX211ID0gZnVuY3Rpb24gKG1hdHJpeCkge1xuICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBtYXRyaXggd2l0aCB6ZXJvIGxvd2VyIHRyaWFuZ2xlLCBzYW1lIHVwcGVyIHRyaWFuZ2xlLFxuICAgICAgICAvLyBhbmQgZGlhZ29uYWxzIGdpdmVuIGJ5IHRoZSBuZWdhdGVkIHN1bSBvZiB0aGUgYmVsb3cgZGlhZ29uYWxcbiAgICAgICAgLy8gZWxlbWVudHMuXG4gICAgICAgIHZhciBtdSA9IG5ldyBBcnJheShtYXRyaXgubGVuZ3RoKTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdW0gPSBhZGQoc3VtLCBtYXRyaXhbaV1baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG11W2ldID0gbmV3IEFycmF5KG1hdHJpeC5sZW5ndGgpO1xuICAgICAgICAgIG11W2ldW2ldID0gdW5hcnlNaW51cyhzdW0pO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgICAgbXVbaV1bal0gPSAwOyAvLyBUT0RPOiBtYWtlIGJpZ251bWJlciAwIGluIGNhc2Ugb2YgYmlnbnVtYmVyIGNvbXB1dGF0aW9uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBtYXRyaXgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG11W2ldW2pdID0gbWF0cml4W2ldW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpKzEgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdW0gPSBzdWJ0cmFjdChzdW0sIG1hdHJpeFtpICsgMV1baSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmEgPSBtYXRyaXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MgLSAxOyBpKyspIHtcbiAgICAgICAgZmEgPSBtdWx0aXBseShjb21wdXRlX211KGZhKSwgbWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvd3MgJSAyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuYXJ5TWludXMoZmFbMF1bMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhWzBdWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnZGV0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYXJyYXknKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc0ludGVnZXI7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSAyLWRpbWVuc2lvbmFsIGlkZW50aXR5IG1hdHJpeCB3aXRoIHNpemUgbSB4IG4gb3IgbiB4IG4uXG4gICAqIFRoZSBtYXRyaXggaGFzIG9uZXMgb24gdGhlIGRpYWdvbmFsIGFuZCB6ZXJvcyBlbHNld2hlcmUuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5leWUobilcbiAgICogICAgbWF0aC5leWUobiwgZm9ybWF0KVxuICAgKiAgICBtYXRoLmV5ZShtLCBuKVxuICAgKiAgICBtYXRoLmV5ZShtLCBuLCBmb3JtYXQpXG4gICAqICAgIG1hdGguZXllKFttLCBuXSlcbiAgICogICAgbWF0aC5leWUoW20sIG5dLCBmb3JtYXQpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmV5ZSgzKTsgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1sxLCAwLCAwXSwgWzAsIDEsIDBdLCBbMCwgMCwgMV1dXG4gICAqICAgIG1hdGguZXllKDMsIDIpOyAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbWzEsIDBdLCBbMCwgMV0sIFswLCAwXV1cbiAgICpcbiAgICogICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICBtYXRoLmV5ZShtYXRoLnNpemUoQSkpOyAgICAgICAgIC8vIHJldHVybnMgW1sxLCAwLCAwXSwgWzAsIDEsIDBdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZGlhZywgb25lcywgemVyb3MsIHNpemUsIHJhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7Li4ubnVtYmVyIHwgTWF0cml4IHwgQXJyYXl9IHNpemUgICBUaGUgc2l6ZSBmb3IgdGhlIG1hdHJpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gICAgICAgICAgICAgICAgICAgVGhlIE1hdHJpeCBzdG9yYWdlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXggfCBBcnJheSB8IG51bWJlcn0gQSBtYXRyaXggd2l0aCBvbmVzIG9uIHRoZSBkaWFnb25hbC5cbiAgICovXG4gIHZhciBleWUgPSB0eXBlZCgnZXllJywge1xuICAgICcnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGNvbmZpZy5tYXRyaXggPT09ICdNYXRyaXgnKSA/IG1hdHJpeChbXSkgOiBbXTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ251bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICByZXR1cm4gX2V5ZShyb3dzLCByb3dzLCBjb25maWcubWF0cml4ID09PSAnTWF0cml4JyA/ICdkZWZhdWx0JyA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBcbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBzdHJpbmcnOiBmdW5jdGlvbiAocm93cywgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX2V5ZShyb3dzLCByb3dzLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyIHwgQmlnTnVtYmVyLCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAocm93cywgY29scykge1xuICAgICAgcmV0dXJuIF9leWUocm93cywgY29scywgY29uZmlnLm1hdHJpeCA9PT0gJ01hdHJpeCcgPyAnZGVmYXVsdCcgOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgXG4gICAgJ251bWJlciB8IEJpZ051bWJlciwgbnVtYmVyIHwgQmlnTnVtYmVyLCBzdHJpbmcnOiBmdW5jdGlvbiAocm93cywgY29scywgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX2V5ZShyb3dzLCBjb2xzLCBmb3JtYXQpO1xuICAgIH0sXG5cbiAgICAnQXJyYXknOiAgZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHJldHVybiBfZXllVmVjdG9yKHNpemUpO1xuICAgIH0sXG4gICAgXG4gICAgJ0FycmF5LCBzdHJpbmcnOiAgZnVuY3Rpb24gKHNpemUsIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9leWVWZWN0b3Ioc2l6ZSwgZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCc6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICByZXR1cm4gX2V5ZVZlY3RvcihzaXplLnZhbHVlT2YoKSwgc2l6ZS5zdG9yYWdlKCkpO1xuICAgIH0sXG4gICAgXG4gICAgJ01hdHJpeCwgc3RyaW5nJzogZnVuY3Rpb24gKHNpemUsIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIF9leWVWZWN0b3Ioc2l6ZS52YWx1ZU9mKCksIGZvcm1hdCk7XG4gICAgfVxuICB9KTtcblxuICBleWUudG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIGV5ZTtcblxuICBmdW5jdGlvbiBfZXllVmVjdG9yIChzaXplLCBmb3JtYXQpIHtcbiAgICBzd2l0Y2ggKHNpemUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmb3JtYXQgPyBtYXRyaXgoZm9ybWF0KSA6IFtdO1xuICAgICAgY2FzZSAxOiByZXR1cm4gX2V5ZShzaXplWzBdLCBzaXplWzBdLCBmb3JtYXQpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gX2V5ZShzaXplWzBdLCBzaXplWzFdLCBmb3JtYXQpO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdWZWN0b3IgY29udGFpbmluZyB0d28gdmFsdWVzIGV4cGVjdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpZGVudGl0eSBtYXRyaXhcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IHJvd3NcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXJ9IGNvbHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXRdXG4gICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZXllIChyb3dzLCBjb2xzLCBmb3JtYXQpIHtcbiAgICAvLyBCaWdOdW1iZXIgY29uc3RydWN0b3Igd2l0aCB0aGUgcmlnaHQgcHJlY2lzaW9uXG4gICAgdmFyIEJpZyA9IChyb3dzICYmIHJvd3MuaXNCaWdOdW1iZXIgPT09IHRydWUpXG4gICAgICAgID8gdHlwZS5CaWdOdW1iZXJcbiAgICAgICAgOiAoY29scyAmJiBjb2xzLmlzQmlnTnVtYmVyID09PSB0cnVlKVxuICAgICAgICAgICAgPyB0eXBlLkJpZ051bWJlclxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJvd3MgJiYgcm93cy5pc0JpZ051bWJlciA9PT0gdHJ1ZSkgcm93cyA9IHJvd3MudG9OdW1iZXIoKTtcbiAgICBpZiAoY29scyAmJiBjb2xzLmlzQmlnTnVtYmVyID09PSB0cnVlKSBjb2xzID0gY29scy50b051bWJlcigpO1xuXG4gICAgaWYgKCFpc0ludGVnZXIocm93cykgfHwgcm93cyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVycyBpbiBmdW5jdGlvbiBleWUgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VycycpO1xuICAgIH1cbiAgICBpZiAoIWlzSW50ZWdlcihjb2xzKSB8fCBjb2xzIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIGV5ZSBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXJzJyk7XG4gICAgfVxuICAgIFxuICAgIHZhciBvbmUgPSBCaWcgPyBuZXcgdHlwZS5CaWdOdW1iZXIoMSkgOiAxO1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBCaWcgPyBuZXcgQmlnKDApIDogMDtcbiAgICB2YXIgc2l6ZSA9IFtyb3dzLCBjb2xzXTtcbiAgICBcbiAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHJldHVybiBhIG1hdHJpeFxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIC8vIGdldCBtYXRyaXggc3RvcmFnZSBjb25zdHJ1Y3RvclxuICAgICAgdmFyIEYgPSB0eXBlLk1hdHJpeC5zdG9yYWdlKGZvcm1hdCk7XG4gICAgICAvLyBjcmVhdGUgZGlhZ29uYWwgbWF0cml4ICh1c2Ugb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciBzdG9yYWdlIGZvcm1hdClcbiAgICAgIHJldHVybiBGLmRpYWdvbmFsKHNpemUsIG9uZSwgMCwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gY3JlYXRlIGFuZCByZXNpemUgYXJyYXlcbiAgICB2YXIgcmVzID0gYXJyYXkucmVzaXplKFtdLCBzaXplLCBkZWZhdWx0VmFsdWUpO1xuICAgIC8vIGZpbGwgaW4gb25lcyBvbiB0aGUgZGlhZ29uYWxcbiAgICB2YXIgbWluaW11bSA9IHJvd3MgPCBjb2xzID8gcm93cyA6IGNvbHM7XG4gICAgLy8gZmlsbCBkaWFnb25hbFxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbWluaW11bTsgZCsrKSB7XG4gICAgICByZXNbZF1bZF0gPSBvbmU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuZXhwb3J0cy5uYW1lID0gJ2V5ZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2l6ZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5Jykuc2l6ZTtcbnZhciBtYXhBcmd1bWVudENvdW50ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZnVuY3Rpb24nKS5tYXhBcmd1bWVudENvdW50O1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcbiAgXG4gIC8qKlxuICAgKiBGaWx0ZXIgdGhlIGl0ZW1zIGluIGFuIGFycmF5IG9yIG9uZSBkaW1lbnNpb25hbCBtYXRyaXguXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5maWx0ZXIoeCwgdGVzdClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIGZ1bmN0aW9uIGlzUG9zaXRpdmUgKHgpIHtcbiAgICogICAgICByZXR1cm4geCA+IDA7XG4gICAqICAgIH1cbiAgICogICAgbWF0aC5maWx0ZXIoWzYsIC0yLCAtMSwgNCwgM10sIGlzUG9zaXRpdmUpOyAvLyByZXR1cm5zIFs2LCA0LCAzXVxuICAgKlxuICAgKiAgICBtYXRoLmZpbHRlcihbXCIyM1wiLCBcImZvb1wiLCBcIjEwMFwiLCBcIjU1XCIsIFwiYmFyXCJdLCAvWzAtOV0rLyk7IC8vIHJldHVybnMgW1wiMjNcIiwgXCIxMDBcIiwgXCI1NVwiXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgZm9yRWFjaCwgbWFwLCBzb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgQSBvbmUgZGltZW5zaW9uYWwgbWF0cml4IG9yIGFycmF5IHRvIGZpbHRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgUmVnRXhwfSB0ZXN0XG4gICAqICAgICAgICBBIGZ1bmN0aW9uIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IGl0ZW1zLlxuICAgKiAgICAgICAgQWxsIGVudHJpZXMgZm9yIHdoaWNoIGB0ZXN0YCByZXR1cm5zIHRydWUgYXJlIHJldHVybmVkLlxuICAgKiAgICAgICAgV2hlbiBgdGVzdGAgaXMgYSBmdW5jdGlvbiwgaXQgaXMgaW52b2tlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gICAqICAgICAgICB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCwgYW5kIHRoZVxuICAgKiAgICAgICAgbWF0cml4L2FycmF5IGJlaW5nIHRyYXZlcnNlZC4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHJldHVybiB7TWF0cml4IHwgQXJyYXl9IFJldHVybnMgdGhlIGZpbHRlcmVkIG1hdHJpeC5cbiAgICovXG4gIHZhciBmaWx0ZXIgPSB0eXBlZCgnZmlsdGVyJywge1xuICAgICdBcnJheSwgZnVuY3Rpb24nOiBfZmlsdGVyQ2FsbGJhY2ssXG5cbiAgICAnQXJyYXksIFJlZ0V4cCc6IF9maWx0ZXJSZWdFeHAsXG5cbiAgICAnTWF0cml4LCBmdW5jdGlvbic6IGZ1bmN0aW9uICh4LCB0ZXN0KSB7XG4gICAgICByZXR1cm4gbWF0cml4KF9maWx0ZXJDYWxsYmFjayh4LnRvQXJyYXkoKSwgdGVzdCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBSZWdFeHAnOiBmdW5jdGlvbiAoeCwgdGVzdCkge1xuICAgICAgcmV0dXJuIG1hdHJpeChfZmlsdGVyUmVnRXhwKHgudG9BcnJheSgpLCB0ZXN0KSk7XG4gICAgfVxuICB9KTtcblxuICBmaWx0ZXIudG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIGZpbHRlcjtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgdmFsdWVzIGluIGEgY2FsbGJhY2sgZ2l2ZW4gYSBjYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtBcnJheX0geFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBmaWx0ZXJlZCBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2ZpbHRlckNhbGxiYWNrICh4LCBjYWxsYmFjaykge1xuICBpZiAoc2l6ZSh4KS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGRpbWVuc2lvbmFsIG1hdHJpY2VzIHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCB3aGF0IG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4cGVjdHNcbiAgdmFyIGFyZ3MgPSBtYXhBcmd1bWVudENvdW50KGNhbGxiYWNrKTtcblxuICByZXR1cm4geC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgYXJyYXkpIHtcbiAgICAvLyBpbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggdGhlIHJpZ2h0IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICBpZiAoYXJncyA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncyA9PT0gMikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBbaW5kZXhdKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIDMgb3IgLTFcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSwgW2luZGV4XSwgYXJyYXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRmlsdGVyIHZhbHVlcyBpbiBhIGNhbGxiYWNrIGdpdmVuIGEgcmVndWxhciBleHByZXNzaW9uXG4gKiBAcGFyYW0ge0FycmF5fSB4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWdleHBcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBmaWx0ZXJlZCBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2ZpbHRlclJlZ0V4cCAoeCwgcmVnZXhwKSB7XG4gIGlmIChzaXplKHgpLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgZGltZW5zaW9uYWwgbWF0cmljZXMgc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4geC5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHJlZ2V4cC50ZXN0KGVudHJ5KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmaWx0ZXInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1heEFyZ3VtZW50Q291bnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9mdW5jdGlvbicpLm1heEFyZ3VtZW50Q291bnQ7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgZWxlbWVudHMgb2YgYSBtYXRyaXgvYXJyYXksIGFuZCBleGVjdXRlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5mb3JFYWNoKHgsIGNhbGxiYWNrKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5mb3JFYWNoKFsxLCAyLCAzXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICogICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAqICAgIH0pO1xuICAgKiAgICAvLyBvdXRwdXRzIDEsIDIsIDNcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGZpbHRlciwgbWFwLCBzb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4IHwgQXJyYXl9IHggICAgVGhlIG1hdHJpeCB0byBpdGVyYXRlIG9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBlbGVtZW50LCBhbmQgdGhlIE1hdHJpeC9hcnJheSBiZWluZyB0cmF2ZXJzZWQuXG4gICAqL1xuICB2YXIgZm9yRWFjaCA9IHR5cGVkKCdmb3JFYWNoJywge1xuICAgICdBcnJheSwgZnVuY3Rpb24nOiBfZm9yRWFjaCxcblxuICAgICdNYXRyaXgsIGZ1bmN0aW9uJzogZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4geC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvckVhY2gudG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIGZvckVhY2g7XG59XG5cbi8qKlxuICogZm9yRWFjaCBmb3IgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZm9yRWFjaCAoYXJyYXksIGNhbGxiYWNrKSB7XG4gIC8vIGZpZ3VyZSBvdXQgd2hhdCBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleHBlY3RzXG4gIHZhciBhcmdzID0gbWF4QXJndW1lbnRDb3VudChjYWxsYmFjayk7XG5cbiAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBjb3B5IG9mIHRoZSBpbmRleCBhcnJheSBhbmQgYXBwZW5kIHRoZSBuZXcgaW5kZXggdmFsdWVcbiAgICAgICAgcmVjdXJzZShjaGlsZCwgaW5kZXguY29uY2F0KGkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCB0aGUgcmlnaHQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgaWYgKGFyZ3MgPT09IDEpIHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJncyA9PT0gMikge1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIDMgb3IgLTFcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZWN1cnNlKGFycmF5LCBbXSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdmb3JFYWNoJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaW5kZXgnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG4gIHZhciBkaXZpZGVTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvZGl2aWRlU2NhbGFyJykpO1xuICB2YXIgYWRkU2NhbGFyICAgID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FkZFNjYWxhcicpKTtcbiAgdmFyIG11bHRpcGx5ICAgICA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9tdWx0aXBseScpKTtcbiAgdmFyIHVuYXJ5TWludXMgICA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy91bmFyeU1pbnVzJykpO1xuICB2YXIgZGV0ICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi9tYXRyaXgvZGV0JykpO1xuICB2YXIgZXllICAgICAgICAgID0gbG9hZChyZXF1aXJlKCcuL2V5ZScpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIG9mIGEgc3F1YXJlIG1hdHJpeC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5pbnYoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLmludihbWzEsIDJdLCBbMywgNF1dKTsgIC8vIHJldHVybnMgW1stMiwgMV0sIFsxLjUsIC0wLjVdXVxuICAgKiAgICAgbWF0aC5pbnYoNCk7ICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDAuMjVcbiAgICogICAgIDEgLyA0OyAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwLjI1XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgZGV0LCB0cmFuc3Bvc2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggICAgIE1hdHJpeCB0byBiZSBpbnZlcnNlZFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBpbnZlcnNlIG9mIGB4YC5cbiAgICovXG4gIHZhciBpbnYgPSB0eXBlZCgnaW52Jywge1xuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB2YXIgc2l6ZSA9ICh4LmlzTWF0cml4ID09PSB0cnVlKSA/IHguc2l6ZSgpIDogdXRpbC5hcnJheS5zaXplKHgpO1xuICAgICAgc3dpdGNoIChzaXplLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gdmVjdG9yXG4gICAgICAgICAgaWYgKHNpemVbMF0gPT0gMSkge1xuICAgICAgICAgICAgaWYgKHguaXNNYXRyaXggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdHJpeChbXG4gICAgICAgICAgICAgICAgZGl2aWRlU2NhbGFyKDEsIHgudmFsdWVPZigpWzBdKVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGRpdmlkZVNjYWxhcigxLCB4WzBdKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSBzcXVhcmUgJyArXG4gICAgICAgICAgICAnKHNpemU6ICcgKyB1dGlsLnN0cmluZy5mb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgLy8gdHdvIGRpbWVuc2lvbmFsIGFycmF5XG4gICAgICAgICAgdmFyIHJvd3MgPSBzaXplWzBdO1xuICAgICAgICAgIHZhciBjb2xzID0gc2l6ZVsxXTtcbiAgICAgICAgICBpZiAocm93cyA9PSBjb2xzKSB7XG4gICAgICAgICAgICBpZiAoeC5pc01hdHJpeCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbWF0cml4KFxuICAgICAgICAgICAgICAgICAgX2ludih4LnZhbHVlT2YoKSwgcm93cywgY29scyksXG4gICAgICAgICAgICAgICAgICB4LnN0b3JhZ2UoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiBhbiBBcnJheVxuICAgICAgICAgICAgICByZXR1cm4gX2ludih4LCByb3dzLCBjb2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IG11c3QgYmUgc3F1YXJlICcgK1xuICAgICAgICAgICAgJyhzaXplOiAnICsgdXRpbC5zdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSB0d28gZGltZW5zaW9uYWwgJyArXG4gICAgICAgICAgJyhzaXplOiAnICsgdXRpbC5zdHJpbmcuZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2FueSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBzY2FsYXJcbiAgICAgIHJldHVybiBkaXZpZGVTY2FsYXIoMSwgeCk7IC8vIEZJWE1FOiBjcmVhdGUgYSBCaWdOdW1iZXIgb25lIHdoZW4gY29uZmlndXJlZCBmb3IgYmlnbnVtYmVyc1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBvZiBhIHNxdWFyZSBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheVtdfSBtYXQgICAgIEEgc3F1YXJlIG1hdHJpeFxuICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAgICAgTnVtYmVyIG9mIHJvd3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHMgICAgIE51bWJlciBvZiBjb2x1bW5zLCBtdXN0IGVxdWFsIHJvd3NcbiAgICogQHJldHVybiB7QXJyYXlbXX0gaW52ICAgIEludmVyc2UgbWF0cml4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfaW52IChtYXQsIHJvd3MsIGNvbHMpe1xuICAgIHZhciByLCBzLCBmLCB2YWx1ZSwgdGVtcDtcblxuICAgIGlmIChyb3dzID09IDEpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSAxIHggMSBtYXRyaXhcbiAgICAgIHZhbHVlID0gbWF0WzBdWzBdO1xuICAgICAgaWYgKHZhbHVlID09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgaW52ZXJzZSwgZGV0ZXJtaW5hbnQgaXMgemVybycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtbXG4gICAgICAgIGRpdmlkZVNjYWxhcigxLCB2YWx1ZSlcbiAgICAgIF1dO1xuICAgIH1cbiAgICBlbHNlIGlmIChyb3dzID09IDIpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSAyIHggMiBtYXRyaXhcbiAgICAgIHZhciBkID0gZGV0KG1hdCk7XG4gICAgICBpZiAoZCA9PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIGludmVyc2UsIGRldGVybWluYW50IGlzIHplcm8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICBkaXZpZGVTY2FsYXIobWF0WzFdWzFdLCBkKSxcbiAgICAgICAgICBkaXZpZGVTY2FsYXIodW5hcnlNaW51cyhtYXRbMF1bMV0pLCBkKVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgZGl2aWRlU2NhbGFyKHVuYXJ5TWludXMobWF0WzFdWzBdKSwgZCksXG4gICAgICAgICAgZGl2aWRlU2NhbGFyKG1hdFswXVswXSwgZClcbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIGEgbWF0cml4IG9mIDMgeCAzIG9yIGxhcmdlclxuICAgICAgLy8gY2FsY3VsYXRlIGludmVyc2UgdXNpbmcgZ2F1c3Mtam9yZGFuIGVsaW1pbmF0aW9uXG4gICAgICAvLyAgICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2F1c3NpYW5fZWxpbWluYXRpb25cbiAgICAgIC8vICAgICAgaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9NYXRyaXhJbnZlcnNlLmh0bWxcbiAgICAgIC8vICAgICAgaHR0cDovL21hdGgudXd3LmVkdS9+bWNmYXJsYXQvaW52ZXJzZS5odG1cblxuICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIG1hdHJpeCAob25seSB0aGUgYXJyYXlzLCBub3Qgb2YgdGhlIGVsZW1lbnRzKVxuICAgICAgdmFyIEEgPSBtYXQuY29uY2F0KCk7XG4gICAgICBmb3IgKHIgPSAwOyByIDwgcm93czsgcisrKSB7XG4gICAgICAgIEFbcl0gPSBBW3JdLmNvbmNhdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYW4gaWRlbnRpdHkgbWF0cml4IHdoaWNoIGluIHRoZSBlbmQgd2lsbCBjb250YWluIHRoZVxuICAgICAgLy8gbWF0cml4IGludmVyc2VcbiAgICAgIHZhciBCID0gZXllKHJvd3MpLnZhbHVlT2YoKTtcblxuICAgICAgLy8gbG9vcCBvdmVyIGFsbCBjb2x1bW5zLCBhbmQgcGVyZm9ybSByb3cgcmVkdWN0aW9uc1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2xzOyBjKyspIHtcbiAgICAgICAgLy8gZWxlbWVudCBBY2Mgc2hvdWxkIGJlIG5vbiB6ZXJvLiBpZiBub3QsIHN3YXAgY29udGVudFxuICAgICAgICAvLyB3aXRoIG9uZSBvZiB0aGUgbG93ZXIgcm93c1xuICAgICAgICByID0gYztcbiAgICAgICAgd2hpbGUgKHIgPCByb3dzICYmIEFbcl1bY10gPT0gMCkge1xuICAgICAgICAgIHIrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSByb3dzIHx8IEFbcl1bY10gPT0gMCkge1xuICAgICAgICAgIC8vIFRPRE86IGluIGNhc2Ugb2YgemVybyBkZXQsIGp1c3QgcmV0dXJuIGEgbWF0cml4IHdpaCBJbmZpbml0eSB2YWx1ZXM/IChsaWtlIG9jdGF2ZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBpbnZlcnNlLCBkZXRlcm1pbmFudCBpcyB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgIT0gYykge1xuICAgICAgICAgIHRlbXAgPSBBW2NdOyBBW2NdID0gQVtyXTsgQVtyXSA9IHRlbXA7XG4gICAgICAgICAgdGVtcCA9IEJbY107IEJbY10gPSBCW3JdOyBCW3JdID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsaW1pbmF0ZSBub24temVybyB2YWx1ZXMgb24gdGhlIG90aGVyIHJvd3MgYXQgY29sdW1uIGNcbiAgICAgICAgdmFyIEFjID0gQVtjXSxcbiAgICAgICAgICAgIEJjID0gQltjXTtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgIHZhciBBciA9IEFbcl0sXG4gICAgICAgICAgICAgIEJyID0gQltyXTtcbiAgICAgICAgICBpZihyICE9IGMpIHtcbiAgICAgICAgICAgIC8vIGVsaW1pbmF0ZSB2YWx1ZSBhdCBjb2x1bW4gYyBhbmQgcm93IHJcbiAgICAgICAgICAgIGlmIChBcltjXSAhPSAwKSB7XG4gICAgICAgICAgICAgIGYgPSBkaXZpZGVTY2FsYXIodW5hcnlNaW51cyhBcltjXSksIEFjW2NdKTtcblxuICAgICAgICAgICAgICAvLyBhZGQgKGYgKiByb3cgYykgdG8gcm93IHIgdG8gZWxpbWluYXRlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAvLyBhdCBjb2x1bW4gY1xuICAgICAgICAgICAgICBmb3IgKHMgPSBjOyBzIDwgY29sczsgcysrKSB7XG4gICAgICAgICAgICAgICAgQXJbc10gPSBhZGRTY2FsYXIoQXJbc10sIG11bHRpcGx5KGYsIEFjW3NdKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChzID0gMDsgcyA8IGNvbHM7IHMrKykge1xuICAgICAgICAgICAgICAgIEJyW3NdID0gYWRkU2NhbGFyKEJyW3NdLCAgbXVsdGlwbHkoZiwgQmNbc10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB2YWx1ZSBhdCBBY2MgdG8gMSxcbiAgICAgICAgICAgIC8vIGRpdmlkZSBlYWNoIHZhbHVlIG9uIHJvdyByIHdpdGggdGhlIHZhbHVlIGF0IEFjY1xuICAgICAgICAgICAgZiA9IEFjW2NdO1xuICAgICAgICAgICAgZm9yIChzID0gYzsgcyA8IGNvbHM7IHMrKykge1xuICAgICAgICAgICAgICBBcltzXSA9IGRpdmlkZVNjYWxhcihBcltzXSwgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHMgPSAwOyBzIDwgY29sczsgcysrKSB7XG4gICAgICAgICAgICAgIEJyW3NdID0gZGl2aWRlU2NhbGFyKEJyW3NdLCBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBCO1xuICAgIH1cbiAgfVxuXG4gIGludi50b1RleCA9IHsxOiAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCleey0xfSd9O1xuXG4gIHJldHVybiBpbnY7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpbnYnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1heEFyZ3VtZW50Q291bnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9mdW5jdGlvbicpLm1heEFyZ3VtZW50Q291bnQ7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtYXRyaXggb3IgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgb25cbiAgICogZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4L2FycmF5LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubWFwKHgsIGNhbGxiYWNrKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5tYXAoWzEsIDIsIDNdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgKiAgICAgIHJldHVybiB2YWx1ZSAqIHZhbHVlO1xuICAgKiAgICB9KTsgIC8vIHJldHVybnMgWzEsIDQsIDldXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBmaWx0ZXIsIGZvckVhY2gsIHNvcnRcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXggfCBBcnJheX0geCAgICBUaGUgbWF0cml4IHRvIGl0ZXJhdGUgb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBlbGVtZW50LCBhbmQgdGhlIG1hdHJpeCBiZWluZyB0cmF2ZXJzZWQuXG4gICAqIEByZXR1cm4ge01hdHJpeCB8IGFycmF5fSAgICAgVHJhbnNmb3JtZWQgbWFwIG9mIHhcbiAgICovXG4gIHZhciBtYXAgPSB0eXBlZCgnbWFwJywge1xuICAgICdBcnJheSwgZnVuY3Rpb24nOiBfbWFwLFxuXG4gICAgJ01hdHJpeCwgZnVuY3Rpb24nOiBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB4Lm1hcChjYWxsYmFjayk7XG4gICAgfVxuICB9KTtcblxuICBtYXAudG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBNYXAgZm9yIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfbWFwIChhcnJheSwgY2FsbGJhY2spIHtcbiAgLy8gZmlndXJlIG91dCB3aGF0IG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4cGVjdHNcbiAgdmFyIGFyZ3MgPSBtYXhBcmd1bWVudENvdW50KGNhbGxiYWNrKTtcblxuICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGluZGV4IGFycmF5IGFuZCBhcHBlbmQgdGhlIG5ldyBpbmRleCB2YWx1ZVxuICAgICAgICByZXR1cm4gcmVjdXJzZShjaGlsZCwgaW5kZXguY29uY2F0KGkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCB0aGUgcmlnaHQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgaWYgKGFyZ3MgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3MgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gMyBvciAtMVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiByZWN1cnNlKGFycmF5LCBbXSk7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtYXAnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIFpFUk8gPSBuZXcgdHlwZS5CaWdOdW1iZXIoMCk7XG4gIHZhciBPTkUgPSBuZXcgdHlwZS5CaWdOdW1iZXIoMSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcnJheSBmcm9tIGEgcmFuZ2UuXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSByYW5nZSBlbmQgaXMgZXhjbHVkZWQuIFRoaXMgY2FuIGJlIGN1c3RvbWl6ZWQgYnkgcHJvdmlkaW5nXG4gICAqIGFuIGV4dHJhIHBhcmFtZXRlciBgaW5jbHVkZUVuZGAuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGgucmFuZ2Uoc3RyIFssIGluY2x1ZGVFbmRdKSAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHJhbmdlIGZyb20gYSBzdHJpbmcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSB0aGUgc3RyaW5nIGNvbnRhaW5zIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQsIG9wdGlvbmFsIHN0ZXAsIGFuZCBlbmQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZWQgYnkgYSBjb2xvbi5cbiAgICogICAgIG1hdGgucmFuZ2Uoc3RhcnQsIGVuZCBbLCBpbmNsdWRlRW5kXSkgICAgICAgIC8vIENyZWF0ZSBhIHJhbmdlIHdpdGggc3RhcnQgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmQgYW5kIGEgc3RlcCBzaXplIG9mIDEuXG4gICAqICAgICBtYXRoLnJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAgWywgaW5jbHVkZUVuZF0pICAvLyBDcmVhdGUgYSByYW5nZSB3aXRoIHN0YXJ0LCBzdGVwLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGVuZC5cbiAgICpcbiAgICogV2hlcmU6XG4gICAqXG4gICAqIC0gYHN0cjogc3RyaW5nYFxuICAgKiAgIEEgc3RyaW5nICdzdGFydDplbmQnIG9yICdzdGFydDpzdGVwOmVuZCdcbiAgICogLSBgc3RhcnQ6IHtudW1iZXIgfCBCaWdOdW1iZXJ9YFxuICAgKiAgIFN0YXJ0IG9mIHRoZSByYW5nZVxuICAgKiAtIGBlbmQ6IG51bWJlciB8IEJpZ051bWJlcmBcbiAgICogICBFbmQgb2YgdGhlIHJhbmdlLCBleGNsdWRlZCBieSBkZWZhdWx0LCBpbmNsdWRlZCB3aGVuIHBhcmFtZXRlciBpbmNsdWRlRW5kPXRydWVcbiAgICogLSBgc3RlcDogbnVtYmVyIHwgQmlnTnVtYmVyYFxuICAgKiAgIFN0ZXAgc2l6ZS4gRGVmYXVsdCB2YWx1ZSBpcyAxLlxuICAgKiAtIGBpbmNsdWRlRW5kOiBib29sZWFuYFxuICAgKiAgIE9wdGlvbiB0byBzcGVjaWZ5IHdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgZW5kIG9yIG5vdC4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLnJhbmdlKDIsIDYpOyAgICAgICAgLy8gWzIsIDMsIDQsIDVdXG4gICAqICAgICBtYXRoLnJhbmdlKDIsIC0zLCAtMSk7ICAgLy8gWzIsIDEsIDAsIC0xLCAtMl1cbiAgICogICAgIG1hdGgucmFuZ2UoJzI6MTo2Jyk7ICAgICAvLyBbMiwgMywgNCwgNV1cbiAgICogICAgIG1hdGgucmFuZ2UoMiwgNiwgdHJ1ZSk7ICAvLyBbMiwgMywgNCwgNSwgNl1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgICBvbmVzLCB6ZXJvcywgc2l6ZSwgc3Vic2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYXJncyAgIFBhcmFtZXRlcnMgZGVzY3JpYmluZyB0aGUgcmFuZ2VzIGBzdGFydGAsIGBlbmRgLCBhbmQgb3B0aW9uYWwgYHN0ZXBgLlxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gcmFuZ2VcbiAgICovXG4gIHZhciByYW5nZSA9IHR5cGVkKCdyYW5nZScsIHtcbiAgICAvLyBUT0RPOiBzaW1wbGlmeSBzaWduYXR1cmVzIHdoZW4gdHlwZWQtZnVuY3Rpb24gc3VwcG9ydHMgZGVmYXVsdCB2YWx1ZXMgYW5kIG9wdGlvbmFsIGFyZ3VtZW50c1xuXG4gICAgLy8gVE9ETzogYSBudW1iZXIgb3IgYm9vbGVhbiBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgaGVyZVxuICAgICdzdHJpbmcnOiBfc3RyUmFuZ2UsXG4gICAgJ3N0cmluZywgYm9vbGVhbic6IF9zdHJSYW5nZSxcblxuICAgICdudW1iZXIsIG51bWJlcic6ICBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIF9vdXQoX3JhbmdlRXgoc3RhcnQsIGVuZCwgMSkpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgcmV0dXJuIF9vdXQoX3JhbmdlRXgoc3RhcnQsIGVuZCwgc3RlcCkpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyLCBib29sZWFuJzogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGluY2x1ZGVFbmQpIHtcbiAgICAgIHJldHVybiBpbmNsdWRlRW5kXG4gICAgICAgICAgPyBfb3V0KF9yYW5nZUluYyhzdGFydCwgZW5kLCAxKSlcbiAgICAgICAgICA6IF9vdXQoX3JhbmdlRXgoc3RhcnQsIGVuZCwgMSkpO1xuICAgIH0sXG4gICAgJ251bWJlciwgbnVtYmVyLCBudW1iZXIsIGJvb2xlYW4nOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCwgaW5jbHVkZUVuZCkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVFbmRcbiAgICAgICAgICA/IF9vdXQoX3JhbmdlSW5jKHN0YXJ0LCBlbmQsIHN0ZXApKVxuICAgICAgICAgIDogX291dChfcmFuZ2VFeChzdGFydCwgZW5kLCBzdGVwKSk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6ICBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIF9vdXQoX2JpZ1JhbmdlRXgoc3RhcnQsIGVuZCwgT05FKSk7XG4gICAgfSxcbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICByZXR1cm4gX291dChfYmlnUmFuZ2VFeChzdGFydCwgZW5kLCBzdGVwKSk7XG4gICAgfSxcbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXIsIGJvb2xlYW4nOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgaW5jbHVkZUVuZCkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVFbmRcbiAgICAgICAgICA/IF9vdXQoX2JpZ1JhbmdlSW5jKHN0YXJ0LCBlbmQsIE9ORSkpXG4gICAgICAgICAgOiBfb3V0KF9iaWdSYW5nZUV4KHN0YXJ0LCBlbmQsIE9ORSkpO1xuICAgIH0sXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyLCBCaWdOdW1iZXIsIGJvb2xlYW4nOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCwgaW5jbHVkZUVuZCkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVFbmRcbiAgICAgICAgICA/IF9vdXQoX2JpZ1JhbmdlSW5jKHN0YXJ0LCBlbmQsIHN0ZXApKVxuICAgICAgICAgIDogX291dChfYmlnUmFuZ2VFeChzdGFydCwgZW5kLCBzdGVwKSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHJhbmdlLnRvVGV4ID0gdW5kZWZpbmVkOyAvLyB1c2UgZGVmYXVsdCB0ZW1wbGF0ZVxuXG4gIHJldHVybiByYW5nZTtcblxuICBmdW5jdGlvbiBfb3V0KGFycikge1xuICAgIHJldHVybiBjb25maWcubWF0cml4ID09PSAnQXJyYXknID8gYXJyIDogbWF0cml4KGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBfc3RyUmFuZ2UgKHN0ciwgaW5jbHVkZUVuZCkge1xuICAgIHZhciByID0gX3BhcnNlKHN0cik7XG4gICAgaWYgKCFyKXtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignU3RyaW5nIFwiJyArIHN0ciArICdcIiBpcyBubyB2YWxpZCByYW5nZScpO1xuICAgIH1cblxuICAgIHZhciBmbjtcbiAgICBpZiAoY29uZmlnLm51bWJlciA9PT0gJ0JpZ051bWJlcicpIHtcbiAgICAgIGZuID0gaW5jbHVkZUVuZCA/IF9iaWdSYW5nZUluYyA6IF9iaWdSYW5nZUV4O1xuICAgICAgcmV0dXJuIF9vdXQoZm4oXG4gICAgICAgICAgbmV3IHR5cGUuQmlnTnVtYmVyKHIuc3RhcnQpLFxuICAgICAgICAgIG5ldyB0eXBlLkJpZ051bWJlcihyLmVuZCksXG4gICAgICAgICAgbmV3IHR5cGUuQmlnTnVtYmVyKHIuc3RlcCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmbiA9IGluY2x1ZGVFbmQgPyBfcmFuZ2VJbmMgOiBfcmFuZ2VFeDtcbiAgICAgIHJldHVybiBfb3V0KGZuKHIuc3RhcnQsIHIuZW5kLCByLnN0ZXApKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmFuZ2Ugd2l0aCBudW1iZXJzLiBFbmQgaXMgZXhjbHVkZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXBcbiAgICogQHJldHVybnMge0FycmF5fSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3JhbmdlRXggKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICB2YXIgYXJyYXkgPSBbXSxcbiAgICAgICAgeCA9IHN0YXJ0O1xuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHggPCBlbmQpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCArPSBzdGVwO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgd2hpbGUgKHggPiBlbmQpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCArPSBzdGVwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZSB3aXRoIG51bWJlcnMuIEVuZCBpcyBpbmNsdWRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfcmFuZ2VJbmMgKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICB2YXIgYXJyYXkgPSBbXSxcbiAgICAgICAgeCA9IHN0YXJ0O1xuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHggPD0gZW5kKSB7XG4gICAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgICAgIHggKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHdoaWxlICh4ID49IGVuZCkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJhbmdlIHdpdGggYmlnIG51bWJlcnMuIEVuZCBpcyBleGNsdWRlZFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IGVuZFxuICAgKiBAcGFyYW0ge0JpZ051bWJlcn0gc3RlcFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHJhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfYmlnUmFuZ2VFeCAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIHZhciBhcnJheSA9IFtdLFxuICAgICAgICB4ID0gc3RhcnQ7XG4gICAgaWYgKHN0ZXAuZ3QoWkVSTykpIHtcbiAgICAgIHdoaWxlICh4Lmx0KGVuZCkpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCA9IHgucGx1cyhzdGVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RlcC5sdChaRVJPKSkge1xuICAgICAgd2hpbGUgKHguZ3QoZW5kKSkge1xuICAgICAgICBhcnJheS5wdXNoKHgpO1xuICAgICAgICB4ID0geC5wbHVzKHN0ZXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZSB3aXRoIGJpZyBudW1iZXJzLiBFbmQgaXMgaW5jbHVkZWRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBlbmRcbiAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IHN0ZXBcbiAgICogQHJldHVybnMge0FycmF5fSByYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2JpZ1JhbmdlSW5jIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgIHggPSBzdGFydDtcbiAgICBpZiAoc3RlcC5ndChaRVJPKSkge1xuICAgICAgd2hpbGUgKHgubHRlKGVuZCkpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCA9IHgucGx1cyhzdGVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RlcC5sdChaRVJPKSkge1xuICAgICAgd2hpbGUgKHguZ3RlKGVuZCkpIHtcbiAgICAgICAgYXJyYXkucHVzaCh4KTtcbiAgICAgICAgeCA9IHgucGx1cyhzdGVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzdHJpbmcgaW50byBhIHJhbmdlLFxuICAgKiBUaGUgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdGFydCwgb3B0aW9uYWwgc3RlcCwgYW5kIGVuZCwgc2VwYXJhdGVkIGJ5IGEgY29sb24uXG4gICAqIElmIHRoZSBzdHJpbmcgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHJhbmdlLCBudWxsIGlzIHJldHVybmVkLlxuICAgKiBGb3IgZXhhbXBsZSBzdHI9JzA6MjoxMScuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzdGVwOiBudW1iZXJ9IHwgbnVsbH0gcmFuZ2UgT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBzdGFydCwgZW5kLCBzdGVwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfcGFyc2UgKHN0cikge1xuICAgIHZhciBhcmdzID0gc3RyLnNwbGl0KCc6Jyk7XG5cbiAgICAvLyBudW1iZXJcbiAgICB2YXIgbnVtcyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIC8vIHVzZSBOdW1iZXIgYW5kIG5vdCBwYXJzZUZsb2F0IGFzIE51bWJlciByZXR1cm5zIE5hTiBvbiBpbnZhbGlkIGdhcmJhZ2UgaW4gdGhlIHN0cmluZ1xuICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgIH0pO1xuXG4gICAgdmFyIGludmFsaWQgPSBudW1zLnNvbWUoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuIGlzTmFOKG51bSk7XG4gICAgfSk7XG4gICAgaWYoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChudW1zLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiBudW1zWzBdLFxuICAgICAgICAgIGVuZDogbnVtc1sxXSxcbiAgICAgICAgICBzdGVwOiAxXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydDogbnVtc1swXSxcbiAgICAgICAgICBlbmQ6IG51bXNbMl0sXG4gICAgICAgICAgc3RlcDogbnVtc1sxXVxuICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnRzLm5hbWUgPSAncmFuZ2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsb25lID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuY2xvbmU7XG52YXIgdmFsaWRhdGVJbmRleCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2FycmF5JykudmFsaWRhdGVJbmRleDtcbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGEgc3Vic2V0IG9mIGEgbWF0cml4IG9yIHN0cmluZy5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKiAgICAgbWF0aC5zdWJzZXQodmFsdWUsIGluZGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgYSBzdWJzZXRcbiAgICogICAgIG1hdGguc3Vic2V0KHZhbHVlLCBpbmRleCwgcmVwbGFjZW1lbnQgWywgZGVmYXVsdFZhbHVlXSkgIC8vIHJlcGxhY2UgYSBzdWJzZXRcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICAvLyBnZXQgYSBzdWJzZXRcbiAgICogICAgIHZhciBkID0gW1sxLCAyXSwgWzMsIDRdXTtcbiAgICogICAgIG1hdGguc3Vic2V0KGQsIG1hdGguaW5kZXgoMSwgMCkpOyAgICAgICAgLy8gcmV0dXJucyAzXG4gICAqICAgICBtYXRoLnN1YnNldChkLCBtYXRoLmluZGV4KFswLCAyXSwgMSkpOyAgIC8vIHJldHVybnMgW1syXSwgWzRdXVxuICAgKlxuICAgKiAgICAgLy8gcmVwbGFjZSBhIHN1YnNldFxuICAgKiAgICAgdmFyIGUgPSBbXTtcbiAgICogICAgIHZhciBmID0gbWF0aC5zdWJzZXQoZSwgbWF0aC5pbmRleCgwLCBbMCwgMl0pLCBbNSwgNl0pOyAgLy8gZiA9IFtbNSwgNl1dXG4gICAqICAgICB2YXIgZyA9IG1hdGguc3Vic2V0KGYsIG1hdGguaW5kZXgoMSwgMSksIDcsIDApOyAgICAgICAgIC8vIGcgPSBbWzUsIDZdLCBbMCwgN11dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgc2l6ZSwgcmVzaXplLCBzcXVlZXplLCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4IHwgc3RyaW5nfSBtYXRyaXggIEFuIGFycmF5LCBtYXRyaXgsIG9yIHN0cmluZ1xuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleCAgICAgICAgICAgICAgICAgICAgIEFuIGluZGV4IGNvbnRhaW5pbmcgcmFuZ2VzIGZvciBlYWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uXG4gICAqIEBwYXJhbSB7Kn0gW3JlcGxhY2VtZW50XSAgICAgICAgICAgICAgICAgQW4gYXJyYXksIG1hdHJpeCwgb3Igc2NhbGFyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHByb3ZpZGVkLCB0aGUgc3Vic2V0IGlzIHJlcGxhY2VkIHdpdGggcmVwbGFjZW1lbnQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgc3Vic2V0IGlzIHJldHVybmVkXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZT11bmRlZmluZWRdICAgICAgRGVmYXVsdCB2YWx1ZSwgZmlsbGVkIGluIG9uIG5ldyBlbnRyaWVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbWF0cml4IGlzIHJlc2l6ZWQuIElmIG5vdCBwcm92aWRlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm1hdHJpeCBlbGVtZW50cyB3aWxsIGJlIGxlZnQgdW5kZWZpbmVkLlxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeCB8IHN0cmluZ30gRWl0aGVyIHRoZSByZXRyaWV2ZWQgc3Vic2V0IG9yIHRoZSB1cGRhdGVkIG1hdHJpeC5cbiAgICovXG4gIHZhciBzdWJzZXQgPSB0eXBlZCgnc3Vic2V0Jywge1xuICAgIC8vIGdldCBzdWJzZXRcbiAgICAnQXJyYXksIEluZGV4JzogZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgdmFyIG0gPSBtYXRyaXgodmFsdWUpO1xuICAgICAgdmFyIHN1YnNldCA9IG0uc3Vic2V0KGluZGV4KTsgICAgICAgLy8gcmV0dXJucyBhIE1hdHJpeFxuICAgICAgcmV0dXJuIHN1YnNldCAmJiBzdWJzZXQudmFsdWVPZigpOyAgLy8gcmV0dXJuIGFuIEFycmF5IChsaWtlIHRoZSBpbnB1dClcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgSW5kZXgnOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3Vic2V0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgJ09iamVjdCwgSW5kZXgnOiBfZ2V0T2JqZWN0UHJvcGVydHksXG5cbiAgICAnc3RyaW5nLCBJbmRleCc6IF9nZXRTdWJzdHJpbmcsXG5cbiAgICAvLyBzZXQgc3Vic2V0XG4gICAgJ0FycmF5LCBJbmRleCwgYW55JzogZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBtYXRyaXgoY2xvbmUodmFsdWUpKVxuICAgICAgICAgIC5zdWJzZXQoaW5kZXgsIHJlcGxhY2VtZW50LCB1bmRlZmluZWQpXG4gICAgICAgICAgLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBJbmRleCwgYW55LCBhbnknOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gbWF0cml4KGNsb25lKHZhbHVlKSlcbiAgICAgICAgICAuc3Vic2V0KGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKVxuICAgICAgICAgIC52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEluZGV4LCBhbnknOiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmNsb25lKCkuc3Vic2V0KGluZGV4LCByZXBsYWNlbWVudCk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEluZGV4LCBhbnksIGFueSc6IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIHJlcGxhY2VtZW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpLnN1YnNldChpbmRleCwgcmVwbGFjZW1lbnQsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIEluZGV4LCBzdHJpbmcnOiBfc2V0U3Vic3RyaW5nLFxuICAgICdzdHJpbmcsIEluZGV4LCBzdHJpbmcsIHN0cmluZyc6IF9zZXRTdWJzdHJpbmcsXG4gICAgJ09iamVjdCwgSW5kZXgsIGFueSc6IF9zZXRPYmplY3RQcm9wZXJ0eVxuICB9KTtcblxuICBzdWJzZXQudG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIHN1YnNldDtcblxuICAvKipcbiAgICogUmV0cmlldmUgYSBzdWJzZXQgb2YgYSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAgICAgICAgICAgIHN0cmluZyBmcm9tIHdoaWNoIHRvIGdldCBhIHN1YnN0cmluZ1xuICAgKiBAcGFyYW0ge0luZGV4fSBpbmRleCAgICAgICAgICAgQW4gaW5kZXggY29udGFpbmluZyByYW5nZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHN1YnN0cmluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFN1YnN0cmluZyhzdHIsIGluZGV4KSB7XG4gICAgaWYgKCFpbmRleCB8fCBpbmRleC5pc0luZGV4ICE9PSB0cnVlKSB7XG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGluZGV4LnNpemUoKS5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGluZGV4LnNpemUoKS5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHdoZXRoZXIgdGhlIHJhbmdlIGlzIG91dCBvZiByYW5nZVxuICAgIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhbGlkYXRlSW5kZXgoaW5kZXgubWluKClbMF0sIHN0ckxlbik7XG4gICAgdmFsaWRhdGVJbmRleChpbmRleC5tYXgoKVswXSwgc3RyTGVuKTtcblxuICAgIHZhciByYW5nZSA9IGluZGV4LmRpbWVuc2lvbigwKTtcblxuICAgIHZhciBzdWJzdHIgPSAnJztcbiAgICByYW5nZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBzdWJzdHIgKz0gc3RyLmNoYXJBdCh2KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdWJzdHI7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSBhIHN1YnN0cmluZyBpbiBhIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyICAgICAgICAgICAgc3RyaW5nIHRvIGJlIHJlcGxhY2VkXG4gICAqIEBwYXJhbSB7SW5kZXh9IGluZGV4ICAgICAgICAgICBBbiBpbmRleCBjb250YWluaW5nIHJhbmdlcyBmb3IgZWFjaCBkaW1lbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2VtZW50ICAgIFJlcGxhY2VtZW50IHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRWYWx1ZV0gRGVmYXVsdCB2YWx1ZSB0byBiZSB1c2VzIHdoZW4gcmVzaXppbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdHJpbmcuIGlzICcgJyBieSBkZWZhdWx0XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3NldFN1YnN0cmluZyhzdHIsIGluZGV4LCByZXBsYWNlbWVudCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKCFpbmRleCB8fCBpbmRleC5pc0luZGV4ICE9PSB0cnVlKSB7XG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGluZGV4LnNpemUoKS5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGluZGV4LnNpemUoKS5sZW5ndGgsIDEpO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAnc3RyaW5nJyB8fCBkZWZhdWx0VmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpbmdsZSBjaGFyYWN0ZXIgZXhwZWN0ZWQgYXMgZGVmYXVsdFZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyAnO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IGluZGV4LmRpbWVuc2lvbigwKTtcbiAgICB2YXIgbGVuID0gcmFuZ2Uuc2l6ZSgpWzBdO1xuXG4gICAgaWYgKGxlbiAhPSByZXBsYWNlbWVudC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihyYW5nZS5zaXplKClbMF0sIHJlcGxhY2VtZW50Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgd2hldGhlciB0aGUgcmFuZ2UgaXMgb3V0IG9mIHJhbmdlXG4gICAgdmFyIHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdmFsaWRhdGVJbmRleChpbmRleC5taW4oKVswXSk7XG4gICAgdmFsaWRhdGVJbmRleChpbmRleC5tYXgoKVswXSk7XG5cbiAgICAvLyBjb3B5IHRoZSBzdHJpbmcgaW50byBhbiBhcnJheSB3aXRoIGNoYXJhY3RlcnNcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ckxlbjsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuXG4gICAgcmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgY2hhcnNbdl0gPSByZXBsYWNlbWVudC5jaGFyQXQoaVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBpbml0aWFsaXplIHVuZGVmaW5lZCBjaGFyYWN0ZXJzIHdpdGggYSBzcGFjZVxuICAgIGlmIChjaGFycy5sZW5ndGggPiBzdHJMZW4pIHtcbiAgICAgIGZvciAoaSA9IHN0ckxlbiAtIDEsIGxlbiA9IGNoYXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghY2hhcnNbaV0pIHtcbiAgICAgICAgICBjaGFyc1tpXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlIGEgcHJvcGVydHkgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7SW5kZXh9IGluZGV4XG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRPYmplY3RQcm9wZXJ0eSAob2JqZWN0LCBpbmRleCkge1xuICBpZiAoaW5kZXguc2l6ZSgpLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihpbmRleC5zaXplKCksIDEpO1xuICB9XG5cbiAgdmFyIGtleSA9IGluZGV4LmRpbWVuc2lvbigwKTtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkIGFzIGluZGV4IHRvIHJldHJpZXZlIGFuIG9iamVjdCBwcm9wZXJ0eScpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtJbmRleH0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gcmVwbGFjZW1lbnRcbiAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIHVwZGF0ZWQgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2V0T2JqZWN0UHJvcGVydHkgKG9iamVjdCwgaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gIGlmIChpbmRleC5zaXplKCkubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKGluZGV4LnNpemUoKSwgMSk7XG4gIH1cblxuICB2YXIga2V5ID0gaW5kZXguZGltZW5zaW9uKDApO1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdHJpbmcgZXhwZWN0ZWQgYXMgaW5kZXggdG8gcmV0cmlldmUgYW4gb2JqZWN0IHByb3BlcnR5Jyk7XG4gIH1cblxuICAvLyBjbG9uZSB0aGUgb2JqZWN0LCBhbmQgYXBwbHkgdGhlIHByb3BlcnR5IHRvIHRoZSBjbG9uZVxuICB2YXIgdXBkYXRlZCA9IGNsb25lKG9iamVjdCk7XG4gIHVwZGF0ZWRba2V5XSA9IHJlcGxhY2VtZW50O1xuXG4gIHJldHVybiB1cGRhdGVkO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc3Vic2V0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmNsb25lO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpLmZvcm1hdDtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgYWRkID0gbG9hZChyZXF1aXJlKCcuLi9hcml0aG1ldGljL2FkZCcpKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB0cmFjZSBvZiBhIG1hdHJpeDogdGhlIHN1bSBvZiB0aGUgZWxlbWVudHMgb24gdGhlIG1haW5cbiAgICogZGlhZ29uYWwgb2YgYSBzcXVhcmUgbWF0cml4LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgudHJhY2UoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgudHJhY2UoW1sxLCAyXSwgWzMsIDRdXSk7IC8vIHJldHVybnMgNVxuICAgKlxuICAgKiAgICB2YXIgQSA9IFtcbiAgICogICAgICBbMSwgMiwgM10sXG4gICAqICAgICAgWy0xLCAyLCAzXSxcbiAgICogICAgICBbMiwgMCwgM11cbiAgICogICAgXVxuICAgKiAgICBtYXRoLnRyYWNlKEEpOyAvLyByZXR1cm5zIDZcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGRpYWdcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0geCAgQSBtYXRyaXhcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdHJhY2Ugb2YgYHhgXG4gICAqL1xuICB2YXIgdHJhY2UgPSB0eXBlZCgndHJhY2UnLCB7XG4gICAgXG4gICAgJ0FycmF5JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIHVzZSBkZW5zZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiB0cmFjZShtYXRyaXgoeCkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBwcm9jZXNzIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ2RlbnNlJzpcbiAgICAgICAgICBjID0gX2RlbnNlVHJhY2UoeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IF9zcGFyc2VUcmFjZSh4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgXG4gICAgJ2FueSc6IGNsb25lXG4gIH0pO1xuICBcbiAgdmFyIF9kZW5zZVRyYWNlID0gZnVuY3Rpb24gKG0pIHtcbiAgICAvLyBtYXRyaXggc2l6ZSAmIGRhdGFcbiAgICB2YXIgc2l6ZSA9IG0uX3NpemU7XG4gICAgdmFyIGRhdGEgPSBtLl9kYXRhO1xuICAgIFxuICAgIC8vIHByb2Nlc3MgZGltZW5zaW9uc1xuICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gdmVjdG9yXG4gICAgICAgIGlmIChzaXplWzBdID09IDEpIHtcbiAgICAgICAgICAvLyByZXR1cm4gZGF0YVswXVxuICAgICAgICAgIHJldHVybiBjbG9uZShkYXRhWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IG11c3QgYmUgc3F1YXJlIChzaXplOiAnICsgZm9ybWF0KHNpemUpICsgJyknKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdHdvIGRpbWVuc2lvbmFsXG4gICAgICAgIHZhciByb3dzID0gc2l6ZVswXTtcbiAgICAgICAgdmFyIGNvbHMgPSBzaXplWzFdO1xuICAgICAgICBpZiAocm93cyA9PT0gY29scykge1xuICAgICAgICAgIC8vIGNhbHVsYXRlIHN1bVxuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIC8vIGxvb3AgZGlhZ29uYWxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKylcbiAgICAgICAgICAgIHN1bSA9IGFkZChzdW0sIGRhdGFbaV1baV0pO1xuICAgICAgICAgIC8vIHJldHVybiB0cmFjZVxuICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZSAoc2l6ZTogJyArIGZvcm1hdChzaXplKSArICcpJyk7ICAgICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG11bHRpIGRpbWVuc2lvbmFsXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaXggbXVzdCBiZSB0d28gZGltZW5zaW9uYWwgKHNpemU6ICcgKyBmb3JtYXQoc2l6ZSkgKyAnKScpO1xuICAgIH1cbiAgfTtcbiAgXG4gIHZhciBfc3BhcnNlVHJhY2UgPSBmdW5jdGlvbiAobSkge1xuICAgIC8vIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgdmFsdWVzID0gbS5fdmFsdWVzO1xuICAgIHZhciBpbmRleCA9IG0uX2luZGV4O1xuICAgIHZhciBwdHIgPSBtLl9wdHI7XG4gICAgdmFyIHNpemUgPSBtLl9zaXplO1xuICAgIC8vIGNoZWNrIGRpbWVuc2lvbnNcbiAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBzaXplWzFdO1xuICAgIC8vIG1hdHJpeCBtdXN0IGJlIHNxdWFyZVxuICAgIGlmIChyb3dzID09PSBjb2x1bW5zKSB7XG4gICAgICAvLyBjYWx1bGF0ZSBzdW1cbiAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgLy8gY2hlY2sgd2UgaGF2ZSBkYXRhIChhdm9pZCBsb29waW5nIGNvbHVtbnMpXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgLy8gazAgPD0gayA8IGsxIHdoZXJlIGswID0gX3B0cltqXSAmJiBrMSA9IF9wdHJbaisxXVxuICAgICAgICAgIHZhciBrMCA9IHB0cltqXTtcbiAgICAgICAgICB2YXIgazEgPSBwdHJbaiArIDFdO1xuICAgICAgICAgIC8vIGxvb3AgayB3aXRoaW4gW2swLCBrMVtcbiAgICAgICAgICBmb3IgKHZhciBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgICAgICAvLyByb3cgaW5kZXhcbiAgICAgICAgICAgIHZhciBpID0gaW5kZXhba107XG4gICAgICAgICAgICAvLyBjaGVjayByb3dcbiAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdmFsdWVcbiAgICAgICAgICAgICAgc3VtID0gYWRkKHN1bSwgdmFsdWVzW2tdKTtcbiAgICAgICAgICAgICAgLy8gZXhpdCBsb29wXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgICAgIC8vIGV4aXQgbG9vcCwgbm8gdmFsdWUgb24gdGhlIGRpYWdvbmFsIGZvciBjb2x1bW4galxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiB0cmFjZVxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZSAoc2l6ZTogJyArIGZvcm1hdChzaXplKSArICcpJyk7ICAgXG4gIH07XG5cbiAgdHJhY2UudG9UZXggPSB7MTogJ1xcXFxtYXRocm17dHJ9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcbiAgXG4gIHJldHVybiB0cmFjZTtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3RyYWNlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpLmNsb25lO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpLmZvcm1hdDtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4LFxuICAgICAgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIFRyYW5zcG9zZSBhIG1hdHJpeC4gQWxsIHZhbHVlcyBvZiB0aGUgbWF0cml4IGFyZSByZWZsZWN0ZWQgb3ZlciBpdHNcbiAgICogbWFpbiBkaWFnb25hbC4gT25seSBhcHBsaWNhYmxlIHRvIHR3byBkaW1lbnNpb25hbCBtYXRyaWNlcyBjb250YWluaW5nXG4gICAqIGEgdmVjdG9yIChpLmUuIGhhdmluZyBzaXplIGBbMSxuXWAgb3IgYFtuLDFdYCkuIE9uZSBkaW1lbnNpb25hbFxuICAgKiB2ZWN0b3JzIGFuZCBzY2FsYXJzIHJldHVybiB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLnRyYW5zcG9zZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIHZhciBBID0gW1sxLCAyLCAzXSwgWzQsIDUsIDZdXTtcbiAgICogICAgIG1hdGgudHJhbnNwb3NlKEEpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1sxLCA0XSwgWzIsIDVdLCBbMywgNl1dXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICAgZGlhZywgaW52LCBzdWJzZXQsIHNxdWVlemVcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0geCAgTWF0cml4IHRvIGJlIHRyYW5zcG9zZWRcbiAgICogQHJldHVybiB7QXJyYXkgfCBNYXRyaXh9ICAgVGhlIHRyYW5zcG9zZWQgbWF0cml4XG4gICAqL1xuICB2YXIgdHJhbnNwb3NlID0gdHlwZWQoJ3RyYW5zcG9zZScsIHtcblxuICAgICdBcnJheSc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyB1c2UgZGVuc2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gdHJhbnNwb3NlKG1hdHJpeCh4KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIG1hdHJpeCBzaXplXG4gICAgICB2YXIgc2l6ZSA9IHguc2l6ZSgpO1xuXG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgXG4gICAgICAvLyBwcm9jZXNzIGRpbWVuc2lvbnNcbiAgICAgIHN3aXRjaCAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIHZlY3RvclxuICAgICAgICAgIGMgPSB4LmNsb25lKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIHJvd3MgYW5kIGNvbHVtbnNcbiAgICAgICAgICB2YXIgcm93cyA9IHNpemVbMF07XG4gICAgICAgICAgdmFyIGNvbHVtbnMgPSBzaXplWzFdO1xuXG4gICAgICAgICAgLy8gY2hlY2sgY29sdW1uc1xuICAgICAgICAgIGlmIChjb2x1bW5zID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBleGNlcHRpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDYW5ub3QgdHJhbnNwb3NlIGEgMkQgbWF0cml4IHdpdGggbm8gY29sdW1ucyAoc2l6ZTogJyArIGZvcm1hdChzaXplKSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJvY2VzcyBzdG9yYWdlIGZvcm1hdFxuICAgICAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RlbnNlJzpcbiAgICAgICAgICAgICAgYyA9IF9kZW5zZVRyYW5zcG9zZSh4LCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICBjID0gX3NwYXJzZVRyYW5zcG9zZSh4LCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIG11bHRpIGRpbWVuc2lvbmFsXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpeCBtdXN0IGJlIGEgdmVjdG9yIG9yIHR3byBkaW1lbnNpb25hbCAoc2l6ZTogJyArIGZvcm1hdCh0aGlzLl9zaXplKSArICcpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgLy8gc2NhbGFyc1xuICAgICdhbnknOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGNsb25lKHgpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIF9kZW5zZVRyYW5zcG9zZSA9IGZ1bmN0aW9uIChtLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgLy8gbWF0cml4IGFycmF5XG4gICAgdmFyIGRhdGEgPSBtLl9kYXRhO1xuICAgIC8vIHRyYW5zcG9zZWQgbWF0cml4IGRhdGFcbiAgICB2YXIgdHJhbnNwb3NlZCA9IFtdO1xuICAgIHZhciB0cmFuc3Bvc2VkUm93O1xuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBpbml0aWFsaXplIHJvd1xuICAgICAgdHJhbnNwb3NlZFJvdyA9IHRyYW5zcG9zZWRbal0gPSBbXTtcbiAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgLy8gc2V0IGRhdGFcbiAgICAgICAgdHJhbnNwb3NlZFJvd1tpXSA9IGNsb25lKGRhdGFbaV1bal0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiB0cmFuc3Bvc2VkLFxuICAgICAgc2l6ZTogW2NvbHVtbnMsIHJvd3NdLFxuICAgICAgZGF0YXR5cGU6IG0uX2RhdGF0eXBlXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9zcGFyc2VUcmFuc3Bvc2UgPSBmdW5jdGlvbiAobSwgcm93cywgY29sdW1ucykge1xuICAgIC8vIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgdmFsdWVzID0gbS5fdmFsdWVzO1xuICAgIHZhciBpbmRleCA9IG0uX2luZGV4O1xuICAgIHZhciBwdHIgPSBtLl9wdHI7XG4gICAgLy8gcmVzdWx0IG1hdHJpY2VzXG4gICAgdmFyIGN2YWx1ZXMgPSB2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyByb3cgY291bnRzXG4gICAgdmFyIHcgPSBbXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHJvd3M7IHgrKylcbiAgICAgIHdbeF0gPSAwO1xuICAgIC8vIHZhcnNcbiAgICB2YXIgcCwgbCwgajtcbiAgICAvLyBsb29wIHZhbHVlcyBpbiBtYXRyaXhcbiAgICBmb3IgKHAgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBwIDwgbDsgcCsrKSB7XG4gICAgICAvLyBudW1iZXIgb2YgdmFsdWVzIGluIHJvd1xuICAgICAgd1tpbmRleFtwXV0rKztcbiAgICB9XG4gICAgLy8gY3VtdWxhdGl2ZSBzdW1cbiAgICB2YXIgc3VtID0gMDtcbiAgICAvLyBpbml0aWFsaXplIGNwdHIgd2l0aCB0aGUgY3VtbXVsYXRpdmUgc3VtIG9mIHJvdyBjb3VudHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgLy8gdXBkYXRlIGNwdHJcbiAgICAgIGNwdHIucHVzaChzdW0pO1xuICAgICAgLy8gdXBkYXRlIHN1bVxuICAgICAgc3VtICs9IHdbaV07XG4gICAgICAvLyB1cGRhdGUgd1xuICAgICAgd1tpXSA9IGNwdHJbaV07XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjcHRyXG4gICAgY3B0ci5wdXNoKHN1bSk7XG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gdmFsdWVzICYgaW5kZXggaW4gY29sdW1uXG4gICAgICBmb3IgKHZhciBrMCA9IHB0cltqXSwgazEgPSBwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIEMgdmFsdWVzICYgaW5kZXhcbiAgICAgICAgdmFyIHEgPSB3W2luZGV4W2tdXSsrO1xuICAgICAgICAvLyBDW2osIGldID0gQVtpLCBqXVxuICAgICAgICBjaW5kZXhbcV0gPSBqO1xuICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzIChwYXR0ZXJuIG1hdHJpeClcbiAgICAgICAgaWYgKHZhbHVlcylcbiAgICAgICAgICBjdmFsdWVzW3FdID0gY2xvbmUodmFsdWVzW2tdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIG1hdHJpeFxuICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KHtcbiAgICAgIHZhbHVlczogY3ZhbHVlcyxcbiAgICAgIGluZGV4OiBjaW5kZXgsXG4gICAgICBwdHI6IGNwdHIsXG4gICAgICBzaXplOiBbY29sdW1ucywgcm93c10sXG4gICAgICBkYXRhdHlwZTogbS5fZGF0YXR5cGVcbiAgICB9KTtcbiAgfTtcblxuICB0cmFuc3Bvc2UudG9UZXggPSB7MTogJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJyArIGxhdGV4Lm9wZXJhdG9yc1sndHJhbnNwb3NlJ119O1xuXG4gIHJldHVybiB0cmFuc3Bvc2U7XG59XG5cbmV4cG9ydHMubmFtZSA9ICd0cmFuc3Bvc2UnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpLmlzSW50ZWdlcjtcbnZhciByZXNpemUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpLnJlc2l6ZTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1hdHJpeCBmaWxsZWQgd2l0aCB6ZXJvcy4gVGhlIGNyZWF0ZWQgbWF0cml4IGNhbiBoYXZlIG9uZSBvclxuICAgKiBtdWx0aXBsZSBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguemVyb3MobSlcbiAgICogICAgbWF0aC56ZXJvcyhtLCBmb3JtYXQpXG4gICAqICAgIG1hdGguemVyb3MobSwgbilcbiAgICogICAgbWF0aC56ZXJvcyhtLCBuLCBmb3JtYXQpXG4gICAqICAgIG1hdGguemVyb3MoW20sIG5dKVxuICAgKiAgICBtYXRoLnplcm9zKFttLCBuXSwgZm9ybWF0KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC56ZXJvcygzKTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFswLCAwLCAwXVxuICAgKiAgICBtYXRoLnplcm9zKDMsIDIpOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgW1swLCAwXSwgWzAsIDBdLCBbMCwgMF1dXG4gICAqICAgIG1hdGguemVyb3MoMywgJ2RlbnNlJyk7ICAgICAgICAgLy8gcmV0dXJucyBbMCwgMCwgMF1cbiAgICpcbiAgICogICAgdmFyIEEgPSBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dO1xuICAgKiAgICBtYXRoLnplcm9zKG1hdGguc2l6ZShBKSk7ICAgICAgIC8vIHJldHVybnMgW1swLCAwLCAwXSwgWzAsIDAsIDBdXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgb25lcywgZXllLCBzaXplLCByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gey4uLm51bWJlciB8IEFycmF5fSBzaXplICAgIFRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uIG9mIHRoZSBtYXRyaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXRdICAgICAgICAgICBUaGUgTWF0cml4IHN0b3JhZ2UgZm9ybWF0XG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSAgICAgICAgICAgQSBtYXRyaXggZmlsbGVkIHdpdGggemVyb3NcbiAgICovXG4gIHZhciB6ZXJvcyA9IHR5cGVkKCd6ZXJvcycsIHtcbiAgICAnJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChjb25maWcubWF0cml4ID09PSAnQXJyYXknKVxuICAgICAgICAgID8gX3plcm9zKFtdKVxuICAgICAgICAgIDogX3plcm9zKFtdLCAnZGVmYXVsdCcpO1xuICAgIH0sXG5cbiAgICAvLyBtYXRoLnplcm9zKG0sIG4sIHAsIC4uLiwgZm9ybWF0KVxuICAgIC8vIFRPRE86IG1vcmUgYWNjdXJhdGUgc2lnbmF0dXJlICcuLi5udW1iZXIgfCBCaWdOdW1iZXIsIHN0cmluZycgYXMgc29vbiBhcyB0eXBlZC1mdW5jdGlvbiBzdXBwb3J0cyB0aGlzXG4gICAgJy4uLm51bWJlciB8IEJpZ051bWJlciB8IHN0cmluZyc6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB2YXIgbGFzdCA9IHNpemVbc2l6ZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHNpemUucG9wKCk7XG4gICAgICAgIHJldHVybiBfemVyb3Moc2l6ZSwgZm9ybWF0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbmZpZy5tYXRyaXggPT09ICdBcnJheScpIHtcbiAgICAgICAgcmV0dXJuIF96ZXJvcyhzaXplKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX3plcm9zKHNpemUsICdkZWZhdWx0Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdBcnJheSc6IF96ZXJvcyxcblxuICAgICdNYXRyaXgnOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IHNpemUuc3RvcmFnZSgpO1xuICAgICAgcmV0dXJuIF96ZXJvcyhzaXplLnZhbHVlT2YoKSwgZm9ybWF0KTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4LCBzdHJpbmcnOiBmdW5jdGlvbiAoc2l6ZSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gX3plcm9zIChzaXplLnZhbHVlT2YoKSwgZm9ybWF0KTtcbiAgICB9XG4gIH0pO1xuXG4gIHplcm9zLnRvVGV4ID0gdW5kZWZpbmVkOyAvLyB1c2UgZGVmYXVsdCB0ZW1wbGF0ZVxuXG4gIHJldHVybiB6ZXJvcztcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEFycmF5IG9yIE1hdHJpeCB3aXRoIHplcm9zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNpemVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXQ9J2RlZmF1bHQnXVxuICAgKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF96ZXJvcyhzaXplLCBmb3JtYXQpIHtcbiAgICB2YXIgaGFzQmlnTnVtYmVycyA9IF9ub3JtYWxpemUoc2l6ZSk7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGhhc0JpZ051bWJlcnMgPyBuZXcgdHlwZS5CaWdOdW1iZXIoMCkgOiAwO1xuICAgIF92YWxpZGF0ZShzaXplKTtcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIC8vIHJldHVybiBhIG1hdHJpeFxuICAgICAgdmFyIG0gPSBtYXRyaXgoZm9ybWF0KTtcbiAgICAgIGlmIChzaXplLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG0ucmVzaXplKHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyByZXR1cm4gYW4gQXJyYXlcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGlmIChzaXplLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc2l6ZShhcnIsIHNpemUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlcGxhY2UgQmlnTnVtYmVycyB3aXRoIG51bWJlcnMsIHJldHVybnMgdHJ1ZSBpZiBzaXplIGNvbnRhaW5lZCBCaWdOdW1iZXJzXG4gIGZ1bmN0aW9uIF9ub3JtYWxpemUoc2l6ZSkge1xuICAgIHZhciBoYXNCaWdOdW1iZXJzID0gZmFsc2U7XG4gICAgc2l6ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycikge1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzQmlnTnVtYmVyID09PSB0cnVlKSB7XG4gICAgICAgIGhhc0JpZ051bWJlcnMgPSB0cnVlO1xuICAgICAgICBhcnJbaW5kZXhdID0gdmFsdWUudG9OdW1iZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGFzQmlnTnVtYmVycztcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIGFyZ3VtZW50c1xuICBmdW5jdGlvbiBfdmFsaWRhdGUgKHNpemUpIHtcbiAgICBzaXplLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXJzIGluIGZ1bmN0aW9uIHplcm9zIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBUT0RPOiB6ZXJvcyBjb250YWlucyBhbG1vc3QgdGhlIHNhbWUgY29kZSBhcyBvbmVzLiBSZXVzZSB0aGlzP1xuXG5leHBvcnRzLm5hbWUgPSAnemVyb3MnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICBcbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4vZXF1YWxTY2FsYXInKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiB0ZXN0cyB3aGV0aGVyIHRoZSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeSBpc1xuICAgKiBzbWFsbGVyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvXG4gICAqIGNvbXBhcmUgdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKiBJbiBjYXNlIG9mIGNvbXBsZXggbnVtYmVycywgeC5yZSBtdXN0IGVxdWFsIHkucmUsIGFuZCB4LmltIG11c3QgZXF1YWwgeS5pbS5cbiAgICpcbiAgICogVmFsdWVzIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbXBhcmVkIHN0cmljdGx5LCB0aHVzIGBudWxsYCBpcyBvbmx5XG4gICAqIGVxdWFsIHRvIGBudWxsYCBhbmQgbm90aGluZyBlbHNlLCBhbmQgYHVuZGVmaW5lZGAgaXMgb25seSBlcXVhbCB0b1xuICAgKiBgdW5kZWZpbmVkYCBhbmQgbm90aGluZyBlbHNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoMiArIDIsIDMpOyAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5lcXVhbCgyICsgMiwgNCk7ICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KCc1MCBjbScpO1xuICAgKiAgICB2YXIgYiA9IG1hdGgudW5pdCgnNSBtJyk7XG4gICAqICAgIG1hdGguZXF1YWwoYSwgYik7ICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiAgICB2YXIgYyA9IFsyLCA1LCAxXTtcbiAgICogICAgdmFyIGQgPSBbMiwgNywgMV07XG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoYywgZCk7ICAgICAgICAgICAgIC8vIHJldHVybnMgW3RydWUsIGZhbHNlLCB0cnVlXVxuICAgKiAgICBtYXRoLmRlZXBFcXVhbChjLCBkKTsgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqICAgIG1hdGguZXF1YWwoMCwgbnVsbCk7ICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHVuZXF1YWwsIHNtYWxsZXIsIHNtYWxsZXJFcSwgbGFyZ2VyLCBsYXJnZXJFcSwgY29tcGFyZSwgZGVlcEVxdWFsXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IGJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4fSB4IEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgYm9vbGVhbiB8IENvbXBsZXggfCBVbml0IHwgc3RyaW5nIHwgQXJyYXkgfCBNYXRyaXh9IHkgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiB7Ym9vbGVhbiB8IEFycmF5IHwgTWF0cml4fSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgY29tcGFyZWQgdmFsdWVzIGFyZSBlcXVhbCwgZWxzZSByZXR1cm5zIGZhbHNlXG4gICAqL1xuICB2YXIgZXF1YWwgPSB0eXBlZCgnZXF1YWwnLCB7XG4gICAgXG4gICAgJ2FueSwgYW55JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHN0cmljdCBlcXVhbGl0eSBmb3IgbnVsbCBhbmQgdW5kZWZpbmVkP1xuICAgICAgaWYgKHggPT09IG51bGwpIHsgcmV0dXJuIHkgPT09IG51bGw7IH1cbiAgICAgIGlmICh5ID09PSBudWxsKSB7IHJldHVybiB4ID09PSBudWxsOyB9XG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB5ID09PSB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHggPT09IHVuZGVmaW5lZDsgfVxuXG4gICAgICByZXR1cm4gZXF1YWxTY2FsYXIoeCwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBlcXVhbFNjYWxhcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHksIHgsIGVxdWFsU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBlcXVhbFNjYWxhciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGVxdWFsU2NhbGFyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgICBcbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBlcXVhbChtYXRyaXgoeCksIG1hdHJpeCh5KSkudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gZXF1YWwobWF0cml4KHgpLCB5KTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGVxdWFsKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcbiAgICBcbiAgICAnTWF0cml4LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcbiAgICAgIC8vIGNoZWNrIHN0b3JhZ2UgZm9ybWF0XG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTEyKHgsIHksIGVxdWFsU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGVxdWFsU2NhbGFyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCBlcXVhbFNjYWxhciwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHksIHgsIGVxdWFsU2NhbGFyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBlcXVhbFNjYWxhciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgZXF1YWxTY2FsYXIsIHRydWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGVxdWFsLnRvVGV4ID0ge1xuICAgIDI6ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snZXF1YWwnXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSdcbiAgfTtcblxuICByZXR1cm4gZXF1YWw7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdlcXVhbCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5uZWFybHlFcXVhbDtcbnZhciBiaWdOZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9uZWFybHlFcXVhbCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW4gfCBDb21wbGV4IHwgVW5pdH0geCAgIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuIHwgQ29tcGxleH0geSAgICAgICAgICBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGNvbXBhcmVkIHZhbHVlcyBhcmUgZXF1YWwsIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIGVxdWFsU2NhbGFyID0gdHlwZWQoJ2VxdWFsU2NhbGFyJywge1xuXG4gICAgJ2Jvb2xlYW4sIGJvb2xlYW4nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9PT0geSB8fCBuZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXIsIEJpZ051bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5lcSh5KSB8fCBiaWdOZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguZXF1YWxzKHkpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCwgQ29tcGxleCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5lcXVhbHMoeSk7XG4gICAgfSxcblxuICAgICdVbml0LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSB1bml0cyB3aXRoIGRpZmZlcmVudCBiYXNlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXF1YWxTY2FsYXIoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9PT0geTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGVxdWFsU2NhbGFyO1xufVxuXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5uZWFybHlFcXVhbDtcbnZhciBiaWdOZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9uZWFybHlFcXVhbCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIFxuICB2YXIgbWF0cml4ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC9mdW5jdGlvbi9tYXRyaXgnKSk7XG5cbiAgdmFyIGFsZ29yaXRobTAzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wMycpKTtcbiAgdmFyIGFsZ29yaXRobTA3ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0wNycpKTtcbiAgdmFyIGFsZ29yaXRobTEyID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMicpKTtcbiAgdmFyIGFsZ29yaXRobTEzID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xMycpKTtcbiAgdmFyIGFsZ29yaXRobTE0ID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL21hdHJpeC91dGlscy9hbGdvcml0aG0xNCcpKTtcblxuICB2YXIgbGF0ZXggPSByZXF1aXJlKCcuLi8uLi91dGlscy9sYXRleCcpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdmFsdWUgeCBpcyBsYXJnZXIgdGhhbiB5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4geCBpcyBsYXJnZXIgdGhhbiB5IGFuZCB0aGUgcmVsYXRpdmVcbiAgICogZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXMgbGFyZ2VyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZXBzaWxvbi4gVGhlXG4gICAqIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzIHNtYWxsZXIgdGhhbiBhcHByb3hpbWF0ZWx5IDIuMjJlLTE2LlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubGFyZ2VyKHgsIHkpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmxhcmdlcigyLCAzKTsgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmxhcmdlcig1LCAyICsgMik7ICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqICAgIHZhciBhID0gbWF0aC51bml0KCc1IGNtJyk7XG4gICAqICAgIHZhciBiID0gbWF0aC51bml0KCcyIGluY2gnKTtcbiAgICogICAgbWF0aC5sYXJnZXIoYSwgYik7ICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGVxdWFsLCB1bmVxdWFsLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGxhcmdlckVxLCBjb21wYXJlXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geCBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEBwYXJhbSAge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbiB8IFVuaXQgfCBzdHJpbmcgfCBBcnJheSB8IE1hdHJpeH0geSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFuIHwgQXJyYXkgfCBNYXRyaXh9IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB4IGlzIGxhcmdlciB0aGFuIHksIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgdmFyIGxhcmdlciA9IHR5cGVkKCdsYXJnZXInLCB7XG5cbiAgICAnYm9vbGVhbiwgYm9vbGVhbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHk7XG4gICAgfSxcblxuICAgICdudW1iZXIsIG51bWJlcic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHkgJiYgIW5lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlciwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4Lmd0KHkpICYmICFiaWdOZWFybHlFcXVhbCh4LCB5LCBjb25maWcuZXBzaWxvbik7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbiwgRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHguY29tcGFyZSh5KSA9PT0gMTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBvcmRlcmluZyByZWxhdGlvbiBpcyBkZWZpbmVkIGZvciBjb21wbGV4IG51bWJlcnMnKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIFVuaXQnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKCF4LmVxdWFsQmFzZSh5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHVuaXRzIHdpdGggZGlmZmVyZW50IGJhc2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXJnZXIoeC52YWx1ZSwgeS52YWx1ZSk7XG4gICAgfSxcblxuICAgICdzdHJpbmcsIHN0cmluZyc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geCA+IHk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuXG4gICAgICAvLyBwcm9jZXNzIG1hdHJpeCBzdG9yYWdlXG4gICAgICBzd2l0Y2ggKHguc3RvcmFnZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wNyh4LCB5LCBsYXJnZXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCBsYXJnZXIsIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHgsIHksIGxhcmdlciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGxhcmdlcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBsYXJnZXIobWF0cml4KHgpLCBtYXRyaXgoeSkpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGxhcmdlcihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gbGFyZ2VyKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeCwgeSwgbGFyZ2VyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYyA9IGFsZ29yaXRobTE0KHgsIHksIGxhcmdlciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdhbnksIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgbGFyZ2VyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgbGFyZ2VyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYWxnb3JpdGhtMTQobWF0cml4KHgpLCB5LCBsYXJnZXIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdhbnksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGxhcmdlciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGFyZ2VyLnRvVGV4ID0ge1xuICAgIDI6ICdcXFxcbGVmdCgke2FyZ3NbMF19JyArIGxhdGV4Lm9wZXJhdG9yc1snbGFyZ2VyJ10gKyAnJHthcmdzWzFdfVxcXFxyaWdodCknXG4gIH07XG5cbiAgcmV0dXJuIGxhcmdlcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2xhcmdlcic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmVhcmx5RXF1YWwgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5uZWFybHlFcXVhbDtcbnZhciBiaWdOZWFybHlFcXVhbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2JpZ251bWJlci9uZWFybHlFcXVhbCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIG1hdHJpeCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvZnVuY3Rpb24vbWF0cml4JykpO1xuXG4gIHZhciBhbGdvcml0aG0wMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDMnKSk7XG4gIHZhciBhbGdvcml0aG0wNyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMDcnKSk7XG4gIHZhciBhbGdvcml0aG0xMiA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTInKSk7XG4gIHZhciBhbGdvcml0aG0xMyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTMnKSk7XG4gIHZhciBhbGdvcml0aG0xNCA9IGxvYWQocmVxdWlyZSgnLi4vLi4vdHlwZS9tYXRyaXgvdXRpbHMvYWxnb3JpdGhtMTQnKSk7XG5cbiAgdmFyIGxhdGV4ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbGF0ZXgnKTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHZhbHVlIHggaXMgc21hbGxlciB0aGFuIHkuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiB4IGlzIHNtYWxsZXIgdGhhbiB5IGFuZCB0aGUgcmVsYXRpdmVcbiAgICogZGlmZmVyZW5jZSBiZXR3ZWVuIHggYW5kIHkgaXMgc21hbGxlciB0aGFuIHRoZSBjb25maWd1cmVkIGVwc2lsb24uIFRoZVxuICAgKiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0byBjb21wYXJlIHZhbHVlcyBzbWFsbGVyIHRoYW4gYXBwcm94aW1hdGVseSAyLjIyZS0xNi5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnNtYWxsZXIoeCwgeSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc21hbGxlcigyLCAzKTsgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5zbWFsbGVyKDUsIDIgKiAyKTsgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogICAgdmFyIGEgPSBtYXRoLnVuaXQoJzUgY20nKTtcbiAgICogICAgdmFyIGIgPSBtYXRoLnVuaXQoJzIgaW5jaCcpO1xuICAgKiAgICBtYXRoLnNtYWxsZXIoYSwgYik7ICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBlcXVhbCwgdW5lcXVhbCwgc21hbGxlckVxLCBzbWFsbGVyLCBzbWFsbGVyRXEsIGNvbXBhcmVcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuIHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4fSB4IEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtICB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBib29sZWFuIHwgVW5pdCB8IHN0cmluZyB8IEFycmF5IHwgTWF0cml4fSB5IFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHggaXMgc21hbGxlciB0aGFuIHksIGVsc2UgcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgdmFyIHNtYWxsZXIgPSB0eXBlZCgnc21hbGxlcicsIHtcblxuICAgICdib29sZWFuLCBib29sZWFuJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IDwgeTtcbiAgICB9LFxuXG4gICAgJ251bWJlciwgbnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IDwgeSAmJiAhbmVhcmx5RXF1YWwoeCwgeSwgY29uZmlnLmVwc2lsb24pO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHgubHQoeSkgJiYgIWJpZ05lYXJseUVxdWFsKHgsIHksIGNvbmZpZy5lcHNpbG9uKTtcbiAgICB9LFxuXG4gICAgJ0ZyYWN0aW9uLCBGcmFjdGlvbic6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4geC5jb21wYXJlKHkpID09PSAtMTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgsIENvbXBsZXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gb3JkZXJpbmcgcmVsYXRpb24gaXMgZGVmaW5lZCBmb3IgY29tcGxleCBudW1iZXJzJyk7XG4gICAgfSxcblxuICAgICdVbml0LCBVbml0JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICgheC5lcXVhbEJhc2UoeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcGFyZSB1bml0cyB3aXRoIGRpZmZlcmVudCBiYXNlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc21hbGxlcih4LnZhbHVlLCB5LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZywgc3RyaW5nJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHJldHVybiB4IDwgeTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG5cbiAgICAgIC8vIHByb2Nlc3MgbWF0cml4IHN0b3JhZ2VcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBzcGFyc2UgKyBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA3KHgsIHksIHNtYWxsZXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSArIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh5LCB4LCBzbWFsbGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIGRlbnNlICsgc3BhcnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMyh4LCB5LCBzbWFsbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgKyBkZW5zZVxuICAgICAgICAgICAgICBjID0gYWxnb3JpdGhtMTMoeCwgeSwgc21hbGxlcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG5cbiAgICAnQXJyYXksIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBzbWFsbGVyKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBzbWFsbGVyKG1hdHJpeCh4KSwgeSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBzbWFsbGVyKHgsIG1hdHJpeCh5KSk7XG4gICAgfSxcblxuICAgICdNYXRyaXgsIGFueSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeC5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeCwgeSwgc21hbGxlciwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBzbWFsbGVyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ2FueSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh5LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMih5LCB4LCBzbWFsbGVyLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTQoeSwgeCwgc21hbGxlciwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBhbnknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgc21hbGxlciwgZmFsc2UpLnZhbHVlT2YoKTtcbiAgICB9LFxuXG4gICAgJ2FueSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh5KSwgeCwgc21hbGxlciwgdHJ1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgfSk7XG5cbiAgc21hbGxlci50b1RleCA9IHtcbiAgICAyOiAnXFxcXGxlZnQoJHthcmdzWzBdfScgKyBsYXRleC5vcGVyYXRvcnNbJ3NtYWxsZXInXSArICcke2FyZ3NbMV19XFxcXHJpZ2h0KSdcbiAgfTtcblxuICByZXR1cm4gc21hbGxlcjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3NtYWxsZXInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBGb3JFYWNoID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwRm9yRWFjaCcpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vcmVkdWNlJyk7XG52YXIgY29udGFpbnNDb2xsZWN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vY29udGFpbnNDb2xsZWN0aW9ucycpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBsYXJnZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvbGFyZ2VyJykpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgbWF0cml4IG9yIGEgIGxpc3Qgd2l0aCB2YWx1ZXMuXG4gICAqIEluIGNhc2Ugb2YgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheSwgdGhlIG1heGltdW0gb2YgdGhlIGZsYXR0ZW5lZCBhcnJheVxuICAgKiB3aWxsIGJlIGNhbGN1bGF0ZWQuIFdoZW4gYGRpbWAgaXMgcHJvdmlkZWQsIHRoZSBtYXhpbXVtIG92ZXIgdGhlIHNlbGVjdGVkXG4gICAqIGRpbWVuc2lvbiB3aWxsIGJlIGNhbGN1bGF0ZWQuIFBhcmFtZXRlciBgZGltYCBpcyB6ZXJvLWJhc2VkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLm1heChhLCBiLCBjLCAuLi4pXG4gICAqICAgICBtYXRoLm1heChBKVxuICAgKiAgICAgbWF0aC5tYXgoQSwgZGltKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgubWF4KDIsIDEsIDQsIDMpOyAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgNFxuICAgKiAgICAgbWF0aC5tYXgoWzIsIDEsIDQsIDNdKTsgICAgICAgICAgICAgICAgLy8gcmV0dXJucyA0XG4gICAqXG4gICAqICAgICAvLyBtYXhpbXVtIG92ZXIgYSBzcGVjaWZpZWQgZGltZW5zaW9uICh6ZXJvLWJhc2VkKVxuICAgKiAgICAgbWF0aC5tYXgoW1syLCA1XSwgWzQsIDNdLCBbMSwgN11dLCAwKTsgLy8gcmV0dXJucyBbNCwgN11cbiAgICogICAgIG1hdGgubWF4KFtbMiwgNV0sIFs0LCAzXV0sIFsxLCA3XSwgMSk7IC8vIHJldHVybnMgWzUsIDQsIDddXG4gICAqXG4gICAqICAgICBtYXRoLm1heCgyLjcsIDcuMSwgLTQuNSwgMi4wLCA0LjEpOyAgICAvLyByZXR1cm5zIDcuMVxuICAgKiAgICAgbWF0aC5taW4oMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKTsgICAgLy8gcmV0dXJucyAtNC41XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBtZWFuLCBtZWRpYW4sIG1pbiwgcHJvZCwgc3RkLCBzdW0sIHZhclxuICAgKlxuICAgKiBAcGFyYW0gey4uLiAqfSBhcmdzICBBIHNpbmdsZSBtYXRyaXggb3Igb3IgbXVsdGlwbGUgc2NhbGFyIHZhbHVlc1xuICAgKiBAcmV0dXJuIHsqfSBUaGUgbWF4aW11bSB2YWx1ZVxuICAgKi9cbiAgdmFyIG1heCA9IHR5cGVkKCdtYXgnLCB7XG4gICAgLy8gbWF4KFthLCBiLCBjLCBkLCAuLi5dKVxuICAgICdBcnJheSB8IE1hdHJpeCc6IF9tYXgsXG5cbiAgICAvLyBtYXgoW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAnQXJyYXkgfCBNYXRyaXgsIG51bWJlciB8IEJpZ051bWJlcic6IGZ1bmN0aW9uIChhcnJheSwgZGltKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGFycmF5LCBkaW0udmFsdWVPZigpLCBfbGFyZ2VzdCk7XG4gICAgfSxcblxuICAgIC8vIG1heChhLCBiLCBjLCBkLCAuLi4pXG4gICAgJy4uLic6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICBpZiAoY29udGFpbnNDb2xsZWN0aW9ucyhhcmdzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY2FsYXIgdmFsdWVzIGV4cGVjdGVkIGluIGZ1bmN0aW9uIG1heCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21heChhcmdzKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1heC50b1RleCA9ICdcXFxcbWF4XFxcXGxlZnQoJHthcmdzfVxcXFxyaWdodCknO1xuXG4gIHJldHVybiBtYXg7XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFyZ2VzdCBvZiB0d28gdmFsdWVzXG4gICAqIEBwYXJhbSB7Kn0geFxuICAgKiBAcGFyYW0geyp9IHlcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgeCB3aGVuIHggaXMgbGFyZ2VzdCwgb3IgeSB3aGVuIHkgaXMgbGFyZ2VzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2xhcmdlc3QoeCwgeSl7XG4gICAgcmV0dXJuIGxhcmdlcih4LCB5KSA/IHggOiB5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNhbGN1bGF0ZSB0aGUgbWF4aW11bSB2YWx1ZSBpbiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm4ge251bWJlcn0gbWF4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfbWF4KGFycmF5KSB7XG4gICAgdmFyIG1heCA9IHVuZGVmaW5lZDtcblxuICAgIGRlZXBGb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCB8fCBsYXJnZXIodmFsdWUsIG1heCkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtYXggb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4O1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtYXgnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNpemUgPSByZXF1aXJlKCcuLi8uLi91dGlscy9hcnJheScpLnNpemU7XG52YXIgZGVlcEZvckVhY2ggPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBGb3JFYWNoJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9yZWR1Y2UnKTtcbnZhciBjb250YWluc0NvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9jb250YWluc0NvbGxlY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIGFkZCA9IGxvYWQocmVxdWlyZSgnLi4vYXJpdGhtZXRpYy9hZGQnKSk7XG4gIHZhciBkaXZpZGUgPSBsb2FkKHJlcXVpcmUoJy4uL2FyaXRobWV0aWMvZGl2aWRlJykpO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBtZWFuIHZhbHVlIG9mIG1hdHJpeCBvciBhIGxpc3Qgd2l0aCB2YWx1ZXMuXG4gICAqIEluIGNhc2Ugb2YgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheSwgdGhlIG1lYW4gb2YgdGhlIGZsYXR0ZW5lZCBhcnJheVxuICAgKiB3aWxsIGJlIGNhbGN1bGF0ZWQuIFdoZW4gYGRpbWAgaXMgcHJvdmlkZWQsIHRoZSBtYXhpbXVtIG92ZXIgdGhlIHNlbGVjdGVkXG4gICAqIGRpbWVuc2lvbiB3aWxsIGJlIGNhbGN1bGF0ZWQuIFBhcmFtZXRlciBgZGltYCBpcyB6ZXJvLWJhc2VkLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLm1lYW4oYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC5tZWFuKEEpXG4gICAqICAgICBtYXRoLm1lYW4oQSwgZGltKVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIG1hdGgubWVhbigyLCAxLCA0LCAzKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDIuNVxuICAgKiAgICAgbWF0aC5tZWFuKFsxLCAyLjcsIDMuMiwgNF0pOyAgICAgICAgICAgICAgIC8vIHJldHVybnMgMi43MjVcbiAgICpcbiAgICogICAgIG1hdGgubWVhbihbWzIsIDVdLCBbNiwgM10sIFsxLCA3XV0sIDApOyAgICAvLyByZXR1cm5zIFszLCA1XVxuICAgKiAgICAgbWF0aC5tZWFuKFtbMiwgNV0sIFs2LCAzXSwgWzEsIDddXSwgMSk7ICAgIC8vIHJldHVybnMgWzMuNSwgNC41LCA0XVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgIG1lZGlhbiwgbWluLCBtYXgsIHN1bSwgcHJvZCwgc3RkLCB2YXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gKn0gYXJncyAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHJldHVybiB7Kn0gVGhlIG1lYW4gb2YgYWxsIHZhbHVlc1xuICAgKi9cbiAgdmFyIG1lYW4gPSB0eXBlZCgnbWVhbicsIHtcbiAgICAgIC8vIG1lYW4oW2EsIGIsIGMsIGQsIC4uLl0pXG4gICAgJ0FycmF5IHwgTWF0cml4JzogX21lYW4sXG5cbiAgICAgIC8vIG1lYW4oW2EsIGIsIGMsIGQsIC4uLl0sIGRpbSlcbiAgICAnQXJyYXkgfCBNYXRyaXgsIG51bWJlciB8IEJpZ051bWJlcic6IF9ubWVhbixcblxuICAgIC8vIG1lYW4oYSwgYiwgYywgZCwgLi4uKVxuICAgICcuLi4nOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgaWYgKGNvbnRhaW5zQ29sbGVjdGlvbnMoYXJncykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2NhbGFyIHZhbHVlcyBleHBlY3RlZCBpbiBmdW5jdGlvbiBtZWFuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWVhbihhcmdzKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1lYW4udG9UZXggPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHRlbXBsYXRlXG5cbiAgcmV0dXJuIG1lYW47XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbWVhbiB2YWx1ZSBpbiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5LCByZXR1cm5pbmcgYVxuICAgKiBuLTEgZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpbVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IG1lYW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9ubWVhbihhcnJheSwgZGltKXtcbiAgICB2YXIgc3VtID0gcmVkdWNlKGFycmF5LCBkaW0sIGFkZCk7XG4gICAgdmFyIHMgPSBBcnJheS5pc0FycmF5KGFycmF5KSA/IHNpemUoYXJyYXkpIDogYXJyYXkuc2l6ZSgpO1xuICAgIHJldHVybiBkaXZpZGUoc3VtLCBzW2RpbV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNhbGN1bGF0ZSB0aGUgbWVhbiB2YWx1ZSBpbiBhbiBuLWRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm4ge251bWJlcn0gbWVhblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX21lYW4oYXJyYXkpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgbnVtID0gMDtcblxuICAgIGRlZXBGb3JFYWNoKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHN1bSA9IGFkZChzdW0sIHZhbHVlKTtcbiAgICAgIG51bSsrO1xuICAgIH0pO1xuXG4gICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIG1lYW4gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGl2aWRlKHN1bSwgbnVtKTtcbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnbWVhbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcEZvckVhY2ggPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBGb3JFYWNoJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9yZWR1Y2UnKTtcbnZhciBjb250YWluc0NvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9jb250YWluc0NvbGxlY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgdmFyIHNtYWxsZXIgPSBsb2FkKHJlcXVpcmUoJy4uL3JlbGF0aW9uYWwvc21hbGxlcicpKTtcbiAgXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgbWF0cml4IG9yIGEgIGxpc3Qgb2YgdmFsdWVzLlxuICAgKiBJbiBjYXNlIG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXksIHRoZSBtYXhpbXVtIG9mIHRoZSBmbGF0dGVuZWQgYXJyYXlcbiAgICogd2lsbCBiZSBjYWxjdWxhdGVkLiBXaGVuIGBkaW1gIGlzIHByb3ZpZGVkLCB0aGUgbWF4aW11bSBvdmVyIHRoZSBzZWxlY3RlZFxuICAgKiBkaW1lbnNpb24gd2lsbCBiZSBjYWxjdWxhdGVkLiBQYXJhbWV0ZXIgYGRpbWAgaXMgemVyby1iYXNlZC5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICAgbWF0aC5taW4oYSwgYiwgYywgLi4uKVxuICAgKiAgICAgbWF0aC5taW4oQSlcbiAgICogICAgIG1hdGgubWluKEEsIGRpbSlcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgICBtYXRoLm1pbigyLCAxLCA0LCAzKTsgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIDFcbiAgICogICAgIG1hdGgubWluKFsyLCAxLCA0LCAzXSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgMVxuICAgKlxuICAgKiAgICAgLy8gbWF4aW11bSBvdmVyIGEgc3BlY2lmaWVkIGRpbWVuc2lvbiAoemVyby1iYXNlZClcbiAgICogICAgIG1hdGgubWluKFtbMiwgNV0sIFs0LCAzXSwgWzEsIDddXSwgMCk7IC8vIHJldHVybnMgWzEsIDNdXG4gICAqICAgICBtYXRoLm1pbihbWzIsIDVdLCBbNCwgM10sIFsxLCA3XV0sIDEpOyAvLyByZXR1cm5zIFsyLCAzLCAxXVxuICAgKlxuICAgKiAgICAgbWF0aC5tYXgoMi43LCA3LjEsIC00LjUsIDIuMCwgNC4xKTsgICAgLy8gcmV0dXJucyA3LjFcbiAgICogICAgIG1hdGgubWluKDIuNywgNy4xLCAtNC41LCAyLjAsIDQuMSk7ICAgIC8vIHJldHVybnMgLTQuNVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgbWVhbiwgbWVkaWFuLCBtYXgsIHByb2QsIHN0ZCwgc3VtLCB2YXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi4gKn0gYXJncyAgQSBzaW5nbGUgbWF0cml4IG9yIG9yIG11bHRpcGxlIHNjYWxhciB2YWx1ZXNcbiAgICogQHJldHVybiB7Kn0gVGhlIG1pbmltdW0gdmFsdWVcbiAgICovXG4gIHZhciBtaW4gPSB0eXBlZCgnbWluJywge1xuICAgIC8vIG1pbihbYSwgYiwgYywgZCwgLi4uXSlcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBfbWluLFxuXG4gICAgLy8gbWluKFthLCBiLCBjLCBkLCAuLi5dLCBkaW0pXG4gICAgJ0FycmF5IHwgTWF0cml4LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoYXJyYXksIGRpbSkge1xuICAgICAgcmV0dXJuIHJlZHVjZShhcnJheSwgZGltLnZhbHVlT2YoKSwgX3NtYWxsZXN0KTtcbiAgICB9LFxuXG4gICAgLy8gbWluKGEsIGIsIGMsIGQsIC4uLilcbiAgICAnLi4uJzogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChjb250YWluc0NvbGxlY3Rpb25zKGFyZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjYWxhciB2YWx1ZXMgZXhwZWN0ZWQgaW4gZnVuY3Rpb24gbWluJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWluKGFyZ3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWluLnRvVGV4ID0gJ1xcXFxtaW5cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSc7XG5cbiAgcmV0dXJuIG1pbjtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0d28gdmFsdWVzXG4gICAqIEBwYXJhbSB7Kn0geFxuICAgKiBAcGFyYW0geyp9IHlcbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgeCB3aGVuIHggaXMgc21hbGxlc3QsIG9yIHkgd2hlbiB5IGlzIHNtYWxsZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc21hbGxlc3QoeCwgeSkge1xuICAgIHJldHVybiBzbWFsbGVyKHgsIHkpID8geCA6IHk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgY2FsY3VsYXRlIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIG4tZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybiB7bnVtYmVyfSBtaW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9taW4oYXJyYXkpIHtcbiAgICB2YXIgbWluID0gdW5kZWZpbmVkO1xuXG4gICAgZGVlcEZvckVhY2goYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkIHx8IHNtYWxsZXIodmFsdWUsIG1pbikpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBtaW4gb2YgYW4gZW1wdHkgYXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9XG59XG5cbmV4cG9ydHMubmFtZSA9ICdtaW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgYSB2YWx1ZSBvZiBhbnkgdHlwZSBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguZm9ybWF0KHZhbHVlKVxuICAgKiAgICBtYXRoLmZvcm1hdCh2YWx1ZSwgb3B0aW9ucylcbiAgICogICAgbWF0aC5mb3JtYXQodmFsdWUsIHByZWNpc2lvbilcbiAgICogICAgbWF0aC5mb3JtYXQodmFsdWUsIGNhbGxiYWNrKVxuICAgKlxuICAgKiBXaGVyZTpcbiAgICpcbiAgICogIC0gYHZhbHVlOiAqYFxuICAgKiAgICBUaGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqICAtIGBvcHRpb25zOiBPYmplY3RgXG4gICAqICAgIEFuIG9iamVjdCB3aXRoIGZvcm1hdHRpbmcgb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqICAgIC0gYG5vdGF0aW9uOiBzdHJpbmdgXG4gICAqICAgICAgTnVtYmVyIG5vdGF0aW9uLiBDaG9vc2UgZnJvbTpcbiAgICogICAgICAtICdmaXhlZCdcbiAgICogICAgICAgIEFsd2F5cyB1c2UgcmVndWxhciBudW1iZXIgbm90YXRpb24uXG4gICAqICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQwJyBhbmQgJzE0MDAwMDAwJ1xuICAgKiAgICAgIC0gJ2V4cG9uZW50aWFsJ1xuICAgKiAgICAgICAgQWx3YXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICogICAgICAgIEZvciBleGFtcGxlICcxLjIzNGUrMicgYW5kICcxLjRlKzcnXG4gICAqICAgICAgLSAnZW5naW5lZXJpbmcnXG4gICAqICAgICAgICBBbHdheXMgdXNlIGVuZ2luZWVyaW5nIG5vdGF0aW9uLlxuICAgKiAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40ZSswJyBhbmQgJzE0LjBlKzYnXG4gICAqICAgICAgLSAnYXV0bycgKGRlZmF1bHQpXG4gICAqICAgICAgICBSZWd1bGFyIG51bWJlciBub3RhdGlvbiBmb3IgbnVtYmVycyBoYXZpbmcgYW4gYWJzb2x1dGUgdmFsdWUgYmV0d2VlblxuICAgKiAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAgICogICAgICAgIExvd2VyIGJvdW5kIGlzIGluY2x1ZGVkLCB1cHBlciBib3VuZCBpcyBleGNsdWRlZC5cbiAgICogICAgICAgIEZvciBleGFtcGxlICcxMjMuNCcgYW5kICcxLjRlNycuXG4gICAqICAgIC0gYHByZWNpc2lvbjogbnVtYmVyYFxuICAgKiAgICAgIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMTYgdG8gcm91bmQgdGhlIGRpZ2l0cyBvZiB0aGUgbnVtYmVyLiBJbiBjYXNlXG4gICAqICAgICAgb2Ygbm90YXRpb25zICdleHBvbmVudGlhbCcgYW5kICdhdXRvJywgYHByZWNpc2lvbmAgZGVmaW5lcyB0aGUgdG90YWxcbiAgICogICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAgICogICAgICBJbiBjYXNlIG9mIG5vdGF0aW9uICdmaXhlZCcsIGBwcmVjaXNpb25gIGRlZmluZXMgdGhlIG51bWJlciBvZlxuICAgKiAgICAgIHNpZ25pZmljYW50IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgYW5kIGlzIDAgYnkgZGVmYXVsdC5cbiAgICogICAgLSBgZXhwb25lbnRpYWw6IE9iamVjdGBcbiAgICogICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycywge251bWJlcn0gbG93ZXIgYW5kIHtudW1iZXJ9IHVwcGVyLFxuICAgKiAgICAgIHVzZWQgYnkgbm90YXRpb24gJ2F1dG8nIHRvIGRldGVybWluZSB3aGVuIHRvIHJldHVybiBleHBvbmVudGlhbFxuICAgKiAgICAgIG5vdGF0aW9uLiBEZWZhdWx0IHZhbHVlcyBhcmUgYGxvd2VyPTFlLTNgIGFuZCBgdXBwZXI9MWU1YC4gT25seVxuICAgKiAgICAgIGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAgICogICAgLSBgZnJhY3Rpb246IHN0cmluZ2AuIEF2YWlsYWJsZSB2YWx1ZXM6ICdyYXRpbycgKGRlZmF1bHQpIG9yICdkZWNpbWFsJy5cbiAgICogICAgICBGb3IgZXhhbXBsZSBgZm9ybWF0KGZyYWN0aW9uKDEsIDMpKWAgd2lsbCBvdXRwdXQgJzEvMycgd2hlbiAncmF0aW8nIGlzXG4gICAqICAgICAgY29uZmlndXJlZCwgYW5kIHdpbGwgb3V0cHV0IGAwLigzKWAgd2hlbiAnZGVjaW1hbCcgaXMgY29uZmlndXJlZC5cbiAgICogLSBgY2FsbGJhY2s6IGZ1bmN0aW9uYFxuICAgKiAgIEEgY3VzdG9tIGZvcm1hdHRpbmcgZnVuY3Rpb24sIGludm9rZWQgZm9yIGFsbCBudW1lcmljIGVsZW1lbnRzIGluIGB2YWx1ZWAsXG4gICAqICAgZm9yIGV4YW1wbGUgYWxsIGVsZW1lbnRzIG9mIGEgbWF0cml4LCBvciB0aGUgcmVhbCBhbmQgaW1hZ2luYXJ5XG4gICAqICAgcGFydHMgb2YgYSBjb21wbGV4IG51bWJlci4gVGhpcyBjYWxsYmFjayBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB0aGVcbiAgICogICBidWlsdC1pbiBudW1lcmljIG5vdGF0aW9uIHdpdGggYW55IHR5cGUgb2YgZm9ybWF0dGluZy4gRnVuY3Rpb24gYGNhbGxiYWNrYFxuICAgKiAgIGlzIGNhbGxlZCB3aXRoIGB2YWx1ZWAgYXMgcGFyYW1ldGVyIGFuZCBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICpcbiAgICogV2hlbiBgdmFsdWVgIGlzIGFuIE9iamVjdDpcbiAgICpcbiAgICogLSBXaGVuIHRoZSBvYmplY3QgY29udGFpbnMgYSBwcm9wZXJ0eSBgZm9ybWF0YCBiZWluZyBhIGZ1bmN0aW9uLCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgaXMgaW52b2tlZCBhcyBgdmFsdWUuZm9ybWF0KG9wdGlvbnMpYCBhbmQgdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICogLSBXaGVuIHRoZSBvYmplY3QgaGFzIGl0cyBvd24gYHRvU3RyaW5nYCBtZXRob2QsIHRoaXMgbWV0aG9kIGlzIGludm9rZWRcbiAgICogICBhbmQgdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICogLSBJbiBvdGhlciBjYXNlcyB0aGUgZnVuY3Rpb24gd2lsbCBsb29wIG92ZXIgYWxsIG9iamVjdCBwcm9wZXJ0aWVzIGFuZFxuICAgKiAgIHJldHVybiBKU09OIG9iamVjdCBub3RhdGlvbiBsaWtlICd7XCJhXCI6IDIsIFwiYlwiOiAzfScuXG4gICAqXG4gICAqIFdoZW4gdmFsdWUgaXMgYSBmdW5jdGlvbjpcbiAgICpcbiAgICogLSBXaGVuIHRoZSBmdW5jdGlvbiBoYXMgYSBwcm9wZXJ0eSBgc3ludGF4YCwgaXQgcmV0dXJucyB0aGlzXG4gICAqICAgc3ludGF4IGRlc2NyaXB0aW9uLlxuICAgKiAtIEluIG90aGVyIGNhc2VzLCBhIHN0cmluZyBgJ2Z1bmN0aW9uJ2AgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmZvcm1hdCg2LjQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICc2LjQnXG4gICAqICAgIG1hdGguZm9ybWF0KDEyNDAwMDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJzEuMjRlNidcbiAgICogICAgbWF0aC5mb3JtYXQoMS8zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnMC4zMzMzMzMzMzMzMzMzMzMzJ1xuICAgKiAgICBtYXRoLmZvcm1hdCgxLzMsIDMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zICcwLjMzMydcbiAgICogICAgbWF0aC5mb3JtYXQoMjEzODUsIDIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnMjEwMDAnXG4gICAqICAgIG1hdGguZm9ybWF0KDEyLjA3MSwge25vdGF0aW9uOiAnZml4ZWQnfSk7ICAgICAgICAgICAgICAgIC8vIHJldHVybnMgJzEyJ1xuICAgKiAgICBtYXRoLmZvcm1hdCgyLjMsICAgIHtub3RhdGlvbjogJ2ZpeGVkJywgcHJlY2lzaW9uOiAyfSk7ICAvLyByZXR1cm5zICcyLjMwJ1xuICAgKiAgICBtYXRoLmZvcm1hdCg1Mi44LCAgIHtub3RhdGlvbjogJ2V4cG9uZW50aWFsJ30pOyAgICAgICAgICAvLyByZXR1cm5zICc1LjI4ZSsxJ1xuICAgKiAgICBtYXRoLmZvcm1hdCgxMjQwMCwgIHtub3RhdGlvbjogJ2VuZ2luZWVyaW5nJ30pOyAgICAgICAgIC8vIHJldHVybnMgJzEyLjQwMGUrMydcbiAgICpcbiAgICogICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kodmFsdWUpIHtcbiAgICogICAgICAvLyByZXR1cm4gY3VycmVuY3kgbm90YXRpb24gd2l0aCB0d28gZGlnaXRzOlxuICAgKiAgICAgIHJldHVybiAnJCcgKyB2YWx1ZS50b0ZpeGVkKDIpO1xuICAgKlxuICAgKiAgICAgIC8vIHlvdSBjb3VsZCBhbHNvIHVzZSBtYXRoLmZvcm1hdCBpbnNpZGUgdGhlIGNhbGxiYWNrOlxuICAgKiAgICAgIC8vIHJldHVybiAnJCcgKyBtYXRoLmZvcm1hdCh2YWx1ZSwge25vdGF0aW9uOiAnZml4ZWQnLCBwcmVjaXNpb246IDJ9KTtcbiAgICogICAgfVxuICAgKiAgICBtYXRoLmZvcm1hdChbMi4xLCAzLCAwLjAxNl0sIGZvcm1hdEN1cnJlbmN5fTsgICAgICAgICAgICAvLyByZXR1cm5zICdbJDIuMTAsICQzLjAwLCAkMC4wMl0nXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBwcmludFxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIGJlIHN0cmluZ2lmaWVkXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBudW1iZXJ9IFtvcHRpb25zXSAgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB2YWx1ZVxuICAgKi9cbiAgdmFyIGZvcm1hdCA9IHR5cGVkKCdmb3JtYXQnLCB7XG4gICAgJ2FueSc6IHN0cmluZy5mb3JtYXQsXG4gICAgJ2FueSwgT2JqZWN0IHwgZnVuY3Rpb24gfCBudW1iZXInOiBzdHJpbmcuZm9ybWF0XG4gIH0pO1xuXG4gIGZvcm1hdC50b1RleCA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdGVtcGxhdGVcblxuICByZXR1cm4gZm9ybWF0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZm9ybWF0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIGNvc2luZSBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYWNvcyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hY29zKDAuNSk7ICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAxLjA0NzE5NzU1MTE5NjU5NzlcbiAgICogICAgbWF0aC5hY29zKG1hdGguY29zKDEuNSkpOyAvLyByZXR1cm5zIG51bWJlciAxLjVcbiAgICpcbiAgICogICAgbWF0aC5hY29zKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMCArIDEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3MsIGF0YW4sIGFzaW5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGhlIGFyYyBjb3NpbmUgb2YgeFxuICAgKi9cbiAgdmFyIGFjb3MgPSB0eXBlZCgnYWNvcycsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgoeCA+PSAtMSAmJiB4IDw9IDEpIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgsIDApLmFjb3MoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWNvcygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFjb3MoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFjb3MpO1xuICAgIH1cbiAgfSk7XG5cbiAgYWNvcy50b1RleCA9IHsxOiAnXFxcXGNvc157LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gYWNvcztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjb3MnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjY29zIG9mIGEgdmFsdWUsXG4gICAqIGRlZmluZWQgYXMgYGFjb3NoKHgpID0gbG4oc3FydCh4XjIgLSAxKSArIHgpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFjb3NoKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjb3NoKDEuNSk7ICAgICAgIC8vIHJldHVybnMgMC45NjI0MjM2NTAxMTkyMDY5XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3NoLCBhc2luaCwgYXRhbmhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjY29zaW5lIG9mIHhcbiAgICovXG4gIHZhciBhY29zaCA9IHR5cGVkKCdhY29zaCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICh4ID49IDEgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBfYWNvc2goeCk7XG4gICAgICB9XG4gICAgICBpZiAoeCA8PSAtMSkge1xuICAgICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleChNYXRoLmxvZyhNYXRoLnNxcnQoeCp4IC0gMSkgLSB4KSwgTWF0aC5QSSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5hY29zaCgpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hY29zaCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFjb3NoKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhY29zaCk7XG4gICAgfVxuICB9KTtcblxuICBhY29zaC50b1RleCA9IHsxOiAnXFxcXGNvc2heey0xfVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XG5cbiAgcmV0dXJuIGFjb3NoO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNjb3Mgb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgX2Fjb3NoID0gTWF0aC5hY29zaCB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KHgqeCAtIDEpICsgeClcbn07XG5cbmV4cG9ydHMubmFtZSA9ICdhY29zaCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBjb3RhbmdlbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYWNvdCh4KSA9IGF0YW4oMS94KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hY290KHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjb3QoMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNDYzNjQ3NjA5MDAwODA2MVxuICAgKiAgICBtYXRoLmFjb3QobWF0aC5jb3QoMS41KSk7IC8vIHJldHVybnMgbnVtYmVyIDEuNVxuICAgKlxuICAgKiAgICBtYXRoLmFjb3QoMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAxLjU3MDc5NjMyNjc5NDg5NjYgLTEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3QsIGF0YW5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBhcmMgY290YW5nZW50IG9mIHhcbiAgICovXG4gIHZhciBhY290ID0gdHlwZWQoJ2Fjb3QnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuKDEgLyB4KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWNvdCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHgpLmF0YW4oKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFjb3QpO1xuICAgIH1cbiAgfSk7XG5cbiAgYWNvdC50b1RleCA9IHsxOiAnXFxcXGNvdF57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gYWNvdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjb3QnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjY290YW5nZW50IG9mIGEgdmFsdWUsXG4gICAqIGRlZmluZWQgYXMgYGFjb3RoKHgpID0gYXRhbmgoMS94KSA9IChsbigoeCsxKS94KSArIGxuKHgvKHgtMSkpKSAvIDJgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYWNvdGgoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYWNvdGgoMC41KTsgICAgICAgLy8gcmV0dXJucyAwLjgwNDcxODk1NjIxNzA1MDNcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFjc2NoLCBhc2VjaFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIGFyY2NvdGFuZ2VudCBvZiB4XG4gICAqL1xuICB2YXIgYWNvdGggPSB0eXBlZCgnYWNvdGgnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA+PSAxIHx8IHggPD0gLTEgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh4KSA/IChNYXRoLmxvZygoeCsxKS94KSArIE1hdGgubG9nKHgvKHgtMSkpKSAvIDIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYWNvdGgoKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYWNvdGgoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdih4KS5hdGFuaCgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYWNvdGgpO1xuICAgIH1cbiAgfSk7XG5cbiAgYWNvdGgudG9UZXggPSB7MTogJ1xcXFxjb3RoXnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBhY290aDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjb3RoJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgY29zZWNhbnQgb2YgYSB2YWx1ZSwgZGVmaW5lZCBhcyBgYWNzYyh4KSA9IGFzaW4oMS94KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hY3NjKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjc2MoMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNTIzNTk4Nzc1NTk4Mjk4OVxuICAgKiAgICBtYXRoLmFjc2MobWF0aC5jc2MoMS41KSk7IC8vIHJldHVybnMgbnVtYmVyIH4xLjVcbiAgICpcbiAgICogICAgbWF0aC5hY3NjKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMS41NzA3OTYzMjY3OTQ4OTY2IC0xLjMxNjk1Nzg5NjkyNDgxNjYgaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY3NjLCBhc2luLCBhc2VjXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIGNvc2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBhY3NjID0gdHlwZWQoJ2Fjc2MnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA8PSAtMSB8fCB4ID49IDEgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oMSAvIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYWNzYygpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hY3NjKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeCkuYXNpbigpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYWNzYyk7XG4gICAgfVxuICB9KTtcblxuICBhY3NjLnRvVGV4ID0gezE6ICdcXFxcY3NjXnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBhY3NjO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWNzYyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNjb3NlY2FudCBvZiBhIHZhbHVlLFxuICAgKiBkZWZpbmVkIGFzIGBhY3NjaCh4KSA9IGFzaW5oKDEveCkgPSBsbigxL3ggKyBzcXJ0KDEveF4yICsgMSkpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFjc2NoKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFjc2NoKDAuNSk7ICAgICAgIC8vIHJldHVybnMgMS40NDM2MzU0NzUxNzg4MTAzXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBhc2VjaCwgYWNvdGhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyBhcmNjb3NlY2FudCBvZiB4XG4gICAqL1xuICB2YXIgYWNzY2ggPSB0eXBlZCgnYWNzY2gnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB4ID0gMSAvIHg7XG4gICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4KnggKyAxKSk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFjc2NoKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeCkuYXNpbmgoKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFjc2NoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFjc2NoLnRvVGV4ID0gezE6ICdcXFxcbWF0aHJte2NzY2h9XnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBhY3NjaDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Fjc2NoJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIHNlY2FudCBvZiBhIHZhbHVlLiBEZWZpbmVkIGFzIGBhc2VjKHgpID0gYWNvcygxL3gpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmFzZWMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYXNlYygwLjUpOyAgICAgICAgICAgLy8gcmV0dXJucyAxLjA0NzE5NzU1MTE5NjU5NzlcbiAgICogICAgbWF0aC5hc2VjKG1hdGguc2VjKDEuNSkpOyAvLyByZXR1cm5zIDEuNVxuICAgKlxuICAgKiAgICBtYXRoLmFzZWMoMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgMCArIDEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBhY29zLCBhY290LCBhY3NjXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBhcmMgc2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBhc2VjID0gdHlwZWQoJ2FzZWMnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoeCA8PSAtMSB8fCB4ID49IDEgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoMSAvIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYXNlYygpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hc2VjKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeCkuYWNvcygpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYXNlYyk7XG4gICAgfVxuICB9KTtcblxuICBhc2VjLnRvVGV4ID0gezE6ICdcXFxcc2VjXnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBhc2VjO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYXNlYyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIHZhciBhY29zaCA9IHR5cGVkLmZpbmQobG9hZChyZXF1aXJlKCcuL2Fjb3NoJykpLCBbJ0NvbXBsZXgnXSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmNzZWNhbnQgb2YgYSB2YWx1ZSxcbiAgICogZGVmaW5lZCBhcyBgYXNlY2goeCkgPSBhY29zaCgxL3gpID0gbG4oc3FydCgxL3heMiAtIDEpICsgMS94KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hc2VjaCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hc2VjaCgwLjUpOyAgICAgICAvLyByZXR1cm5zIDEuMzE2OTU3ODk2OTI0ODE2NlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYWNzY2gsIGFjb3RoXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgYXJjc2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBhc2VjaCA9IHR5cGVkKCdhc2VjaCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgoeCA8PSAxICYmIHggPj0gLTEpIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICB4ID0gMSAvIHg7XG5cbiAgICAgICAgdmFyIHJldCA9IE1hdGguc3FydCh4KnggLSAxKTtcbiAgICAgICAgaWYgKHggPiAwIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhyZXQgKyB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KE1hdGgubG9nKHJldCAtIHgpLCBNYXRoLlBJKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkNvbXBsZXgoeCwgMCkuYXNlY2goKTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYXNlY2goKVxuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHgpLmFjb3NoKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBhc2VjaCk7XG4gICAgfVxuICB9KTtcblxuICBhc2VjaC50b1RleCA9IHsxOiAnXFxcXG1hdGhybXtzZWNofV57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gYXNlY2g7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhc2VjaCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBzaW5lIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hc2luKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmFzaW4oMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNTIzNTk4Nzc1NTk4Mjk4OVxuICAgKiAgICBtYXRoLmFzaW4obWF0aC5zaW4oMS41KSk7IC8vIHJldHVybnMgbnVtYmVyIH4xLjVcbiAgICpcbiAgICogICAgbWF0aC5hc2luKDIpOyAgICAgICAgICAgICAvLyByZXR1cm5zIENvbXBsZXggMS41NzA3OTYzMjY3OTQ4OTY2IC0xLjMxNjk1Nzg5NjkyNDgxNjYgaVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgc2luLCBhdGFuLCBhY29zXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSB4ICAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBUaGUgYXJjIHNpbmUgb2YgeFxuICAgKi9cbiAgdmFyIGFzaW4gPSB0eXBlZCgnYXNpbicsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgoeCA+PSAtMSAmJiB4IDw9IDEpIHx8IGNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hc2luKHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdHlwZS5Db21wbGV4KHgsIDApLmFzaW4oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYXNpbigpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmFzaW4oKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgYXNpbigwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFzaW4sIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgYXNpbi50b1RleCA9IHsxOiAnXFxcXHNpbl57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gYXNpbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FzaW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjc2luZSBvZiBhIHZhbHVlLFxuICAgKiBkZWZpbmVkIGFzIGBhc2luaCh4KSA9IGxuKHggKyBzcXJ0KHheMiArIDEpKWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hc2luaCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hc2luaCgwLjUpOyAgICAgICAvLyByZXR1cm5zIDAuNDgxMjExODI1MDU5NjAzNDdcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFjb3NoLCBhdGFuaFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIGFyY3NpbmUgb2YgeFxuICAgKi9cbiAgdmFyIGFzaW5oID0gdHlwZWQoJ2FzaW5oJywge1xuICAgICdudW1iZXInOiBNYXRoLmFzaW5oIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KHgqeCArIDEpICsgeCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguYXNpbmgoKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hc2luaCgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSBhc2luaCgwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGFzaW5oLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFzaW5oLnRvVGV4ID0gezE6ICdcXFxcc2luaF57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gYXNpbmg7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhc2luaCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSB0YW5nZW50IG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hdGFuKHgpXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICBtYXRoLmF0YW4oMC41KTsgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNDYzNjQ3NjA5MDAwODA2MVxuICAgKiAgICBtYXRoLmF0YW4obWF0aC50YW4oMS41KSk7IC8vIHJldHVybnMgbnVtYmVyIDEuNVxuICAgKlxuICAgKiAgICBtYXRoLmF0YW4oMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAxLjU3MDc5NjMyNjc5NDg5NjYgLTEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICB0YW4sIGFzaW4sIGFjb3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IHggICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IFRoZSBhcmMgdGFuZ2VudCBvZiB4XG4gICAqL1xuICB2YXIgYXRhbiA9IHR5cGVkKCdhdGFuJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbih4KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguYXRhbigpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmF0YW4oKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2UgYXRhbigwKSA9IDBcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGF0YW4sIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgYXRhbi50b1RleCA9IHsxOiAnXFxcXHRhbl57LTF9XFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gYXRhbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2F0YW4nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBtYXRyaXggPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L2Z1bmN0aW9uL21hdHJpeCcpKTtcblxuICB2YXIgYWxnb3JpdGhtMDIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAyJykpO1xuICB2YXIgYWxnb3JpdGhtMDMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTAzJykpO1xuICB2YXIgYWxnb3JpdGhtMDkgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTA5JykpO1xuICB2YXIgYWxnb3JpdGhtMTEgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTExJykpO1xuICB2YXIgYWxnb3JpdGhtMTIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEyJykpO1xuICB2YXIgYWxnb3JpdGhtMTMgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTEzJykpO1xuICB2YXIgYWxnb3JpdGhtMTQgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbWF0cml4L3V0aWxzL2FsZ29yaXRobTE0JykpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgdGFuZ2VudCBmdW5jdGlvbiB3aXRoIHR3byBhcmd1bWVudHMsIHkveC5cbiAgICogQnkgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIHRoZSByaWdodCBxdWFkcmFudCBvZiB0aGUgY29tcHV0ZWQgYW5nbGUgY2FuIGJlXG4gICAqIGRldGVybWluZWQuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5hdGFuMih5LCB4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5hdGFuMigyLCAyKSAvIG1hdGgucGk7ICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuMjVcbiAgICpcbiAgICogICAgdmFyIGFuZ2xlID0gbWF0aC51bml0KDYwLCAnZGVnJyk7IC8vIHJldHVybnMgVW5pdCA2MCBkZWdcbiAgICogICAgdmFyIHggPSBtYXRoLmNvcyhhbmdsZSk7XG4gICAqICAgIHZhciB5ID0gbWF0aC5zaW4oYW5nbGUpO1xuICAgKlxuICAgKiAgICBtYXRoLmF0YW4oMik7ICAgICAgICAgICAgIC8vIHJldHVybnMgQ29tcGxleCAxLjU3MDc5NjMyNjc5NDg5NjYgLTEuMzE2OTU3ODk2OTI0ODE2NiBpXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICB0YW4sIGF0YW4sIHNpbiwgY29zXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQXJyYXkgfCBNYXRyaXh9IHkgIFNlY29uZCBkaW1lbnNpb25cbiAgICogQHBhcmFtIHtudW1iZXIgfCBBcnJheSB8IE1hdHJpeH0geCAgRmlyc3QgZGltZW5zaW9uXG4gICAqIEByZXR1cm4ge251bWJlciB8IEFycmF5IHwgTWF0cml4fSBGb3VyLXF1YWRyYW50IGludmVyc2UgdGFuZ2VudFxuICAgKi9cbiAgdmFyIGF0YW4yID0gdHlwZWQoJ2F0YW4yJywge1xuXG4gICAgJ251bWJlciwgbnVtYmVyJzogTWF0aC5hdGFuMixcblxuICAgIC8vIENvbXBsZXggbnVtYmVycyBkb2Vzbid0IHNlZW0gdG8gaGF2ZSBhIHJlYXNvbmFibGUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAvLyBhdGFuMigpLiBFdmVuIE1hdGxhYiByZW1vdmVkIHRoZSBzdXBwb3J0LCBhZnRlciB0aGV5IG9ubHkgY2FsY3VsYXRlZFxuICAgIC8vIHRoZSBhdGFuIG9ubHkgb24gYmFzZSBvZiB0aGUgcmVhbCBwYXJ0IG9mIHRoZSBudW1iZXJzIGFuZCBpZ25vcmVkIHRoZSBpbWFnaW5hcnkuXG5cbiAgICAnQmlnTnVtYmVyLCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeSwgeCkge1xuICAgICAgcmV0dXJuIHR5cGUuQmlnTnVtYmVyLmF0YW4yKHksIHgpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBNYXRyaXgnOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gcmVzdWx0XG4gICAgICB2YXIgYztcblxuICAgICAgLy8gcHJvY2VzcyBtYXRyaXggc3RvcmFnZVxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYXJzZSc6XG4gICAgICAgICAgICAgIC8vIHNwYXJzZSAuKiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTA5KHgsIHksIGF0YW4yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc3BhcnNlIC4qIGRlbnNlXG4gICAgICAgICAgICAgIGMgPSBhbGdvcml0aG0wMih5LCB4LCBhdGFuMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzd2l0Y2ggKHkuc3RvcmFnZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgICAgICAvLyBkZW5zZSAuKiBzcGFyc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTAzKHgsIHksIGF0YW4yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gZGVuc2UgLiogZGVuc2VcbiAgICAgICAgICAgICAgYyA9IGFsZ29yaXRobTEzKHgsIHksIGF0YW4yKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdBcnJheSwgQXJyYXknOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGF0YW4yKG1hdHJpeCh4KSwgbWF0cml4KHkpKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdBcnJheSwgTWF0cml4JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhdGFuMihtYXRyaXgoeCksIHkpO1xuICAgIH0sXG5cbiAgICAnTWF0cml4LCBBcnJheSc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyB1c2UgbWF0cml4IGltcGxlbWVudGF0aW9uXG4gICAgICByZXR1cm4gYXRhbjIoeCwgbWF0cml4KHkpKTtcbiAgICB9LFxuXG4gICAgJ01hdHJpeCwgbnVtYmVyIHwgQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHJlc3VsdFxuICAgICAgdmFyIGM7XG4gICAgICAvLyBjaGVjayBzdG9yYWdlIGZvcm1hdFxuICAgICAgc3dpdGNoICh4LnN0b3JhZ2UoKSkge1xuICAgICAgICBjYXNlICdzcGFyc2UnOlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xMSh4LCB5LCBhdGFuMiwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh4LCB5LCBhdGFuMiwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIE1hdHJpeCc6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyByZXN1bHRcbiAgICAgIHZhciBjO1xuICAgICAgLy8gY2hlY2sgc3RvcmFnZSBmb3JtYXRcbiAgICAgIHN3aXRjaCAoeS5zdG9yYWdlKCkpIHtcbiAgICAgICAgY2FzZSAnc3BhcnNlJzpcbiAgICAgICAgICBjID0gYWxnb3JpdGhtMTIoeSwgeCwgYXRhbjIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGMgPSBhbGdvcml0aG0xNCh5LCB4LCBhdGFuMiwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgJ0FycmF5LCBudW1iZXIgfCBCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgLy8gdXNlIG1hdHJpeCBpbXBsZW1lbnRhdGlvblxuICAgICAgcmV0dXJuIGFsZ29yaXRobTE0KG1hdHJpeCh4KSwgeSwgYXRhbjIsIGZhbHNlKS52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdudW1iZXIgfCBCaWdOdW1iZXIsIEFycmF5JzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIC8vIHVzZSBtYXRyaXggaW1wbGVtZW50YXRpb25cbiAgICAgIHJldHVybiBhbGdvcml0aG0xNChtYXRyaXgoeSksIHgsIGF0YW4yLCB0cnVlKS52YWx1ZU9mKCk7XG4gICAgfVxuICB9KTtcblxuICBhdGFuMi50b1RleCA9IHsyOiAnXFxcXG1hdGhybXthdGFuMn1cXFxcbGVmdCgke2FyZ3N9XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBhdGFuMjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2F0YW4yJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBhcmN0YW5nZW50IG9mIGEgdmFsdWUsXG4gICAqIGRlZmluZWQgYXMgYGF0YW5oKHgpID0gbG4oKDEgKyB4KS8oMSAtIHgpKSAvIDJgLlxuICAgKlxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGguYXRhbmgoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguYXRhbmgoMC41KTsgICAgICAgLy8gcmV0dXJucyAwLjU0OTMwNjE0NDMzNDA1NDlcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGFjb3NoLCBhc2luaFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBIeXBlcmJvbGljIGFyY3RhbmdlbnQgb2YgeFxuICAgKi9cbiAgdmFyIGF0YW5oID0gdHlwZWQoJ2F0YW5oJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCh4IDw9IDEgJiYgeCA+PSAtMSkgfHwgY29uZmlnLnByZWRpY3RhYmxlKSB7XG4gICAgICAgIHJldHVybiBfYXRhbmgoeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHR5cGUuQ29tcGxleCh4LCAwKS5hdGFuaCgpO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5hdGFuaCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmF0YW5oKCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIGF0YW5oKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgYXRhbmgsIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgYXRhbmgudG9UZXggPSB7MTogJ1xcXFx0YW5oXnstMX1cXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xuXG4gIHJldHVybiBhdGFuaDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgYXJjdGFuZ2VudCBvZiBhIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBfYXRhbmggPSBNYXRoLmF0YW5oIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBNYXRoLmxvZygoMSArIHgpLygxIC0geCkpIC8gMlxufTtcblxuZXhwb3J0cy5uYW1lID0gJ2F0YW5oJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb3NpbmUgb2YgYSB2YWx1ZS5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmNvcyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jb3MoMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIC0wLjQxNjE0NjgzNjU0NzE0MjJcbiAgICogICAgbWF0aC5jb3MobWF0aC5waSAvIDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyICAwLjcwNzEwNjc4MTE4NjU0NzVcbiAgICogICAgbWF0aC5jb3MobWF0aC51bml0KDE4MCwgJ2RlZycpKTsgIC8vIHJldHVybnMgbnVtYmVyIC0xXG4gICAqICAgIG1hdGguY29zKG1hdGgudW5pdCg2MCwgJ2RlZycpKTsgICAvLyByZXR1cm5zIG51bWJlciAgMC41XG4gICAqXG4gICAqICAgIHZhciBhbmdsZSA9IDAuMjtcbiAgICogICAgbWF0aC5wb3cobWF0aC5zaW4oYW5nbGUpLCAyKSArIG1hdGgucG93KG1hdGguY29zKGFuZ2xlKSwgMik7IC8vIHJldHVybnMgbnVtYmVyIH4xXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3MsIHRhblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gQ29zaW5lIG9mIHhcbiAgICovXG4gIHZhciBjb3MgPSB0eXBlZCgnY29zJywge1xuICAgICdudW1iZXInOiBNYXRoLmNvcyxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNvcygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNvcygpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY29zIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29zKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY29zKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvcy50b1RleCA9IHsxOiAnXFxcXGNvc1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XG5cbiAgcmV0dXJuIGNvcztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2Nvcyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxuXHJcbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgY29zaCh4KSA9IDEvMiAqIChleHAoeCkgKyBleHAoLXgpKWAuXHJcbiAgICpcclxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxyXG4gICAqXHJcbiAgICogU3ludGF4OlxyXG4gICAqXHJcbiAgICogICAgbWF0aC5jb3NoKHgpXHJcbiAgICpcclxuICAgKiBFeGFtcGxlczpcclxuICAgKlxyXG4gICAqICAgIG1hdGguY29zaCgwLjUpOyAgICAgICAvLyByZXR1cm5zIG51bWJlciAxLjEyNzYyNTk2NTIwNjM4MDdcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgdGFuaFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyBjb3NpbmUgb2YgeFxyXG4gICAqL1xyXG4gIHZhciBjb3NoID0gdHlwZWQoJ2Nvc2gnLCB7XHJcbiAgICAnbnVtYmVyJzogX2Nvc2gsXHJcblxyXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geC5jb3NoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geC5jb3NoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY29zaCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb3NoKHgudmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBjb3NoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY29zaC50b1RleCA9IHsxOiAnXFxcXGNvc2hcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSd9O1xyXG5cclxuICByZXR1cm4gY29zaDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYSBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBfY29zaCA9IE1hdGguY29zaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gIHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjtcclxufTtcclxuXHJcbmV4cG9ydHMubmFtZSA9ICdjb3NoJztcclxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvdGFuZ2VudCBvZiBhIHZhbHVlLiBEZWZpbmVkIGFzIGBjb3QoeCkgPSAxIC8gdGFuKHgpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLmNvdCh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5jb3QoMik7ICAgICAgLy8gcmV0dXJucyBudW1iZXIgLTAuNDU3NjU3NTU0MzYwMjg1NzdcbiAgICogICAgMSAvIG1hdGgudGFuKDIpOyAgLy8gcmV0dXJucyBudW1iZXIgLTAuNDU3NjU3NTU0MzYwMjg1NzdcbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIHRhbiwgc2VjLCBjc2NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IENvdGFuZ2VudCBvZiB4XG4gICAqL1xuICB2YXIgY290ID0gdHlwZWQoJ2NvdCcsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAxIC8gTWF0aC50YW4oeCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNvdCgpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHgudGFuKCkpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY290IGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY290KHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY290KTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvdC50b1RleCA9IHsxOiAnXFxcXGNvdFxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XG5cbiAgcmV0dXJuIGNvdDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NvdCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxuXHJcbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgY290YW5nZW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgY290aCh4KSA9IDEgLyB0YW5oKHgpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLmNvdGgoeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gY290aCh4KSA9IDEgLyB0YW5oKHgpXHJcbiAgICogICAgbWF0aC5jb3RoKDIpOyAgICAgICAgIC8vIHJldHVybnMgMS4wMzczMTQ3MjA3Mjc1NDgyXHJcbiAgICogICAgMSAvIG1hdGgudGFuaCgyKTsgICAgIC8vIHJldHVybnMgMS4wMzczMTQ3MjA3Mjc1NDgyXHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIHNpbmgsIHRhbmgsIGNvc2hcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgY290YW5nZW50IG9mIHhcclxuICAgKi9cclxuICB2YXIgY290aCA9IHR5cGVkKCdjb3RoJywge1xyXG4gICAgJ251bWJlcic6IF9jb3RoLFxyXG5cclxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIHguY290aCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeC50YW5oKCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIGNvdGggaXMgbm8gYW5nbGUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY290aCh4LnZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY290aCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGNvdGgudG9UZXggPSB7MTogJ1xcXFxjb3RoXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcclxuXHJcbiAgcmV0dXJuIGNvdGg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGEgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBfY290aCh4KSB7XHJcbiAgdmFyIGUgPSBNYXRoLmV4cCgyICogeCk7XHJcbiAgcmV0dXJuIChlICsgMSkgLyAoZSAtIDEpO1xyXG59XHJcblxyXG5leHBvcnRzLm5hbWUgPSAnY290aCc7XHJcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb3NlY2FudCBvZiBhIHZhbHVlLCBkZWZpbmVkIGFzIGBjc2MoeCkgPSAxL3Npbih4KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5jc2MoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguY3NjKDIpOyAgICAgIC8vIHJldHVybnMgbnVtYmVyIDEuMDk5NzUwMTcwMjk0NjE3XG4gICAqICAgIDEgLyBtYXRoLnNpbigyKTsgIC8vIHJldHVybnMgbnVtYmVyIDEuMDk5NzUwMTcwMjk0NjE3XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBzaW4sIHNlYywgY290XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcbiAgICogQHJldHVybiB7bnVtYmVyIHwgQ29tcGxleCB8IEFycmF5IHwgTWF0cml4fSBDb3NlY2FudCBvZiB4XG4gICAqL1xuICB2YXIgY3NjID0gdHlwZWQoJ2NzYycsIHtcbiAgICAnbnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAxIC8gTWF0aC5zaW4oeCk7XG4gICAgfSxcblxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmNzYygpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5CaWdOdW1iZXIoMSkuZGl2KHguc2luKCkpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY3NjIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NjKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgY3NjKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNzYy50b1RleCA9IHsxOiAnXFxcXGNzY1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XG5cbiAgcmV0dXJuIGNzYztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2NzYyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxudmFyIHNpZ24gPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5zaWduO1xyXG5cclxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBjb3NlY2FudCBvZiBhIHZhbHVlLFxyXG4gICAqIGRlZmluZWQgYXMgYGNzY2goeCkgPSAxIC8gc2luaCh4KWAuXHJcbiAgICpcclxuICAgKiBGb3IgbWF0cmljZXMsIHRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudCB3aXNlLlxyXG4gICAqXHJcbiAgICogU3ludGF4OlxyXG4gICAqXHJcbiAgICogICAgbWF0aC5jc2NoKHgpXHJcbiAgICpcclxuICAgKiBFeGFtcGxlczpcclxuICAgKlxyXG4gICAqICAgIC8vIGNzY2goeCkgPSAxLyBzaW5oKHgpXHJcbiAgICogICAgbWF0aC5jc2NoKDAuNSk7ICAgICAgIC8vIHJldHVybnMgMS45MTkwMzQ3NTEzMzQ5NDM3XHJcbiAgICogICAgMSAvIG1hdGguc2luaCgwLjUpOyAgIC8vIHJldHVybnMgMS45MTkwMzQ3NTEzMzQ5NDM3XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIHNpbmgsIHNlY2gsIGNvdGhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgY29zZWNhbnQgb2YgeFxyXG4gICAqL1xyXG4gIHZhciBjc2NoID0gdHlwZWQoJ2NzY2gnLCB7XHJcbiAgICAnbnVtYmVyJzogX2NzY2gsXHJcblxyXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geC5jc2NoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdih4LnNpbmgoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gY3NjaCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjc2NoKHgudmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBjc2NoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY3NjaC50b1RleCA9IHsxOiAnXFxcXG1hdGhybXtjc2NofVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XHJcblxyXG4gIHJldHVybiBjc2NoO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2VjYW50IG9mIGEgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBfY3NjaCh4KSB7XHJcbiAgLy8gY29uc2lkZXIgdmFsdWVzIGNsb3NlIHRvIHplcm8gKCsvLSlcclxuICBpZiAoeCA9PSAwKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHJldHVybiBNYXRoLmFicygyIC8gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSkgKiBzaWduKHgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5uYW1lID0gJ2NzY2gnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgcmVxdWlyZSgnLi9hY29zJyksXG4gIHJlcXVpcmUoJy4vYWNvc2gnKSxcbiAgcmVxdWlyZSgnLi9hY290JyksXG4gIHJlcXVpcmUoJy4vYWNvdGgnKSxcbiAgcmVxdWlyZSgnLi9hY3NjJyksXG4gIHJlcXVpcmUoJy4vYWNzY2gnKSxcbiAgcmVxdWlyZSgnLi9hc2VjJyksXG4gIHJlcXVpcmUoJy4vYXNlY2gnKSxcbiAgcmVxdWlyZSgnLi9hc2luJyksXG4gIHJlcXVpcmUoJy4vYXNpbmgnKSxcbiAgcmVxdWlyZSgnLi9hdGFuJyksXG4gIHJlcXVpcmUoJy4vYXRhbjInKSxcbiAgcmVxdWlyZSgnLi9hdGFuaCcpLFxuICByZXF1aXJlKCcuL2NvcycpLFxuICByZXF1aXJlKCcuL2Nvc2gnKSxcbiAgcmVxdWlyZSgnLi9jb3QnKSxcbiAgcmVxdWlyZSgnLi9jb3RoJyksXG4gIHJlcXVpcmUoJy4vY3NjJyksXG4gIHJlcXVpcmUoJy4vY3NjaCcpLFxuICByZXF1aXJlKCcuL3NlYycpLFxuICByZXF1aXJlKCcuL3NlY2gnKSxcbiAgcmVxdWlyZSgnLi9zaW4nKSxcbiAgcmVxdWlyZSgnLi9zaW5oJyksXG4gIHJlcXVpcmUoJy4vdGFuJyksXG4gIHJlcXVpcmUoJy4vdGFuaCcpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNlY2FudCBvZiBhIHZhbHVlLCBkZWZpbmVkIGFzIGBzZWMoeCkgPSAxL2Nvcyh4KWAuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zZWMoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc2VjKDIpOyAgICAgIC8vIHJldHVybnMgbnVtYmVyIC0yLjQwMjk5Nzk2MTcyMjM4MjJcbiAgICogICAgMSAvIG1hdGguY29zKDIpOyAgLy8gcmV0dXJucyBudW1iZXIgLTIuNDAyOTk3OTYxNzIyMzgyMlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgY29zLCBjc2MsIGNvdFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gU2VjYW50IG9mIHhcbiAgICovXG4gIHZhciBzZWMgPSB0eXBlZCgnc2VjJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIDEgLyBNYXRoLmNvcyh4KTtcbiAgICB9LFxuXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguc2VjKCk7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcigxKS5kaXYoeC5jb3MoKSk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIGlmICgheC5oYXNCYXNlKHR5cGUuVW5pdC5CQVNFX1VOSVRTLkFOR0xFKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBzZWMgaXMgbm8gYW5nbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWMoeC52YWx1ZSk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzZWMpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2VjLnRvVGV4ID0gezE6ICdcXFxcc2VjXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gc2VjO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnc2VjJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xyXG5cclxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBzZWNhbnQgb2YgYSB2YWx1ZSxcclxuICAgKiBkZWZpbmVkIGFzIGBzZWNoKHgpID0gMSAvIGNvc2goeClgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguc2VjaCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICAvLyBzZWNoKHgpID0gMS8gY29zaCh4KVxyXG4gICAqICAgIG1hdGguc2VjaCgwLjUpOyAgICAgICAvLyByZXR1cm5zIDAuODg2ODE4ODgzOTcwMDc0XHJcbiAgICogICAgMSAvIG1hdGguY29zaCgwLjUpOyAgIC8vIHJldHVybnMgMC44ODY4MTg4ODM5NzAwNzRcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgY29zaCwgY3NjaCwgY290aFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge251bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyBzZWNhbnQgb2YgeFxyXG4gICAqL1xyXG4gIHZhciBzZWNoID0gdHlwZWQoJ3NlY2gnLCB7XHJcbiAgICAnbnVtYmVyJzogX3NlY2gsXHJcblxyXG4gICAgJ0NvbXBsZXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geC5zZWNoKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4gbmV3IHR5cGUuQmlnTnVtYmVyKDEpLmRpdih4LmNvc2goKSk7XHJcbiAgICB9LFxyXG5cclxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gc2VjaCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWNoKHgudmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBzZWNoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgc2VjaC50b1RleCA9IHsxOiAnXFxcXG1hdGhybXtzZWNofVxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XHJcblxyXG4gIHJldHVybiBzZWNoO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIHNlY2FudCBvZiBhIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gX3NlY2goeCkge1xyXG4gIHJldHVybiAyIC8gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKTtcclxufVxyXG5cclxuZXhwb3J0cy5uYW1lID0gJ3NlY2gnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBzaW5lIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5zaW4oeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguc2luKDIpOyAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAwLjkwOTI5NzQyNjgyNTY4MTNcbiAgICogICAgbWF0aC5zaW4obWF0aC5waSAvIDQpOyAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNzA3MTA2NzgxMTg2NTQ3NVxuICAgKiAgICBtYXRoLnNpbihtYXRoLnVuaXQoOTAsICdkZWcnKSk7ICAgLy8gcmV0dXJucyBudW1iZXIgMVxuICAgKiAgICBtYXRoLnNpbihtYXRoLnVuaXQoMzAsICdkZWcnKSk7ICAgLy8gcmV0dXJucyBudW1iZXIgMC41XG4gICAqXG4gICAqICAgIHZhciBhbmdsZSA9IDAuMjtcbiAgICogICAgbWF0aC5wb3cobWF0aC5zaW4oYW5nbGUpLCAyKSArIG1hdGgucG93KG1hdGguY29zKGFuZ2xlKSwgMik7IC8vIHJldHVybnMgbnVtYmVyIH4xXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBjb3MsIHRhblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gU2luZSBvZiB4XG4gICAqL1xuICB2YXIgc2luID0gdHlwZWQoJ3NpbicsIHtcbiAgICAnbnVtYmVyJzogTWF0aC5zaW4sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zaW4oKTtcbiAgICB9LFxuXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zaW4oKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCdVbml0IGluIGZ1bmN0aW9uIHNpbiBpcyBubyBhbmdsZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbih4LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2Ugc2luKDApID0gMFxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgc2luLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNpbi50b1RleCA9IHsxOiAnXFxcXHNpblxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XG5cbiAgcmV0dXJuIHNpbjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ3Npbic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZXBNYXAgPSByZXF1aXJlKCcuLi8uLi91dGlscy9jb2xsZWN0aW9uL2RlZXBNYXAnKTtcclxuXHJcbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBhIHZhbHVlLFxyXG4gICAqIGRlZmluZWQgYXMgYHNpbmgoeCkgPSAxLzIgKiAoZXhwKHgpIC0gZXhwKC14KSlgLlxyXG4gICAqXHJcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cclxuICAgKlxyXG4gICAqIFN5bnRheDpcclxuICAgKlxyXG4gICAqICAgIG1hdGguc2luaCh4KVxyXG4gICAqXHJcbiAgICogRXhhbXBsZXM6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnNpbmgoMC41KTsgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMC41MjEwOTUzMDU0OTM3NDc0XHJcbiAgICpcclxuICAgKiBTZWUgYWxzbzpcclxuICAgKlxyXG4gICAqICAgIGNvc2gsIHRhbmhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgQ29tcGxleCB8IFVuaXQgfCBBcnJheSB8IE1hdHJpeH0geCAgRnVuY3Rpb24gaW5wdXRcclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgQXJyYXkgfCBNYXRyaXh9IEh5cGVyYm9saWMgc2luZSBvZiB4XHJcbiAgICovXHJcbiAgdmFyIHNpbmggPSB0eXBlZCgnc2luaCcsIHtcclxuICAgICdudW1iZXInOiBfc2luaCxcclxuXHJcbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiB4LnNpbmgoKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ0JpZ051bWJlcic6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIHJldHVybiB4LnNpbmgoKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ1VuaXQnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnVW5pdCBpbiBmdW5jdGlvbiBzaW5oIGlzIG5vIGFuZ2xlJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpbmgoeC52YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIC8vIGRlZXAgbWFwIGNvbGxlY3Rpb24sIHNraXAgemVyb3Mgc2luY2Ugc2luaCgwKSA9IDBcclxuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgc2luaCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHNpbmgudG9UZXggPSB7MTogJ1xcXFxzaW5oXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcclxuXHJcbiAgcmV0dXJuIHNpbmg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBhIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIF9zaW5oID0gTWF0aC5zaW5oIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyO1xyXG59O1xyXG5cclxuZXhwb3J0cy5uYW1lID0gJ3NpbmgnO1xyXG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgdGFuZ2VudCBvZiBhIHZhbHVlLiBgdGFuKHgpYCBpcyBlcXVhbCB0byBgc2luKHgpIC8gY29zKHgpYC5cbiAgICpcbiAgICogRm9yIG1hdHJpY2VzLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIGVsZW1lbnQgd2lzZS5cbiAgICpcbiAgICogU3ludGF4OlxuICAgKlxuICAgKiAgICBtYXRoLnRhbih4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC50YW4oMC41KTsgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDAuNTQ2MzAyNDg5ODQzNzkwNVxuICAgKiAgICBtYXRoLnNpbigwLjUpIC8gbWF0aC5jb3MoMC41KTsgICAgLy8gcmV0dXJucyBudW1iZXIgMC41NDYzMDI0ODk4NDM3OTA1XG4gICAqICAgIG1hdGgudGFuKG1hdGgucGkgLyA0KTsgICAgICAgICAgICAvLyByZXR1cm5zIG51bWJlciAxXG4gICAqICAgIG1hdGgudGFuKG1hdGgudW5pdCg0NSwgJ2RlZycpKTsgICAvLyByZXR1cm5zIG51bWJlciAxXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBhdGFuLCBzaW4sIGNvc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIEZ1bmN0aW9uIGlucHV0XG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gVGFuZ2VudCBvZiB4XG4gICAqL1xuICB2YXIgdGFuID0gdHlwZWQoJ3RhbicsIHtcbiAgICAnbnVtYmVyJzogTWF0aC50YW4sXG5cbiAgICAnQ29tcGxleCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnRhbigpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRhbigpO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIXguaGFzQmFzZSh0eXBlLlVuaXQuQkFTRV9VTklUUy5BTkdMRSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gdGFuIGlzIG5vIGFuZ2xlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFuKHgudmFsdWUpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgLy8gZGVlcCBtYXAgY29sbGVjdGlvbiwgc2tpcCB6ZXJvcyBzaW5jZSB0YW4oMCkgPSAwXG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCB0YW4sIHRydWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGFuLnRvVGV4ID0gezE6ICdcXFxcdGFuXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknfTtcblxuICByZXR1cm4gdGFuO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndGFuJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xyXG5cclxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGEgdmFsdWUsXHJcbiAgICogZGVmaW5lZCBhcyBgdGFuaCh4KSA9IChleHAoMiAqIHgpIC0gMSkgLyAoZXhwKDIgKiB4KSArIDEpYC5cclxuICAgKlxyXG4gICAqIEZvciBtYXRyaWNlcywgdGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50IHdpc2UuXHJcbiAgICpcclxuICAgKiBTeW50YXg6XHJcbiAgICpcclxuICAgKiAgICBtYXRoLnRhbmgoeClcclxuICAgKlxyXG4gICAqIEV4YW1wbGVzOlxyXG4gICAqXHJcbiAgICogICAgLy8gdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpID0gMSAvIGNvdGgoeClcclxuICAgKiAgICBtYXRoLnRhbmgoMC41KTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAwLjQ2MjExNzE1NzI2MDAwOTc0XHJcbiAgICogICAgbWF0aC5zaW5oKDAuNSkgLyBtYXRoLmNvc2goMC41KTsgIC8vIHJldHVybnMgMC40NjIxMTcxNTcyNjAwMDk3NFxyXG4gICAqICAgIDEgLyBtYXRoLmNvdGgoMC41KTsgICAgICAgICAgICAgICAvLyByZXR1cm5zIDAuNDYyMTE3MTU3MjYwMDA5NzRcclxuICAgKlxyXG4gICAqIFNlZSBhbHNvOlxyXG4gICAqXHJcbiAgICogICAgc2luaCwgY29zaCwgY290aFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBDb21wbGV4IHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBGdW5jdGlvbiBpbnB1dFxyXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IENvbXBsZXggfCBBcnJheSB8IE1hdHJpeH0gSHlwZXJib2xpYyB0YW5nZW50IG9mIHhcclxuICAgKi9cclxuICB2YXIgdGFuaCA9IHR5cGVkKCd0YW5oJywge1xyXG4gICAgJ251bWJlcic6IF90YW5oLFxyXG5cclxuICAgICdDb21wbGV4JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4geC50YW5oKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geC50YW5oKCk7XHJcbiAgICB9LFxyXG5cclxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgaWYgKCF4Lmhhc0Jhc2UodHlwZS5Vbml0LkJBU0VfVU5JVFMuQU5HTEUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ1VuaXQgaW4gZnVuY3Rpb24gdGFuaCBpcyBubyBhbmdsZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YW5oKHgudmFsdWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAvLyBkZWVwIG1hcCBjb2xsZWN0aW9uLCBza2lwIHplcm9zIHNpbmNlIHRhbmgoMCkgPSAwXHJcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIHRhbmgsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICB0YW5oLnRvVGV4ID0gezE6ICdcXFxcdGFuaFxcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ307XHJcblxyXG4gIHJldHVybiB0YW5oO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYSBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBfdGFuaCA9IE1hdGgudGFuaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gIHZhciBlID0gTWF0aC5leHAoMiAqIHgpO1xyXG4gIHJldHVybiAoZSAtIDEpIC8gKGUgKyAxKTtcclxufTtcclxuXHJcbmV4cG9ydHMubmFtZSA9ICd0YW5oJztcclxuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xudmFyIG51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBuZWdhdGl2ZTogc21hbGxlciB0aGFuIHplcm8uXG4gICAqIFRoZSBmdW5jdGlvbiBzdXBwb3J0cyB0eXBlcyBgbnVtYmVyYCwgYEJpZ051bWJlcmAsIGBGcmFjdGlvbmAsIGFuZCBgVW5pdGAuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudC13aXNlIGluIGNhc2Ugb2YgQXJyYXkgb3IgTWF0cml4IGlucHV0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmlzTmVnYXRpdmUoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGguaXNOZWdhdGl2ZSgzKTsgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlXG4gICAqICAgIG1hdGguaXNOZWdhdGl2ZSgtMik7ICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKDApOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKC0wKTsgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKG1hdGguYmlnbnVtYmVyKDIpKTsgICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc05lZ2F0aXZlKG1hdGguZnJhY3Rpb24oLTIsIDUpKTsgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzTmVnYXRpdmUoJy0yJyk7ICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNOZWdhdGl2ZShbMiwgMCwgLTNdJyk7ICAgICAgICAgICAvLyByZXR1cm5zIFtmYWxzZSwgZmFsc2UsIHRydWVdXG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBpc051bWVyaWMsIGlzUG9zaXRpdmUsIGlzWmVybywgaXNJbnRlZ2VyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQmlnTnVtYmVyIHwgRnJhY3Rpb24gfCBVbml0IHwgQXJyYXkgfCBNYXRyaXh9IHggIFZhbHVlIHRvIGJlIHRlc3RlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgUmV0dXJucyB0cnVlIHdoZW4gYHhgIGlzIGxhcmdlciB0aGFuIHplcm8uXG4gICAqICAgICAgICAgICAgICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaW4gY2FzZSBvZiBhbiB1bmtub3duIGRhdGEgdHlwZS5cbiAgICovXG4gIHZhciBpc05lZ2F0aXZlID0gdHlwZWQoJ2lzTmVnYXRpdmUnLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geCA8IDA7XG4gICAgfSxcblxuICAgICdCaWdOdW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSAmJiAheC5pc05hTigpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucyA8IDA7IC8vIEl0J3MgZW5vdWdoIHRvIGRlY2lkZSBvbiB0aGUgc2lnblxuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gaXNOZWdhdGl2ZSh4LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGlzTmVnYXRpdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlzTmVnYXRpdmU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpc05lZ2F0aXZlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG52YXIgbnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvbnVtYmVyJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIGFuIG51bWVyaWMgdmFsdWUuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiBpcyBldmFsdWF0ZWQgZWxlbWVudC13aXNlIGluIGNhc2Ugb2YgQXJyYXkgb3IgTWF0cml4IGlucHV0LlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgICBtYXRoLmlzTnVtZXJpYyh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5pc051bWVyaWMoMik7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNOdW1lcmljKDApOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzTnVtZXJpYyhtYXRoLmJpZ251bWJlcig1MDApKTsgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc051bWVyaWMobWF0aC5mcmFjdGlvbig0KSk7ICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNOdW1lcmljKG1hdGguY29tcGxleCgnMi00aScpOyAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc051bWVyaWMoJzMnKTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzTnVtZXJpYyhbMi4zLCAnZm9vJywgZmFsc2VdKTsgICAvLyByZXR1cm5zIFt0cnVlLCBmYWxzZSwgdHJ1ZV1cbiAgICpcbiAgICogU2VlIGFsc286XG4gICAqXG4gICAqICAgIGlzWmVybywgaXNQb3NpdGl2ZSwgaXNOZWdhdGl2ZSwgaXNJbnRlZ2VyXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0geCAgICAgICBWYWx1ZSB0byBiZSB0ZXN0ZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIFJldHVybnMgdHJ1ZSB3aGVuIGB4YCBpcyBhIGBudW1iZXJgLCBgQmlnTnVtYmVyYCxcbiAgICogICAgICAgICAgICAgICAgICAgIGBGcmFjdGlvbmAsIG9yIGBib29sZWFuYC4gUmV0dXJucyBmYWxzZSBmb3Igb3RoZXIgdHlwZXMuXG4gICAqICAgICAgICAgICAgICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaW4gY2FzZSBvZiB1bmtub3duIHR5cGVzLlxuICAgKi9cbiAgdmFyIGlzTnVtZXJpYyA9IHR5cGVkKCdpc051bWVyaWMnLCB7XG4gICAgJ251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAnQ29tcGxleCB8IFVuaXQgfCBzdHJpbmcnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBpc051bWVyaWMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlzTnVtZXJpYztcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2lzTnVtZXJpYyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vZGVlcE1hcCcpO1xudmFyIG51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBwb3NpdGl2ZTogbGFyZ2VyIHRoYW4gemVyby5cbiAgICogVGhlIGZ1bmN0aW9uIHN1cHBvcnRzIHR5cGVzIGBudW1iZXJgLCBgQmlnTnVtYmVyYCwgYEZyYWN0aW9uYCwgYW5kIGBVbml0YC5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGlzIGV2YWx1YXRlZCBlbGVtZW50LXdpc2UgaW4gY2FzZSBvZiBBcnJheSBvciBNYXRyaXggaW5wdXQuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgIG1hdGguaXNQb3NpdGl2ZSh4KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5pc1Bvc2l0aXZlKDMpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoLTIpOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoMCk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoLTApOyAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoMC41KTsgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlXG4gICAqICAgIG1hdGguaXNQb3NpdGl2ZShtYXRoLmJpZ251bWJlcigyKSk7ICAgICAvLyByZXR1cm5zIHRydWVcbiAgICogICAgbWF0aC5pc1Bvc2l0aXZlKG1hdGguZnJhY3Rpb24oLTIsIDUpKTsgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc1Bvc2l0aXZlKG1hdGguZnJhY3Rpb24oMSwzKSk7ICAgIC8vIHJldHVybnMgZmFsc2VcbiAgICogICAgbWF0aC5pc1Bvc2l0aXZlKCcyJyk7ICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgICBtYXRoLmlzUG9zaXRpdmUoWzIsIDAsIC0zXScpOyAgICAgICAgICAgLy8gcmV0dXJucyBbdHJ1ZSwgZmFsc2UsIGZhbHNlXVxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgaXNOdW1lcmljLCBpc1plcm8sIGlzTmVnYXRpdmUsIGlzSW50ZWdlclxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgVW5pdCB8IEFycmF5IHwgTWF0cml4fSB4ICBWYWx1ZSB0byBiZSB0ZXN0ZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gIFJldHVybnMgdHJ1ZSB3aGVuIGB4YCBpcyBsYXJnZXIgdGhhbiB6ZXJvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGluIGNhc2Ugb2YgYW4gdW5rbm93biBkYXRhIHR5cGUuXG4gICAqL1xuICB2YXIgaXNQb3NpdGl2ZSA9IHR5cGVkKCdpc1Bvc2l0aXZlJywge1xuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHggPiAwO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAheC5pc05lZygpICYmICF4LmlzWmVybygpICYmICF4LmlzTmFOKCk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zID4gMCAmJiB4Lm4gPiAwO1xuICAgIH0sXG5cbiAgICAnVW5pdCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gaXNQb3NpdGl2ZSh4LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5IHwgTWF0cml4JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGlzUG9zaXRpdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlzUG9zaXRpdmU7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdpc1Bvc2l0aXZlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlLlxuICAgKlxuICAgKiBGdW5jdGlvbiBgdHlwZW9mYCByZWNvZ25pemVzIHRoZSBmb2xsb3dpbmcgdHlwZXMgb2Ygb2JqZWN0czpcbiAgICpcbiAgICogT2JqZWN0ICAgICAgICAgICAgICAgICB8IFJldHVybnMgICAgICAgfCBFeGFtcGxlXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIG51bGwgICAgICAgICAgICAgICAgICAgfCBgJ251bGwnYCAgICAgIHwgYG1hdGgudHlwZW9mKG51bGwpYFxuICAgKiBudW1iZXIgICAgICAgICAgICAgICAgIHwgYCdudW1iZXInYCAgICB8IGBtYXRoLnR5cGVvZigzLjUpYFxuICAgKiBib29sZWFuICAgICAgICAgICAgICAgIHwgYCdib29sZWFuJ2AgICB8IGBtYXRoLnR5cGVvZiAodHJ1ZSlgXG4gICAqIHN0cmluZyAgICAgICAgICAgICAgICAgfCBgJ3N0cmluZydgICAgIHwgYG1hdGgudHlwZW9mICgnaGVsbG8gd29ybGQnKWBcbiAgICogQXJyYXkgICAgICAgICAgICAgICAgICB8IGAnQXJyYXknYCAgICAgfCBgbWF0aC50eXBlb2YgKFsxLCAyLCAzXSlgXG4gICAqIERhdGUgICAgICAgICAgICAgICAgICAgfCBgJ0RhdGUnYCAgICAgIHwgYG1hdGgudHlwZW9mIChuZXcgRGF0ZSgpKWBcbiAgICogRnVuY3Rpb24gICAgICAgICAgICAgICB8IGAnRnVuY3Rpb24nYCAgfCBgbWF0aC50eXBlb2YgKGZ1bmN0aW9uICgpIHt9KWBcbiAgICogT2JqZWN0ICAgICAgICAgICAgICAgICB8IGAnT2JqZWN0J2AgICAgfCBgbWF0aC50eXBlb2YgKHthOiAyLCBiOiAzfSlgXG4gICAqIFJlZ0V4cCAgICAgICAgICAgICAgICAgfCBgJ1JlZ0V4cCdgICAgIHwgYG1hdGgudHlwZW9mICgvYSByZWdleHAvKWBcbiAgICogdW5kZWZpbmVkICAgICAgICAgICAgICB8IGAndW5kZWZpbmVkJ2AgfCBgbWF0aC50eXBlb2YodW5kZWZpbmVkKWBcbiAgICogbWF0aC50eXBlLkJpZ051bWJlciAgICB8IGAnQmlnTnVtYmVyJ2AgfCBgbWF0aC50eXBlb2YgKG1hdGguYmlnbnVtYmVyKCcyLjNlNTAwJykpYFxuICAgKiBtYXRoLnR5cGUuQ2hhaW4gICAgICAgIHwgYCdDaGFpbidgICAgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5jaGFpbigyKSlgXG4gICAqIG1hdGgudHlwZS5Db21wbGV4ICAgICAgfCBgJ0NvbXBsZXgnYCAgIHwgYG1hdGgudHlwZW9mIChtYXRoLmNvbXBsZXgoMiwgMykpYFxuICAgKiBtYXRoLnR5cGUuRnJhY3Rpb24gICAgIHwgYCdGcmFjdGlvbidgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5mcmFjdGlvbigxLCAzKSlgXG4gICAqIG1hdGgudHlwZS5IZWxwICAgICAgICAgfCBgJ0hlbHAnYCAgICAgIHwgYG1hdGgudHlwZW9mIChtYXRoLmhlbHAoJ3NxcnQnKSlgXG4gICAqIG1hdGgudHlwZS5JbmRleCAgICAgICAgfCBgJ0luZGV4J2AgICAgIHwgYG1hdGgudHlwZW9mIChtYXRoLmluZGV4KDEsIDMpKWBcbiAgICogbWF0aC50eXBlLk1hdHJpeCAgICAgICB8IGAnTWF0cml4J2AgICAgfCBgbWF0aC50eXBlb2YgKG1hdGgubWF0cml4KFtbMSwyXSwgWzMsIDRdXSkpYFxuICAgKiBtYXRoLnR5cGUuUmFuZ2UgICAgICAgIHwgYCdSYW5nZSdgICAgICB8IGBtYXRoLnR5cGVvZiAobWF0aC5yYW5nZSgwLCAxMCkpYFxuICAgKiBtYXRoLnR5cGUuVW5pdCAgICAgICAgIHwgYCdVbml0J2AgICAgICB8IGBtYXRoLnR5cGVvZiAobWF0aC51bml0KCc0NSBkZWcnKSlgXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC50eXBlb2YoeClcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqICAgIG1hdGgudHlwZW9mKDMuNSk7ICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyAnbnVtYmVyJ1xuICAgKiAgICBtYXRoLnR5cGVvZihtYXRoLmNvbXBsZXgoJzItNGknKSk7ICAgIC8vIHJldHVybnMgJ0NvbXBsZXgnXG4gICAqICAgIG1hdGgudHlwZW9mKG1hdGgudW5pdCgnNDUgZGVnJykpOyAgICAgLy8gcmV0dXJucyAnVW5pdCdcbiAgICogICAgbWF0aC50eXBlb2YoJ2hlbGxvIHdvcmxkJyk7ICAgICAgICAgICAvLyByZXR1cm5zICdzdHJpbmcnXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0geCAgICAgVGhlIHZhcmlhYmxlIGZvciB3aGljaCB0byB0ZXN0IHRoZSB0eXBlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUuIFByaW1pdGl2ZSB0eXBlcyBhcmUgbG93ZXIgY2FzZSxcbiAgICogICAgICAgICAgICAgICAgICBub24tcHJpbWl0aXZlIHR5cGVzIGFyZSB1cHBlci1jYW1lbC1jYXNlLlxuICAgKiAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlICdudW1iZXInLCAnc3RyaW5nJywgJ0FycmF5JywgJ0RhdGUnLlxuICAgKi9cbiAgdmFyIF90eXBlb2YgPSB0eXBlZCgnX3R5cGVvZicsIHtcbiAgICAnYW55JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIC8vIEphdmFTY3JpcHQgdHlwZXNcbiAgICAgIHZhciB0ID0gdHlwZXMudHlwZSh4KTtcblxuICAgICAgLy8gbWF0aC5qcyB0eXBlc1xuICAgICAgaWYgKHQgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIGlmICh4LmlzQmlnTnVtYmVyID09PSB0cnVlKSByZXR1cm4gJ0JpZ051bWJlcic7XG4gICAgICAgIGlmICh4LmlzQ29tcGxleCA9PT0gdHJ1ZSkgICByZXR1cm4gJ0NvbXBsZXgnO1xuICAgICAgICBpZiAoeC5pc0ZyYWN0aW9uID09PSB0cnVlKSAgcmV0dXJuICdGcmFjdGlvbic7XG4gICAgICAgIGlmICh4LmlzTWF0cml4ID09PSB0cnVlKSAgICByZXR1cm4gJ01hdHJpeCc7XG4gICAgICAgIGlmICh4LmlzVW5pdCA9PT0gdHJ1ZSkgICAgICByZXR1cm4gJ1VuaXQnO1xuICAgICAgICBpZiAoeC5pc0luZGV4ID09PSB0cnVlKSAgICAgcmV0dXJuICdJbmRleCc7XG4gICAgICAgIGlmICh4LmlzUmFuZ2UgPT09IHRydWUpICAgICByZXR1cm4gJ1JhbmdlJztcbiAgICAgICAgaWYgKHguaXNDaGFpbiA9PT0gdHJ1ZSkgICAgIHJldHVybiAnQ2hhaW4nO1xuICAgICAgICBpZiAoeC5pc0hlbHAgPT09IHRydWUpICAgICAgcmV0dXJuICdIZWxwJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9KTtcblxuICBfdHlwZW9mLnRvVGV4ID0gdW5kZWZpbmVkOyAvLyB1c2UgZGVmYXVsdCB0ZW1wbGF0ZVxuXG4gIHJldHVybiBfdHlwZW9mO1xufVxuXG5leHBvcnRzLm5hbWUgPSAndHlwZW9mJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCJ2YXIgQ29tcGxleCA9IHJlcXVpcmUoJ2NvbXBsZXguanMnKTtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5mb3JtYXQ7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9udW1iZXInKS5pc051bWJlcjtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCwgbWF0aCkge1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgQ29tcGxleC5wcm90b3R5cGUudHlwZSA9ICdDb21wbGV4JztcbiAgQ29tcGxleC5wcm90b3R5cGUuaXNDb21wbGV4ID0gdHJ1ZTtcblxuXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wbGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgSlNPTiBvYmplY3Qgc3RydWN0dXJlZCBhczpcbiAgICogICAgICAgICAgICAgICAgICAgYHtcIm1hdGhqc1wiOiBcIkNvbXBsZXhcIiwgXCJyZVwiOiAyLCBcImltXCI6IDN9YFxuICAgKi9cbiAgQ29tcGxleC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRoanM6ICdDb21wbGV4JyxcbiAgICAgIHJlOiB0aGlzLnJlLFxuICAgICAgaW06IHRoaXMuaW1cbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGNvbXBsZXggbnVtYmVyIGluIHBvbGFyIG5vdGF0aW9uXG4gICAqIFRoZSBhbmdsZSBwaGkgd2lsbCBiZSBzZXQgaW4gdGhlIGludGVydmFsIG9mIFstcGksIHBpXS5cbiAgICogQHJldHVybiB7e3I6IG51bWJlciwgcGhpOiBudW1iZXJ9fSBSZXR1cm5zIGFuZCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHIgYW5kIHBoaS5cbiAgICovXG4gIENvbXBsZXgucHJvdG90eXBlLnRvUG9sYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHRoaXMuYWJzKCksXG4gICAgICBwaGk6IHRoaXMuYXJnKClcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBsZXggbnVtYmVyLFxuICAgKiB3aXRoIG9wdGlvbmFsIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlscy9udW1iZXI6Zm9ybWF0IGZvciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gb2YgdGhlIGF2YWlsYWJsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gICAqL1xuICBDb21wbGV4LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgaW0gPSB0aGlzLmltO1xuICAgIHZhciByZSA9IHRoaXMucmU7XG4gICAgdmFyIHN0clJlID0gZm9ybWF0KHRoaXMucmUsIG9wdGlvbnMpO1xuICAgIHZhciBzdHJJbSA9IGZvcm1hdCh0aGlzLmltLCBvcHRpb25zKTtcblxuICAgIC8vIHJvdW5kIGVpdGhlciByZSBvciBpbSB3aGVuIHNtYWxsZXIgdGhhbiB0aGUgY29uZmlndXJlZCBwcmVjaXNpb25cbiAgICB2YXIgcHJlY2lzaW9uID0gaXNOdW1iZXIob3B0aW9ucykgPyBvcHRpb25zIDogb3B0aW9ucyA/IG9wdGlvbnMucHJlY2lzaW9uIDogbnVsbDtcbiAgICBpZiAocHJlY2lzaW9uICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKTtcbiAgICAgIGlmIChNYXRoLmFicyhyZSAvIGltKSA8IGVwc2lsb24pIHtcbiAgICAgICAgcmUgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKGltIC8gcmUpIDwgZXBzaWxvbikge1xuICAgICAgICBpbSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGltID09IDApIHtcbiAgICAgIC8vIHJlYWwgdmFsdWVcbiAgICAgIHN0ciA9IHN0clJlO1xuICAgIH0gZWxzZSBpZiAocmUgPT0gMCkge1xuICAgICAgLy8gcHVyZWx5IGNvbXBsZXggdmFsdWVcbiAgICAgIGlmIChpbSA9PSAxKSB7XG4gICAgICAgIHN0ciA9ICdpJztcbiAgICAgIH0gZWxzZSBpZiAoaW0gPT0gLTEpIHtcbiAgICAgICAgc3RyID0gJy1pJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IHN0ckltICsgJ2knO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IHZhbHVlXG4gICAgICBpZiAoaW0gPiAwKSB7XG4gICAgICAgIGlmIChpbSA9PSAxKSB7XG4gICAgICAgICAgc3RyID0gc3RyUmUgKyAnICsgaSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3RyUmUgKyAnICsgJyArIHN0ckltICsgJ2knO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW0gPT0gLTEpIHtcbiAgICAgICAgICBzdHIgPSBzdHJSZSArICcgLSBpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSBzdHJSZSArICcgLSAnICsgc3RySW0uc3Vic3RyaW5nKDEpICsgJ2knO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbXBsZXggbnVtYmVyIGZyb20gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICpcbiAgICogVXNhZ2U6XG4gICAqXG4gICAqICAgICBDb21wbGV4LmZyb21Qb2xhcihyOiBudW1iZXIsIHBoaTogbnVtYmVyKSA6IENvbXBsZXhcbiAgICogICAgIENvbXBsZXguZnJvbVBvbGFyKHtyOiBudW1iZXIsIHBoaTogbnVtYmVyfSkgOiBDb21wbGV4XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYXJncy4uLlxuICAgKiBAcmV0dXJuIHtDb21wbGV4fVxuICAgKi9cbiAgQ29tcGxleC5mcm9tUG9sYXIgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gQ29tcGxleChhcmcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyB0byBiZSBhbiBvYmplY3Qgd2l0aCByIGFuZCBwaGkga2V5cy4nKTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICB2YXIgciA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIHBoaSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHIpKSB7XG4gICAgICAgICAgaWYgKHBoaSAmJiBwaGkuaXNVbml0ICYmIHBoaS5oYXNCYXNlKCdBTkdMRScpKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHVuaXQgdG8gYSBudW1iZXIgaW4gcmFkaWFuc1xuICAgICAgICAgICAgcGhpID0gcGhpLnRvTnVtYmVyKCdyYWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNOdW1iZXIocGhpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHtyOiByLCBwaGk6IHBoaX0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BoaSBpcyBub3QgYSBudW1iZXIgbm9yIGFuIGFuZ2xlIHVuaXQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmFkaXVzIHIgaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBmdW5jdGlvbiBmcm9tUG9sYXInKTtcbiAgICB9XG4gIH07XG5cblxuICBDb21wbGV4LnByb3RvdHlwZS52YWx1ZU9mID0gQ29tcGxleC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIENvbXBsZXggbnVtYmVyIGZyb20gYSBKU09OIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAgQSBKU09OIE9iamVjdCBzdHJ1Y3R1cmVkIGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB7XCJtYXRoanNcIjogXCJDb21wbGV4XCIsIFwicmVcIjogMiwgXCJpbVwiOiAzfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgQWxsIHByb3BlcnRpZXMgYXJlIG9wdGlvbmFsLCBkZWZhdWx0IHZhbHVlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgZm9yIGByZWAgYW5kIGBpbWAgYXJlIDAuXG4gICAqIEByZXR1cm4ge0NvbXBsZXh9IFJldHVybnMgYSBuZXcgQ29tcGxleCBudW1iZXJcbiAgICovXG4gIENvbXBsZXguZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHJldHVybiBuZXcgQ29tcGxleChqc29uKTtcbiAgfTtcblxuICAvLyBhcHBseSB0aGUgY3VycmVudCBlcHNpbG9uXG4gIENvbXBsZXguRVBTSUxPTiA9IGNvbmZpZy5lcHNpbG9uO1xuXG4gIC8vIGxpc3RlbiBmb3IgY2hhbmdlZCBpbiB0aGUgY29uZmlndXJhdGlvbiwgYXV0b21hdGljYWxseSBhcHBseSBjaGFuZ2VkIGVwc2lsb25cbiAgbWF0aC5vbignY29uZmlnJywgZnVuY3Rpb24gKGN1cnIsIHByZXYpIHtcbiAgICBpZiAoY3Vyci5lcHNpbG9uICE9PSBwcmV2LmVwc2lsb24pIHtcbiAgICAgIENvbXBsZXguRVBTSUxPTiA9IGN1cnIuZXBzaWxvbjtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBDb21wbGV4O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnQ29tcGxleCc7XG5leHBvcnRzLnBhdGggPSAndHlwZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuZXhwb3J0cy5tYXRoID0gdHJ1ZTsgLy8gcmVxdWVzdCBhY2Nlc3MgdG8gdGhlIG1hdGggbmFtZXNwYWNlXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWVwTWFwID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZyYWN0aW9uIGNvbnZlcnQgYSB2YWx1ZSB0byBhIGZyYWN0aW9uLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqICAgICBtYXRoLmZyYWN0aW9uKG51bWVyYXRvciwgZGVub21pbmF0b3IpXG4gICAqICAgICBtYXRoLmZyYWN0aW9uKHtuOiBudW1lcmF0b3IsIGQ6IGRlbm9taW5hdG9yfSlcbiAgICogICAgIG1hdGguZnJhY3Rpb24obWF0cml4OiBBcnJheSB8IE1hdHJpeCkgICAgICAgICBUdXJuIGFsbCBtYXRyaXggZW50cmllc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludG8gZnJhY3Rpb25zXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKlxuICAgKiAgICAgbWF0aC5mcmFjdGlvbigxLCAzKTtcbiAgICogICAgIG1hdGguZnJhY3Rpb24oJzIvMycpO1xuICAgKiAgICAgbWF0aC5mcmFjdGlvbih7bjogMiwgZDogM30pO1xuICAgKiAgICAgbWF0aC5mcmFjdGlvbihbMC4yLCAwLjI1LCAxLjI1XSk7XG4gICAqXG4gICAqIFNlZSBhbHNvOlxuICAgKlxuICAgKiAgICBiaWdudW1iZXIsIG51bWJlciwgc3RyaW5nLCB1bml0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gW2FyZ3NdXG4gICAqICAgICAgICAgICAgQXJndW1lbnRzIHNwZWNpZnlpbmcgdGhlIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3Igb2ZcbiAgICogICAgICAgICAgICB0aGUgZnJhY3Rpb25cbiAgICogQHJldHVybiB7RnJhY3Rpb24gfCBBcnJheSB8IE1hdHJpeH0gUmV0dXJucyBhIGZyYWN0aW9uXG4gICAqL1xuICB2YXIgZnJhY3Rpb24gPSB0eXBlZCgnZnJhY3Rpb24nLCB7XG4gICAgJ251bWJlcic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAoIWlzRmluaXRlKHgpIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih4ICsgJyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBmcmFjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IHR5cGUuRnJhY3Rpb24oeCk7XG4gICAgfSxcblxuICAgICdzdHJpbmcnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKHgpO1xuICAgIH0sXG5cbiAgICAnbnVtYmVyLCBudW1iZXInOiBmdW5jdGlvbiAobnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5GcmFjdGlvbih4LnRvU3RyaW5nKCkpO1xuICAgIH0sXG5cbiAgICAnRnJhY3Rpb24nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7IC8vIGZyYWN0aW9ucyBhcmUgaW1tdXRhYmxlXG4gICAgfSxcblxuICAgICdPYmplY3QnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkZyYWN0aW9uKHgpO1xuICAgIH0sXG5cbiAgICAnQXJyYXkgfCBNYXRyaXgnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGRlZXBNYXAoeCwgZnJhY3Rpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZyYWN0aW9uO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnZnJhY3Rpb24nO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL251bWJlcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5nZS4gQSByYW5nZSBoYXMgYSBzdGFydCwgc3RlcCwgYW5kIGVuZCwgYW5kIGNvbnRhaW5zIGZ1bmN0aW9uc1xuICAgKiB0byBpdGVyYXRlIG92ZXIgdGhlIHJhbmdlLlxuICAgKlxuICAgKiBBIHJhbmdlIGNhbiBiZSBjb25zdHJ1Y3RlZCBhczpcbiAgICogICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTtcbiAgICogICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICpcbiAgICogVG8gZ2V0IHRoZSByZXN1bHQgb2YgdGhlIHJhbmdlOlxuICAgKiAgICAgcmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHgpO1xuICAgKiAgICAgfSk7XG4gICAqICAgICByYW5nZS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICogICAgICAgICByZXR1cm4gbWF0aC5zaW4oeCk7XG4gICAqICAgICB9KTtcbiAgICogICAgIHJhbmdlLnRvQXJyYXkoKTtcbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICogICAgIHZhciBjID0gbmV3IFJhbmdlKDIsIDYpOyAgICAgICAgIC8vIDI6MTo1XG4gICAqICAgICBjLnRvQXJyYXkoKTsgICAgICAgICAgICAgICAgICAgICAvLyBbMiwgMywgNCwgNV1cbiAgICogICAgIHZhciBkID0gbmV3IFJhbmdlKDIsIC0zLCAtMSk7ICAgIC8vIDI6LTE6LTJcbiAgICogICAgIGQudG9BcnJheSgpOyAgICAgICAgICAgICAgICAgICAgIC8vIFsyLCAxLCAwLCAtMSwgLTJdXG4gICAqXG4gICAqIEBjbGFzcyBSYW5nZVxuICAgKiBAY29uc3RydWN0b3IgUmFuZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0ICBpbmNsdWRlZCBsb3dlciBib3VuZFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kICAgIGV4Y2x1ZGVkIHVwcGVyIGJvdW5kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcF0gc3RlcCBzaXplLCBkZWZhdWx0IHZhbHVlIGlzIDFcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICBpZiAoc3RhcnQuaXNCaWdOdW1iZXIgPT09IHRydWUpXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQudG9OdW1iZXIoKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlciBzdGFydCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbnVsbCkge1xuICAgICAgaWYgKGVuZC5pc0JpZ051bWJlciA9PT0gdHJ1ZSlcbiAgICAgICAgZW5kID0gZW5kLnRvTnVtYmVyKCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGVuZCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChzdGVwICE9IG51bGwpIHtcbiAgICAgIGlmIChzdGVwLmlzQmlnTnVtYmVyID09PSB0cnVlKVxuICAgICAgICBzdGVwID0gc3RlcC50b051bWJlcigpO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHN0ZXAgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXJhbWV0ZXIgc3RlcCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IChzdGFydCAhPSBudWxsKSA/IHBhcnNlRmxvYXQoc3RhcnQpIDogMDtcbiAgICB0aGlzLmVuZCAgID0gKGVuZCAhPSBudWxsKSAgID8gcGFyc2VGbG9hdChlbmQpICAgOiAwO1xuICAgIHRoaXMuc3RlcCAgPSAoc3RlcCAhPSBudWxsKSAgPyBwYXJzZUZsb2F0KHN0ZXApICA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS50eXBlID0gJ1JhbmdlJztcbiAgUmFuZ2UucHJvdG90eXBlLmlzUmFuZ2UgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgcmFuZ2UsXG4gICAqIFRoZSBzdHJpbmcgY29udGFpbnMgdGhlIHN0YXJ0LCBvcHRpb25hbCBzdGVwLCBhbmQgZW5kLCBzZXBhcmF0ZWQgYnkgYSBjb2xvbi5cbiAgICogSWYgdGhlIHN0cmluZyBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcmFuZ2UsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqIEZvciBleGFtcGxlIHN0cj0nMDoyOjExJy5cbiAgICogQG1lbWJlcm9mIFJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7UmFuZ2UgfCBudWxsfSByYW5nZVxuICAgKi9cbiAgUmFuZ2UucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IHN0ci5zcGxpdCgnOicpO1xuICAgIHZhciBudW1zID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYXJnKTtcbiAgICB9KTtcblxuICAgIHZhciBpbnZhbGlkID0gbnVtcy5zb21lKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIHJldHVybiBpc05hTihudW0pO1xuICAgIH0pO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG51bXMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UobnVtc1swXSwgbnVtc1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UobnVtc1swXSwgbnVtc1syXSwgbnVtc1sxXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNsb25lIG9mIHRoZSByYW5nZVxuICAgKiBAcmV0dXJuIHtSYW5nZX0gY2xvbmVcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLnN0ZXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgcmFuZ2UuXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBvbmUgbnVtYmVyLCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSByYW5nZS5cbiAgICogQG1lbWJlcm9mIFJhbmdlXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gc2l6ZVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IDAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydCxcbiAgICAgICAgc3RlcCA9IHRoaXMuc3RlcCxcbiAgICAgICAgZW5kID0gdGhpcy5lbmQsXG4gICAgICAgIGRpZmYgPSBlbmQgLSBzdGFydDtcblxuICAgIGlmIChudW1iZXIuc2lnbihzdGVwKSA9PSBudW1iZXIuc2lnbihkaWZmKSkge1xuICAgICAgbGVuID0gTWF0aC5jZWlsKChkaWZmKSAvIHN0ZXApO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaWZmID09IDApIHtcbiAgICAgIGxlbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKGxlbikpIHtcbiAgICAgIGxlbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBbbGVuXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHZhbHVlIGluIHRoZSByYW5nZVxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHJldHVybiB7bnVtYmVyIHwgdW5kZWZpbmVkfSBtaW5cbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKVswXTtcblxuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgICAgLy8gcG9zaXRpdmUgc3RlcFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZWdhdGl2ZSBzdGVwXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgKHNpemUgLSAxKSAqIHRoaXMuc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZVxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHJldHVybiB7bnVtYmVyIHwgdW5kZWZpbmVkfSBtYXhcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKVswXTtcblxuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgICAgLy8gcG9zaXRpdmUgc3RlcFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArIChzaXplIC0gMSkgKiB0aGlzLnN0ZXA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmVnYXRpdmUgc3RlcFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUgaW4gdGhlIHJhbmdlLlxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgbWV0aG9kIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCwgdGhlIGluZGV4XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGVsZW1lbnQsIGFuZCB0aGUgUmFuZ2UgYmVpbmcgdHJhdmVyc2VkLlxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgeCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHggPCBlbmQpIHtcbiAgICAgICAgY2FsbGJhY2soeCwgW2ldLCB0aGlzKTtcbiAgICAgICAgeCArPSBzdGVwO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB3aGlsZSAoeCA+IGVuZCkge1xuICAgICAgICBjYWxsYmFjayh4LCBbaV0sIHRoaXMpO1xuICAgICAgICB4ICs9IHN0ZXA7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgUmFuZ2UsIGFuZCByZXR1cm4gdGhlXG4gICAqIHJlc3VsdHMgYXMgYW4gYXJyYXlcbiAgICogQG1lbWJlcm9mIFJhbmdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQsIHRoZSBpbmRleFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBlbGVtZW50LCBhbmQgdGhlIE1hdHJpeCBiZWluZyB0cmF2ZXJzZWQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXlcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgb2JqKSB7XG4gICAgICBhcnJheVtpbmRleFswXV0gPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQXJyYXkgd2l0aCBhIGNvcHkgb2YgdGhlIFJhbmdlcyBkYXRhXG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgYXJyYXlbaW5kZXhbMF1dID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGUgUmFuZ2UsIGEgb25lIGRpbWVuc2lvbmFsIGFycmF5XG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5XG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBjYWNoaW5nIG1lY2hhbmlzbSBmb3IgcmFuZ2UudmFsdWVPZigpXG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJhbmdlLCB3aXRoIG9wdGlvbmFsIGZvcm1hdHRpbmcgb3B0aW9ucy5cbiAgICogT3V0cHV0IGlzIGZvcm1hdHRlZCBhcyAnc3RhcnQ6c3RlcDplbmQnLCBmb3IgZXhhbXBsZSAnMjo2JyBvciAnMDowLjI6MTEnXG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IGZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3V0aWxzL251bWJlcjpmb3JtYXQgZm9yIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gICAqL1xuICBSYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gbnVtYmVyLmZvcm1hdCh0aGlzLnN0YXJ0LCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgICAgc3RyICs9ICc6JyArIG51bWJlci5mb3JtYXQodGhpcy5zdGVwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RyICs9ICc6JyArIG51bWJlci5mb3JtYXQodGhpcy5lbmQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmFuZ2UuXG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZVxuICAgKiBAbWVtYmVyb2YgUmFuZ2VcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJSYW5nZVwiLCBcInN0YXJ0XCI6IDIsIFwiZW5kXCI6IDQsIFwic3RlcFwiOiAxfWBcbiAgICovXG4gIFJhbmdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGhqczogJ1JhbmdlJyxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgZW5kOiB0aGlzLmVuZCxcbiAgICAgIHN0ZXA6IHRoaXMuc3RlcFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGEgUmFuZ2UgZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBSYW5nZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBBIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJSYW5nZVwiLCBcInN0YXJ0XCI6IDIsIFwiZW5kXCI6IDQsIFwic3RlcFwiOiAxfWBcbiAgICogQHJldHVybiB7UmFuZ2V9XG4gICAqL1xuICBSYW5nZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShqc29uLnN0YXJ0LCBqc29uLmVuZCwganNvbi5zdGVwKTtcbiAgfTtcblxuICByZXR1cm4gUmFuZ2U7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdSYW5nZSc7XG5leHBvcnRzLnBhdGggPSAndHlwZSc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBNYXRyaXguIFRoZSBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IGBtYXRoLnR5cGUuTWF0cml4YCBvYmplY3QgZnJvbVxuICAgKiBhbiBgQXJyYXlgLiBBIE1hdHJpeCBoYXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBpbiB0aGVcbiAgICogbWF0cml4LCBsaWtlIGdldHRpbmcgdGhlIHNpemUgYW5kIGdldHRpbmcgb3Igc2V0dGluZyB2YWx1ZXMgaW4gdGhlIG1hdHJpeC5cbiAgICogU3VwcG9ydGVkIHN0b3JhZ2UgZm9ybWF0cyBhcmUgJ2RlbnNlJyBhbmQgJ3NwYXJzZScuXG4gICAqXG4gICAqIFN5bnRheDpcbiAgICpcbiAgICogICAgbWF0aC5tYXRyaXgoKSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGFuIGVtcHR5IG1hdHJpeCB1c2luZyBkZWZhdWx0IHN0b3JhZ2UgZm9ybWF0IChkZW5zZSkuXG4gICAqICAgIG1hdGgubWF0cml4KGRhdGEpICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG1hdHJpeCB3aXRoIGluaXRpYWwgZGF0YSB1c2luZyBkZWZhdWx0IHN0b3JhZ2UgZm9ybWF0IChkZW5zZSkuXG4gICAqICAgIG1hdGgubWF0cml4KCdkZW5zZScpICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBhbiBlbXB0eSBtYXRyaXggdXNpbmcgdGhlIGdpdmVuIHN0b3JhZ2UgZm9ybWF0LlxuICAgKiAgICBtYXRoLm1hdHJpeChkYXRhLCAnZGVuc2UnKSAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBtYXRyaXggd2l0aCBpbml0aWFsIGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN0b3JhZ2UgZm9ybWF0LlxuICAgKiAgICBtYXRoLm1hdHJpeChkYXRhLCAnc3BhcnNlJykgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBzcGFyc2UgbWF0cml4IHdpdGggaW5pdGlhbCBkYXRhLlxuICAgKiAgICBtYXRoLm1hdHJpeChkYXRhLCAnc3BhcnNlJywgJ251bWJlcicpIC8vIGNyZWF0ZXMgYSBzcGFyc2UgbWF0cml4IHdpdGggaW5pdGlhbCBkYXRhLCBudW1iZXIgZGF0YSB0eXBlLlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgdmFyIG0gPSBtYXRoLm1hdHJpeChbWzEsIDJdLCBbMywgNF1dKTtcbiAgICogICAgbS5zaXplKCk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgWzIsIDJdXG4gICAqICAgIG0ucmVzaXplKFszLCAyXSwgNSk7XG4gICAqICAgIG0udmFsdWVPZigpOyAgICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IFtbMSwgMl0sIFszLCA0XSwgWzUsIDVdXVxuICAgKiAgICBtLmdldChbMSwgMF0pICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgM1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbnVtYmVyLCBzdHJpbmcsIHVuaXQsIHNwYXJzZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBbZGF0YV0gICAgQSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gICAgICAgICAgVGhlIE1hdHJpeCBzdG9yYWdlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9IFRoZSBjcmVhdGVkIG1hdHJpeFxuICAgKi9cbiAgdmFyIG1hdHJpeCA9IHR5cGVkKCdtYXRyaXgnLCB7XG4gICAgJyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlKFtdKTtcbiAgICB9LFxuXG4gICAgJ3N0cmluZyc6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlKFtdLCBmb3JtYXQpO1xuICAgIH0sXG4gICAgXG4gICAgJ3N0cmluZywgc3RyaW5nJzogZnVuY3Rpb24gKGZvcm1hdCwgZGF0YXR5cGUpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlKFtdLCBmb3JtYXQsIGRhdGF0eXBlKTtcbiAgICB9LFxuXG4gICAgJ0FycmF5JzogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlKGRhdGEpO1xuICAgIH0sXG4gICAgICBcbiAgICAnTWF0cml4JzogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlKGRhdGEsIGRhdGEuc3RvcmFnZSgpKTtcbiAgICB9LFxuICAgIFxuICAgICdBcnJheSB8IE1hdHJpeCwgc3RyaW5nJzogX2NyZWF0ZSxcbiAgICBcbiAgICAnQXJyYXkgfCBNYXRyaXgsIHN0cmluZywgc3RyaW5nJzogX2NyZWF0ZVxuICB9KTtcblxuICBtYXRyaXgudG9UZXggPSB7XG4gICAgMDogJ1xcXFxiZWdpbntibWF0cml4fVxcXFxlbmR7Ym1hdHJpeH0nLFxuICAgIDE6ICdcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KScsXG4gICAgMjogJ1xcXFxsZWZ0KCR7YXJnc1swXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiBtYXRyaXg7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBNYXRyaXggd2l0aCBnaXZlbiBzdG9yYWdlIGZvcm1hdFxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGF0eXBlXVxuICAgKiBAcmV0dXJucyB7TWF0cml4fSBSZXR1cm5zIGEgbmV3IE1hdHJpeFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2NyZWF0ZShkYXRhLCBmb3JtYXQsIGRhdGF0eXBlKSB7XG4gICAgLy8gZ2V0IHN0b3JhZ2UgZm9ybWF0IGNvbnN0cnVjdG9yXG4gICAgdmFyIE0gPSB0eXBlLk1hdHJpeC5zdG9yYWdlKGZvcm1hdCB8fCAnZGVmYXVsdCcpO1xuXG4gICAgLy8gY3JlYXRlIGluc3RhbmNlXG4gICAgcmV0dXJuIG5ldyBNKGRhdGEsIGRhdGF0eXBlKTtcbiAgfVxufVxuXG5leHBvcnRzLm5hbWUgPSAnbWF0cml4JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIFNwYXJzZU1hdHJpeCBub256ZXJvIGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKERpaiwgU2lqKS4gXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgTk5aIHRpbWVzIChudW1iZXIgb2Ygbm9uemVybyBpdGVtcyBpbiBTcGFyc2VNYXRyaXgpLlxuICAgKlxuICAgKlxuICAgKiAgICAgICAgICDilIwgIGYoRGlqLCBTaWopICA7IFMoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKRcbiAgICogICAgICAgICAg4pSUICBEaWogICAgICAgICAgOyBvdGhlcndpc2VcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgZGVuc2VNYXRyaXggICAgICAgVGhlIERlbnNlTWF0cml4IGluc3RhbmNlIChEKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBzcGFyc2VNYXRyaXggICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChTKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihEaWosU2lqKSBvcGVyYXRpb24gdG8gaW52b2tlLCB3aGVyZSBEaWogPSBEZW5zZU1hdHJpeChpLGopIGFuZCBTaWogPSBTcGFyc2VNYXRyaXgoaSxqKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBpbnZlcnNlICAgICAgICAgICBBIHRydWUgdmFsdWUgaW5kaWNhdGVzIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkIGYoU2lqLERpailcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgRGVuc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc0Nzc1NzFcbiAgICovXG4gIHZhciBhbGdvcml0aG0wMSA9IGZ1bmN0aW9uIChkZW5zZU1hdHJpeCwgc3BhcnNlTWF0cml4LCBjYWxsYmFjaywgaW52ZXJzZSkge1xuICAgIC8vIGRlbnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYWRhdGEgPSBkZW5zZU1hdHJpeC5fZGF0YTtcbiAgICB2YXIgYXNpemUgPSBkZW5zZU1hdHJpeC5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gZGVuc2VNYXRyaXguX2RhdGF0eXBlO1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBzcGFyc2VNYXRyaXguX3ZhbHVlcztcbiAgICB2YXIgYmluZGV4ID0gc3BhcnNlTWF0cml4Ll9pbmRleDtcbiAgICB2YXIgYnB0ciA9IHNwYXJzZU1hdHJpeC5fcHRyO1xuICAgIHZhciBic2l6ZSA9IHNwYXJzZU1hdHJpeC5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gc3BhcnNlTWF0cml4Ll9kYXRhdHlwZTtcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoYXNpemUubGVuZ3RoICE9PSBic2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoYXNpemUubGVuZ3RoLCBic2l6ZS5sZW5ndGgpO1xuXG4gICAgLy8gY2hlY2sgcm93cyAmIGNvbHVtbnNcbiAgICBpZiAoYXNpemVbMF0gIT09IGJzaXplWzBdIHx8IGFzaXplWzFdICE9PSBic2l6ZVsxXSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2guIE1hdHJpeCBBICgnICsgYXNpemUgKyAnKSBtdXN0IG1hdGNoIE1hdHJpeCBCICgnICsgYnNpemUgKyAnKScpO1xuXG4gICAgLy8gc3BhcnNlIG1hdHJpeCBjYW5ub3QgYmUgYSBQYXR0ZXJuIG1hdHJpeFxuICAgIGlmICghYnZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIG9uIERlbnNlIE1hdHJpeCBhbmQgUGF0dGVybiBTcGFyc2UgTWF0cml4Jyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIHZhciBkdCA9IHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnICYmIGFkdCA9PT0gYmR0ID8gYWR0IDogdW5kZWZpbmVkO1xuICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgdmFyIGNmID0gZHQgPyB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSkgOiBjYWxsYmFjaztcblxuICAgIC8vIHZhcnNcbiAgICB2YXIgaSwgajtcbiAgICBcbiAgICAvLyByZXN1bHQgKERlbnNlTWF0cml4KVxuICAgIHZhciBjZGF0YSA9IFtdO1xuICAgIC8vIGluaXRpYWxpemUgY1xuICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspXG4gICAgICBjZGF0YVtpXSA9IFtdOyAgICAgIFxuICAgIFxuICAgIC8vIHdvcmtzcGFjZVxuICAgIHZhciB4ID0gW107XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuXG4gICAgLy8gbG9vcCBjb2x1bW5zIGluIGJcbiAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyBjb2x1bW4gbWFya1xuICAgICAgdmFyIG1hcmsgPSBqICsgMTtcbiAgICAgIC8vIHZhbHVlcyBpbiBjb2x1bW4galxuICAgICAgZm9yICh2YXIgazAgPSBicHRyW2pdLCBrMSA9IGJwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICBpID0gYmluZGV4W2tdO1xuICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgIHhbaV0gPSBpbnZlcnNlID8gY2YoYnZhbHVlc1trXSwgYWRhdGFbaV1bal0pIDogY2YoYWRhdGFbaV1bal0sIGJ2YWx1ZXNba10pO1xuICAgICAgICAvLyBtYXJrIGkgYXMgdXBkYXRlZFxuICAgICAgICB3W2ldID0gbWFyaztcbiAgICAgIH1cbiAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAvLyBjaGVjayByb3cgaXMgaW4gd29ya3NwYWNlXG4gICAgICAgIGlmICh3W2ldID09PSBtYXJrKSB7XG4gICAgICAgICAgLy8gY1tpXVtqXSB3YXMgYWxyZWFkeSBjYWxjdWxhdGVkXG4gICAgICAgICAgY2RhdGFbaV1bal0gPSB4W2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZW0gZG9lcyBub3QgZXhpc3QgaW4gU1xuICAgICAgICAgIGNkYXRhW2ldW2pdID0gYWRhdGFbaV1bal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gZGVuc2UgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjZGF0YSxcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuICB9O1xuICBcbiAgcmV0dXJuIGFsZ29yaXRobTAxO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDEnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IG5vbnplcm8gaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoRGlqLCBTaWopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBOTlogdGltZXMgKG51bWJlciBvZiBub256ZXJvIGl0ZW1zIGluIFNwYXJzZU1hdHJpeCkuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihEaWosIFNpaikgIDsgUyhpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpFxuICAgKiAgICAgICAgICDilJQgIDAgICAgICAgICAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBkZW5zZU1hdHJpeCAgICAgICBUaGUgRGVuc2VNYXRyaXggaW5zdGFuY2UgKEQpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIHNwYXJzZU1hdHJpeCAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKFMpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKERpaixTaWopIG9wZXJhdGlvbiB0byBpbnZva2UsIHdoZXJlIERpaiA9IERlbnNlTWF0cml4KGksaikgYW5kIFNpaiA9IFNwYXJzZU1hdHJpeChpLGopXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGludmVyc2UgICAgICAgICAgIEEgdHJ1ZSB2YWx1ZSBpbmRpY2F0ZXMgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZihTaWosRGlqKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBTcGFyc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc0Nzc1NzFcbiAgICovXG4gIHZhciBhbGdvcml0aG0wMiA9IGZ1bmN0aW9uIChkZW5zZU1hdHJpeCwgc3BhcnNlTWF0cml4LCBjYWxsYmFjaywgaW52ZXJzZSkge1xuICAgIC8vIGRlbnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYWRhdGEgPSBkZW5zZU1hdHJpeC5fZGF0YTtcbiAgICB2YXIgYXNpemUgPSBkZW5zZU1hdHJpeC5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gZGVuc2VNYXRyaXguX2RhdGF0eXBlO1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBzcGFyc2VNYXRyaXguX3ZhbHVlcztcbiAgICB2YXIgYmluZGV4ID0gc3BhcnNlTWF0cml4Ll9pbmRleDtcbiAgICB2YXIgYnB0ciA9IHNwYXJzZU1hdHJpeC5fcHRyO1xuICAgIHZhciBic2l6ZSA9IHNwYXJzZU1hdHJpeC5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gc3BhcnNlTWF0cml4Ll9kYXRhdHlwZTtcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoYXNpemUubGVuZ3RoICE9PSBic2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoYXNpemUubGVuZ3RoLCBic2l6ZS5sZW5ndGgpO1xuXG4gICAgLy8gY2hlY2sgcm93cyAmIGNvbHVtbnNcbiAgICBpZiAoYXNpemVbMF0gIT09IGJzaXplWzBdIHx8IGFzaXplWzFdICE9PSBic2l6ZVsxXSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2guIE1hdHJpeCBBICgnICsgYXNpemUgKyAnKSBtdXN0IG1hdGNoIE1hdHJpeCBCICgnICsgYnNpemUgKyAnKScpO1xuXG4gICAgLy8gc3BhcnNlIG1hdHJpeCBjYW5ub3QgYmUgYSBQYXR0ZXJuIG1hdHJpeFxuICAgIGlmICghYnZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIG9uIERlbnNlIE1hdHJpeCBhbmQgUGF0dGVybiBTcGFyc2UgTWF0cml4Jyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcbiAgICBcbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBlcXVhbCBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcbiAgICAvLyBjYWxsYmFjayBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGNmID0gY2FsbGJhY2s7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAodHlwZW9mIGFkdCA9PT0gJ3N0cmluZycgJiYgYWR0ID09PSBiZHQpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHQgKFNwYXJzZU1hdHJpeClcbiAgICB2YXIgY3ZhbHVlcyA9IFtdO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuXG4gICAgLy8gbG9vcCBjb2x1bW5zIGluIGJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gdXBkYXRlIGNwdHJcbiAgICAgIGNwdHJbal0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gdmFsdWVzIGluIGNvbHVtbiBqXG4gICAgICBmb3IgKHZhciBrMCA9IGJwdHJbal0sIGsxID0gYnB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIHZhciBpID0gYmluZGV4W2tdO1xuICAgICAgICAvLyB1cGRhdGUgQyhpLGopXG4gICAgICAgIHZhciBjaWogPSBpbnZlcnNlID8gY2YoYnZhbHVlc1trXSwgYWRhdGFbaV1bal0pIDogY2YoYWRhdGFbaV1bal0sIGJ2YWx1ZXNba10pO1xuICAgICAgICAvLyBjaGVjayBmb3Igbm9uemVyb1xuICAgICAgICBpZiAoIWVxKGNpaiwgemVybykpIHtcbiAgICAgICAgICAvLyBwdXNoIGkgJiB2XG4gICAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgICAgY3ZhbHVlcy5wdXNoKGNpaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIGNwdHJcbiAgICBjcHRyW2NvbHVtbnNdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuICB9O1xuICBcbiAgcmV0dXJuIGFsZ29yaXRobTAyO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKERpaiwgU2lqKS5cbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBNKk4gdGltZXMuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihEaWosIFNpaikgIDsgUyhpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpFxuICAgKiAgICAgICAgICDilJQgIGYoRGlqLCAwKSAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBkZW5zZU1hdHJpeCAgICAgICBUaGUgRGVuc2VNYXRyaXggaW5zdGFuY2UgKEQpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIHNwYXJzZU1hdHJpeCAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEMpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKERpaixTaWopIG9wZXJhdGlvbiB0byBpbnZva2UsIHdoZXJlIERpaiA9IERlbnNlTWF0cml4KGksaikgYW5kIFNpaiA9IFNwYXJzZU1hdHJpeChpLGopXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGludmVyc2UgICAgICAgICAgIEEgdHJ1ZSB2YWx1ZSBpbmRpY2F0ZXMgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZihTaWosRGlqKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBEZW5zZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzQ3NzU3MVxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTAzID0gZnVuY3Rpb24gKGRlbnNlTWF0cml4LCBzcGFyc2VNYXRyaXgsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gZGVuc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhZGF0YSA9IGRlbnNlTWF0cml4Ll9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGRlbnNlTWF0cml4Ll9zaXplO1xuICAgIHZhciBhZHQgPSBkZW5zZU1hdHJpeC5fZGF0YXR5cGU7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYnZhbHVlcyA9IHNwYXJzZU1hdHJpeC5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBzcGFyc2VNYXRyaXguX2luZGV4O1xuICAgIHZhciBicHRyID0gc3BhcnNlTWF0cml4Ll9wdHI7XG4gICAgdmFyIGJzaXplID0gc3BhcnNlTWF0cml4Ll9zaXplO1xuICAgIHZhciBiZHQgPSBzcGFyc2VNYXRyaXguX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyBzcGFyc2UgbWF0cml4IGNhbm5vdCBiZSBhIFBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCFidmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gRGVuc2UgTWF0cml4IGFuZCBQYXR0ZXJuIFNwYXJzZSBNYXRyaXgnKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcbiAgICAvLyBjYWxsYmFjayBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGNmID0gY2FsbGJhY2s7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAodHlwZW9mIGFkdCA9PT0gJ3N0cmluZycgJiYgYWR0ID09PSBiZHQpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCAoRGVuc2VNYXRyaXgpXG4gICAgdmFyIGNkYXRhID0gW107XG5cbiAgICAvLyBpbml0aWFsaXplIGRlbnNlIG1hdHJpeFxuICAgIGZvciAodmFyIHogPSAwOyB6IDwgcm93czsgeisrKSB7XG4gICAgICAvLyBpbml0aWFsaXplIHJvd1xuICAgICAgY2RhdGFbel0gPSBbXTtcbiAgICB9XG5cbiAgICAvLyB3b3Jrc3BhY2VcbiAgICB2YXIgeCA9IFtdO1xuICAgIC8vIG1hcmtzIGluZGljYXRpbmcgd2UgaGF2ZSBhIHZhbHVlIGluIHggZm9yIGEgZ2l2ZW4gY29sdW1uXG4gICAgdmFyIHcgPSBbXTtcblxuICAgIC8vIGxvb3AgY29sdW1ucyBpbiBiXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGNvbHVtbiBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gdmFsdWVzIGluIGNvbHVtbiBqXG4gICAgICBmb3IgKHZhciBrMCA9IGJwdHJbal0sIGsxID0gYnB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIHZhciBpID0gYmluZGV4W2tdO1xuICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgIHhbaV0gPSBpbnZlcnNlID8gY2YoYnZhbHVlc1trXSwgYWRhdGFbaV1bal0pIDogY2YoYWRhdGFbaV1bal0sIGJ2YWx1ZXNba10pO1xuICAgICAgICB3W2ldID0gbWFyaztcbiAgICAgIH1cbiAgICAgIC8vIHByb2Nlc3Mgd29ya3NwYWNlXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHJvd3M7IHkrKykge1xuICAgICAgICAvLyBjaGVjayB3ZSBoYXZlIGEgY2FsY3VsYXRlZCB2YWx1ZSBmb3IgY3VycmVudCByb3dcbiAgICAgICAgaWYgKHdbeV0gPT09IG1hcmspIHtcbiAgICAgICAgICAvLyB1c2UgY2FsY3VsYXRlZCB2YWx1ZVxuICAgICAgICAgIGNkYXRhW3ldW2pdID0geFt5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdmFsdWVcbiAgICAgICAgICBjZGF0YVt5XVtqXSA9IGludmVyc2UgPyBjZih6ZXJvLCBhZGF0YVt5XVtqXSkgOiBjZihhZGF0YVt5XVtqXSwgemVybyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gZGVuc2UgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjZGF0YSxcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuICB9O1xuICBcbiAgcmV0dXJuIGFsZ29yaXRobTAzO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDMnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IEEgYW5kIFNwYXJzZU1hdHJpeCBCIG5vbnplcm8gaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoQWlqLCBCaWopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBNQVgoTk5aQSwgTk5aQikgdGltZXNcbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKEFpaiwgQmlqKSAgOyBBKGksaikgIT09IDAgJiYgQihpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpCAgQShpLGopICAgICAgIDsgQShpLGopICE9PSAwXG4gICAqICAgICAgICAgIOKUlCAgQihpLGopICAgICAgIDsgQihpLGopICE9PSAwXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGEgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEEpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGIgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEIpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpaixCaWopIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgU3BhcnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanMvcHVsbC8zNDYjaXNzdWVjb21tZW50LTk3NjIwMjk0XG4gICAqL1xuICB2YXIgYWxnb3JpdGhtMDQgPSBmdW5jdGlvbiAoYSwgYiwgY2FsbGJhY2spIHtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhdmFsdWVzID0gYS5fdmFsdWVzO1xuICAgIHZhciBhaW5kZXggPSBhLl9pbmRleDtcbiAgICB2YXIgYXB0ciA9IGEuX3B0cjtcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBidmFsdWVzID0gYi5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBiLl9pbmRleDtcbiAgICB2YXIgYnB0ciA9IGIuX3B0cjtcbiAgICB2YXIgYnNpemUgPSBiLl9zaXplO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoYXNpemUubGVuZ3RoICE9PSBic2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoYXNpemUubGVuZ3RoLCBic2l6ZS5sZW5ndGgpO1xuXG4gICAgLy8gY2hlY2sgcm93cyAmIGNvbHVtbnNcbiAgICBpZiAoYXNpemVbMF0gIT09IGJzaXplWzBdIHx8IGFzaXplWzFdICE9PSBic2l6ZVsxXSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2guIE1hdHJpeCBBICgnICsgYXNpemUgKyAnKSBtdXN0IG1hdGNoIE1hdHJpeCBCICgnICsgYnNpemUgKyAnKScpO1xuXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gYXNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBlcXVhbCBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcbiAgICAvLyBjYWxsYmFjayBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGNmID0gY2FsbGJhY2s7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAodHlwZW9mIGFkdCA9PT0gJ3N0cmluZycgJiYgYWR0ID09PSBiZHQpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHQgYXJyYXlzXG4gICAgdmFyIGN2YWx1ZXMgPSBhdmFsdWVzICYmIGJ2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gd29ya3NwYWNlXG4gICAgdmFyIHhhID0gYXZhbHVlcyAmJiBidmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHhiID0gYXZhbHVlcyAmJiBidmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgd2EgPSBbXTtcbiAgICB2YXIgd2IgPSBbXTtcblxuICAgIC8vIHZhcnMgXG4gICAgdmFyIGksIGosIGssIGswLCBrMTtcbiAgICBcbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAvLyB1cGRhdGUgY3B0clxuICAgICAgY3B0cltqXSA9IGNpbmRleC5sZW5ndGg7XG4gICAgICAvLyBjb2x1bW5zIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyBsb29wIEEoOixqKVxuICAgICAgZm9yIChrMCA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBhaW5kZXhba107XG4gICAgICAgIC8vIHVwZGF0ZSBjXG4gICAgICAgIGNpbmRleC5wdXNoKGkpO1xuICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgIHdhW2ldID0gbWFyaztcbiAgICAgICAgLy8gY2hlY2sgd2UgbmVlZCB0byBwcm9jZXNzIHZhbHVlc1xuICAgICAgICBpZiAoeGEpXG4gICAgICAgICAgeGFbaV0gPSBhdmFsdWVzW2tdO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCBCKDosailcbiAgICAgIGZvciAoazAgPSBicHRyW2pdLCBrMSA9IGJwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAgIC8vIHJvd1xuICAgICAgICBpID0gYmluZGV4W2tdO1xuICAgICAgICAvLyBjaGVjayByb3cgZXhpc3RzIGluIEFcbiAgICAgICAgaWYgKHdhW2ldID09PSBtYXJrKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHJlY29yZCBpbiB4YSBAIGlcbiAgICAgICAgICBpZiAoeGEpIHtcbiAgICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFja1xuICAgICAgICAgICAgdmFyIHYgPSBjZih4YVtpXSwgYnZhbHVlc1trXSk7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgemVyb1xuICAgICAgICAgICAgaWYgKCFlcSh2LCB6ZXJvKSkge1xuICAgICAgICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgICAgICAgIHhhW2ldID0gdjsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBtYXJrIChpbmRleCB3aWxsIGJlIHJlbW92ZWQgbGF0ZXIpXG4gICAgICAgICAgICAgIHdhW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGNcbiAgICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgICAgd2JbaV0gPSBtYXJrO1xuICAgICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXNcbiAgICAgICAgICBpZiAoeGIpXG4gICAgICAgICAgICB4YltpXSA9IGJ2YWx1ZXNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXMgKG5vbiBwYXR0ZXJuIG1hdHJpeClcbiAgICAgIGlmICh4YSAmJiB4Yikge1xuICAgICAgICAvLyBpbml0aWFsaXplIGZpcnN0IGluZGV4IGluIGpcbiAgICAgICAgayA9IGNwdHJbal07XG4gICAgICAgIC8vIGxvb3AgaW5kZXggaW4galxuICAgICAgICB3aGlsZSAoayA8IGNpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICBpID0gY2luZGV4W2tdO1xuICAgICAgICAgIC8vIGNoZWNrIHdvcmtzcGFjZSBoYXMgdmFsdWUgQCBpXG4gICAgICAgICAgaWYgKHdhW2ldID09PSBtYXJrKSB7XG4gICAgICAgICAgICAvLyBwdXNoIHZhbHVlIChBaWogIT0gMCB8fCAoQWlqICE9IDAgJiYgQmlqICE9IDApKVxuICAgICAgICAgICAgY3ZhbHVlc1trXSA9IHhhW2ldO1xuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBvaW50ZXJcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAod2JbaV0gPT09IG1hcmspIHtcbiAgICAgICAgICAgIC8vIHB1c2ggdmFsdWUgKGJpaiAhPSAwKVxuICAgICAgICAgICAgY3ZhbHVlc1trXSA9IHhiW2ldO1xuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBvaW50ZXJcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgaW5kZXggQCBrXG4gICAgICAgICAgICBjaW5kZXguc3BsaWNlKGssIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY3B0clxuICAgIGNwdHJbY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcbiAgXG4gIHJldHVybiBhbGdvcml0aG0wNDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTA0JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG4gIFxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IEEgYW5kIFNwYXJzZU1hdHJpeCBCIG5vbnplcm8gaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoQWlqLCBCaWopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBNQVgoTk5aQSwgTk5aQikgdGltZXNcbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKEFpaiwgQmlqKSAgOyBBKGksaikgIT09IDAgfHwgQihpLGopICE9PSAwXG4gICAqIEMoaSxqKSA9IOKUpCAgXG4gICAqICAgICAgICAgIOKUlCAgMCAgICAgICAgICAgIDsgb3RoZXJ3aXNlXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGEgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEEpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGIgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEIpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpaixCaWopIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgU3BhcnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy9tYXRoanMvcHVsbC8zNDYjaXNzdWVjb21tZW50LTk3NjIwMjk0XG4gICAqL1xuICB2YXIgYWxnb3JpdGhtMDUgPSBmdW5jdGlvbiAoYSwgYiwgY2FsbGJhY2spIHtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBhdmFsdWVzID0gYS5fdmFsdWVzO1xuICAgIHZhciBhaW5kZXggPSBhLl9pbmRleDtcbiAgICB2YXIgYXB0ciA9IGEuX3B0cjtcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBidmFsdWVzID0gYi5fdmFsdWVzO1xuICAgIHZhciBiaW5kZXggPSBiLl9pbmRleDtcbiAgICB2YXIgYnB0ciA9IGIuX3B0cjtcbiAgICB2YXIgYnNpemUgPSBiLl9zaXplO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoYXNpemUubGVuZ3RoICE9PSBic2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoYXNpemUubGVuZ3RoLCBic2l6ZS5sZW5ndGgpO1xuXG4gICAgLy8gY2hlY2sgcm93cyAmIGNvbHVtbnNcbiAgICBpZiAoYXNpemVbMF0gIT09IGJzaXplWzBdIHx8IGFzaXplWzFdICE9PSBic2l6ZVsxXSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2guIE1hdHJpeCBBICgnICsgYXNpemUgKyAnKSBtdXN0IG1hdGNoIE1hdHJpeCBCICgnICsgYnNpemUgKyAnKScpO1xuXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gYXNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyBlcXVhbCBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGVxID0gZXF1YWxTY2FsYXI7XG4gICAgLy8gemVybyB2YWx1ZVxuICAgIHZhciB6ZXJvID0gMDtcbiAgICAvLyBjYWxsYmFjayBzaWduYXR1cmUgdG8gdXNlXG4gICAgdmFyIGNmID0gY2FsbGJhY2s7XG5cbiAgICAvLyBwcm9jZXNzIGRhdGEgdHlwZXNcbiAgICBpZiAodHlwZW9mIGFkdCA9PT0gJ3N0cmluZycgJiYgYWR0ID09PSBiZHQpIHtcbiAgICAgIC8vIGRhdGF0eXBlXG4gICAgICBkdCA9IGFkdDtcbiAgICAgIC8vIGZpbmQgc2lnbmF0dXJlIHRoYXQgbWF0Y2hlcyAoZHQsIGR0KVxuICAgICAgZXEgPSB0eXBlZC5maW5kKGVxdWFsU2NhbGFyLCBbZHQsIGR0XSk7XG4gICAgICAvLyBjb252ZXJ0IDAgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIHplcm8gPSB0eXBlZC5jb252ZXJ0KDAsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHQgYXJyYXlzXG4gICAgdmFyIGN2YWx1ZXMgPSBhdmFsdWVzICYmIGJ2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gd29ya3NwYWNlc1xuICAgIHZhciB4YSA9IGN2YWx1ZXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgeGIgPSBjdmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgd2EgPSBbXTtcbiAgICB2YXIgd2IgPSBbXTtcblxuICAgIC8vIHZhcnNcbiAgICB2YXIgaSwgaiwgaywgazE7XG4gICAgXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gdXBkYXRlIGNwdHJcbiAgICAgIGNwdHJbal0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gY29sdW1ucyBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gbG9vcCB2YWx1ZXMgQSg6LGopXG4gICAgICBmb3IgKGsgPSBhcHRyW2pdLCBrMSA9IGFwdHJbaiArIDFdOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgaSA9IGFpbmRleFtrXTtcbiAgICAgICAgLy8gcHVzaCBpbmRleFxuICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgICAgLy8gdXBkYXRlIHdvcmtzcGFjZVxuICAgICAgICB3YVtpXSA9IG1hcms7XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXNcbiAgICAgICAgaWYgKHhhKVxuICAgICAgICAgIHhhW2ldID0gYXZhbHVlc1trXTtcbiAgICAgIH1cbiAgICAgIC8vIGxvb3AgdmFsdWVzIEIoOixqKVxuICAgICAgZm9yIChrID0gYnB0cltqXSwgazEgPSBicHRyW2ogKyAxXTsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBiaW5kZXhba107XG4gICAgICAgIC8vIGNoZWNrIHJvdyBleGlzdGVkIGluIEFcbiAgICAgICAgaWYgKHdhW2ldICE9PSBtYXJrKSB7XG4gICAgICAgICAgLy8gcHVzaCBpbmRleFxuICAgICAgICAgIGNpbmRleC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgd2JbaV0gPSBtYXJrO1xuICAgICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzXG4gICAgICAgIGlmICh4YilcbiAgICAgICAgICB4YltpXSA9IGJ2YWx1ZXNba107XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzIChub24gcGF0dGVybiBtYXRyaXgpXG4gICAgICBpZiAoY3ZhbHVlcykge1xuICAgICAgICAvLyBpbml0aWFsaXplIGZpcnN0IGluZGV4IGluIGpcbiAgICAgICAgayA9IGNwdHJbal07XG4gICAgICAgIC8vIGxvb3AgaW5kZXggaW4galxuICAgICAgICB3aGlsZSAoayA8IGNpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICBpID0gY2luZGV4W2tdO1xuICAgICAgICAgIC8vIG1hcmtzXG4gICAgICAgICAgdmFyIHdhaSA9IHdhW2ldO1xuICAgICAgICAgIHZhciB3YmkgPSB3YltpXTtcbiAgICAgICAgICAvLyBjaGVjayBBaWogb3IgQmlqIGFyZSBub256ZXJvXG4gICAgICAgICAgaWYgKHdhaSA9PT0gbWFyayB8fCB3YmkgPT09IG1hcmspIHtcbiAgICAgICAgICAgIC8vIG1hdHJpeCB2YWx1ZXMgQCBpLGpcbiAgICAgICAgICAgIHZhciB2YSA9IHdhaSA9PT0gbWFyayA/IHhhW2ldIDogemVybztcbiAgICAgICAgICAgIHZhciB2YiA9IHdiaSA9PT0gbWFyayA/IHhiW2ldIDogemVybztcbiAgICAgICAgICAgIC8vIENpalxuICAgICAgICAgICAgdmFyIHZjID0gY2YodmEsIHZiKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB6ZXJvXG4gICAgICAgICAgICBpZiAoIWVxKHZjLCB6ZXJvKSkge1xuICAgICAgICAgICAgICAvLyBwdXNoIHZhbHVlXG4gICAgICAgICAgICAgIGN2YWx1ZXMucHVzaCh2Yyk7XG4gICAgICAgICAgICAgIC8vIGluY3JlbWVudCBwb2ludGVyXG4gICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgdmFsdWUgQCBpLCBkbyBub3QgaW5jcmVtZW50IHBvaW50ZXJcbiAgICAgICAgICAgICAgY2luZGV4LnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIGNwdHJcbiAgICBjcHRyW2NvbHVtbnNdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgcmV0dXJuIGFsZ29yaXRobTA1O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDUnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNjYXR0ZXIgPSByZXF1aXJlKCcuLy4uLy4uLy4uL3V0aWxzL2NvbGxlY3Rpb24vc2NhdHRlcicpO1xudmFyIERpbWVuc2lvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3IvRGltZW5zaW9uRXJyb3InKTtcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBlcXVhbFNjYWxhciA9IGxvYWQocmVxdWlyZSgnLi4vLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbFNjYWxhcicpKTtcblxuICB2YXIgU3BhcnNlTWF0cml4ID0gdHlwZS5TcGFyc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IEEgYW5kIFNwYXJzZU1hdHJpeCBCIG5vbnplcm8gaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoQWlqLCBCaWopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCAoQW56IFUgQm56KSB0aW1lcywgd2hlcmUgQW56IGFuZCBCbnogYXJlIHRoZSBub256ZXJvIGVsZW1lbnRzIGluIGJvdGggbWF0cmljZXMuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihBaWosIEJpaikgIDsgQShpLGopICE9PSAwICYmIEIoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKQgIFxuICAgKiAgICAgICAgICDilJQgIDAgICAgICAgICAgICA7IG90aGVyd2lzZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBhICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChBKVxuICAgKiBAcGFyYW0ge01hdHJpeH0gICBiICAgICAgICAgICAgICAgICBUaGUgU3BhcnNlTWF0cml4IGluc3RhbmNlIChCKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWosQmlqKSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIFNwYXJzZU1hdHJpeCAoQylcbiAgICpcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyMDI5NFxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTA2ID0gZnVuY3Rpb24gKGEsIGIsIGNhbGxiYWNrKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXZhbHVlcyA9IGEuX3ZhbHVlcztcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBzcGFyc2UgbWF0cml4IGFycmF5c1xuICAgIHZhciBidmFsdWVzID0gYi5fdmFsdWVzO1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGVxdWFsIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY3ZhbHVlcyA9IGF2YWx1ZXMgJiYgYnZhbHVlcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VzXG4gICAgdmFyIHggPSBjdmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuICAgIC8vIG1hcmtzIGluZGljYXRpbmcgdmFsdWUgaW4gYSBnaXZlbiByb3cgaGFzIGJlZW4gdXBkYXRlZFxuICAgIHZhciB1ID0gW107XG5cbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gdXBkYXRlIGNwdHJcbiAgICAgIGNwdHJbal0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gY29sdW1ucyBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gc2NhdHRlciB0aGUgdmFsdWVzIG9mIEEoOixqKSBpbnRvIHdvcmtzcGFjZVxuICAgICAgc2NhdHRlcihhLCBqLCB3LCB4LCB1LCBtYXJrLCBjLCBjZik7XG4gICAgICAvLyBzY2F0dGVyIHRoZSB2YWx1ZXMgb2YgQig6LGopIGludG8gd29ya3NwYWNlXG4gICAgICBzY2F0dGVyKGIsIGosIHcsIHgsIHUsIG1hcmssIGMsIGNmKTtcbiAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXMgKG5vbiBwYXR0ZXJuIG1hdHJpeClcbiAgICAgIGlmICh4KSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZmlyc3QgaW5kZXggaW4galxuICAgICAgICB2YXIgayA9IGNwdHJbal07XG4gICAgICAgIC8vIGxvb3AgaW5kZXggaW4galxuICAgICAgICB3aGlsZSAoayA8IGNpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByb3dcbiAgICAgICAgICB2YXIgaSA9IGNpbmRleFtrXTtcbiAgICAgICAgICAvLyBjaGVjayBmdW5jdGlvbiB3YXMgaW52b2tlZCBvbiBjdXJyZW50IHJvdyAoQWlqICE9MCAmJiBCaWogIT0gMClcbiAgICAgICAgICBpZiAodVtpXSA9PT0gbWFyaykge1xuICAgICAgICAgICAgLy8gdmFsdWUgQCBpXG4gICAgICAgICAgICB2YXIgdiA9IHhbaV07XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgemVybyB2YWx1ZVxuICAgICAgICAgICAgaWYgKCFlcSh2LCB6ZXJvKSkge1xuICAgICAgICAgICAgICAvLyBwdXNoIHZhbHVlXG4gICAgICAgICAgICAgIGN2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBvaW50ZXJcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSB2YWx1ZSBAIGksIGRvIG5vdCBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgICBjaW5kZXguc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB2YWx1ZSBAIGksIGRvIG5vdCBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgY2luZGV4LnNwbGljZShrLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpbml0aWFsaXplIGZpcnN0IGluZGV4IGluIGpcbiAgICAgICAgdmFyIHAgPSBjcHRyW2pdO1xuICAgICAgICAvLyBsb29wIGluZGV4IGluIGpcbiAgICAgICAgd2hpbGUgKHAgPCBjaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gcm93XG4gICAgICAgICAgdmFyIHIgPSBjaW5kZXhbcF07XG4gICAgICAgICAgLy8gY2hlY2sgZnVuY3Rpb24gd2FzIGludm9rZWQgb24gY3VycmVudCByb3cgKEFpaiAhPTAgJiYgQmlqICE9IDApXG4gICAgICAgICAgaWYgKHVbcl0gIT09IG1hcmspIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB2YWx1ZSBAIGksIGRvIG5vdCBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgY2luZGV4LnNwbGljZShwLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcG9pbnRlclxuICAgICAgICAgICAgcCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY3B0clxuICAgIGNwdHJbY29sdW1uc10gPSBjaW5kZXgubGVuZ3RoO1xuXG4gICAgLy8gcmV0dXJuIHNwYXJzZSBtYXRyaXhcbiAgICByZXR1cm4gYztcbiAgfTtcbiAgXG4gIHJldHVybiBhbGdvcml0aG0wNjtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTA2JztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaW1lbnNpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL0RpbWVuc2lvbkVycm9yJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIFNwYXJzZU1hdHJpeCBBIGFuZCBTcGFyc2VNYXRyaXggQiBpdGVtcyAoemVybyBhbmQgbm9uemVybykgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoQWlqLCBCaWopLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBNeE4gdGltZXMuXG4gICAqXG4gICAqIEMoaSxqKSA9IGYoQWlqLCBCaWopXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGEgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEEpXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGIgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKEIpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpaixCaWopIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgRGVuc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2MjAyOTRcbiAgICovXG4gIHZhciBhbGdvcml0aG0wNyA9IGZ1bmN0aW9uIChhLCBiLCBjYWxsYmFjaykge1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGFzaXplID0gYS5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gYS5fZGF0YXR5cGU7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYnNpemUgPSBiLl9zaXplO1xuICAgIHZhciBiZHQgPSBiLl9kYXRhdHlwZTtcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoYXNpemUubGVuZ3RoICE9PSBic2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoYXNpemUubGVuZ3RoLCBic2l6ZS5sZW5ndGgpO1xuXG4gICAgLy8gY2hlY2sgcm93cyAmIGNvbHVtbnNcbiAgICBpZiAoYXNpemVbMF0gIT09IGJzaXplWzBdIHx8IGFzaXplWzFdICE9PSBic2l6ZVsxXSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2guIE1hdHJpeCBBICgnICsgYXNpemUgKyAnKSBtdXN0IG1hdGNoIE1hdHJpeCBCICgnICsgYnNpemUgKyAnKScpO1xuXG4gICAgLy8gcm93cyAmIGNvbHVtbnNcbiAgICB2YXIgcm93cyA9IGFzaXplWzBdO1xuICAgIHZhciBjb2x1bW5zID0gYXNpemVbMV07XG5cbiAgICAvLyBkYXRhdHlwZVxuICAgIHZhciBkdDtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBqO1xuICAgIFxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY2RhdGEgPSBbXTtcbiAgICAvLyBpbml0aWFsaXplIGNcbiAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKVxuICAgICAgY2RhdGFbaV0gPSBbXTtcblxuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VzXG4gICAgdmFyIHhhID0gW107XG4gICAgdmFyIHhiID0gW107XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgd2EgPSBbXTtcbiAgICB2YXIgd2IgPSBbXTtcblxuICAgIC8vIGxvb3AgY29sdW1uc1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGNvbHVtbnMgbWFya1xuICAgICAgdmFyIG1hcmsgPSBqICsgMTtcbiAgICAgIC8vIHNjYXR0ZXIgdGhlIHZhbHVlcyBvZiBBKDosaikgaW50byB3b3Jrc3BhY2VcbiAgICAgIF9zY2F0dGVyKGEsIGosIHdhLCB4YSwgbWFyayk7XG4gICAgICAvLyBzY2F0dGVyIHRoZSB2YWx1ZXMgb2YgQig6LGopIGludG8gd29ya3NwYWNlXG4gICAgICBfc2NhdHRlcihiLCBqLCB3YiwgeGIsIG1hcmspO1xuICAgICAgLy8gbG9vcCByb3dzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIC8vIG1hdHJpeCB2YWx1ZXMgQCBpLGpcbiAgICAgICAgdmFyIHZhID0gd2FbaV0gPT09IG1hcmsgPyB4YVtpXSA6IHplcm87XG4gICAgICAgIHZhciB2YiA9IHdiW2ldID09PSBtYXJrID8geGJbaV0gOiB6ZXJvO1xuICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tcbiAgICAgICAgY2RhdGFbaV1bal0gPSBjZih2YSwgdmIpO1xuICAgICAgfSAgICAgICAgICBcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuICBcbiAgdmFyIF9zY2F0dGVyID0gZnVuY3Rpb24gKG0sIGosIHcsIHgsIG1hcmspIHtcbiAgICAvLyBhIGFycmF5c1xuICAgIHZhciB2YWx1ZXMgPSBtLl92YWx1ZXM7XG4gICAgdmFyIGluZGV4ID0gbS5faW5kZXg7XG4gICAgdmFyIHB0ciA9IG0uX3B0cjtcbiAgICAvLyBsb29wIHZhbHVlcyBpbiBjb2x1bW4galxuICAgIGZvciAodmFyIGsgPSBwdHJbal0sIGsxID0gcHRyW2ogKyAxXTsgayA8IGsxOyBrKyspIHtcbiAgICAgIC8vIHJvd1xuICAgICAgdmFyIGkgPSBpbmRleFtrXTtcbiAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgIHdbaV0gPSBtYXJrO1xuICAgICAgeFtpXSA9IHZhbHVlc1trXTtcbiAgICB9XG4gIH07XG4gIFxuICByZXR1cm4gYWxnb3JpdGhtMDc7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0wNyc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkKSB7XG5cbiAgdmFyIGVxdWFsU2NhbGFyID0gbG9hZChyZXF1aXJlKCcuLi8uLi8uLi9mdW5jdGlvbi9yZWxhdGlvbmFsL2VxdWFsU2NhbGFyJykpO1xuXG4gIHZhciBTcGFyc2VNYXRyaXggPSB0eXBlLlNwYXJzZU1hdHJpeDtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBTcGFyc2VNYXRyaXggQSBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihBaWosIEJpaikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE5aQSB0aW1lcywgbnVtYmVyIG9mIG5vbnplcm8gZWxlbWVudHMgaW4gQS5cbiAgICpcbiAgICpcbiAgICogICAgICAgICAg4pSMICBmKEFpaiwgQmlqKSAgOyBBKGksaikgIT09IDBcbiAgICogQyhpLGopID0g4pSkICBcbiAgICogICAgICAgICAg4pSUICAwICAgICAgICAgICAgOyBvdGhlcndpc2VcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYSAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQSlcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoQilcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoQWlqLEJpaikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBTcGFyc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2MjAyOTRcbiAgICovXG4gIHZhciBhbGdvcml0aG0wOSA9IGZ1bmN0aW9uIChhLCBiLCBjYWxsYmFjaykge1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBhLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICAgIHZhciBhcHRyID0gYS5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGJ2YWx1ZXMgPSBiLl92YWx1ZXM7XG4gICAgdmFyIGJpbmRleCA9IGIuX2luZGV4O1xuICAgIHZhciBicHRyID0gYi5fcHRyO1xuICAgIHZhciBic2l6ZSA9IGIuX3NpemU7XG4gICAgdmFyIGJkdCA9IGIuX2RhdGF0eXBlO1xuXG4gICAgLy8gdmFsaWRhdGUgZGltZW5zaW9uc1xuICAgIGlmIChhc2l6ZS5sZW5ndGggIT09IGJzaXplLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhc2l6ZS5sZW5ndGgsIGJzaXplLmxlbmd0aCk7XG5cbiAgICAvLyBjaGVjayByb3dzICYgY29sdW1uc1xuICAgIGlmIChhc2l6ZVswXSAhPT0gYnNpemVbMF0gfHwgYXNpemVbMV0gIT09IGJzaXplWzFdKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaC4gTWF0cml4IEEgKCcgKyBhc2l6ZSArICcpIG11c3QgbWF0Y2ggTWF0cml4IEIgKCcgKyBic2l6ZSArICcpJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGVxdWFsIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgZXEgPSBlcXVhbFNjYWxhcjtcbiAgICAvLyB6ZXJvIHZhbHVlXG4gICAgdmFyIHplcm8gPSAwO1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gZmluZCBzaWduYXR1cmUgdGhhdCBtYXRjaGVzIChkdCwgZHQpXG4gICAgICBlcSA9IHR5cGVkLmZpbmQoZXF1YWxTY2FsYXIsIFtkdCwgZHRdKTtcbiAgICAgIC8vIGNvbnZlcnQgMCB0byB0aGUgc2FtZSBkYXRhdHlwZVxuICAgICAgemVybyA9IHR5cGVkLmNvbnZlcnQoMCwgZHQpO1xuICAgICAgLy8gY2FsbGJhY2tcbiAgICAgIGNmID0gdHlwZWQuZmluZChjYWxsYmFjaywgW2R0LCBkdF0pO1xuICAgIH1cblxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY3ZhbHVlcyA9IGF2YWx1ZXMgJiYgYnZhbHVlcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIHZhciBjaW5kZXggPSBbXTtcbiAgICB2YXIgY3B0ciA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IFNwYXJzZU1hdHJpeCh7XG4gICAgICB2YWx1ZXM6IGN2YWx1ZXMsXG4gICAgICBpbmRleDogY2luZGV4LFxuICAgICAgcHRyOiBjcHRyLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VzXG4gICAgdmFyIHggPSBjdmFsdWVzID8gW10gOiB1bmRlZmluZWQ7XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuXG4gICAgLy8gdmFyc1xuICAgIHZhciBpLCBqLCBrLCBrMCwgazE7XG4gICAgXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gdXBkYXRlIGNwdHJcbiAgICAgIGNwdHJbal0gPSBjaW5kZXgubGVuZ3RoO1xuICAgICAgLy8gY29sdW1uIG1hcmtcbiAgICAgIHZhciBtYXJrID0gaiArIDE7XG4gICAgICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzXG4gICAgICBpZiAoeCkge1xuICAgICAgICAvLyBsb29wIEIoOixqKVxuICAgICAgICBmb3IgKGswID0gYnB0cltqXSwgazEgPSBicHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAgIC8vIHJvd1xuICAgICAgICAgIGkgPSBiaW5kZXhba107XG4gICAgICAgICAgLy8gdXBkYXRlIHdvcmtzcGFjZVxuICAgICAgICAgIHdbaV0gPSBtYXJrO1xuICAgICAgICAgIHhbaV0gPSBidmFsdWVzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBsb29wIEEoOixqKVxuICAgICAgZm9yIChrMCA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIGkgPSBhaW5kZXhba107XG4gICAgICAgIC8vIGNoZWNrIHdlIG5lZWQgdG8gcHJvY2VzcyB2YWx1ZXNcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAvLyBiIHZhbHVlIEAgaSxqXG4gICAgICAgICAgdmFyIHZiID0gd1tpXSA9PT0gbWFyayA/IHhbaV0gOiB6ZXJvO1xuICAgICAgICAgIC8vIGludm9rZSBmXG4gICAgICAgICAgdmFyIHZjID0gY2YoYXZhbHVlc1trXSwgdmIpO1xuICAgICAgICAgIC8vIGNoZWNrIHplcm8gdmFsdWVcbiAgICAgICAgICBpZiAoIWVxKHZjLCB6ZXJvKSkge1xuICAgICAgICAgICAgLy8gcHVzaCBpbmRleFxuICAgICAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgICAgICAvLyBwdXNoIHZhbHVlXG4gICAgICAgICAgICBjdmFsdWVzLnB1c2godmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBwdXNoIGluZGV4XG4gICAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIGNwdHJcbiAgICBjcHRyW2NvbHVtbnNdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgcmV0dXJuIGFsZ29yaXRobTA5O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMDknO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IFMgbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihTaWosIGIpLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBOWiB0aW1lcyAobnVtYmVyIG9mIG5vbnplcm8gaXRlbXMgaW4gUykuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihTaWosIGIpICA7IFMoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKQgIFxuICAgKiAgICAgICAgICDilJQgIGIgICAgICAgICAgOyBvdGhlcndpc2VcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgcyAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoUylcbiAgICogQHBhcmFtIHtTY2FsYXJ9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNjYWxhciB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWosYikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBpbnZlcnNlICAgICAgICAgICBBIHRydWUgdmFsdWUgaW5kaWNhdGVzIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkIGYoYixTaWopXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIERlbnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2MjY4MTNcbiAgICovXG4gIHZhciBhbGdvcml0aG0xMCA9IGZ1bmN0aW9uIChzLCBiLCBjYWxsYmFjaywgaW52ZXJzZSkge1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBzLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IHMuX2luZGV4O1xuICAgIHZhciBhcHRyID0gcy5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IHMuX3NpemU7XG4gICAgdmFyIGFkdCA9IHMuX2RhdGF0eXBlO1xuXG4gICAgLy8gc3BhcnNlIG1hdHJpeCBjYW5ub3QgYmUgYSBQYXR0ZXJuIG1hdHJpeFxuICAgIGlmICghYXZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIG9uIFBhdHRlcm4gU3BhcnNlIE1hdHJpeCBhbmQgU2NhbGFyIHZhbHVlJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gY29udmVydCBiIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICBiID0gdHlwZWQuY29udmVydChiLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gcmVzdWx0IGFycmF5c1xuICAgIHZhciBjZGF0YSA9IFtdO1xuICAgIC8vIG1hdHJpeFxuICAgIHZhciBjID0gbmV3IERlbnNlTWF0cml4KHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgc2l6ZTogW3Jvd3MsIGNvbHVtbnNdLFxuICAgICAgZGF0YXR5cGU6IGR0XG4gICAgfSk7XG5cbiAgICAvLyB3b3Jrc3BhY2VzXG4gICAgdmFyIHggPSBbXTtcbiAgICAvLyBtYXJrcyBpbmRpY2F0aW5nIHdlIGhhdmUgYSB2YWx1ZSBpbiB4IGZvciBhIGdpdmVuIGNvbHVtblxuICAgIHZhciB3ID0gW107XG5cbiAgICAvLyBsb29wIGNvbHVtbnNcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgLy8gY29sdW1ucyBtYXJrXG4gICAgICB2YXIgbWFyayA9IGogKyAxO1xuICAgICAgLy8gdmFsdWVzIGluIGpcbiAgICAgIGZvciAodmFyIGswID0gYXB0cltqXSwgazEgPSBhcHRyW2ogKyAxXSwgayA9IGswOyBrIDwgazE7IGsrKykge1xuICAgICAgICAvLyByb3dcbiAgICAgICAgdmFyIHIgPSBhaW5kZXhba107XG4gICAgICAgIC8vIHVwZGF0ZSB3b3Jrc3BhY2VcbiAgICAgICAgeFtyXSA9IGF2YWx1ZXNba107XG4gICAgICAgIHdbcl0gPSBtYXJrO1xuICAgICAgfVxuICAgICAgLy8gbG9vcCByb3dzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAvLyBpbml0aWFsaXplIEMgb24gZmlyc3QgY29sdW1uXG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHJvdyBhcnJheVxuICAgICAgICAgIGNkYXRhW2ldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgc3BhcnNlIG1hdHJpeCBoYXMgYSB2YWx1ZSBAIGksalxuICAgICAgICBpZiAod1tpXSA9PT0gbWFyaykge1xuICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFjaywgdXBkYXRlIENcbiAgICAgICAgICBjZGF0YVtpXVtqXSA9IGludmVyc2UgPyBjZihiLCB4W2ldKSA6IGNmKHhbaV0sIGIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGRlbnNlIG1hdHJpeCB2YWx1ZSBAIGksIGpcbiAgICAgICAgICBjZGF0YVtpXVtqXSA9IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gc3BhcnNlIG1hdHJpeFxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIHJldHVybiBhbGdvcml0aG0xMDtcbn1cblxuZXhwb3J0cy5uYW1lID0gJ2FsZ29yaXRobTEwJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgZXF1YWxTY2FsYXIgPSBsb2FkKHJlcXVpcmUoJy4uLy4uLy4uL2Z1bmN0aW9uL3JlbGF0aW9uYWwvZXF1YWxTY2FsYXInKSk7XG5cbiAgdmFyIFNwYXJzZU1hdHJpeCA9IHR5cGUuU3BhcnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIFNwYXJzZU1hdHJpeCBTIG5vbnplcm8gaXRlbXMgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGYoU2lqLCBiKS4gXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgTlogdGltZXMgKG51bWJlciBvZiBub256ZXJvIGl0ZW1zIGluIFMpLlxuICAgKlxuICAgKlxuICAgKiAgICAgICAgICDilIwgIGYoU2lqLCBiKSAgOyBTKGksaikgIT09IDBcbiAgICogQyhpLGopID0g4pSkICBcbiAgICogICAgICAgICAg4pSUICAwICAgICAgICAgIDsgb3RoZXJ3aXNlXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIHMgICAgICAgICAgICAgICAgIFRoZSBTcGFyc2VNYXRyaXggaW5zdGFuY2UgKFMpXG4gICAqIEBwYXJhbSB7U2NhbGFyfSAgIGIgICAgICAgICAgICAgICAgIFRoZSBTY2FsYXIgdmFsdWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgVGhlIGYoQWlqLGIpIG9wZXJhdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHtib29sZWFufSAgaW52ZXJzZSAgICAgICAgICAgQSB0cnVlIHZhbHVlIGluZGljYXRlcyBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZCBmKGIsU2lqKVxuICAgKlxuICAgKiBAcmV0dXJuIHtNYXRyaXh9ICAgICAgICAgICAgICAgICAgICBTcGFyc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzYyNjgxM1xuICAgKi9cbiAgdmFyIGFsZ29yaXRobTExID0gZnVuY3Rpb24gKHMsIGIsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gc3BhcnNlIG1hdHJpeCBhcnJheXNcbiAgICB2YXIgYXZhbHVlcyA9IHMuX3ZhbHVlcztcbiAgICB2YXIgYWluZGV4ID0gcy5faW5kZXg7XG4gICAgdmFyIGFwdHIgPSBzLl9wdHI7XG4gICAgdmFyIGFzaXplID0gcy5fc2l6ZTtcbiAgICB2YXIgYWR0ID0gcy5fZGF0YXR5cGU7XG5cbiAgICAvLyBzcGFyc2UgbWF0cml4IGNhbm5vdCBiZSBhIFBhdHRlcm4gbWF0cml4XG4gICAgaWYgKCFhdmFsdWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gb24gUGF0dGVybiBTcGFyc2UgTWF0cml4IGFuZCBTY2FsYXIgdmFsdWUnKTtcblxuICAgIC8vIHJvd3MgJiBjb2x1bW5zXG4gICAgdmFyIHJvd3MgPSBhc2l6ZVswXTtcbiAgICB2YXIgY29sdW1ucyA9IGFzaXplWzFdO1xuXG4gICAgLy8gZGF0YXR5cGVcbiAgICB2YXIgZHQ7XG4gICAgLy8gZXF1YWwgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBlcSA9IGVxdWFsU2NhbGFyO1xuICAgIC8vIHplcm8gdmFsdWVcbiAgICB2YXIgemVybyA9IDA7XG4gICAgLy8gY2FsbGJhY2sgc2lnbmF0dXJlIHRvIHVzZVxuICAgIHZhciBjZiA9IGNhbGxiYWNrO1xuXG4gICAgLy8gcHJvY2VzcyBkYXRhIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBhZHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkYXRhdHlwZVxuICAgICAgZHQgPSBhZHQ7XG4gICAgICAvLyBmaW5kIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgKGR0LCBkdClcbiAgICAgIGVxID0gdHlwZWQuZmluZChlcXVhbFNjYWxhciwgW2R0LCBkdF0pO1xuICAgICAgLy8gY29udmVydCAwIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICB6ZXJvID0gdHlwZWQuY29udmVydCgwLCBkdCk7XG4gICAgICAvLyBjb252ZXJ0IGIgdG8gdGhlIHNhbWUgZGF0YXR5cGVcbiAgICAgIGIgPSB0eXBlZC5jb252ZXJ0KGIsIGR0KTtcbiAgICAgIC8vIGNhbGxiYWNrXG4gICAgICBjZiA9IHR5cGVkLmZpbmQoY2FsbGJhY2ssIFtkdCwgZHRdKTtcbiAgICB9XG5cbiAgICAvLyByZXN1bHQgYXJyYXlzXG4gICAgdmFyIGN2YWx1ZXMgPSBbXTtcbiAgICB2YXIgY2luZGV4ID0gW107XG4gICAgdmFyIGNwdHIgPSBbXTtcbiAgICAvLyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBTcGFyc2VNYXRyaXgoe1xuICAgICAgdmFsdWVzOiBjdmFsdWVzLFxuICAgICAgaW5kZXg6IGNpbmRleCxcbiAgICAgIHB0cjogY3B0cixcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGluaXRpYWxpemUgcHRyXG4gICAgICBjcHRyW2pdID0gY2luZGV4Lmxlbmd0aDtcbiAgICAgIC8vIHZhbHVlcyBpbiBqXG4gICAgICBmb3IgKHZhciBrMCA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIHZhciBpID0gYWluZGV4W2tdO1xuICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tcbiAgICAgICAgdmFyIHYgPSBpbnZlcnNlID8gY2YoYiwgYXZhbHVlc1trXSkgOiBjZihhdmFsdWVzW2tdLCBiKTtcbiAgICAgICAgLy8gY2hlY2sgdmFsdWUgaXMgemVyb1xuICAgICAgICBpZiAoIWVxKHYsIHplcm8pKSB7XG4gICAgICAgICAgLy8gcHVzaCBpbmRleCAmIHZhbHVlXG4gICAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgICAgY3ZhbHVlcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBwdHJcbiAgICBjcHRyW2NvbHVtbnNdID0gY2luZGV4Lmxlbmd0aDtcblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgcmV0dXJuIGFsZ29yaXRobTExO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMTEnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuXG4gIHZhciBEZW5zZU1hdHJpeCA9IHR5cGUuRGVuc2VNYXRyaXg7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgU3BhcnNlTWF0cml4IFMgbm9uemVybyBpdGVtcyBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZihTaWosIGIpLiBcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBNeE4gdGltZXMuXG4gICAqXG4gICAqXG4gICAqICAgICAgICAgIOKUjCAgZihTaWosIGIpICA7IFMoaSxqKSAhPT0gMFxuICAgKiBDKGksaikgPSDilKQgIFxuICAgKiAgICAgICAgICDilJQgIGYoMCwgYikgICAgOyBvdGhlcndpc2VcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgcyAgICAgICAgICAgICAgICAgVGhlIFNwYXJzZU1hdHJpeCBpbnN0YW5jZSAoUylcbiAgICogQHBhcmFtIHtTY2FsYXJ9ICAgYiAgICAgICAgICAgICAgICAgVGhlIFNjYWxhciB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWosYikgb3BlcmF0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBpbnZlcnNlICAgICAgICAgICBBIHRydWUgdmFsdWUgaW5kaWNhdGVzIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkIGYoYixTaWopXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIERlbnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2MjY4MTNcbiAgICovXG4gIHZhciBhbGdvcml0aG0xMiA9IGZ1bmN0aW9uIChzLCBiLCBjYWxsYmFjaywgaW52ZXJzZSkge1xuICAgIC8vIHNwYXJzZSBtYXRyaXggYXJyYXlzXG4gICAgdmFyIGF2YWx1ZXMgPSBzLl92YWx1ZXM7XG4gICAgdmFyIGFpbmRleCA9IHMuX2luZGV4O1xuICAgIHZhciBhcHRyID0gcy5fcHRyO1xuICAgIHZhciBhc2l6ZSA9IHMuX3NpemU7XG4gICAgdmFyIGFkdCA9IHMuX2RhdGF0eXBlO1xuXG4gICAgLy8gc3BhcnNlIG1hdHJpeCBjYW5ub3QgYmUgYSBQYXR0ZXJuIG1hdHJpeFxuICAgIGlmICghYXZhbHVlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIG9uIFBhdHRlcm4gU3BhcnNlIE1hdHJpeCBhbmQgU2NhbGFyIHZhbHVlJyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciByb3dzID0gYXNpemVbMF07XG4gICAgdmFyIGNvbHVtbnMgPSBhc2l6ZVsxXTtcblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gY29udmVydCBiIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICBiID0gdHlwZWQuY29udmVydChiLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuICAgIFxuICAgIC8vIHJlc3VsdCBhcnJheXNcbiAgICB2YXIgY2RhdGEgPSBbXTtcbiAgICAvLyBtYXRyaXhcbiAgICB2YXIgYyA9IG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjZGF0YSxcbiAgICAgIHNpemU6IFtyb3dzLCBjb2x1bW5zXSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuXG4gICAgLy8gd29ya3NwYWNlc1xuICAgIHZhciB4ID0gW107XG4gICAgLy8gbWFya3MgaW5kaWNhdGluZyB3ZSBoYXZlIGEgdmFsdWUgaW4geCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAgICB2YXIgdyA9IFtdO1xuXG4gICAgLy8gbG9vcCBjb2x1bW5zXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIC8vIGNvbHVtbnMgbWFya1xuICAgICAgdmFyIG1hcmsgPSBqICsgMTtcbiAgICAgIC8vIHZhbHVlcyBpbiBqXG4gICAgICBmb3IgKHZhciBrMCA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgICAgLy8gcm93XG4gICAgICAgIHZhciByID0gYWluZGV4W2tdO1xuICAgICAgICAvLyB1cGRhdGUgd29ya3NwYWNlXG4gICAgICAgIHhbcl0gPSBhdmFsdWVzW2tdO1xuICAgICAgICB3W3JdID0gbWFyaztcbiAgICAgIH1cbiAgICAgIC8vIGxvb3Agcm93c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBDIG9uIGZpcnN0IGNvbHVtblxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIC8vIGNyZWF0ZSByb3cgYXJyYXlcbiAgICAgICAgICBjZGF0YVtpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHNwYXJzZSBtYXRyaXggaGFzIGEgdmFsdWUgQCBpLGpcbiAgICAgICAgaWYgKHdbaV0gPT09IG1hcmspIHtcbiAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2ssIHVwZGF0ZSBDXG4gICAgICAgICAgY2RhdGFbaV1bal0gPSBpbnZlcnNlID8gY2YoYiwgeFtpXSkgOiBjZih4W2ldLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBkZW5zZSBtYXRyaXggdmFsdWUgQCBpLCBqXG4gICAgICAgICAgY2RhdGFbaV1bal0gPSBpbnZlcnNlID8gY2YoYiwgMCkgOiBjZigwLCBiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBzcGFyc2UgbWF0cml4XG4gICAgcmV0dXJuIGM7XG4gIH07XG4gIFxuICByZXR1cm4gYWxnb3JpdGhtMTI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0xMic7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL2luZGV4Jyk7XG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xuXG52YXIgc3RyaW5nID0gdXRpbC5zdHJpbmcsXG4gICAgaXNTdHJpbmcgPSBzdHJpbmcuaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIERlbnNlTWF0cml4IGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKEFpai4ueiwgQmlqLi56KS4gXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgTXhOIHRpbWVzLlxuICAgKlxuICAgKiBDKGksaiwuLi56KSA9IGYoQWlqLi56LCBCaWouLnopXG4gICAqXG4gICAqIEBwYXJhbSB7TWF0cml4fSAgIGEgICAgICAgICAgICAgICAgIFRoZSBEZW5zZU1hdHJpeCBpbnN0YW5jZSAoQSlcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYiAgICAgICAgICAgICAgICAgVGhlIERlbnNlTWF0cml4IGluc3RhbmNlIChCKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICAgICBUaGUgZihBaWouLnosQmlqLi56KSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqXG4gICAqIEByZXR1cm4ge01hdHJpeH0gICAgICAgICAgICAgICAgICAgIERlbnNlTWF0cml4IChDKVxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vam9zZGVqb25nL21hdGhqcy9wdWxsLzM0NiNpc3N1ZWNvbW1lbnQtOTc2NTg2NThcbiAgICovXG4gIHZhciBhbGdvcml0aG0xMyA9IGZ1bmN0aW9uIChhLCBiLCBjYWxsYmFjaykge1xuICAgIC8vIGEgYXJyYXlzXG4gICAgdmFyIGFkYXRhID0gYS5fZGF0YTtcbiAgICB2YXIgYXNpemUgPSBhLl9zaXplO1xuICAgIHZhciBhZHQgPSBhLl9kYXRhdHlwZTtcbiAgICAvLyBiIGFycmF5c1xuICAgIHZhciBiZGF0YSA9IGIuX2RhdGE7XG4gICAgdmFyIGJzaXplID0gYi5fc2l6ZTtcbiAgICB2YXIgYmR0ID0gYi5fZGF0YXR5cGU7XG4gICAgLy8gYyBhcnJheXNcbiAgICB2YXIgY3NpemUgPSBbXTtcblxuICAgIC8vIHZhbGlkYXRlIGRpbWVuc2lvbnNcbiAgICBpZiAoYXNpemUubGVuZ3RoICE9PSBic2l6ZS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoYXNpemUubGVuZ3RoLCBic2l6ZS5sZW5ndGgpO1xuXG4gICAgLy8gdmFsaWRhdGUgZWFjaCBvbmUgb2YgdGhlIGRpbWVuc2lvbiBzaXplc1xuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgYXNpemUubGVuZ3RoOyBzKyspIHtcbiAgICAgIC8vIG11c3QgbWF0Y2hcbiAgICAgIGlmIChhc2l6ZVtzXSAhPT0gYnNpemVbc10pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2guIE1hdHJpeCBBICgnICsgYXNpemUgKyAnKSBtdXN0IG1hdGNoIE1hdHJpeCBCICgnICsgYnNpemUgKyAnKScpO1xuICAgICAgLy8gdXBkYXRlIGRpbWVuc2lvbiBpbiBjXG4gICAgICBjc2l6ZVtzXSA9IGFzaXplW3NdO1xuICAgIH1cblxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJyAmJiBhZHQgPT09IGJkdCkge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gY29udmVydCBiIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICBiID0gdHlwZWQuY29udmVydChiLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuXG4gICAgLy8gcG9wdWxhdGUgY2RhdGEsIGl0ZXJhdGUgdGhyb3VnaCBkaW1lbnNpb25zXG4gICAgdmFyIGNkYXRhID0gY3NpemUubGVuZ3RoID4gMCA/IF9pdGVyYXRlKGNmLCAwLCBjc2l6ZSwgY3NpemVbMF0sIGFkYXRhLCBiZGF0YSkgOiBbXTtcbiAgICBcbiAgICAvLyBjIG1hdHJpeFxuICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoe1xuICAgICAgZGF0YTogY2RhdGEsXG4gICAgICBzaXplOiBjc2l6ZSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gcmVjdXJzaXZlIGZ1bmN0aW9uXG4gIHZhciBfaXRlcmF0ZSA9IGZ1bmN0aW9uIChmLCBsZXZlbCwgcywgbiwgYXYsIGJ2KSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBhcnJheSBmb3IgdGhpcyBsZXZlbFxuICAgIHZhciBjdiA9IFtdO1xuICAgIC8vIGNoZWNrIHdlIHJlYWNoIHRoZSBsYXN0IGxldmVsXG4gICAgaWYgKGxldmVsID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGxvb3AgYXJyYXlzIGluIGxhc3QgbGV2ZWxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIC8vIGludm9rZSBjYWxsYmFjayBhbmQgc3RvcmUgdmFsdWVcbiAgICAgICAgY3ZbaV0gPSBmKGF2W2ldLCBidltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gaXRlcmF0ZSBjdXJyZW50IGxldmVsXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAvLyBpdGVyYXRlIG5leHQgbGV2ZWxcbiAgICAgICAgY3Zbal0gPSBfaXRlcmF0ZShmLCBsZXZlbCArIDEsIHMsIHNbbGV2ZWwgKyAxXSwgYXZbal0sIGJ2W2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN2O1xuICB9O1xuICBcbiAgcmV0dXJuIGFsZ29yaXRobTEzO1xufVxuXG5leHBvcnRzLm5hbWUgPSAnYWxnb3JpdGhtMTMnO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsb25lID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvb2JqZWN0JykuY2xvbmU7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcblxuICB2YXIgRGVuc2VNYXRyaXggPSB0eXBlLkRlbnNlTWF0cml4O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIERlbnNlTWF0cml4IGl0ZW1zIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmKEFpai4ueiwgYikuIFxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIE14TiB0aW1lcy5cbiAgICpcbiAgICogQyhpLGosLi4ueikgPSBmKEFpai4ueiwgYilcbiAgICpcbiAgICogQHBhcmFtIHtNYXRyaXh9ICAgYSAgICAgICAgICAgICAgICAgVGhlIERlbnNlTWF0cml4IGluc3RhbmNlIChBKVxuICAgKiBAcGFyYW0ge1NjYWxhcn0gICBiICAgICAgICAgICAgICAgICBUaGUgU2NhbGFyIHZhbHVlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgICAgICAgIFRoZSBmKEFpai4ueixiKSBvcGVyYXRpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGludmVyc2UgICAgICAgICAgIEEgdHJ1ZSB2YWx1ZSBpbmRpY2F0ZXMgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQgZihiLEFpai4ueilcbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSAgICAgICAgICAgICAgICAgICAgRGVuc2VNYXRyaXggKEMpXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NkZWpvbmcvbWF0aGpzL3B1bGwvMzQ2I2lzc3VlY29tbWVudC05NzY1OTA0MlxuICAgKi9cbiAgdmFyIGFsZ29yaXRobTE0ID0gZnVuY3Rpb24gKGEsIGIsIGNhbGxiYWNrLCBpbnZlcnNlKSB7XG4gICAgLy8gYSBhcnJheXNcbiAgICB2YXIgYWRhdGEgPSBhLl9kYXRhO1xuICAgIHZhciBhc2l6ZSA9IGEuX3NpemU7XG4gICAgdmFyIGFkdCA9IGEuX2RhdGF0eXBlO1xuICAgIFxuICAgIC8vIGRhdGF0eXBlXG4gICAgdmFyIGR0O1xuICAgIC8vIGNhbGxiYWNrIHNpZ25hdHVyZSB0byB1c2VcbiAgICB2YXIgY2YgPSBjYWxsYmFjaztcblxuICAgIC8vIHByb2Nlc3MgZGF0YSB0eXBlc1xuICAgIGlmICh0eXBlb2YgYWR0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGF0YXR5cGVcbiAgICAgIGR0ID0gYWR0O1xuICAgICAgLy8gY29udmVydCBiIHRvIHRoZSBzYW1lIGRhdGF0eXBlXG4gICAgICBiID0gdHlwZWQuY29udmVydChiLCBkdCk7XG4gICAgICAvLyBjYWxsYmFja1xuICAgICAgY2YgPSB0eXBlZC5maW5kKGNhbGxiYWNrLCBbZHQsIGR0XSk7XG4gICAgfVxuICAgIFxuICAgIC8vIHBvcHVsYXRlIGNkYXRhLCBpdGVyYXRlIHRocm91Z2ggZGltZW5zaW9uc1xuICAgIHZhciBjZGF0YSA9IGFzaXplLmxlbmd0aCA+IDAgPyBfaXRlcmF0ZShjZiwgMCwgYXNpemUsIGFzaXplWzBdLCBhZGF0YSwgYiwgaW52ZXJzZSkgOiBbXTtcblxuICAgIC8vIGMgbWF0cml4XG4gICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeCh7XG4gICAgICBkYXRhOiBjZGF0YSxcbiAgICAgIHNpemU6IGNsb25lKGFzaXplKSxcbiAgICAgIGRhdGF0eXBlOiBkdFxuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gcmVjdXJzaXZlIGZ1bmN0aW9uXG4gIHZhciBfaXRlcmF0ZSA9IGZ1bmN0aW9uIChmLCBsZXZlbCwgcywgbiwgYXYsIGJ2LCBpbnZlcnNlKSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBhcnJheSBmb3IgdGhpcyBsZXZlbFxuICAgIHZhciBjdiA9IFtdO1xuICAgIC8vIGNoZWNrIHdlIHJlYWNoIHRoZSBsYXN0IGxldmVsXG4gICAgaWYgKGxldmVsID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGxvb3AgYXJyYXlzIGluIGxhc3QgbGV2ZWxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIC8vIGludm9rZSBjYWxsYmFjayBhbmQgc3RvcmUgdmFsdWVcbiAgICAgICAgY3ZbaV0gPSBpbnZlcnNlID8gZihidiwgYXZbaV0pIDogZihhdltpXSwgYnYpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGl0ZXJhdGUgY3VycmVudCBsZXZlbFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgLy8gaXRlcmF0ZSBuZXh0IGxldmVsXG4gICAgICAgIGN2W2pdID0gX2l0ZXJhdGUoZiwgbGV2ZWwgKyAxLCBzLCBzW2xldmVsICsgMV0sIGF2W2pdLCBidiwgaW52ZXJzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdjtcbiAgfTtcblxuICByZXR1cm4gYWxnb3JpdGhtMTQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdhbGdvcml0aG0xNCc7XG5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVlcE1hcCA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvY29sbGVjdGlvbi9kZWVwTWFwJyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkgKHR5cGUsIGNvbmZpZywgbG9hZCwgdHlwZWQpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG51bWJlciBvciBjb252ZXJ0IGEgc3RyaW5nLCBib29sZWFuLCBvciB1bml0IHRvIGEgbnVtYmVyLlxuICAgKiBXaGVuIHZhbHVlIGlzIGEgbWF0cml4LCBhbGwgZWxlbWVudHMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gbnVtYmVyLlxuICAgKlxuICAgKiBTeW50YXg6XG4gICAqXG4gICAqICAgIG1hdGgubnVtYmVyKHZhbHVlKVxuICAgKiAgICBtYXRoLm51bWJlcih1bml0LCB2YWx1ZWxlc3NVbml0KVxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgbWF0aC5udW1iZXIoMik7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDJcbiAgICogICAgbWF0aC5udW1iZXIoJzcuMicpOyAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgbnVtYmVyIDcuMlxuICAgKiAgICBtYXRoLm51bWJlcih0cnVlKTsgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgMVxuICAgKiAgICBtYXRoLm51bWJlcihbdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWVdKTsgLy8gcmV0dXJucyBbMSwgMCwgMSwgMV1cbiAgICogICAgbWF0aC5udW1iZXIobWF0aC51bml0KCc1MmNtJyksICdtJyk7ICAgIC8vIHJldHVybnMgMC41MlxuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICpcbiAgICogICAgYmlnbnVtYmVyLCBib29sZWFuLCBjb21wbGV4LCBpbmRleCwgbWF0cml4LCBzdHJpbmcsIHVuaXRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW4gfCBBcnJheSB8IE1hdHJpeCB8IFVuaXQgfCBudWxsfSBbdmFsdWVdICBWYWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHBhcmFtIHtVbml0IHwgc3RyaW5nfSBbdmFsdWVsZXNzVW5pdF0gQSB2YWx1ZWxlc3MgdW5pdCwgdXNlZCB0byBjb252ZXJ0IGEgdW5pdCB0byBhIG51bWJlclxuICAgKiBAcmV0dXJuIHtudW1iZXIgfCBBcnJheSB8IE1hdHJpeH0gVGhlIGNyZWF0ZWQgbnVtYmVyXG4gICAqL1xuICB2YXIgbnVtYmVyID0gdHlwZWQoJ251bWJlcicsIHtcbiAgICAnJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgICdudW1iZXInOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgICdzdHJpbmcnOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdmFyIG51bSA9IE51bWJlcih4KTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignU3RyaW5nIFwiJyArIHggKyAnXCIgaXMgbm8gdmFsaWQgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH0sXG5cbiAgICAnQmlnTnVtYmVyJzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnRvTnVtYmVyKCk7XG4gICAgfSxcblxuICAgICdGcmFjdGlvbic6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC52YWx1ZU9mKCk7XG4gICAgfSxcblxuICAgICdVbml0JzogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IHdpdGggdmFsdWVsZXNzIHVuaXQgZXhwZWN0ZWQnKTtcbiAgICB9LFxuXG4gICAgJ1VuaXQsIHN0cmluZyB8IFVuaXQnOiBmdW5jdGlvbiAodW5pdCwgdmFsdWVsZXNzVW5pdCkge1xuICAgICAgcmV0dXJuIHVuaXQudG9OdW1iZXIodmFsdWVsZXNzVW5pdCk7XG4gICAgfSxcblxuICAgICdBcnJheSB8IE1hdHJpeCc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZGVlcE1hcCh4LCBudW1iZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgbnVtYmVyLnRvVGV4ID0ge1xuICAgIDA6ICcwJyxcbiAgICAxOiAnXFxcXGxlZnQoJHthcmdzWzBdfVxcXFxyaWdodCknLFxuICAgIDI6ICdcXFxcbGVmdChcXFxcbGVmdCgke2FyZ3NbMF19XFxcXHJpZ2h0KSR7YXJnc1sxXX1cXFxccmlnaHQpJ1xuICB9O1xuXG4gIHJldHVybiBudW1iZXI7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdudW1iZXInO1xuZXhwb3J0cy5mYWN0b3J5ID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZmFjdG9yeSAodHlwZSwgY29uZmlnLCBsb2FkLCB0eXBlZCkge1xuICAvKipcbiAgICogQSBSZXN1bHRTZXQgY29udGFpbnMgYSBsaXN0IG9yIHJlc3VsdHNcbiAgICogQGNsYXNzIFJlc3VsdFNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBlbnRyaWVzXG4gICAqIEBjb25zdHJ1Y3RvciBSZXN1bHRTZXRcbiAgICovXG4gIGZ1bmN0aW9uIFJlc3VsdFNldChlbnRyaWVzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3VsdFNldCkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggdHlwZSBpbmZvcm1hdGlvblxuICAgKi9cbiAgUmVzdWx0U2V0LnByb3RvdHlwZS50eXBlID0gJ1Jlc3VsdFNldCc7XG4gIFJlc3VsdFNldC5wcm90b3R5cGUuaXNSZXN1bHRTZXQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSB3aXRoIHJlc3VsdHMgaG9sZCBieSB0aGlzIFJlc3VsdFNldFxuICAgKiBAbWVtYmVyb2YgUmVzdWx0U2V0XG4gICAqIEByZXR1cm5zIHtBcnJheX0gZW50cmllc1xuICAgKi9cbiAgUmVzdWx0U2V0LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHJlc3VsdHMgb2YgdGhlIFJlc3VsdFNldFxuICAgKiBAbWVtYmVyb2YgUmVzdWx0U2V0XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZ1xuICAgKi9cbiAgUmVzdWx0U2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1snICsgdGhpcy5lbnRyaWVzLmpvaW4oJywgJykgKyAnXSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIFJlc3VsdFNldFxuICAgKiBAbWVtYmVyb2YgUmVzdWx0U2V0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBKU09OIG9iamVjdCBzdHJ1Y3R1cmVkIGFzOlxuICAgKiAgICAgICAgICAgICAgICAgICBge1wibWF0aGpzXCI6IFwiUmVzdWx0U2V0XCIsIFwiZW50cmllc1wiOiBbLi4uXX1gXG4gICAqL1xuICBSZXN1bHRTZXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0aGpzOiAnUmVzdWx0U2V0JyxcbiAgICAgIGVudHJpZXM6IHRoaXMuZW50cmllc1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGEgUmVzdWx0U2V0IGZyb20gYSBKU09OIG9iamVjdFxuICAgKiBAbWVtYmVyb2YgUmVzdWx0U2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uICBBIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICBge1wibWF0aGpzXCI6IFwiUmVzdWx0U2V0XCIsIFwiZW50cmllc1wiOiBbLi4uXX1gXG4gICAqIEByZXR1cm4ge1Jlc3VsdFNldH1cbiAgICovXG4gIFJlc3VsdFNldC5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBSZXN1bHRTZXQoanNvbi5lbnRyaWVzKTtcbiAgfTtcblxuICByZXR1cm4gUmVzdWx0U2V0O1xufVxuXG5leHBvcnRzLm5hbWUgPSAnUmVzdWx0U2V0JztcbmV4cG9ydHMucGF0aCA9ICd0eXBlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmRzV2l0aCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3N0cmluZycpLmVuZHNXaXRoO1xudmFyIGNsb25lID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JykuY2xvbmU7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYmlnbnVtYmVyL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBmYWN0b3J5ICh0eXBlLCBjb25maWcsIGxvYWQsIHR5cGVkLCBtYXRoKSB7XG4gIHZhciBhZGQgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWRkU2NhbGFyJykpO1xuICB2YXIgc3VidHJhY3QgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9hcml0aG1ldGljL3N1YnRyYWN0JykpO1xuICB2YXIgbXVsdGlwbHkgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9hcml0aG1ldGljL211bHRpcGx5U2NhbGFyJykpO1xuICB2YXIgZGl2aWRlICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9hcml0aG1ldGljL2RpdmlkZVNjYWxhcicpKTtcbiAgdmFyIHBvdyAgICAgICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vYXJpdGhtZXRpYy9wb3cnKSk7XG4gIHZhciBhYnMgICAgICAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL2Z1bmN0aW9uL2FyaXRobWV0aWMvYWJzJykpO1xuICB2YXIgZml4ICAgICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9hcml0aG1ldGljL2ZpeCcpKTtcbiAgdmFyIGVxdWFsICAgICA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vcmVsYXRpb25hbC9lcXVhbCcpKTtcbiAgdmFyIGlzTnVtZXJpYyA9IGxvYWQocmVxdWlyZSgnLi4vLi4vZnVuY3Rpb24vdXRpbHMvaXNOdW1lcmljJykpO1xuICB2YXIgZm9ybWF0ICAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi9zdHJpbmcvZm9ybWF0JykpO1xuICB2YXIgZ2V0VHlwZU9mID0gbG9hZChyZXF1aXJlKCcuLi8uLi9mdW5jdGlvbi91dGlscy90eXBlb2YnKSk7XG4gIHZhciB0b051bWJlciAgPSBsb2FkKHJlcXVpcmUoJy4uLy4uL3R5cGUvbnVtYmVyJykpO1xuICB2YXIgQ29tcGxleCAgID0gbG9hZChyZXF1aXJlKCcuLi8uLi90eXBlL2NvbXBsZXgvQ29tcGxleCcpKTtcblxuICAvKipcbiAgICogQSB1bml0IGNhbiBiZSBjb25zdHJ1Y3RlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gICAqICAgICB2YXIgYSA9IG5ldyBVbml0KHZhbHVlLCBuYW1lKTtcbiAgICogICAgIHZhciBiID0gbmV3IFVuaXQobnVsbCwgbmFtZSk7XG4gICAqICAgICB2YXIgYyA9IFVuaXQucGFyc2Uoc3RyKTtcbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICogICAgIHZhciBhID0gbmV3IFVuaXQoNSwgJ2NtJyk7ICAgICAgICAgICAgICAgLy8gNTAgbW1cbiAgICogICAgIHZhciBiID0gVW5pdC5wYXJzZSgnMjMga2cnKTsgICAgICAgICAgICAgLy8gMjMga2dcbiAgICogICAgIHZhciBjID0gbWF0aC5pbihhLCBuZXcgVW5pdChudWxsLCAnbScpOyAgLy8gMC4wNSBtXG4gICAqICAgICB2YXIgZCA9IG5ldyBVbml0KDkuODEsIFwibS9zXjJcIik7ICAgICAgICAgLy8gOS44MSBtL3NeMlxuICAgKlxuICAgKiBAY2xhc3MgVW5pdFxuICAgKiBAY29uc3RydWN0b3IgVW5pdFxuICAgKiBAcGFyYW0ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgQ29tcGxleCB8IGJvb2xlYW59IFt2YWx1ZV0gIEEgdmFsdWUgbGlrZSA1LjJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAgIEEgdW5pdCBuYW1lIGxpa2UgXCJjbVwiIG9yIFwiaW5jaFwiLCBvciBhIGRlcml2ZWQgdW5pdCBvZiB0aGUgZm9ybTogXCJ1MVteZXgxXSBbdTJbXmV4Ml0gLi4uXSBbLyB1M1teZXgzXSBbdTRbXmV4NF1dXVwiLCBzdWNoIGFzIFwia2cgbV4yL3NeMlwiLCB3aGVyZSBlYWNoIHVuaXQgYXBwZWFyaW5nIGFmdGVyIHRoZSBmb3J3YXJkIHNsYXNoIGlzIHRha2VuIHRvIGJlIGluIHRoZSBkZW5vbWluYXRvci4gXCJrZyBtXjIgc14tMlwiIGlzIGEgc3lub255bSBhbmQgaXMgYWxzbyBhY2NlcHRhYmxlLiBBbnkgb2YgdGhlIHVuaXRzIGNhbiBpbmNsdWRlIGEgcHJlZml4LlxuICAgKi9cbiAgZnVuY3Rpb24gVW5pdCh2YWx1ZSwgbmFtZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVbml0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICBpZiAoISh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzTnVtZXJpYyh2YWx1ZSkgfHwgdmFsdWUuaXNDb21wbGV4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgcGFyYW1ldGVyIGluIFVuaXQgY29uc3RydWN0b3IgbXVzdCBiZSBudW1iZXIsIEJpZ051bWJlciwgRnJhY3Rpb24sIENvbXBsZXgsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAobmFtZSAhPSB1bmRlZmluZWQgJiYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lID09ICcnKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2Vjb25kIHBhcmFtZXRlciBpbiBVbml0IGNvbnN0cnVjdG9yIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB1ID0gVW5pdC5wYXJzZShuYW1lKTtcbiAgICAgIHRoaXMudW5pdHMgPSB1LnVuaXRzO1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gdS5kaW1lbnNpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudW5pdHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB1bml0OiBVTklUX05PTkUsXG4gICAgICAgICAgcHJlZml4OiBQUkVGSVhFUy5OT05FLCAgLy8gbGluayB0byBhIGxpc3Qgd2l0aCBzdXBwb3J0ZWQgcHJlZml4ZXNcbiAgICAgICAgICBwb3dlcjogMFxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gW107IFxuICAgICAgZm9yKHZhciBpPTA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9ICh2YWx1ZSAhPSB1bmRlZmluZWQpID8gdGhpcy5fbm9ybWFsaXplKHZhbHVlKSA6IG51bGw7XG5cbiAgICB0aGlzLmZpeFByZWZpeCA9IGZhbHNlOyAvLyBpZiB0cnVlLCBmdW5jdGlvbiBmb3JtYXQgd2lsbCBub3Qgc2VhcmNoIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZXN0IHByZWZpeCBidXQgbGVhdmUgaXQgYXMgaW5pdGlhbGx5IHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeFByZWZpeCBpcyBzZXQgdHJ1ZSBieSB0aGUgbWV0aG9kIFVuaXQudG9cblxuICAgIC8vIFRoZSBqdXN0aWZpY2F0aW9uIGJlaGluZCB0aGlzIGlzIHRoYXQgaWYgdGhlIGNvbnN0cnVjdG9yIGlzIGV4cGxpY2l0bHkgY2FsbGVkLFxuICAgIC8vIHRoZSBjYWxsZXIgd2lzaGVzIHRoZSB1bml0cyB0byBiZSByZXR1cm5lZCBleGFjdGx5IGFzIGhlIHN1cHBsaWVkLlxuICAgIHRoaXMuaXNVbml0TGlzdFNpbXBsaWZpZWQgPSB0cnVlO1xuXG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHR5cGUgaW5mb3JtYXRpb25cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnR5cGUgPSAnVW5pdCc7XG4gIFVuaXQucHJvdG90eXBlLmlzVW5pdCA9IHRydWU7XG5cbiAgLy8gcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlIFVuaXQgcGFyc2VyXG4gIHZhciB0ZXh0LCBpbmRleCwgYztcblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAoYyA9PSAnICcgfHwgYyA9PSAnXFx0Jykge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGlnaXREb3QoYykge1xuICAgIHJldHVybiAoKGMgPj0gJzAnICYmIGMgPD0gJzknKSB8fCBjID09ICcuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RpZ2l0KGMpIHtcbiAgICByZXR1cm4gKChjID49ICcwJyAmJiBjIDw9ICc5JykpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpbmRleCsrO1xuICAgIGMgPSB0ZXh0LmNoYXJBdChpbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnQob2xkSW5kZXgpIHtcbiAgICBpbmRleCA9IG9sZEluZGV4O1xuICAgIGMgPSB0ZXh0LmNoYXJBdChpbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU51bWJlcigpIHtcbiAgICB2YXIgbnVtYmVyID0gJyc7XG4gICAgdmFyIG9sZEluZGV4O1xuICAgIG9sZEluZGV4ID0gaW5kZXg7XG5cbiAgICBpZiAoYyA9PSAnKycpIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYyA9PSAnLScpIHtcbiAgICAgIG51bWJlciArPSBjO1xuICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIGlmICghaXNEaWdpdERvdChjKSkge1xuICAgICAgLy8gYSArIG9yIC0gbXVzdCBiZSBmb2xsb3dlZCBieSBhIGRpZ2l0XG4gICAgICByZXZlcnQob2xkSW5kZXgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG51bWJlciwgY2FuIGhhdmUgYSBzaW5nbGUgZG90XG4gICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICAgIGlmICghaXNEaWdpdChjKSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vIGxlZ2FsIG51bWJlciwgaXQgaXMganVzdCBhIGRvdFxuICAgICAgICByZXZlcnQob2xkSW5kZXgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgICBudW1iZXIgKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICAgIG51bWJlciArPSBjO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpc0RpZ2l0KGMpKSB7XG4gICAgICBudW1iZXIgKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZXhwb25lbnRpYWwgbm90YXRpb24gbGlrZSBcIjIuM2UtNFwiIG9yIFwiMS4yM2U1MFwiXG4gICAgaWYgKGMgPT0gJ0UnIHx8IGMgPT0gJ2UnKSB7XG4gICAgICAvLyBUaGUgZ3JhbW1hciBicmFuY2hlcyBoZXJlLiBUaGlzIGNvdWxkIGVpdGhlciBiZSBwYXJ0IG9mIGFuIGV4cG9uZW50IG9yIHRoZSBzdGFydCBvZiBhIHVuaXQgdGhhdCBiZWdpbnMgd2l0aCB0aGUgbGV0dGVyIGUsIHN1Y2ggYXMgXCI0ZXhhYnl0ZXNcIlxuXG4gICAgICB2YXIgdGVudGF0aXZlTnVtYmVyID0gJyc7XG4gICAgICB2YXIgdGVudGF0aXZlSW5kZXggPSBpbmRleDtcblxuICAgICAgdGVudGF0aXZlTnVtYmVyICs9IGM7XG4gICAgICBuZXh0KCk7XG5cbiAgICAgIGlmIChjID09ICcrJyB8fCBjID09ICctJykge1xuICAgICAgICB0ZW50YXRpdmVOdW1iZXIgKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTY2llbnRpZmljIG5vdGF0aW9uIE1VU1QgYmUgZm9sbG93ZWQgYnkgYW4gZXhwb25lbnQgKG90aGVyd2lzZSB3ZSBhc3N1bWUgaXQgaXMgbm90IHNjaWVudGlmaWMgbm90YXRpb24pXG4gICAgICBpZiAoIWlzRGlnaXQoYykpIHtcbiAgICAgICAgLy8gVGhlIGUgb3IgRSBtdXN0IGJlbG9uZyB0byBzb21ldGhpbmcgZWxzZSwgc28gcmV0dXJuIHRoZSBudW1iZXIgd2l0aG91dCB0aGUgZSBvciBFLlxuICAgICAgICByZXZlcnQodGVudGF0aXZlSW5kZXgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBXZSBjYW4gbm93IHNhZmVseSBzYXkgdGhhdCB0aGlzIGlzIHNjaWVudGlmaWMgbm90YXRpb24uXG4gICAgICBudW1iZXIgPSBudW1iZXIgKyB0ZW50YXRpdmVOdW1iZXI7XG4gICAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgICBudW1iZXIgKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVVuaXQoKSB7XG4gICAgdmFyIHVuaXROYW1lID0gJyc7XG5cbiAgICAvLyBBbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvbmx5OyBtYXRjaGVzIFthLXpBLVowLTldXG4gICAgdmFyIGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIHdoaWxlICggKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikpIHtcbiAgICAgIHVuaXROYW1lICs9IGM7XG4gICAgICBuZXh0KCk7XG4gICAgICBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBNdXN0IGJlZ2luIHdpdGggW2EtekEtWl1cbiAgICBjb2RlID0gdW5pdE5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpKSB7XG4gICAgICAgIHJldHVybiB1bml0TmFtZSB8fCBudWxsO1xuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNoYXJhY3Rlcih0b0ZpbmQpIHtcbiAgICBpZiAoYyA9PT0gdG9GaW5kKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gdG9GaW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGEgdW5pdC4gVGhlIHZhbHVlIG9mIHRoZSB1bml0IGlzIHBhcnNlZCBhcyBudW1iZXIsXG4gICAqIEJpZ051bWJlciwgb3IgRnJhY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBtYXRoLmpzIGNvbmZpZyBzZXR0aW5nIGBudW1iZXJgLlxuICAgKlxuICAgKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBwcm92aWRlZCBzdHJpbmcgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHVuaXQgb3JcbiAgICogY2Fubm90IGJlIHBhcnNlZC5cbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAgICAgICAgQSBzdHJpbmcgbGlrZSBcIjUuMiBpbmNoXCIsIFwiNGUyIGNtL3NeMlwiXG4gICAqIEByZXR1cm4ge1VuaXR9IHVuaXRcbiAgICovXG4gIFVuaXQucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGV4dCA9IHN0cjtcbiAgICBpbmRleCA9IC0xO1xuICAgIGMgPSAnJztcblxuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgaW4gVW5pdC5wYXJzZSwgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgdmFyIHVuaXQgPSBuZXcgVW5pdCgpO1xuICAgIHVuaXQudW5pdHMgPSBbXTtcblxuICAgIC8vIEEgdW5pdCBzaG91bGQgZm9sbG93IHRoaXMgcGF0dGVybjpcbiAgICAvLyBbbnVtYmVyXXVuaXRbXm51bWJlcl0gW3VuaXRbXm51bWJlcl1dLi4uWy91bml0W15udW1iZXJdIFt1bml0W15udW1iZXJdXV1cblxuICAgIC8vIFJ1bGVzOlxuICAgIC8vIG51bWJlciBpcyBhbnkgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgIC8vIHVuaXQgaXMgYW55IGFscGhhbnVtZXJpYyBzdHJpbmcgYmVnaW5uaW5nIHdpdGggYW4gYWxwaGEuIFVuaXRzIHdpdGggbmFtZXMgbGlrZSBlMyBzaG91bGQgYmUgYXZvaWRlZCBiZWNhdXNlIHRoZXkgbG9vayBsaWtlIHRoZSBleHBvbmVudCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciFcbiAgICAvLyBUaGUgc3RyaW5nIG1heSBvcHRpb25hbGx5IGJlZ2luIHdpdGggYSBudW1iZXIuXG4gICAgLy8gRWFjaCB1bml0IG1heSBvcHRpb25hbGx5IGJlIGZvbGxvd2VkIGJ5IF5udW1iZXIuXG4gICAgLy8gV2hpdGVzcGFjZSBvciBhIGZvcndhcmQgc2xhc2ggaXMgcmVjb21tZW5kZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSB1bml0cywgYWx0aG91Z2ggdGhlIGZvbGxvd2luZyB0ZWNobmljYWxseSBpcyBwYXJzZWFibGU6XG4gICAgLy8gICAybV4ya2cvc14yXG4gICAgLy8gaXQgaXMgbm90IGdvb2QgZm9ybS4gSWYgYSB1bml0IHN0YXJ0cyB3aXRoIGUsIHRoZW4gaXQgY291bGQgYmUgY29uZnVzZWQgYXMgYSBmbG9hdGluZyBwb2ludCBudW1iZXI6XG4gICAgLy8gICA0ZXJnXG5cbiAgICBuZXh0KCk7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAvLyBPcHRpb25hbCBudW1iZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzdHJpbmdcbiAgICB2YXIgdmFsdWVTdHIgPSBwYXJzZU51bWJlcigpO1xuICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgaWYodmFsdWVTdHIpIHtcbiAgICAgIGlmIChjb25maWcubnVtYmVyID09PSAnQmlnTnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IG5ldyB0eXBlLkJpZ051bWJlcih2YWx1ZVN0cik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb25maWcubnVtYmVyID09PSAnRnJhY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IHR5cGUuRnJhY3Rpb24odmFsdWVTdHIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIG51bWJlclxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWVTdHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBza2lwV2hpdGVzcGFjZSgpOyAgICAvLyBXaGl0ZXNwYWNlIGlzIG5vdCByZXF1aXJlZCBoZXJlXG5cbiAgICAvLyBOZXh0LCB3ZSByZWFkIGFueSBudW1iZXIgb2YgdW5pdFtebnVtYmVyXVxuICAgIHZhciBwb3dlck11bHRpcGxpZXJDdXJyZW50ID0gMTtcbiAgICB2YXIgZXhwZWN0aW5nVW5pdCA9IGZhbHNlO1xuXG4gICAgLy8gU3RhY2sgdG8ga2VlcCB0cmFjayBvZiBwb3dlck11bHRpcGxpZXJzIGFwcGxpZWQgdG8gZWFjaCBwYXJlbnRoZXNlcyBncm91cFxuICAgIHZhciBwb3dlck11bHRpcGxpZXJTdGFjayA9IFtdO1xuXG4gICAgLy8gUnVubmluZyBwcm9kdWN0IG9mIGFsbCBlbGVtZW50cyBpbiBwb3dlck11bHRpcGxpZXJTdGFja1xuICAgIHZhciBwb3dlck11bHRpcGxpZXJTdGFja1Byb2R1Y3QgPSAxO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBhbmQgY29uc3VtZSBvcGVuaW5nIHBhcmVudGhlc2VzLCBwdXNoaW5nIHBvd2VyTXVsdGlwbGllckN1cnJlbnQgdG8gdGhlIHN0YWNrXG4gICAgICAvLyBBICcoJyB3aWxsIGFsd2F5cyBhcHBlYXIgZGlyZWN0bHkgYmVmb3JlIGEgdW5pdC5cbiAgICAgIHdoaWxlIChjID09PSAnKCcpIHtcbiAgICAgICAgcG93ZXJNdWx0aXBsaWVyU3RhY2sucHVzaChwb3dlck11bHRpcGxpZXJDdXJyZW50KTtcbiAgICAgICAgcG93ZXJNdWx0aXBsaWVyU3RhY2tQcm9kdWN0ICo9IHBvd2VyTXVsdGlwbGllckN1cnJlbnQ7XG4gICAgICAgIHBvd2VyTXVsdGlwbGllckN1cnJlbnQgPSAxO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZXJlIHNvbWV0aGluZyBoZXJlP1xuICAgICAgaWYoYykge1xuICAgICAgICB2YXIgb2xkQyA9IGM7XG4gICAgICAgIHZhciB1U3RyID0gcGFyc2VVbml0KCk7XG4gICAgICAgIGlmKHVTdHIgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBcIicgKyBvbGRDICsgJ1wiIGluIFwiJyArIHRleHQgKyAnXCIgYXQgaW5kZXggJyArIGluZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gRW5kIG9mIGlucHV0LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHRoZSB1bml0IGV4aXN0cyBhbmQgZ2V0IHRoZSBwcmVmaXggKGlmIGFueSlcbiAgICAgIHZhciByZXMgPSBfZmluZFVuaXQodVN0cik7XG4gICAgICBpZihyZXMgPT0gbnVsbCkge1xuICAgICAgICAvLyBVbml0IG5vdCBmb3VuZC5cbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbml0IFwiJyArIHVTdHIgKyAnXCIgbm90IGZvdW5kLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG93ZXIgPSBwb3dlck11bHRpcGxpZXJDdXJyZW50ICogcG93ZXJNdWx0aXBsaWVyU3RhY2tQcm9kdWN0O1xuICAgICAgLy8gSXMgdGhlcmUgYSBcIl4gbnVtYmVyXCI/XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgaWYgKHBhcnNlQ2hhcmFjdGVyKCdeJykpIHtcbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgdmFyIHAgPSBwYXJzZU51bWJlcigpO1xuICAgICAgICBpZihwID09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyB2YWxpZCBudW1iZXIgZm91bmQgZm9yIHRoZSBwb3dlciFcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0luIFwiJyArIHN0ciArICdcIiwgXCJeXCIgbXVzdCBiZSBmb2xsb3dlZCBieSBhIGZsb2F0aW5nLXBvaW50IG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHBvd2VyICo9IHA7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgdW5pdCB0byB0aGUgbGlzdFxuICAgICAgdW5pdC51bml0cy5wdXNoKCB7XG4gICAgICAgIHVuaXQ6IHJlcy51bml0LFxuICAgICAgICBwcmVmaXg6IHJlcy5wcmVmaXgsXG4gICAgICAgIHBvd2VyOiBwb3dlclxuICAgICAgfSk7XG4gICAgICBmb3IodmFyIGk9MDsgaTxCQVNFX0RJTUVOU0lPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdW5pdC5kaW1lbnNpb25zW2ldICs9IChyZXMudW5pdC5kaW1lbnNpb25zW2ldIHx8IDApICogcG93ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBhbmQgY29uc3VtZSBjbG9zaW5nIHBhcmVudGhlc2VzLCBwb3BwaW5nIGZyb20gdGhlIHN0YWNrLlxuICAgICAgLy8gQSAnKScgd2lsbCBhbHdheXMgZm9sbG93IGEgdW5pdC5cbiAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICB3aGlsZSAoYyA9PT0gJyknKSB7XG4gICAgICAgIGlmKHBvd2VyTXVsdGlwbGllclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5tYXRjaGVkIFwiKVwiIGluIFwiJyArIHRleHQgKyAnXCIgYXQgaW5kZXggJyArIGluZGV4LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvd2VyTXVsdGlwbGllclN0YWNrUHJvZHVjdCAvPSBwb3dlck11bHRpcGxpZXJTdGFjay5wb3AoKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBcIipcIiBhbmQgXCIvXCIgc2hvdWxkIG1lYW4gd2UgYXJlIGV4cGVjdGluZyBzb21ldGhpbmcgdG8gY29tZSBuZXh0LlxuICAgICAgLy8gSXMgdGhlcmUgYSBmb3J3YXJkIHNsYXNoPyBJZiBzbywgbmVnYXRlIHBvd2VyTXVsdGlwbGllckN1cnJlbnQuIFRoZSBuZXh0IHVuaXQgb3IgcGFyZW4gZ3JvdXAgaXMgaW4gdGhlIGRlbm9taW5hdG9yLlxuICAgICAgZXhwZWN0aW5nVW5pdCA9IGZhbHNlO1xuXG4gICAgICBpZiAocGFyc2VDaGFyYWN0ZXIoJyonKSkge1xuICAgICAgICAvLyBleHBsaWNpdCBtdWx0aXBsaWNhdGlvblxuICAgICAgICBwb3dlck11bHRpcGxpZXJDdXJyZW50ID0gMTtcbiAgICAgICAgZXhwZWN0aW5nVW5pdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwYXJzZUNoYXJhY3RlcignLycpKSB7XG4gICAgICAgIC8vIGRpdmlzaW9uXG4gICAgICAgIHBvd2VyTXVsdGlwbGllckN1cnJlbnQgPSAtMTtcbiAgICAgICAgZXhwZWN0aW5nVW5pdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1wbGljaXQgbXVsdGlwbGljYXRpb25cbiAgICAgICAgcG93ZXJNdWx0aXBsaWVyQ3VycmVudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgdGhlIHVuaXQgaW50byB0aGUgYXV0byB1bml0IHN5c3RlbVxuICAgICAgaWYocmVzLnVuaXQuYmFzZSkge1xuICAgICAgICB2YXIgYmFzZURpbSA9IHJlcy51bml0LmJhc2Uua2V5O1xuICAgICAgICBVTklUX1NZU1RFTVMuYXV0b1tiYXNlRGltXSA9IHtcbiAgICAgICAgICB1bml0OiByZXMudW5pdCxcbiAgICAgICAgICBwcmVmaXg6IHJlcy5wcmVmaXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFzIHRoZSBzdHJpbmcgYmVlbiBlbnRpcmVseSBjb25zdW1lZD9cbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGlmKGMpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ291bGQgbm90IHBhcnNlOiBcIicgKyBzdHIgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGVyZSBhIHRyYWlsaW5nIHNsYXNoP1xuICAgIGlmKGV4cGVjdGluZ1VuaXQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVHJhaWxpbmcgY2hhcmFjdGVyczogXCInICsgc3RyICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhlIHBhcmVudGhlc2VzIHN0YWNrIGVtcHR5P1xuICAgIGlmKHBvd2VyTXVsdGlwbGllclN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbm1hdGNoZWQgXCIoXCIgaW4gXCInICsgdGV4dCArICdcIicpO1xuICAgIH1cblxuICAgIC8vIEFyZSB0aGVyZSBhbnkgdW5pdHMgYXQgYWxsP1xuICAgIGlmKHVuaXQudW5pdHMubGVuZ3RoID09IDAgJiYgIW9wdGlvbnMuYWxsb3dOb1VuaXRzKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1wiJyArIHN0ciArICdcIiBjb250YWlucyBubyB1bml0cycpO1xuICAgIH1cblxuICAgIHVuaXQudmFsdWUgPSAodmFsdWUgIT0gdW5kZWZpbmVkKSA/IHVuaXQuX25vcm1hbGl6ZSh2YWx1ZSkgOiBudWxsO1xuICAgIHJldHVybiB1bml0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBjb3B5IG9mIHRoaXMgdW5pdFxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcmV0dXJuIHtVbml0fSBSZXR1cm5zIGEgY2xvbmVkIHZlcnNpb24gb2YgdGhlIHVuaXRcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1bml0ID0gbmV3IFVuaXQoKTtcblxuICAgIHVuaXQuZml4UHJlZml4ID0gdGhpcy5maXhQcmVmaXg7XG4gICAgdW5pdC5pc1VuaXRMaXN0U2ltcGxpZmllZCA9IHRoaXMuaXNVbml0TGlzdFNpbXBsaWZpZWQ7XG5cbiAgICB1bml0LnZhbHVlID0gY2xvbmUodGhpcy52YWx1ZSk7XG4gICAgdW5pdC5kaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zLnNsaWNlKDApO1xuICAgIHVuaXQudW5pdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdW5pdC51bml0c1tpXSA9IHsgfTtcbiAgICAgIGZvciAodmFyIHAgaW4gdGhpcy51bml0c1tpXSkge1xuICAgICAgICBpZiAodGhpcy51bml0c1tpXS5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHVuaXQudW5pdHNbaV1bcF0gPSB0aGlzLnVuaXRzW2ldW3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSB1bml0IGlzIGRlcml2ZWQgKHN1Y2ggYXMgbS9zLCBvciBjbV4yLCBidXQgbm90IE4pXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHVuaXQgaXMgZGVyaXZlZFxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuX2lzRGVyaXZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVuaXRzLmxlbmd0aCA+IDEgfHwgTWF0aC5hYnModGhpcy51bml0c1swXS5wb3dlciAtIDEuMCkgPiAxZS0xNTtcbiAgfTtcblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgdmFsdWUsIGJhc2VkIG9uIGl0cyBjdXJyZW50bHkgc2V0IHVuaXQocylcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtudW1iZXIgfCBCaWdOdW1iZXIgfCBGcmFjdGlvbiB8IGJvb2xlYW59IHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9uIHwgYm9vbGVhbn0gbm9ybWFsaXplZCB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuX25vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciB1bml0VmFsdWUsIHVuaXRPZmZzZXQsIHVuaXRQb3dlciwgdW5pdFByZWZpeFZhbHVlO1xuICAgIHZhciBjb252ZXJ0O1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdGhpcy51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5faXNEZXJpdmVkKCkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBkZXJpdmVkIHVuaXQsIHNvIGRvIG5vdCBhcHBseSBvZmZzZXRzLlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIHdpdGggSiBrZ14tMSBkZWdDXi0xIHlvdSB3b3VsZCBOT1Qgd2FudCB0byBhcHBseSB0aGUgb2Zmc2V0LlxuICAgICAgdmFyIHJlcyA9IHZhbHVlO1xuICAgICAgY29udmVydCA9IFVuaXQuX2dldE51bWJlckNvbnZlcnRlcihnZXRUeXBlT2YodmFsdWUpKTsgLy8gY29udmVydCB0byBGcmFjdGlvbiBvciBCaWdOdW1iZXIgaWYgbmVlZGVkXG5cbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1bml0VmFsdWUgICAgICAgPSBjb252ZXJ0KHRoaXMudW5pdHNbaV0udW5pdC52YWx1ZSk7XG4gICAgICAgIHVuaXRQcmVmaXhWYWx1ZSA9IGNvbnZlcnQodGhpcy51bml0c1tpXS5wcmVmaXgudmFsdWUpO1xuICAgICAgICB1bml0UG93ZXIgICAgICAgPSBjb252ZXJ0KHRoaXMudW5pdHNbaV0ucG93ZXIpO1xuICAgICAgICByZXMgPSBtdWx0aXBseShyZXMsIHBvdyhtdWx0aXBseSh1bml0VmFsdWUsIHVuaXRQcmVmaXhWYWx1ZSksIHVuaXRQb3dlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgdW5pdCBvZiBwb3dlciAxLCBsaWtlIGtnIG9yIGRlZ0NcbiAgICAgIGNvbnZlcnQgPSBVbml0Ll9nZXROdW1iZXJDb252ZXJ0ZXIoZ2V0VHlwZU9mKHZhbHVlKSk7IC8vIGNvbnZlcnQgdG8gRnJhY3Rpb24gb3IgQmlnTnVtYmVyIGlmIG5lZWRlZFxuXG4gICAgICB1bml0VmFsdWUgICAgICAgPSBjb252ZXJ0KHRoaXMudW5pdHNbMF0udW5pdC52YWx1ZSk7XG4gICAgICB1bml0T2Zmc2V0ICAgICAgPSBjb252ZXJ0KHRoaXMudW5pdHNbMF0udW5pdC5vZmZzZXQpO1xuICAgICAgdW5pdFByZWZpeFZhbHVlID0gY29udmVydCh0aGlzLnVuaXRzWzBdLnByZWZpeC52YWx1ZSk7XG5cbiAgICAgIHJldHVybiBtdWx0aXBseShhZGQodmFsdWUsIHVuaXRPZmZzZXQpLCBtdWx0aXBseSh1bml0VmFsdWUsIHVuaXRQcmVmaXhWYWx1ZSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVub3JtYWxpemUgYSB2YWx1ZSwgYmFzZWQgb24gaXRzIGN1cnJlbnRseSBzZXQgdW5pdChzKVxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVmaXhWYWx1ZV0gICAgT3B0aW9uYWwgcHJlZml4IHZhbHVlIHRvIGJlIHVzZWQgKGlnbm9yZWQgaWYgdGhpcyBpcyBhIGRlcml2ZWQgdW5pdClcbiAgICogQHJldHVybiB7bnVtYmVyfSBkZW5vcm1hbGl6ZWQgdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLl9kZW5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZml4VmFsdWUpIHtcbiAgICB2YXIgdW5pdFZhbHVlLCB1bml0T2Zmc2V0LCB1bml0UG93ZXIsIHVuaXRQcmVmaXhWYWx1ZTtcbiAgICB2YXIgY29udmVydDtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHRoaXMudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX2lzRGVyaXZlZCgpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgZGVyaXZlZCB1bml0LCBzbyBkbyBub3QgYXBwbHkgb2Zmc2V0cy5cbiAgICAgIC8vIEZvciBleGFtcGxlLCB3aXRoIEoga2deLTEgZGVnQ14tMSB5b3Ugd291bGQgTk9UIHdhbnQgdG8gYXBwbHkgdGhlIG9mZnNldC5cbiAgICAgIC8vIEFsc28sIHByZWZpeFZhbHVlIGlzIGlnbm9yZWQtLWJ1dCB3ZSB3aWxsIHN0aWxsIHVzZSB0aGUgcHJlZml4IHZhbHVlIHN0b3JlZCBpbiBlYWNoIHVuaXQsIHNpbmNlIGtnIGlzIHVzdWFsbHkgcHJlZmVyYWJsZSB0byBnIHVubGVzcyB0aGUgdXNlciBkZWNpZGVzIG90aGVyd2lzZS5cbiAgICAgIHZhciByZXMgPSB2YWx1ZTtcbiAgICAgIGNvbnZlcnQgPSBVbml0Ll9nZXROdW1iZXJDb252ZXJ0ZXIoZ2V0VHlwZU9mKHZhbHVlKSk7IC8vIGNvbnZlcnQgdG8gRnJhY3Rpb24gb3IgQmlnTnVtYmVyIGlmIG5lZWRlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdW5pdFZhbHVlICAgICAgID0gY29udmVydCh0aGlzLnVuaXRzW2ldLnVuaXQudmFsdWUpO1xuICAgICAgICB1bml0UHJlZml4VmFsdWUgPSBjb252ZXJ0KHRoaXMudW5pdHNbaV0ucHJlZml4LnZhbHVlKTtcbiAgICAgICAgdW5pdFBvd2VyICAgICAgID0gY29udmVydCh0aGlzLnVuaXRzW2ldLnBvd2VyKTtcbiAgICAgICAgcmVzID0gZGl2aWRlKHJlcywgcG93KG11bHRpcGx5KHVuaXRWYWx1ZSwgdW5pdFByZWZpeFZhbHVlKSwgdW5pdFBvd2VyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSB1bml0IG9mIHBvd2VyIDEsIGxpa2Uga2cgb3IgZGVnQ1xuICAgICAgY29udmVydCA9IFVuaXQuX2dldE51bWJlckNvbnZlcnRlcihnZXRUeXBlT2YodmFsdWUpKTsgLy8gY29udmVydCB0byBGcmFjdGlvbiBvciBCaWdOdW1iZXIgaWYgbmVlZGVkXG5cbiAgICAgIHVuaXRWYWx1ZSAgICAgICA9IGNvbnZlcnQodGhpcy51bml0c1swXS51bml0LnZhbHVlKTtcbiAgICAgIHVuaXRQcmVmaXhWYWx1ZSA9IGNvbnZlcnQodGhpcy51bml0c1swXS5wcmVmaXgudmFsdWUpO1xuICAgICAgdW5pdE9mZnNldCAgICAgID0gY29udmVydCh0aGlzLnVuaXRzWzBdLnVuaXQub2Zmc2V0KTtcblxuICAgICAgaWYgKHByZWZpeFZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3VidHJhY3QoZGl2aWRlKGRpdmlkZSh2YWx1ZSwgdW5pdFZhbHVlKSwgdW5pdFByZWZpeFZhbHVlKSwgdW5pdE9mZnNldCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0KGRpdmlkZShkaXZpZGUodmFsdWUsIHVuaXRWYWx1ZSksIHByZWZpeFZhbHVlKSwgdW5pdE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGEgdW5pdCBmcm9tIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgICAgICAgICAgICAgIEEgc3RyaW5nIGxpa2UgJ2NtJyBvciAnaW5jaCdcbiAgICogQHJldHVybnMge09iamVjdCB8IG51bGx9IHJlc3VsdCAgV2hlbiBmb3VuZCwgYW4gb2JqZWN0IHdpdGggZmllbGRzIHVuaXQgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCBpcyByZXR1cm5lZC4gRWxzZSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9maW5kVW5pdChzdHIpIHtcbiAgXG4gICAgLy8gRmlyc3QsIG1hdGNoIHVuaXRzIG5hbWVzIGV4YWN0bHkuIEZvciBleGFtcGxlLCBhIHVzZXIgY291bGQgZGVmaW5lICdtbScgYXMgMTBeLTQgbSwgd2hpY2ggaXMgc2lsbHksIGJ1dCB0aGVuIHdlIHdvdWxkIHdhbnQgJ21tJyB0byBtYXRjaCB0aGUgdXNlci1kZWZpbmVkIHVuaXQuXG4gICAgaWYoVU5JVFMuaGFzT3duUHJvcGVydHkoc3RyKSkge1xuICAgICAgdmFyIHVuaXQgPSBVTklUU1tzdHJdO1xuICAgICAgdmFyIHByZWZpeCA9IHVuaXQucHJlZml4ZXNbJyddO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIFVOSVRTKSB7XG4gICAgICBpZiAoVU5JVFMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaWYgKGVuZHNXaXRoKHN0ciwgbmFtZSkpIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IFVOSVRTW25hbWVdO1xuICAgICAgICAgIHZhciBwcmVmaXhMZW4gPSAoc3RyLmxlbmd0aCAtIG5hbWUubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcHJlZml4TmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgcHJlZml4TGVuKTtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gdW5pdC5wcmVmaXhlc1twcmVmaXhOYW1lXTtcbiAgICAgICAgICBpZiAocHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHVuaXQsIHByZWZpeCwgYW5kIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnaXZlbiBleHByZXNzaW9uIGlzIGEgdW5pdC5cbiAgICogVGhlIHVuaXQgY2FuIGhhdmUgYSBwcmVmaXggYnV0IGNhbm5vdCBoYXZlIGEgdmFsdWUuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgQSBzdHJpbmcgdG8gYmUgdGVzdGVkIHdoZXRoZXIgaXQgaXMgYSB2YWx1ZSBsZXNzIHVuaXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHVuaXQgY2FuIGhhdmUgcHJlZml4LCBsaWtlIFwiY21cIlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHVuaXRcbiAgICovXG4gIFVuaXQuaXNWYWx1ZWxlc3NVbml0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gKF9maW5kVW5pdChuYW1lKSAhPSBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogY2hlY2sgaWYgdGhpcyB1bml0IGhhcyBnaXZlbiBiYXNlIHVuaXRcbiAgICogSWYgdGhpcyB1bml0IGlzIGEgZGVyaXZlZCB1bml0LCB0aGlzIHdpbGwgQUxXQVlTIHJldHVybiBmYWxzZSwgc2luY2UgYnkgZGVmaW5pdGlvbiBiYXNlIHVuaXRzIGFyZSBub3QgZGVyaXZlZC5cbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtCQVNFX1VOSVRTIHwgc3RyaW5nIHwgdW5kZWZpbmVkfSBiYXNlXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5oYXNCYXNlID0gZnVuY3Rpb24gKGJhc2UpIHtcblxuICAgIGlmKHR5cGVvZihiYXNlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYmFzZSA9IEJBU0VfVU5JVFNbYmFzZV07XG4gICAgfVxuXG4gICAgaWYoIWJhc2UpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cblxuICAgIC8vIEFsbCBkaW1lbnNpb25zIG11c3QgYmUgdGhlIHNhbWVcbiAgICBmb3IodmFyIGk9MDsgaTxCQVNFX0RJTUVOU0lPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChNYXRoLmFicygodGhpcy5kaW1lbnNpb25zW2ldIHx8IDApIC0gKGJhc2UuZGltZW5zaW9uc1tpXSB8fCAwKSkgPiAxZS0xMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgdW5pdCBoYXMgYSBiYXNlIG9yIGJhc2VzIGVxdWFsIHRvIGFub3RoZXIgYmFzZSBvciBiYXNlc1xuICAgKiBGb3IgZGVyaXZlZCB1bml0cywgdGhlIGV4cG9uZW50IG9uIGVhY2ggYmFzZSBhbHNvIG11c3QgbWF0Y2hcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtVbml0fSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGVxdWFsIGJhc2VcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLmVxdWFsQmFzZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIC8vIEFsbCBkaW1lbnNpb25zIG11c3QgYmUgdGhlIHNhbWVcbiAgICBmb3IodmFyIGk9MDsgaTxCQVNFX0RJTUVOU0lPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChNYXRoLmFicygodGhpcy5kaW1lbnNpb25zW2ldIHx8IDApIC0gKG90aGVyLmRpbWVuc2lvbnNbaV0gfHwgMCkpID4gMWUtMTIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyB1bml0IGVxdWFscyBhbm90aGVyIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtVbml0fSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGJvdGggdW5pdHMgYXJlIGVxdWFsXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gKHRoaXMuZXF1YWxCYXNlKG90aGVyKSAmJiBlcXVhbCh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGlzIHVuaXQgd2l0aCBhbm90aGVyIG9uZVxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge1VuaXR9IG90aGVyXG4gICAqIEByZXR1cm4ge1VuaXR9IHByb2R1Y3Qgb2YgdGhpcyB1bml0IGFuZCB0aGUgb3RoZXIgdW5pdFxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5jbG9uZSgpO1xuICAgIFxuICAgIGZvcih2YXIgaSA9IDA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBEaW1lbnNpb25zIGFycmF5cyBtYXkgYmUgb2YgZGlmZmVyZW50IGxlbmd0aHMuIERlZmF1bHQgdG8gMC5cbiAgICAgIHJlcy5kaW1lbnNpb25zW2ldID0gKHRoaXMuZGltZW5zaW9uc1tpXSB8fCAwKSArIChvdGhlci5kaW1lbnNpb25zW2ldIHx8IDApO1xuICAgIH1cblxuICAgIC8vIEFwcGVuZCBvdGhlcidzIHVuaXRzIGxpc3Qgb250byByZXMgKHNpbXBsaWZ5IGxhdGVyIGluIFVuaXQucHJvdG90eXBlLmZvcm1hdClcbiAgICBmb3IodmFyIGk9MDsgaTxvdGhlci51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTWFrZSBhIGRlZXAgY29weVxuICAgICAgdmFyIGludmVydGVkID0ge307XG4gICAgICBmb3IodmFyIGtleSBpbiBvdGhlci51bml0c1tpXSkge1xuICAgICAgICBpbnZlcnRlZFtrZXldID0gb3RoZXIudW5pdHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICAgIHJlcy51bml0cy5wdXNoKGludmVydGVkKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhdCBsZWFzdCBvbmUgb3BlcmFuZCBoYXMgYSB2YWx1ZSwgdGhlbiB0aGUgcmVzdWx0IHNob3VsZCBhbHNvIGhhdmUgYSB2YWx1ZVxuICAgIGlmKHRoaXMudmFsdWUgIT0gbnVsbCB8fCBvdGhlci52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgdmFsVGhpcyA9IHRoaXMudmFsdWUgPT0gbnVsbCA/IHRoaXMuX25vcm1hbGl6ZSgxKSA6IHRoaXMudmFsdWU7XG4gICAgICB2YXIgdmFsT3RoZXIgPSBvdGhlci52YWx1ZSA9PSBudWxsID8gb3RoZXIuX25vcm1hbGl6ZSgxKSA6IG90aGVyLnZhbHVlO1xuICAgICAgcmVzLnZhbHVlID0gbXVsdGlwbHkodmFsVGhpcywgdmFsT3RoZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBzaW1wbGlmaWNhdGlvbiBvZiB0aGUgdW5pdCBsaXN0IGF0IHNvbWUgZnV0dXJlIHRpbWVcbiAgICByZXMuaXNVbml0TGlzdFNpbXBsaWZpZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBnZXROdW1lcmljSWZVbml0bGVzcyhyZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXZpZGUgdGhpcyB1bml0IGJ5IGFub3RoZXIgb25lXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7VW5pdH0gb3RoZXJcbiAgICogQHJldHVybiB7VW5pdH0gcmVzdWx0IG9mIGRpdmlkaW5nIHRoaXMgdW5pdCBieSB0aGUgb3RoZXIgdW5pdFxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuY2xvbmUoKTtcbiAgICBcbiAgICBmb3IodmFyIGk9MDsgaTxCQVNFX0RJTUVOU0lPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIERpbWVuc2lvbnMgYXJyYXlzIG1heSBiZSBvZiBkaWZmZXJlbnQgbGVuZ3Rocy4gRGVmYXVsdCB0byAwLlxuICAgICAgcmVzLmRpbWVuc2lvbnNbaV0gPSAodGhpcy5kaW1lbnNpb25zW2ldIHx8IDApIC0gKG90aGVyLmRpbWVuc2lvbnNbaV0gfHwgMCk7XG4gICAgfVxuXG4gICAgLy8gSW52ZXJ0IGFuZCBhcHBlbmQgb3RoZXIncyB1bml0cyBsaXN0IG9udG8gcmVzIChzaW1wbGlmeSBsYXRlciBpbiBVbml0LnByb3RvdHlwZS5mb3JtYXQpXG4gICAgZm9yKHZhciBpPTA7IGk8b3RoZXIudW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE1ha2UgYSBkZWVwIGNvcHlcbiAgICAgIHZhciBpbnZlcnRlZCA9IHt9O1xuICAgICAgZm9yKHZhciBrZXkgaW4gb3RoZXIudW5pdHNbaV0pIHtcbiAgICAgICAgaW52ZXJ0ZWRba2V5XSA9IG90aGVyLnVuaXRzW2ldW2tleV07XG4gICAgICB9XG4gICAgICBpbnZlcnRlZC5wb3dlciA9IC1pbnZlcnRlZC5wb3dlcjtcbiAgICAgIHJlcy51bml0cy5wdXNoKGludmVydGVkKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhdCBsZWFzdCBvbmUgb3BlcmFuZCBoYXMgYSB2YWx1ZSwgdGhlIHJlc3VsdCBzaG91bGQgaGF2ZSBhIHZhbHVlXG4gICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCB8fCBvdGhlci52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgdmFsVGhpcyA9IHRoaXMudmFsdWUgPT0gbnVsbCA/IHRoaXMuX25vcm1hbGl6ZSgxKSA6IHRoaXMudmFsdWU7XG4gICAgICB2YXIgdmFsT3RoZXIgPSBvdGhlci52YWx1ZSA9PSBudWxsID8gb3RoZXIuX25vcm1hbGl6ZSgxKSA6IG90aGVyLnZhbHVlO1xuICAgICAgcmVzLnZhbHVlID0gZGl2aWRlKHZhbFRoaXMsIHZhbE90aGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXMudmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgc2ltcGxpZmljYXRpb24gb2YgdGhlIHVuaXQgbGlzdCBhdCBzb21lIGZ1dHVyZSB0aW1lXG4gICAgcmVzLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZ2V0TnVtZXJpY0lmVW5pdGxlc3MocmVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBwb3dlciBvZiBhIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtudW1iZXIgfCBGcmFjdGlvbiB8IEJpZ051bWJlcn0gcFxuICAgKiBAcmV0dXJucyB7VW5pdH0gICAgICBUaGUgcmVzdWx0OiB0aGlzXnBcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuY2xvbmUoKTtcbiAgICBcbiAgICBmb3IodmFyIGk9MDsgaTxCQVNFX0RJTUVOU0lPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIERpbWVuc2lvbnMgYXJyYXlzIG1heSBiZSBvZiBkaWZmZXJlbnQgbGVuZ3Rocy4gRGVmYXVsdCB0byAwLlxuICAgICAgcmVzLmRpbWVuc2lvbnNbaV0gPSAodGhpcy5kaW1lbnNpb25zW2ldIHx8IDApICogcDtcbiAgICB9XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvd2VyIG9mIGVhY2ggdW5pdCBpbiB0aGUgbGlzdFxuICAgIGZvcih2YXIgaT0wOyBpPHJlcy51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzLnVuaXRzW2ldLnBvd2VyICo9IHA7XG4gICAgfVxuXG4gICAgaWYocmVzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlcy52YWx1ZSA9IHBvdyhyZXMudmFsdWUsIHApO1xuXG4gICAgICAvLyBvbmx5IGFsbG93IG51bWVyaWMgb3V0cHV0LCB3ZSBkb24ndCB3YW50IHRvIHJldHVybiBhIENvbXBsZXggbnVtYmVyXG4gICAgICAvL2lmICghaXNOdW1lcmljKHJlcy52YWx1ZSkpIHtcbiAgICAgIC8vICByZXMudmFsdWUgPSBOYU47XG4gICAgICAvL31cbiAgICAgIC8vIFVwZGF0ZTogQ29tcGxleCBzdXBwb3J0ZWQgbm93XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzLnZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyIGxhenkgZXZhbHVhdGlvbiBvZiB0aGUgdW5pdCBsaXN0XG4gICAgcmVzLmlzVW5pdExpc3RTaW1wbGlmaWVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZ2V0TnVtZXJpY0lmVW5pdGxlc3MocmVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBudW1lcmljIHZhbHVlIG9mIHRoaXMgdW5pdCBpZiBpdCBpcyBkaW1lbnNpb25sZXNzLCBoYXMgYSB2YWx1ZSwgYW5kIGNvbmZpZy5wcmVkaWN0YWJsZSA9PSBmYWxzZTsgb3IgdGhlIG9yaWdpbmFsIHVuaXQgb3RoZXJ3aXNlXG4gICAqIEBwYXJhbSB7VW5pdH0gdW5pdFxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXIgfCBVbml0fSAgVGhlIG51bWVyaWMgdmFsdWUgb2YgdGhlIHVuaXQgaWYgY29uZGl0aW9ucyBhcmUgbWV0LCBvciB0aGUgb3JpZ2luYWwgdW5pdCBvdGhlcndpc2VcbiAgICovXG4gIHZhciBnZXROdW1lcmljSWZVbml0bGVzcyA9IGZ1bmN0aW9uKHVuaXQpIHtcbiAgICBpZih1bml0LmVxdWFsQmFzZShCQVNFX1VOSVRTLk5PTkUpICYmIHVuaXQudmFsdWUgIT09IG51bGwgJiYgIWNvbmZpZy5wcmVkaWN0YWJsZSkge1xuICAgICAgcmV0dXJuIHVuaXQudmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gICAgXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSB1bml0XG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgRnJhY3Rpb24gfCBCaWdOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge1VuaXR9ICAgICAgVGhlIHJlc3VsdDogfHh8LCBhYnNvbHV0ZSB2YWx1ZSBvZiB4XG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBnaXZlcyBjb3JyZWN0LCBidXQgdW5leHBlY3RlZCwgcmVzdWx0cyBmb3IgdW5pdHMgd2l0aCBhbiBvZmZzZXQuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGFicygtMjgzLjE1IGRlZ0MpID0gLTI2My4xNSBkZWdDICEhIVxuICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgcmV0LnZhbHVlID0gYWJzKHJldC52YWx1ZSk7XG5cbiAgICBmb3IodmFyIGkgaW4gcmV0LnVuaXRzKSB7XG4gICAgICBpZihyZXQudW5pdHNbaV0udW5pdC5uYW1lID09PSAnVkEnIHx8IHJldC51bml0c1tpXS51bml0Lm5hbWUgPT09ICdWQVInKSB7XG4gICAgICAgIHJldC51bml0c1tpXS51bml0ID0gVU5JVFNbXCJXXCJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHVuaXQgdG8gYSBzcGVjaWZpYyB1bml0IG5hbWUuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVW5pdH0gdmFsdWVsZXNzVW5pdCAgIEEgdW5pdCB3aXRob3V0IHZhbHVlLiBDYW4gaGF2ZSBwcmVmaXgsIGxpa2UgXCJjbVwiXG4gICAqIEByZXR1cm5zIHtVbml0fSBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHVuaXQgd2l0aCBhIGZpeGVkIHByZWZpeCBhbmQgdW5pdC5cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHZhbHVlbGVzc1VuaXQpIHtcbiAgICB2YXIgb3RoZXI7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSA9PSBudWxsID8gdGhpcy5fbm9ybWFsaXplKDEpIDogdGhpcy52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlbGVzc1VuaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvL290aGVyID0gbmV3IFVuaXQobnVsbCwgdmFsdWVsZXNzVW5pdCk7XG4gICAgICBvdGhlciA9IFVuaXQucGFyc2UodmFsdWVsZXNzVW5pdCk7XG4gICAgICBpZiAoIXRoaXMuZXF1YWxCYXNlKG90aGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaXRzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgdG8gYSB1bml0IHdpdGggYSB2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBvdGhlci52YWx1ZSA9IGNsb25lKHZhbHVlKTtcbiAgICAgIG90aGVyLmZpeFByZWZpeCA9IHRydWU7XG4gICAgICBvdGhlci5pc1VuaXRMaXN0U2ltcGxpZmllZCA9IHRydWU7XG4gICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlbGVzc1VuaXQgJiYgdmFsdWVsZXNzVW5pdC5pc1VuaXQpIHtcbiAgICAgIGlmICghdGhpcy5lcXVhbEJhc2UodmFsdWVsZXNzVW5pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbml0cyBkbyBub3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZWxlc3NVbml0LnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgdG8gYSB1bml0IHdpdGggYSB2YWx1ZScpO1xuICAgICAgfVxuICAgICAgb3RoZXIgPSB2YWx1ZWxlc3NVbml0LmNsb25lKCk7XG4gICAgICBvdGhlci52YWx1ZSA9IGNsb25lKHZhbHVlKTtcbiAgICAgIG90aGVyLmZpeFByZWZpeCA9IHRydWU7XG4gICAgICBvdGhlci5pc1VuaXRMaXN0U2ltcGxpZmllZCA9IHRydWU7XG4gICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgb3IgVW5pdCBleHBlY3RlZCBhcyBwYXJhbWV0ZXInKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgd2hlbiByZXByZXNlbnRlZCB3aXRoIGdpdmVuIHZhbHVlbGVzcyB1bml0XG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVW5pdH0gdmFsdWVsZXNzVW5pdCAgICBGb3IgZXhhbXBsZSAnY20nIG9yICdpbmNoJ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybnMgdGhlIHVuaXQgdmFsdWUgYXMgbnVtYmVyLlxuICAgKi9cbiAgLy8gVE9ETzogZGVwcmVjYXRlIFVuaXQudG9OdW1iZXI/IEl0J3MgYWx3YXlzIGJldHRlciB0byB1c2UgdG9OdW1lcmljXG4gIFVuaXQucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlbGVzc1VuaXQpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodGhpcy50b051bWVyaWModmFsdWVsZXNzVW5pdCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSB1bml0IGluIHRoZSBvcmlnaW5hbCBudW1lcmljIHR5cGVcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVbml0fSB2YWx1ZWxlc3NVbml0ICAgIEZvciBleGFtcGxlICdjbScgb3IgJ2luY2gnXG4gICAqIEByZXR1cm4ge251bWJlciB8IEJpZ051bWJlciB8IEZyYWN0aW9ufSBSZXR1cm5zIHRoZSB1bml0IHZhbHVlXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS50b051bWVyaWMgPSBmdW5jdGlvbiAodmFsdWVsZXNzVW5pdCkge1xuICAgIHZhciBvdGhlciA9IHRoaXM7XG4gICAgaWYodmFsdWVsZXNzVW5pdCkge1xuICAgICAgLy8gQWxsb3cgZ2V0dGluZyB0aGUgbnVtZXJpYyB2YWx1ZSB3aXRob3V0IGNvbnZlcnRpbmcgdG8gYSBkaWZmZXJlbnQgdW5pdFxuICAgICAgb3RoZXIgPSB0aGlzLnRvKHZhbHVlbGVzc1VuaXQpO1xuICAgIH1cblxuICAgIGlmKG90aGVyLl9pc0Rlcml2ZWQoKSkge1xuICAgICAgcmV0dXJuIG90aGVyLl9kZW5vcm1hbGl6ZShvdGhlci52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG90aGVyLl9kZW5vcm1hbGl6ZShvdGhlci52YWx1ZSwgb3RoZXIudW5pdHNbMF0ucHJlZml4LnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5pdC5cbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXRcbiAgICogQG1lbWJlcm9mIFVuaXRcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgIGB7XCJtYXRoanNcIjogXCJVbml0XCIsIFwidmFsdWVcIjogMiwgXCJ1bml0XCI6IFwiY21cIiwgXCJmaXhQcmVmaXhcIjogZmFsc2V9YFxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRoanM6ICdVbml0JyxcbiAgICAgIHZhbHVlOiB0aGlzLl9kZW5vcm1hbGl6ZSh0aGlzLnZhbHVlKSxcbiAgICAgIHVuaXQ6IHRoaXMuZm9ybWF0VW5pdHMoKSxcbiAgICAgIGZpeFByZWZpeDogdGhpcy5maXhQcmVmaXhcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhIFVuaXQgZnJvbSBhIEpTT04gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uICBBIEpTT04gb2JqZWN0IHN0cnVjdHVyZWQgYXM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICBge1wibWF0aGpzXCI6IFwiVW5pdFwiLCBcInZhbHVlXCI6IDIsIFwidW5pdFwiOiBcImNtXCIsIFwiZml4UHJlZml4XCI6IGZhbHNlfWBcbiAgICogQHJldHVybiB7VW5pdH1cbiAgICovXG4gIFVuaXQuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciB1bml0ID0gbmV3IFVuaXQoanNvbi52YWx1ZSwganNvbi51bml0KTtcbiAgICB1bml0LmZpeFByZWZpeCA9IGpzb24uZml4UHJlZml4IHx8IGZhbHNlO1xuICAgIHJldHVybiB1bml0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXQuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnZhbHVlT2YgPSBVbml0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBzaW1wbGlmeSB0aGUgbGlzdCBvZiB1bml0cyBmb3IgdGhpcyB1bml0IGFjY29yZGluZyB0byB0aGUgZGltZW5zaW9ucyBhcnJheSBhbmQgdGhlIGN1cnJlbnQgdW5pdCBzeXN0ZW0uIEFmdGVyIHRoZSBjYWxsLCB0aGlzIFVuaXQgd2lsbCBjb250YWluIGEgbGlzdCBvZiB0aGUgXCJiZXN0XCIgdW5pdHMgZm9yIGZvcm1hdHRpbmcuXG4gICAqIEludGVuZGVkIHRvIGJlIGV2YWx1YXRlZCBsYXppbHkuIFlvdSBtdXN0IHNldCBpc1VuaXRMaXN0U2ltcGxpZmllZCA9IGZhbHNlIGJlZm9yZSB0aGUgY2FsbCEgQWZ0ZXIgdGhlIGNhbGwsIGlzVW5pdExpc3RTaW1wbGlmaWVkIHdpbGwgYmUgc2V0IHRvIHRydWUuXG4gICAqL1xuICBVbml0LnByb3RvdHlwZS5zaW1wbGlmeVVuaXRMaXN0TGF6eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHRoaXMuaXNVbml0TGlzdFNpbXBsaWZpZWQgfHwgdGhpcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3Bvc2VkVW5pdExpc3QgPSBbXTtcblxuICAgIC8vIFNlYXJjaCBmb3IgYSBtYXRjaGluZyBiYXNlXG4gICAgdmFyIG1hdGNoaW5nQmFzZTtcbiAgICBmb3IodmFyIGtleSBpbiBjdXJyZW50VW5pdFN5c3RlbSkge1xuICAgICAgaWYodGhpcy5oYXNCYXNlKEJBU0VfVU5JVFNba2V5XSkpIHtcbiAgICAgICAgbWF0Y2hpbmdCYXNlID0ga2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtYXRjaGluZ0Jhc2UgPT09ICdOT05FJylcbiAgICB7XG4gICAgICB0aGlzLnVuaXRzID0gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG1hdGNoaW5nVW5pdDtcbiAgICAgIGlmKG1hdGNoaW5nQmFzZSkge1xuICAgICAgICAvLyBEb2VzIHRoZSB1bml0IHN5c3RlbSBoYXZlIGEgbWF0Y2hpbmcgdW5pdD9cbiAgICAgICAgaWYoY3VycmVudFVuaXRTeXN0ZW0uaGFzT3duUHJvcGVydHkobWF0Y2hpbmdCYXNlKSkge1xuICAgICAgICAgIG1hdGNoaW5nVW5pdCA9IGN1cnJlbnRVbml0U3lzdGVtW21hdGNoaW5nQmFzZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBzdHI7XG4gICAgICBpZihtYXRjaGluZ1VuaXQpIHtcbiAgICAgICAgdGhpcy51bml0cyA9IFt7XG4gICAgICAgICAgdW5pdDogbWF0Y2hpbmdVbml0LnVuaXQsXG4gICAgICAgICAgcHJlZml4OiBtYXRjaGluZ1VuaXQucHJlZml4LFxuICAgICAgICAgIHBvd2VyOiAxLjBcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgdW5pdHMgb3IgdW5pdHMgd2l0aCBwb3dlcnMgYXJlIGZvcm1hdHRlZCBsaWtlIHRoaXM6XG4gICAgICAgIC8vIDUgKGtnIG1eMikgLyAoc14zIG1vbClcbiAgICAgICAgLy8gQnVpbGQgYW4gcmVwcmVzZW50YXRpb24gZnJvbSB0aGUgYmFzZSB1bml0cyBvZiB0aGUgY3VycmVudCB1bml0IHN5c3RlbVxuICAgICAgICB2YXIgbWlzc2luZ0Jhc2VEaW0gPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJhc2VEaW0gPSBCQVNFX0RJTUVOU0lPTlNbaV07XG4gICAgICAgICAgaWYoTWF0aC5hYnModGhpcy5kaW1lbnNpb25zW2ldIHx8IDApID4gMWUtMTIpIHtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRVbml0U3lzdGVtLmhhc093blByb3BlcnR5KGJhc2VEaW0pKSB7XG4gICAgICAgICAgICAgIHByb3Bvc2VkVW5pdExpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgdW5pdDogY3VycmVudFVuaXRTeXN0ZW1bYmFzZURpbV0udW5pdCxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGN1cnJlbnRVbml0U3lzdGVtW2Jhc2VEaW1dLnByZWZpeCxcbiAgICAgICAgICAgICAgICBwb3dlcjogdGhpcy5kaW1lbnNpb25zW2ldIHx8IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbWlzc2luZ0Jhc2VEaW0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuICAgICAgICAvLyBJcyB0aGUgcHJvcG9zZWQgdW5pdCBsaXN0IFwic2ltcGxlclwiIHRoYW4gdGhlIGV4aXN0aW5nIG9uZT9cbiAgICAgICAgaWYocHJvcG9zZWRVbml0TGlzdC5sZW5ndGggPCB0aGlzLnVuaXRzLmxlbmd0aCAmJiAhbWlzc2luZ0Jhc2VEaW0pIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIHRoaXMgdW5pdCBsaXN0IHdpdGggdGhlIHByb3Bvc2VkIGxpc3RcbiAgICAgICAgICB0aGlzLnVuaXRzID0gcHJvcG9zZWRVbml0TGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNVbml0TGlzdFNpbXBsaWZpZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuaXRzIG9mIHRoaXMgVW5pdCwgd2l0aG91dCB0aGUgdmFsdWUuXG4gICAqIEBtZW1iZXJvZiBVbml0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLmZvcm1hdFVuaXRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gTGF6eSBldmFsdWF0aW9uIG9mIHRoZSB1bml0IGxpc3RcbiAgICB0aGlzLnNpbXBsaWZ5VW5pdExpc3RMYXp5KCk7XG5cbiAgICB2YXIgc3RyTnVtID0gXCJcIjtcbiAgICB2YXIgc3RyRGVuID0gXCJcIjtcbiAgICB2YXIgbk51bSA9IDA7XG4gICAgdmFyIG5EZW4gPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYodGhpcy51bml0c1tpXS5wb3dlciA+IDApIHtcbiAgICAgICAgbk51bSsrO1xuICAgICAgICBzdHJOdW0gKz0gXCIgXCIgKyB0aGlzLnVuaXRzW2ldLnByZWZpeC5uYW1lICsgdGhpcy51bml0c1tpXS51bml0Lm5hbWU7XG4gICAgICAgIGlmKE1hdGguYWJzKHRoaXMudW5pdHNbaV0ucG93ZXIgLSAxLjApID4gMWUtMTUpIHtcbiAgICAgICAgICBzdHJOdW0gKz0gXCJeXCIgKyB0aGlzLnVuaXRzW2ldLnBvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHRoaXMudW5pdHNbaV0ucG93ZXIgPCAwKSB7XG4gICAgICAgIG5EZW4rKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihuRGVuID4gMCkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy51bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZih0aGlzLnVuaXRzW2ldLnBvd2VyIDwgMCkge1xuICAgICAgICAgIGlmKG5OdW0gPiAwKSB7XG4gICAgICAgICAgICBzdHJEZW4gKz0gXCIgXCIgKyB0aGlzLnVuaXRzW2ldLnByZWZpeC5uYW1lICsgdGhpcy51bml0c1tpXS51bml0Lm5hbWU7XG4gICAgICAgICAgICBpZihNYXRoLmFicyh0aGlzLnVuaXRzW2ldLnBvd2VyICsgMS4wKSA+IDFlLTE1KSB7XG4gICAgICAgICAgICAgIHN0ckRlbiArPSBcIl5cIiArICgtdGhpcy51bml0c1tpXS5wb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyRGVuICs9IFwiIFwiICsgdGhpcy51bml0c1tpXS5wcmVmaXgubmFtZSArIHRoaXMudW5pdHNbaV0udW5pdC5uYW1lO1xuICAgICAgICAgICAgc3RyRGVuICs9IFwiXlwiICsgKHRoaXMudW5pdHNbaV0ucG93ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgbGVhZGluZyBcIiBcIlxuICAgIHN0ck51bSA9IHN0ck51bS5zdWJzdHIoMSk7XG4gICAgc3RyRGVuID0gc3RyRGVuLnN1YnN0cigxKTtcblxuICAgIC8vIEFkZCBwYXJhbnMgZm9yIGJldHRlciBjb3B5L3Bhc3RlIGJhY2sgaW50byB0aGUgZXZhbCwgZm9yIGV4YW1wbGUsIG9yIGZvciBiZXR0ZXIgcHJldHR5IHByaW50IGZvcm1hdHRpbmdcbiAgICBpZihuTnVtID4gMSAmJiBuRGVuID4gMCkge1xuICAgICAgc3RyTnVtID0gXCIoXCIgKyBzdHJOdW0gKyBcIilcIjtcbiAgICB9XG4gICAgaWYobkRlbiA+IDEgJiYgbk51bSA+IDApIHtcbiAgICAgIHN0ckRlbiA9IFwiKFwiICsgc3RyRGVuICsgXCIpXCI7XG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IHN0ck51bTtcbiAgICBpZihuTnVtID4gMCAmJiBuRGVuID4gMCkge1xuICAgICAgc3RyICs9IFwiIC8gXCI7XG4gICAgfVxuICAgIHN0ciArPSBzdHJEZW47XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVuaXQsIHdpdGggb3B0aW9uYWwgZm9ybWF0dGluZyBvcHRpb25zLlxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IEZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliL3V0aWxzL251bWJlcjpmb3JtYXQgZm9yIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgVW5pdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIC8vIFNpbXBsZnkgdGhlIHVuaXQgbGlzdCwgaWYgbmVjZXNzYXJ5XG4gICAgdGhpcy5zaW1wbGlmeVVuaXRMaXN0TGF6eSgpO1xuXG4gICAgLy8gQXBwbHkgc29tZSBjdXN0b20gbG9naWMgZm9yIGhhbmRsaW5nIFZBIGFuZCBWQVIuIFRoZSBnb2FsIGlzIHRvIGV4cHJlc3MgdGhlIHZhbHVlIG9mIHRoZSB1bml0IGFzIGEgcmVhbCB2YWx1ZSwgaWYgcG9zc2libGUuIE90aGVyd2lzZSwgdXNlIGEgcmVhbC12YWx1ZWQgdW5pdCBpbnN0ZWFkIG9mIGEgY29tcGxleC12YWx1ZWQgb25lLlxuICAgIHZhciBpc0ltYWdpbmFyeSA9IGZhbHNlO1xuICAgIHZhciBpc1JlYWwgPSB0cnVlO1xuICAgIGlmKHR5cGVvZih0aGlzLnZhbHVlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy52YWx1ZSAhPT0gbnVsbCAmJiB0aGlzLnZhbHVlLmlzQ29tcGxleCkge1xuICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIGJldHRlciwgZm9yIGV4YW1wbGUsIHVzZSByZWxhdGl2ZSBtYWduaXR1ZGUgb2YgcmUgYW5kIGltIHJhdGhlciB0aGFuIGFic29sdXRlXG4gICAgICBpc0ltYWdpbmFyeSA9IE1hdGguYWJzKHRoaXMudmFsdWUucmUpIDwgMWUtMTQ7XG4gICAgICBpc1JlYWwgPSBNYXRoLmFicyh0aGlzLnZhbHVlLmltKSA8IDFlLTE0O1xuICAgIH1cbiAgICBcbiAgICBmb3IodmFyIGkgaW4gdGhpcy51bml0cykge1xuICAgICAgaWYodGhpcy51bml0c1tpXS51bml0KSB7XG4gICAgICAgIGlmKHRoaXMudW5pdHNbaV0udW5pdC5uYW1lID09PSAnVkEnICYmIGlzSW1hZ2luYXJ5KSB7XG4gICAgICAgICAgdGhpcy51bml0c1tpXS51bml0ID0gVU5JVFNbXCJWQVJcIl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLnVuaXRzW2ldLnVuaXQubmFtZSA9PT0gJ1ZBUicgJiYgIWlzSW1hZ2luYXJ5KSB7XG4gICAgICAgICAgdGhpcy51bml0c1tpXS51bml0ID0gVU5JVFNbXCJWQVwiXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTm93IGFwcGx5IHRoZSBiZXN0IHByZWZpeFxuICAgIC8vIFVuaXRzIG11c3QgaGF2ZSBvbmx5IG9uZSB1bml0IGFuZCBub3QgaGF2ZSB0aGUgZml4UHJlZml4IGZsYWcgc2V0XG4gICAgaWYgKHRoaXMudW5pdHMubGVuZ3RoID09PSAxICYmICF0aGlzLmZpeFByZWZpeCkge1xuICAgICAgLy8gVW5pdHMgbXVzdCBoYXZlIGludGVnZXIgcG93ZXJzLCBvdGhlcndpc2UgdGhlIHByZWZpeCB3aWxsIGNoYW5nZSB0aGVcbiAgICAgIC8vIG91dHB1dHRlZCB2YWx1ZSBieSBub3QtYW4taW50ZWdlci1wb3dlci1vZi10ZW5cbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnVuaXRzWzBdLnBvd2VyIC0gTWF0aC5yb3VuZCh0aGlzLnVuaXRzWzBdLnBvd2VyKSkgPCAxZS0xNCkge1xuICAgICAgICAvLyBBcHBseSB0aGUgYmVzdCBwcmVmaXhcbiAgICAgICAgdGhpcy51bml0c1swXS5wcmVmaXggPSB0aGlzLl9iZXN0UHJlZml4KCk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9kZW5vcm1hbGl6ZSh0aGlzLnZhbHVlKTtcbiAgICB2YXIgc3RyID0gKHRoaXMudmFsdWUgIT09IG51bGwpID8gZm9ybWF0KHZhbHVlLCBvcHRpb25zIHx8IHt9KSA6ICcnO1xuICAgIHZhciB1bml0U3RyID0gdGhpcy5mb3JtYXRVbml0cygpO1xuICAgIGlmKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5pc0NvbXBsZXgpIHtcbiAgICAgIHN0ciA9IFwiKFwiICsgc3RyICsgXCIpXCI7ICAgIC8vIFN1cnJvdW5kIGNvbXBsZXggdmFsdWVzIHdpdGggKCApIHRvIGVuYWJsZSBiZXR0ZXIgcGFyc2luZyBcbiAgICB9XG4gICAgaWYodW5pdFN0ci5sZW5ndGggPiAwICYmIHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICBzdHIgKz0gXCIgXCI7XG4gICAgfVxuICAgIHN0ciArPSB1bml0U3RyO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBiZXN0IHByZWZpeCB1c2luZyBjdXJyZW50IHZhbHVlLlxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwcmVmaXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFVuaXQucHJvdG90eXBlLl9iZXN0UHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnVuaXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgY29tcHV0ZSB0aGUgYmVzdCBwcmVmaXggZm9yIHNpbmdsZSB1bml0cyB3aXRoIGludGVnZXIgcG93ZXJzLCBsaWtlIGtnLCBzXjIsIE5eLTEsIGFuZCBzbyBmb3J0aCFcIik7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyh0aGlzLnVuaXRzWzBdLnBvd2VyIC0gTWF0aC5yb3VuZCh0aGlzLnVuaXRzWzBdLnBvd2VyKSkgPj0gMWUtMTQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IGNvbXB1dGUgdGhlIGJlc3QgcHJlZml4IGZvciBzaW5nbGUgdW5pdHMgd2l0aCBpbnRlZ2VyIHBvd2VycywgbGlrZSBrZywgc14yLCBOXi0xLCBhbmQgc28gZm9ydGghXCIpO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIGJlc3QgcHJlZml4IHZhbHVlIChyZXN1bHRpbmcgaW4gdGhlIHZhbHVlIG9mIHdoaWNoXG4gICAgLy8gdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBsb2cxMCBpcyBjbG9zZXN0IHRvIHplcm8sXG4gICAgLy8gdGhvdWdoIHdpdGggYSBsaXR0bGUgb2Zmc2V0IG9mIDEuMiBmb3IgbmljZXIgdmFsdWVzOiB5b3UgZ2V0IGFcbiAgICAvLyBzZXF1ZW5jZSAxbW0gMTAwbW0gNTAwbW0gMC42bSAxbSAxMG0gMTAwbSA1MDBtIDAuNmttIDFrbSAuLi5cblxuICAgIC8vIE5vdGU6IHRoZSB1bml0cyB2YWx1ZSBjYW4gYmUgYW55IG51bWVyaWMgdHlwZSwgYnV0IHRvIGZpbmQgdGhlIGJlc3RcbiAgICAvLyBwcmVmaXggaXQncyBlbm91Z2ggdG8gd29yayB3aXRoIGxpbWl0ZWQgcHJlY2lzaW9uIG9mIGEgcmVndWxhciBudW1iZXJcbiAgICAvLyBVcGRhdGU6IHVzaW5nIG1hdGhqcyBhYnMgc2luY2Ugd2UgYWxzbyBhbGxvdyBjb21wbGV4IG51bWJlcnNcbiAgICB2YXIgYWJzVmFsdWUgPSBhYnModGhpcy52YWx1ZSk7XG4gICAgdmFyIGFic1VuaXRWYWx1ZSA9IGFicyh0aGlzLnVuaXRzWzBdLnVuaXQudmFsdWUpO1xuICAgIHZhciBiZXN0UHJlZml4ID0gdGhpcy51bml0c1swXS5wcmVmaXg7XG4gICAgaWYgKGFic1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gYmVzdFByZWZpeDtcbiAgICB9XG4gICAgdmFyIHBvd2VyID0gdGhpcy51bml0c1swXS5wb3dlcjtcbiAgICB2YXIgYmVzdERpZmYgPSBNYXRoLmxvZyhhYnNWYWx1ZSAvIE1hdGgucG93KGJlc3RQcmVmaXgudmFsdWUgKiBhYnNVbml0VmFsdWUsIHBvd2VyKSkgLyBNYXRoLkxOMTAgLSAxLjI7XG4gICAgaWYoYmVzdERpZmYgPiAtMi4yMDAwMDEgJiYgYmVzdERpZmYgPCAxLjgwMDAwMSkgcmV0dXJuIGJlc3RQcmVmaXg7ICAgIC8vIEFsbG93IHRoZSBvcmlnaW5hbCBwcmVmaXhcbiAgICBiZXN0RGlmZiA9IE1hdGguYWJzKGJlc3REaWZmKTtcbiAgICB2YXIgcHJlZml4ZXMgPSB0aGlzLnVuaXRzWzBdLnVuaXQucHJlZml4ZXM7XG4gICAgZm9yICh2YXIgcCBpbiBwcmVmaXhlcykge1xuICAgICAgaWYgKHByZWZpeGVzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1twXTtcbiAgICAgICAgaWYgKHByZWZpeC5zY2llbnRpZmljKSB7XG5cbiAgICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgICAgICBNYXRoLmxvZyhhYnNWYWx1ZSAvIE1hdGgucG93KHByZWZpeC52YWx1ZSAqIGFic1VuaXRWYWx1ZSwgcG93ZXIpKSAvIE1hdGguTE4xMCAtIDEuMik7XG5cbiAgICAgICAgICBpZiAoZGlmZiA8IGJlc3REaWZmXG4gICAgICAgICAgICAgIHx8IChkaWZmID09PSBiZXN0RGlmZiAmJiBwcmVmaXgubmFtZS5sZW5ndGggPCBiZXN0UHJlZml4Lm5hbWUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIC8vIGNob29zZSB0aGUgcHJlZml4IHdpdGggdGhlIHNtYWxsZXN0IGRpZmYsIG9yIGlmIGVxdWFsLCBjaG9vc2UgdGhlIG9uZVxuICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIHNob3J0ZXN0IG5hbWUgKGNhbiBoYXBwZW4gd2l0aCBTSE9SVExPTkcgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgYmVzdFByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBiZXN0RGlmZiA9IGRpZmY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RQcmVmaXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdW5pdHMgd2hvc2Ugc3VtIGlzIGVxdWFsIHRvIHRoaXMgdW5pdFxuICAgKiBAbWVtYmVyb2YgVW5pdFxuICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydHNdIEFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgdmFsdWVsZXNzIHVuaXRzLiBcbiAgICpcbiAgICogICBFeGFtcGxlOlxuICAgKlxuICAgKiAgIHZhciB1ID0gbmV3IFVuaXQoMSwgJ20nKTtcbiAgICogICB1LnNwbGl0VW5pdChbJ2ZlZXQnLCAnaW5jaCddKTtcbiAgICogICAgIFsgMyBmZWV0LCAzLjM3MDA3ODc0MDE1NzUgaW5jaCBdXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB1bml0cy5cbiAgICovXG4gIFVuaXQucHJvdG90eXBlLnNwbGl0VW5pdCA9IGZ1bmN0aW9uKHBhcnRzKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB4LnRvKHBhcnRzW2ldKTtcbiAgICAgIGlmKGk9PXBhcnRzLmxlbmd0aC0xKSBicmVhaztcbiAgICAgIC8vIGZpeCByb3VuZHMgYSBudW1iZXIgdG93YXJkcyAwXG4gICAgICB2YXIgZml4ZWRWYWwgPSBmaXgoeC50b051bWVyaWMoKSk7XG4gICAgICB2YXIgeSA9IG5ldyBVbml0KGZpeGVkVmFsLCBwYXJ0c1tpXS50b1N0cmluZygpKTtcbiAgICAgIHJldC5wdXNoKHkpO1xuICAgICAgeCA9IHN1YnRyYWN0KHgsIHkpO1xuICAgIH1cbiAgICByZXQucHVzaCh4KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIFBSRUZJWEVTID0ge1xuICAgIE5PTkU6IHtcbiAgICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfVxuICAgIH0sXG4gICAgU0hPUlQ6IHtcbiAgICAgICcnOiB7bmFtZTogJycsIHZhbHVlOiAxLCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ2RhJzoge25hbWU6ICdkYScsIHZhbHVlOiAxZTEsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdoJzoge25hbWU6ICdoJywgdmFsdWU6IDFlMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2snOiB7bmFtZTogJ2snLCB2YWx1ZTogMWUzLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdNJzoge25hbWU6ICdNJywgdmFsdWU6IDFlNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRyc6IHtuYW1lOiAnRycsIHZhbHVlOiAxZTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1QnOiB7bmFtZTogJ1QnLCB2YWx1ZTogMWUxMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnUCc6IHtuYW1lOiAnUCcsIHZhbHVlOiAxZTE1LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdFJzoge25hbWU6ICdFJywgdmFsdWU6IDFlMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1onOiB7bmFtZTogJ1onLCB2YWx1ZTogMWUyMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnWSc6IHtuYW1lOiAnWScsIHZhbHVlOiAxZTI0LCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ2QnOiB7bmFtZTogJ2QnLCB2YWx1ZTogMWUtMSwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2MnOiB7bmFtZTogJ2MnLCB2YWx1ZTogMWUtMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ20nOiB7bmFtZTogJ20nLCB2YWx1ZTogMWUtMywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAndSc6IHtuYW1lOiAndScsIHZhbHVlOiAxZS02LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICduJzoge25hbWU6ICduJywgdmFsdWU6IDFlLTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3AnOiB7bmFtZTogJ3AnLCB2YWx1ZTogMWUtMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2YnOiB7bmFtZTogJ2YnLCB2YWx1ZTogMWUtMTUsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2EnOiB7bmFtZTogJ2EnLCB2YWx1ZTogMWUtMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3onOiB7bmFtZTogJ3onLCB2YWx1ZTogMWUtMjEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3knOiB7bmFtZTogJ3knLCB2YWx1ZTogMWUtMjQsIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfSxcbiAgICBMT05HOiB7XG4gICAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkZWNhJzoge25hbWU6ICdkZWNhJywgdmFsdWU6IDFlMSwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2hlY3RvJzoge25hbWU6ICdoZWN0bycsIHZhbHVlOiAxZTIsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdraWxvJzoge25hbWU6ICdraWxvJywgdmFsdWU6IDFlMywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbWVnYSc6IHtuYW1lOiAnbWVnYScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2dpZ2EnOiB7bmFtZTogJ2dpZ2EnLCB2YWx1ZTogMWU5LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd0ZXJhJzoge25hbWU6ICd0ZXJhJywgdmFsdWU6IDFlMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3BldGEnOiB7bmFtZTogJ3BldGEnLCB2YWx1ZTogMWUxNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZXhhJzoge25hbWU6ICdleGEnLCB2YWx1ZTogMWUxOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnemV0dGEnOiB7bmFtZTogJ3pldHRhJywgdmFsdWU6IDFlMjEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3lvdHRhJzoge25hbWU6ICd5b3R0YScsIHZhbHVlOiAxZTI0LCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ2RlY2knOiB7bmFtZTogJ2RlY2knLCB2YWx1ZTogMWUtMSwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2NlbnRpJzoge25hbWU6ICdjZW50aScsIHZhbHVlOiAxZS0yLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAnbWlsbGknOiB7bmFtZTogJ21pbGxpJywgdmFsdWU6IDFlLTMsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ21pY3JvJzoge25hbWU6ICdtaWNybycsIHZhbHVlOiAxZS02LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICduYW5vJzoge25hbWU6ICduYW5vJywgdmFsdWU6IDFlLTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3BpY28nOiB7bmFtZTogJ3BpY28nLCB2YWx1ZTogMWUtMTIsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2ZlbXRvJzoge25hbWU6ICdmZW10bycsIHZhbHVlOiAxZS0xNSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnYXR0byc6IHtuYW1lOiAnYXR0bycsIHZhbHVlOiAxZS0xOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnemVwdG8nOiB7bmFtZTogJ3plcHRvJywgdmFsdWU6IDFlLTIxLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd5b2N0byc6IHtuYW1lOiAneW9jdG8nLCB2YWx1ZTogMWUtMjQsIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfSxcbiAgICBTUVVBUkVEOiB7XG4gICAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkYSc6IHtuYW1lOiAnZGEnLCB2YWx1ZTogMWUyLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAnaCc6IHtuYW1lOiAnaCcsIHZhbHVlOiAxZTQsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdrJzoge25hbWU6ICdrJywgdmFsdWU6IDFlNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnTSc6IHtuYW1lOiAnTScsIHZhbHVlOiAxZTEyLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdHJzoge25hbWU6ICdHJywgdmFsdWU6IDFlMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1QnOiB7bmFtZTogJ1QnLCB2YWx1ZTogMWUyNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnUCc6IHtuYW1lOiAnUCcsIHZhbHVlOiAxZTMwLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdFJzoge25hbWU6ICdFJywgdmFsdWU6IDFlMzYsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1onOiB7bmFtZTogJ1onLCB2YWx1ZTogMWU0Miwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnWSc6IHtuYW1lOiAnWScsIHZhbHVlOiAxZTQ4LCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ2QnOiB7bmFtZTogJ2QnLCB2YWx1ZTogMWUtMiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2MnOiB7bmFtZTogJ2MnLCB2YWx1ZTogMWUtNCwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ20nOiB7bmFtZTogJ20nLCB2YWx1ZTogMWUtNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAndSc6IHtuYW1lOiAndScsIHZhbHVlOiAxZS0xMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbic6IHtuYW1lOiAnbicsIHZhbHVlOiAxZS0xOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAncCc6IHtuYW1lOiAncCcsIHZhbHVlOiAxZS0yNCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZic6IHtuYW1lOiAnZicsIHZhbHVlOiAxZS0zMCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnYSc6IHtuYW1lOiAnYScsIHZhbHVlOiAxZS0zNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneic6IHtuYW1lOiAneicsIHZhbHVlOiAxZS00Miwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneSc6IHtuYW1lOiAneScsIHZhbHVlOiAxZS00OCwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgICB9LFxuICAgIENVQklDOiB7XG4gICAgICAnJzoge25hbWU6ICcnLCB2YWx1ZTogMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG5cbiAgICAgICdkYSc6IHtuYW1lOiAnZGEnLCB2YWx1ZTogMWUzLCBzY2llbnRpZmljOiBmYWxzZX0sXG4gICAgICAnaCc6IHtuYW1lOiAnaCcsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IGZhbHNlfSxcbiAgICAgICdrJzoge25hbWU6ICdrJywgdmFsdWU6IDFlOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnTSc6IHtuYW1lOiAnTScsIHZhbHVlOiAxZTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdHJzoge25hbWU6ICdHJywgdmFsdWU6IDFlMjcsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1QnOiB7bmFtZTogJ1QnLCB2YWx1ZTogMWUzNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnUCc6IHtuYW1lOiAnUCcsIHZhbHVlOiAxZTQ1LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdFJzoge25hbWU6ICdFJywgdmFsdWU6IDFlNTQsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1onOiB7bmFtZTogJ1onLCB2YWx1ZTogMWU2Mywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnWSc6IHtuYW1lOiAnWScsIHZhbHVlOiAxZTcyLCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ2QnOiB7bmFtZTogJ2QnLCB2YWx1ZTogMWUtMywgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ2MnOiB7bmFtZTogJ2MnLCB2YWx1ZTogMWUtNiwgc2NpZW50aWZpYzogZmFsc2V9LFxuICAgICAgJ20nOiB7bmFtZTogJ20nLCB2YWx1ZTogMWUtOSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAndSc6IHtuYW1lOiAndScsIHZhbHVlOiAxZS0xOCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnbic6IHtuYW1lOiAnbicsIHZhbHVlOiAxZS0yNywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAncCc6IHtuYW1lOiAncCcsIHZhbHVlOiAxZS0zNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZic6IHtuYW1lOiAnZicsIHZhbHVlOiAxZS00NSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnYSc6IHtuYW1lOiAnYScsIHZhbHVlOiAxZS01NCwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneic6IHtuYW1lOiAneicsIHZhbHVlOiAxZS02Mywgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneSc6IHtuYW1lOiAneScsIHZhbHVlOiAxZS03Miwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgICB9LFxuICAgIEJJTkFSWV9TSE9SVDoge1xuICAgICAgJyc6IHtuYW1lOiAnJywgdmFsdWU6IDEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2snOiB7bmFtZTogJ2snLCB2YWx1ZTogMWUzLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdNJzoge25hbWU6ICdNJywgdmFsdWU6IDFlNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnRyc6IHtuYW1lOiAnRycsIHZhbHVlOiAxZTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1QnOiB7bmFtZTogJ1QnLCB2YWx1ZTogMWUxMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnUCc6IHtuYW1lOiAnUCcsIHZhbHVlOiAxZTE1LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdFJzoge25hbWU6ICdFJywgdmFsdWU6IDFlMTgsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ1onOiB7bmFtZTogJ1onLCB2YWx1ZTogMWUyMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnWSc6IHtuYW1lOiAnWScsIHZhbHVlOiAxZTI0LCBzY2llbnRpZmljOiB0cnVlfSxcblxuICAgICAgJ0tpJzoge25hbWU6ICdLaScsIHZhbHVlOiAxMDI0LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdNaSc6IHtuYW1lOiAnTWknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgMiksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ0dpJzoge25hbWU6ICdHaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCAzKSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnVGknOiB7bmFtZTogJ1RpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDQpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdQaSc6IHtuYW1lOiAnUGknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgNSksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ0VpJzoge25hbWU6ICdFaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA2KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnWmknOiB7bmFtZTogJ1ppJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDcpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdZaSc6IHtuYW1lOiAnWWknLCB2YWx1ZTogTWF0aC5wb3coMTAyNCwgOCksIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfSxcbiAgICBCSU5BUllfTE9ORzoge1xuICAgICAgJyc6IHtuYW1lOiAnJywgdmFsdWU6IDEsIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ2tpbG8nOiB7bmFtZTogJ2tpbG8nLCB2YWx1ZTogMWUzLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdtZWdhJzoge25hbWU6ICdtZWdhJywgdmFsdWU6IDFlNiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnZ2lnYSc6IHtuYW1lOiAnZ2lnYScsIHZhbHVlOiAxZTksIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ3RlcmEnOiB7bmFtZTogJ3RlcmEnLCB2YWx1ZTogMWUxMiwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAncGV0YSc6IHtuYW1lOiAncGV0YScsIHZhbHVlOiAxZTE1LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdleGEnOiB7bmFtZTogJ2V4YScsIHZhbHVlOiAxZTE4LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd6ZXR0YSc6IHtuYW1lOiAnemV0dGEnLCB2YWx1ZTogMWUyMSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneW90dGEnOiB7bmFtZTogJ3lvdHRhJywgdmFsdWU6IDFlMjQsIHNjaWVudGlmaWM6IHRydWV9LFxuXG4gICAgICAna2liaSc6IHtuYW1lOiAna2liaScsIHZhbHVlOiAxMDI0LCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdtZWJpJzoge25hbWU6ICdtZWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDIpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdnaWJpJzoge25hbWU6ICdnaWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDMpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICd0ZWJpJzoge25hbWU6ICd0ZWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDQpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdwZWJpJzoge25hbWU6ICdwZWJpJywgdmFsdWU6IE1hdGgucG93KDEwMjQsIDUpLCBzY2llbnRpZmljOiB0cnVlfSxcbiAgICAgICdleGknOiB7bmFtZTogJ2V4aScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA2KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAnemViaSc6IHtuYW1lOiAnemViaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA3KSwgc2NpZW50aWZpYzogdHJ1ZX0sXG4gICAgICAneW9iaSc6IHtuYW1lOiAneW9iaScsIHZhbHVlOiBNYXRoLnBvdygxMDI0LCA4KSwgc2NpZW50aWZpYzogdHJ1ZX1cbiAgICB9LFxuICAgIEJUVToge1xuICAgICAgJyc6ICAge25hbWU6ICcnLCAgIHZhbHVlOiAxLCAgIHNjaWVudGlmaWM6IHRydWV9LFxuICAgICAgJ01NJzoge25hbWU6ICdNTScsIHZhbHVlOiAxZTYsIHNjaWVudGlmaWM6IHRydWV9XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBhIHByZWZpeCBsaXN0IGZvciBib3RoIHNob3J0IGFuZCBsb25nIHByZWZpeGVzIChmb3Igb2htIGluIHBhcnRpY3VsYXIsIHNpbmNlIE1vaG0gYW5kIG1lZ2FvaG0gYXJlIGJvdGggYWNjZXB0YWJsZSk6XG4gIFBSRUZJWEVTLlNIT1JUTE9ORyA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gUFJFRklYRVMuU0hPUlQpIHtcbiAgICBpZihQUkVGSVhFUy5TSE9SVC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBQUkVGSVhFUy5TSE9SVExPTkdba2V5XSA9IFBSRUZJWEVTLlNIT1JUW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGtleSBpbiBQUkVGSVhFUy5MT05HKSB7XG4gICAgaWYoUFJFRklYRVMuTE9ORy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBQUkVGSVhFUy5TSE9SVExPTkdba2V5XSA9IFBSRUZJWEVTLkxPTkdba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKiBJbnRlcm5hbGx5LCBlYWNoIHVuaXQgaXMgcmVwcmVzZW50ZWQgYnkgYSB2YWx1ZSBhbmQgYSBkaW1lbnNpb24gYXJyYXkuIFRoZSBlbGVtZW50cyBvZiB0aGUgZGltZW5zaW9ucyBhcnJheSBoYXZlIHRoZSBmb2xsb3dpbmcgbWVhbmluZzpcbiAgICogSW5kZXggIERpbWVuc2lvblxuICAgKiAtLS0tLSAgLS0tLS0tLS0tXG4gICAqICAgMCAgICBMZW5ndGhcbiAgICogICAxICAgIE1hc3NcbiAgICogICAyICAgIFRpbWVcbiAgICogICAzICAgIEN1cnJlbnRcbiAgICogICA0ICAgIFRlbXBlcmF0dXJlXG4gICAqICAgNSAgICBMdW1pbm91cyBpbnRlbnNpdHlcbiAgICogICA2ICAgIEFtb3VudCBvZiBzdWJzdGFuY2VcbiAgICogICA3ICAgIEFuZ2xlXG4gICAqICAgOCAgICBCaXQgKGRpZ2l0YWwpXG4gICAqIEZvciBleGFtcGxlLCB0aGUgdW5pdCBcIjI5OC4xNSBLXCIgaXMgYSBwdXJlIHRlbXBlcmF0dXJlIGFuZCB3b3VsZCBoYXZlIGEgdmFsdWUgb2YgMjk4LjE1IGFuZCBhIGRpbWVuc2lvbiBhcnJheSBvZiBbMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMF0uIFRoZSB1bml0IFwiMSBjYWwgLyAoZ20gwrBDKVwiIGNhbiBiZSB3cml0dGVuIGluIHRlcm1zIG9mIHRoZSA5IGZ1bmRhbWVudGFsIGRpbWVuc2lvbnMgYXMgW2xlbmd0aF4yXSAvIChbdGltZV4yXSAqIFt0ZW1wZXJhdHVyZV0pLCBhbmQgd291bGQgYSB2YWx1ZSBvZiAoYWZ0ZXIgY29udmVyc2lvbiB0byBTSSkgNDE4NC4wIGFuZCBhIGRpbWVuc2lvbnMgYXJyYXkgb2YgWzIsIDAsIC0yLCAwLCAtMSwgMCwgMCwgMCwgMF0uXG4gICAqXG4gICAqL1xuXG4gIHZhciBCQVNFX0RJTUVOU0lPTlMgPSBbXCJNQVNTXCIsIFwiTEVOR1RIXCIsIFwiVElNRVwiLCBcIkNVUlJFTlRcIiwgXCJURU1QRVJBVFVSRVwiLCBcIkxVTUlOT1VTX0lOVEVOU0lUWVwiLCBcIkFNT1VOVF9PRl9TVUJTVEFOQ0VcIiwgXCJBTkdMRVwiLCBcIkJJVFwiXTtcblxuICB2YXIgQkFTRV9VTklUUyA9IHtcbiAgICBOT05FOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIE1BU1M6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgTEVOR1RIOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIFRJTUU6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgQ1VSUkVOVDoge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBURU1QRVJBVFVSRToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBMVU1JTk9VU19JTlRFTlNJVFk6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgQU1PVU5UX09GX1NVQlNUQU5DRToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDBdXG4gICAgfSxcblxuICAgIEZPUkNFOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMSwgLTIsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBTVVJGQUNFOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMiwgMCwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIFZPTFVNRToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDMsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBFTkVSR1k6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAyLCAtMiwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIFBPV0VSOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMiwgLTMsIDAsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBQUkVTU1VSRToge1xuICAgICAgZGltZW5zaW9uczogWzEsIC0xLCAtMiwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuXG4gICAgRUxFQ1RSSUNfQ0hBUkdFOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMCwgMSwgMSwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIEVMRUNUUklDX0NBUEFDSVRBTkNFOiB7XG4gICAgICBkaW1lbnNpb25zOiBbLTEsIC0yLCA0LCAyLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgRUxFQ1RSSUNfUE9URU5USUFMOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMSwgMiwgLTMsIC0xLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgRUxFQ1RSSUNfUkVTSVNUQU5DRToge1xuICAgICAgZGltZW5zaW9uczogWzEsIDIsIC0zLCAtMiwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIEVMRUNUUklDX0lORFVDVEFOQ0U6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAyLCAtMiwgLTIsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBFTEVDVFJJQ19DT05EVUNUQU5DRToge1xuICAgICAgZGltZW5zaW9uczogWy0xLCAtMiwgMywgMiwgMCwgMCwgMCwgMCwgMF1cbiAgICB9LFxuICAgIE1BR05FVElDX0ZMVVg6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAyLCAtMiwgLTEsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcbiAgICBNQUdORVRJQ19GTFVYX0RFTlNJVFk6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFsxLCAwLCAtMiwgLTEsIDAsIDAsIDAsIDAsIDBdXG4gICAgfSxcblxuICAgIEZSRVFVRU5DWToge1xuICAgICAgZGltZW5zaW9uczogWzAsIDAsIC0xLCAwLCAwLCAwLCAwLCAwLCAwXVxuICAgIH0sXG4gICAgQU5HTEU6IHtcbiAgICAgIGRpbWVuc2lvbnM6IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwXVxuICAgIH0sXG4gICAgQklUOiB7XG4gICAgICBkaW1lbnNpb25zOiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV1cbiAgICB9XG4gIH07XG5cbiAgZm9yKHZhciBrZXkgaW4gQkFTRV9VTklUUykge1xuICAgIEJBU0VfVU5JVFNba2V5XS5rZXkgPSBrZXk7XG4gIH1cblxuICB2YXIgQkFTRV9VTklUX05PTkUgPSB7fTtcblxuICB2YXIgVU5JVF9OT05FID0ge25hbWU6ICcnLCBiYXNlOiBCQVNFX1VOSVRfTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMCwgZGltZW5zaW9uczogWzAsMCwwLDAsMCwwLDAsMCwwXX07XG5cbiAgdmFyIFVOSVRTID0ge1xuICAgIC8vIGxlbmd0aFxuICAgIG1ldGVyOiB7XG4gICAgICBuYW1lOiAnbWV0ZXInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBpbmNoOiB7XG4gICAgICBuYW1lOiAnaW5jaCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDI1NCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZm9vdDoge1xuICAgICAgbmFtZTogJ2Zvb3QnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjMwNDgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHlhcmQ6IHtcbiAgICAgIG5hbWU6ICd5YXJkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC45MTQ0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtaWxlOiB7XG4gICAgICBuYW1lOiAnbWlsZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDE2MDkuMzQ0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBsaW5rOiB7XG4gICAgICBuYW1lOiAnbGluaycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMjAxMTY4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICByb2Q6IHtcbiAgICAgIG5hbWU6ICdyb2QnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA1LjAyOTIxMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY2hhaW46IHtcbiAgICAgIG5hbWU6ICdjaGFpbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDIwLjExNjgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGFuZ3N0cm9tOiB7XG4gICAgICBuYW1lOiAnYW5nc3Ryb20nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxZS0xMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICBtOiB7XG4gICAgICBuYW1lOiAnbScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAnaW4nOiB7XG4gICAgICBuYW1lOiAnaW4nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAyNTQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGZ0OiB7XG4gICAgICBuYW1lOiAnZnQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjMwNDgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHlkOiB7XG4gICAgICBuYW1lOiAneWQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjkxNDQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG1pOiB7XG4gICAgICBuYW1lOiAnbWknLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxNjA5LjM0NCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbGk6IHtcbiAgICAgIG5hbWU6ICdsaScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxFTkdUSCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMjAxMTY4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICByZDoge1xuICAgICAgbmFtZTogJ3JkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTEVOR1RILFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNS4wMjkyMTAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGNoOiB7XG4gICAgICBuYW1lOiAnY2gnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAyMC4xMTY4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtaWw6IHtcbiAgICAgIG5hbWU6ICdtaWwnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MRU5HVEgsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDAyNTQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxLzEwMDAgaW5jaFxuXG4gICAgLy8gU3VyZmFjZVxuICAgIG0yOiB7XG4gICAgICBuYW1lOiAnbTInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNRVUFSRUQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgc3Fpbjoge1xuICAgICAgbmFtZTogJ3NxaW4nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDA2NDUxNixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDY0NS4xNiBtbTJcbiAgICBzcWZ0OiB7XG4gICAgICBuYW1lOiAnc3FmdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjA5MjkwMzA0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMC4wOTI5MDMwNCBtMlxuICAgIHNxeWQ6IHtcbiAgICAgIG5hbWU6ICdzcXlkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuODM2MTI3MzYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAwLjgzNjEyNzM2IG0yXG4gICAgc3FtaToge1xuICAgICAgbmFtZTogJ3NxbWknLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMjU4OTk4OC4xMTAzMzYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAyLjU4OTk4ODExMDMzNiBrbTJcbiAgICBzcXJkOiB7XG4gICAgICBuYW1lOiAnc3FyZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlNVUkZBQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAyNS4yOTI5NSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDI1LjI5Mjk1IG0yXG4gICAgc3FjaDoge1xuICAgICAgbmFtZTogJ3NxY2gnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNDA0LjY4NzMsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA0MDQuNjg3MyBtMlxuICAgIHNxbWlsOiB7XG4gICAgICBuYW1lOiAnc3FtaWwnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNi40NTE2ZS0xMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDYuNDUxNiAqIDEwXi0xMCBtMlxuICAgIGFjcmU6IHtcbiAgICAgIG5hbWU6ICdhY3JlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuU1VSRkFDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDQwNDYuODYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA0MDQ2Ljg2IG0yXG4gICAgaGVjdGFyZToge1xuICAgICAgbmFtZTogJ2hlY3RhcmUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5TVVJGQUNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMTAwMDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxMDAwMCBtMlxuXG4gICAgLy8gVm9sdW1lXG4gICAgbTM6IHtcbiAgICAgIG5hbWU6ICdtMycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5DVUJJQyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBMOiB7XG4gICAgICBuYW1lOiAnTCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAwLjAwMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIGxpdHJlXG4gICAgbDoge1xuICAgICAgbmFtZTogJ2wnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMC4wMDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyBsaXRyZVxuICAgIGxpdHJlOiB7XG4gICAgICBuYW1lOiAnbGl0cmUnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAwLjAwMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY3Vpbjoge1xuICAgICAgbmFtZTogJ2N1aW4nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLjYzODcwNjRlLTUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxLjYzODcwNjRlLTUgbTNcbiAgICBjdWZ0OiB7XG4gICAgICBuYW1lOiAnY3VmdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDI4MzE2ODQ2NTkyLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMjguMzE2IDg0NiA1OTIgTFxuICAgIGN1eWQ6IHtcbiAgICAgIG5hbWU6ICdjdXlkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC43NjQ1NTQ4NTc5ODQsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyA3NjQuNTU0IDg1NyA5ODQgTFxuICAgIHRlYXNwb29uOiB7XG4gICAgICBuYW1lOiAndGVhc3Bvb24nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDAwNSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDUgbUxcbiAgICB0YWJsZXNwb29uOiB7XG4gICAgICBuYW1lOiAndGFibGVzcG9vbicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMDE1LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMTUgbUxcbiAgICAvL3tuYW1lOiAnY3VwJywgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLCB2YWx1ZTogMC4wMDAyNDAsIG9mZnNldDogMH0sIC8vIDI0MCBtTCAgLy8gbm90IHBvc3NpYmxlLCB3ZSBoYXZlIGFscmVhZHkgYW5vdGhlciBjdXBcbiAgICBkcm9wOiB7XG4gICAgICBuYW1lOiAnZHJvcCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDVlLTgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAgLy8gMC4wNSBtTCA9IDVlLTggbTNcbiAgICBndHQ6IHtcbiAgICAgIG5hbWU6ICdndHQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA1ZS04LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgIC8vIDAuMDUgbUwgPSA1ZS04IG0zXG5cbiAgICAvLyBMaXF1aWQgdm9sdW1lXG4gICAgbWluaW06IHtcbiAgICAgIG5hbWU6ICdtaW5pbScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMDAwMDYxNjExNTIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAwLjA2MTYxMTUyIG1MXG4gICAgZmx1aWRkcmFtOiB7XG4gICAgICBuYW1lOiAnZmx1aWRkcmFtJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDAwMDM2OTY2OTExLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgIC8vIDMuNjk2NjkxIG1MXG4gICAgZmx1aWRvdW5jZToge1xuICAgICAgbmFtZTogJ2ZsdWlkb3VuY2UnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDAyOTU3MzUzLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMjkuNTczNTMgbUxcbiAgICBnaWxsOiB7XG4gICAgICBuYW1lOiAnZ2lsbCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMTE4Mjk0MSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDExOC4yOTQxIG1MXG4gICAgY2M6IHtcbiAgICAgIG5hbWU6ICdjYycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDFlLTYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxZS02IExcbiAgICBjdXA6IHtcbiAgICAgIG5hbWU6ICdjdXAnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMDIzNjU4ODIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAyMzYuNTg4MiBtTFxuICAgIHBpbnQ6IHtcbiAgICAgIG5hbWU6ICdwaW50JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDA0NzMxNzY1LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gNDczLjE3NjUgbUxcbiAgICBxdWFydDoge1xuICAgICAgbmFtZTogJ3F1YXJ0JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDA5NDYzNTI5LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gOTQ2LjM1MjkgbUxcbiAgICBnYWxsb246IHtcbiAgICAgIG5hbWU6ICdnYWxsb24nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjAwMzc4NTQxMixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDMuNzg1NDEyIExcbiAgICBiZWVyYmFycmVsOiB7XG4gICAgICBuYW1lOiAnYmVlcmJhcnJlbCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMTE3MzQ3OCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDExNy4zNDc4IExcbiAgICBvaWxiYXJyZWw6IHtcbiAgICAgIG5hbWU6ICdvaWxiYXJyZWwnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5WT0xVTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAwLjE1ODk4NzMsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAxNTguOTg3MyBMXG4gICAgaG9nc2hlYWQ6IHtcbiAgICAgIG5hbWU6ICdob2dzaGVhZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMjM4NDgxMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDIzOC40ODEwIExcblxuICAgIC8ve25hbWU6ICdtaW4nLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjAwMDAwMDA2MTYxMTUyLCBvZmZzZXQ6IDB9LCAvLyAwLjA2MTYxMTUyIG1MIC8vIG1pbiBpcyBhbHJlYWR5IGluIHVzZSBhcyBtaW51dGVcbiAgICBmbGRyOiB7XG4gICAgICBuYW1lOiAnZmxkcicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMDAzNjk2NjkxMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sICAvLyAzLjY5NjY5MSBtTFxuICAgIGZsb3o6IHtcbiAgICAgIG5hbWU6ICdmbG96JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDAwMjk1NzM1MyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDI5LjU3MzUzIG1MXG4gICAgZ2k6IHtcbiAgICAgIG5hbWU6ICdnaScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMTE4Mjk0MSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDExOC4yOTQxIG1MXG4gICAgY3A6IHtcbiAgICAgIG5hbWU6ICdjcCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwMjM2NTg4MixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDIzNi41ODgyIG1MXG4gICAgcHQ6IHtcbiAgICAgIG5hbWU6ICdwdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwNDczMTc2NSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDQ3My4xNzY1IG1MXG4gICAgcXQ6IHtcbiAgICAgIG5hbWU6ICdxdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMDAwOTQ2MzUyOSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDk0Ni4zNTI5IG1MXG4gICAgZ2FsOiB7XG4gICAgICBuYW1lOiAnZ2FsJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4wMDM3ODU0MTIsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCAvLyAzLjc4NTQxMiBMXG4gICAgYmJsOiB7XG4gICAgICBuYW1lOiAnYmJsJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVk9MVU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMC4xMTczNDc4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSwgLy8gMTE3LjM0NzggTFxuICAgIG9ibDoge1xuICAgICAgbmFtZTogJ29ibCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDAuMTU4OTg3MyxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sIC8vIDE1OC45ODczIExcbiAgICAvL3tuYW1lOiAnaG9nc2hlYWQnLCBiYXNlOiBCQVNFX1VOSVRTLlZPTFVNRSwgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsIHZhbHVlOiAwLjIzODQ4MTAsIG9mZnNldDogMH0sIC8vIDIzOC40ODEwIEwgLy8gVE9ETzogaGg/XG5cbiAgICAvLyBNYXNzXG4gICAgZzoge1xuICAgICAgbmFtZTogJ2cnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDAuMDAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBncmFtOiB7XG4gICAgICBuYW1lOiAnZ3JhbScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAwLjAwMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICB0b246IHtcbiAgICAgIG5hbWU6ICd0b24nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDkwNy4xODQ3NCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgdG9ubmU6IHtcbiAgICAgIG5hbWU6ICd0b25uZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMTAwMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICBncmFpbjoge1xuICAgICAgbmFtZTogJ2dyYWluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDY0Ljc5ODkxZS02LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBkcmFtOiB7XG4gICAgICBuYW1lOiAnZHJhbScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLjc3MTg0NTE5NTMxMjVlLTMsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG91bmNlOiB7XG4gICAgICBuYW1lOiAnb3VuY2UnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMjguMzQ5NTIzMTI1ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBwb3VuZG1hc3M6IHtcbiAgICAgIG5hbWU6ICdwb3VuZG1hc3MnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNDUzLjU5MjM3ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBodW5kcmVkd2VpZ2h0OiB7XG4gICAgICBuYW1lOiAnaHVuZHJlZHdlaWdodCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA0NS4zNTkyMzcsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHN0aWNrOiB7XG4gICAgICBuYW1lOiAnc3RpY2snLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMTE1ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBzdG9uZToge1xuICAgICAgbmFtZTogJ3N0b25lJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFTUyxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDYuMzUwMjkzMTgsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgZ3I6IHtcbiAgICAgIG5hbWU6ICdncicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA2NC43OTg5MWUtNixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZHI6IHtcbiAgICAgIG5hbWU6ICdkcicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BU1MsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLjc3MTg0NTE5NTMxMjVlLTMsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG96OiB7XG4gICAgICBuYW1lOiAnb3onLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMjguMzQ5NTIzMTI1ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBsYm06IHtcbiAgICAgIG5hbWU6ICdsYm0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNDUzLjU5MjM3ZS0zLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBjd3Q6IHtcbiAgICAgIG5hbWU6ICdjd3QnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQVNTLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNDUuMzU5MjM3LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIFRpbWVcbiAgICBzOiB7XG4gICAgICBuYW1lOiAncycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbWluOiB7XG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDYwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBoOiB7XG4gICAgICBuYW1lOiAnaCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAzNjAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBzZWNvbmQ6IHtcbiAgICAgIG5hbWU6ICdzZWNvbmQnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgc2VjOiB7XG4gICAgICBuYW1lOiAnc2VjJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIG1pbnV0ZToge1xuICAgICAgbmFtZTogJ21pbnV0ZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA2MCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgaG91cjoge1xuICAgICAgbmFtZTogJ2hvdXInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMzYwMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZGF5OiB7XG4gICAgICBuYW1lOiAnZGF5JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDg2NDAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB3ZWVrOiB7XG4gICAgICBuYW1lOiAnd2VlaycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA3Kjg2NDAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtb250aDoge1xuICAgICAgbmFtZTogJ21vbnRoJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDI2Mjk4MDAsIC8vMS8xMnRoIG9mIEp1bGlhbiB5ZWFyXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHllYXI6IHtcbiAgICAgIG5hbWU6ICd5ZWFyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVElNRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDMxNTU3NjAwLCAvL0p1bGlhbiB5ZWFyXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGRlY2FkZToge1xuICAgICAgbmFtZTogJ3llYXInLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMzE1NTc2MDAwLCAvL0p1bGlhbiBkZWNhZGVcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY2VudHVyeToge1xuICAgICAgbmFtZTogJ2NlbnR1cnknLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5USU1FLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMzE1NTc2MDAwMCwgLy9KdWxpYW4gY2VudHVyeVxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtaWxsZW5uaXVtOiB7XG4gICAgICBuYW1lOiAnbWlsbGVubml1bScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRJTUUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAzMTU1NzYwMDAwMCwgLy9KdWxpYW4gbWlsbGVubml1bVxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIEZyZXF1ZW5jeVxuICAgIGhlcnR6OiB7XG4gICAgICBuYW1lOiAnSGVydHonLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5GUkVRVUVOQ1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgcmVjaXByb2NhbDogdHJ1ZVxuICAgIH0sXG4gICAgSHo6IHtcbiAgICAgIG5hbWU6ICdIeicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZSRVFVRU5DWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgcmVjaXByb2NhbDogdHJ1ZVxuICAgIH0sXG5cbiAgICAvLyBBbmdsZVxuICAgIHJhZDoge1xuICAgICAgbmFtZTogJ3JhZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLy8gZGVnID0gcmFkIC8gKDIqcGkpICogMzYwID0gcmFkIC8gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NjkyMzY5MDc2ODQ4ODhcbiAgICBkZWc6IHtcbiAgICAgIG5hbWU6ICdkZWcnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5BTkdMRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IG51bGwsIC8vIHdpbGwgYmUgZmlsbGVkIGluIGJ5IGNhbGN1bGF0ZUFuZ2xlVmFsdWVzKClcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLy8gZ3JhZCA9IHJhZCAvICgyKnBpKSAqIDQwMCAgPSByYWQgLyAwLjAxNTcwNzk2MzI2Nzk0ODk2NjE5MjMxMzIxNjkxNjM5OVxuICAgIGdyYWQ6IHtcbiAgICAgIG5hbWU6ICdncmFkJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuQU5HTEUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiBudWxsLCAvLyB3aWxsIGJlIGZpbGxlZCBpbiBieSBjYWxjdWxhdGVBbmdsZVZhbHVlcygpXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIGN5Y2xlID0gcmFkIC8gKDIqcGkpID0gcmFkIC8gNi4yODMxODUzMDcxNzk1ODY0NzY5MjUyODY3NjY1NzkzXG4gICAgY3ljbGU6IHtcbiAgICAgIG5hbWU6ICdjeWNsZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogbnVsbCwgLy8gd2lsbCBiZSBmaWxsZWQgaW4gYnkgY2FsY3VsYXRlQW5nbGVWYWx1ZXMoKVxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBhcmNzZWMgPSByYWQgLyAoMzYwMCAqICgzNjAgLyAyICogcGkpKSA9IHJhZCAvIDAuMDAwMDA0ODQ4MTM2ODExMDk1MzU5OTM1ODk5MTQxMDIzNTc5NVxuICAgIGFyY3NlYzoge1xuICAgICAgbmFtZTogJ2FyY3NlYycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFOR0xFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogbnVsbCwgLy8gd2lsbCBiZSBmaWxsZWQgaW4gYnkgY2FsY3VsYXRlQW5nbGVWYWx1ZXMoKVxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBhcmNtaW4gPSByYWQgLyAoNjAgKiAoMzYwIC8gMiAqIHBpKSkgPSByYWQgLyAwLjAwMDI5MDg4ODIwODY2NTcyMTU5NjE1Mzk0ODQ2MTQxNDc3XG4gICAgYXJjbWluOiB7XG4gICAgICBuYW1lOiAnYXJjbWluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuQU5HTEUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiBudWxsLCAvLyB3aWxsIGJlIGZpbGxlZCBpbiBieSBjYWxjdWxhdGVBbmdsZVZhbHVlcygpXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIFxuICAgIC8vIEVsZWN0cmljIGN1cnJlbnRcbiAgICBBOiB7XG4gICAgICBuYW1lOiAnQScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkNVUlJFTlQsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgYW1wZXJlOiB7XG4gICAgICBuYW1lOiAnYW1wZXJlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuQ1VSUkVOVCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgLy8gVGVtcGVyYXR1cmVcbiAgICAvLyBLKEMpID0gwrBDICsgMjczLjE1XG4gICAgLy8gSyhGKSA9ICjCsEYgKyA0NTkuNjcpIC8gMS44XG4gICAgLy8gSyhSKSA9IMKwUiAvIDEuOFxuICAgIEs6IHtcbiAgICAgIG5hbWU6ICdLJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVEVNUEVSQVRVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBkZWdDOiB7XG4gICAgICBuYW1lOiAnZGVnQycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMjczLjE1XG4gICAgfSxcbiAgICBkZWdGOiB7XG4gICAgICBuYW1lOiAnZGVnRicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSAvIDEuOCxcbiAgICAgIG9mZnNldDogNDU5LjY3XG4gICAgfSxcbiAgICBkZWdSOiB7XG4gICAgICBuYW1lOiAnZGVnUicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSAvIDEuOCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAga2VsdmluOiB7XG4gICAgICBuYW1lOiAna2VsdmluJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuVEVNUEVSQVRVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBjZWxzaXVzOiB7XG4gICAgICBuYW1lOiAnY2Vsc2l1cycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMjczLjE1XG4gICAgfSxcbiAgICBmYWhyZW5oZWl0OiB7XG4gICAgICBuYW1lOiAnZmFocmVuaGVpdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSAvIDEuOCxcbiAgICAgIG9mZnNldDogNDU5LjY3XG4gICAgfSxcbiAgICByYW5raW5lOiB7XG4gICAgICBuYW1lOiAncmFua2luZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlRFTVBFUkFUVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMSAvIDEuOCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICAvLyBhbW91bnQgb2Ygc3Vic3RhbmNlXG4gICAgbW9sOiB7XG4gICAgICBuYW1lOiAnbW9sJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuQU1PVU5UX09GX1NVQlNUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtb2xlOiB7XG4gICAgICBuYW1lOiAnbW9sZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkFNT1VOVF9PRl9TVUJTVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIGx1bWlub3VzIGludGVuc2l0eVxuICAgIGNkOiB7XG4gICAgICBuYW1lOiAnY2QnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5MVU1JTk9VU19JTlRFTlNJVFksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBjYW5kZWxhOiB7XG4gICAgICBuYW1lOiAnY2FuZGVsYScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkxVTUlOT1VTX0lOVEVOU0lUWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIFRPRE86IHVuaXRzIFNURVJBRElBTlxuICAgIC8ve25hbWU6ICdzcicsIGJhc2U6IEJBU0VfVU5JVFMuU1RFUkFESUFOLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG4gICAgLy97bmFtZTogJ3N0ZXJhZGlhbicsIGJhc2U6IEJBU0VfVU5JVFMuU1RFUkFESUFOLCBwcmVmaXhlczogUFJFRklYRVMuTk9ORSwgdmFsdWU6IDEsIG9mZnNldDogMH0sXG5cbiAgICAvLyBGb3JjZVxuICAgIE46IHtcbiAgICAgIG5hbWU6ICdOJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRk9SQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbmV3dG9uOiB7XG4gICAgICBuYW1lOiAnbmV3dG9uJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRk9SQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBkeW46IHtcbiAgICAgIG5hbWU6ICdkeW4nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5GT1JDRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAwLjAwMDAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBkeW5lOiB7XG4gICAgICBuYW1lOiAnZHluZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMC4wMDAwMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbGJmOiB7XG4gICAgICBuYW1lOiAnbGJmJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRk9SQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA0LjQ0ODIyMTYxNTI2MDUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHBvdW5kZm9yY2U6IHtcbiAgICAgIG5hbWU6ICdwb3VuZGZvcmNlJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRk9SQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA0LjQ0ODIyMTYxNTI2MDUsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGtpcDoge1xuICAgICAgbmFtZTogJ2tpcCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkZPUkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogNDQ0OC4yMjE2LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblx0XG4gICAgLy8gRW5lcmd5XG4gICAgSjoge1xuICAgICAgbmFtZTogJ0onLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTkVSR1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgam91bGU6IHtcbiAgICAgIG5hbWU6ICdqb3VsZScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVORVJHWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBlcmc6IHtcbiAgICAgIG5hbWU6ICdlcmcnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTkVSR1ksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxZS01LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBXaDoge1xuICAgICAgbmFtZTogJ1doJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRU5FUkdZLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDM2MDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIEJUVToge1xuICAgICAgbmFtZTogJ0JUVScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVORVJHWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5CVFUsXG4gICAgICB2YWx1ZTogMTA1NS4wNTU4NTI2MixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZVY6IHtcbiAgICAgIG5hbWU6ICdlVicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVORVJHWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLjYwMjE3NjU2NWUtMTksXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIGVsZWN0cm9udm9sdDoge1xuICAgICAgbmFtZTogJ2VsZWN0cm9udm9sdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVORVJHWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEuNjAyMTc2NTY1ZS0xOSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cblxuICAgIC8vIFBvd2VyXG4gICAgVzoge1xuICAgICAgbmFtZTogJ1cnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QT1dFUixcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB3YXR0OiB7XG4gICAgICBuYW1lOiAnVycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBPV0VSLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgaHA6IHtcbiAgICAgIG5hbWU6ICdocCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBPV0VSLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogNzQ1LjY5OTg3MTUzODYsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgLy8gRWxlY3RyaWNhbCBwb3dlciB1bml0c1xuICAgIFZBUjoge1xuICAgICAgbmFtZTogJ1ZBUicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBPV0VSLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IENvbXBsZXguSSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgXG4gICAgVkE6IHtcbiAgICAgIG5hbWU6ICdWQScsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBPV0VSLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgLy8gUHJlc3N1cmVcbiAgICBQYToge1xuICAgICAgbmFtZTogJ1BhJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuUFJFU1NVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuU0hPUlQsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgcHNpOiB7XG4gICAgICBuYW1lOiAncHNpJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuUFJFU1NVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiA2ODk0Ljc1NzI5Mjc2NDU5LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBhdG06IHtcbiAgICAgIG5hbWU6ICdhdG0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5QUkVTU1VSRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5OT05FLFxuICAgICAgdmFsdWU6IDEwMTMyNSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICBuYW1lOiAnYmFyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuUFJFU1NVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxMDAwMDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHRvcnI6IHtcbiAgICAgIG5hbWU6ICd0b3JyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuUFJFU1NVUkUsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTk9ORSxcbiAgICAgIHZhbHVlOiAxMzMuMzIyLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBtbUhnOiB7XG4gICAgICBuYW1lOiAnbW1IZycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogMTMzLjMyMixcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgbW1IMk86IHtcbiAgICAgIG5hbWU6ICdtbUgyTycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogOS44MDY2NSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgY21IMk86IHtcbiAgICAgIG5hbWU6ICdjbUgyTycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLlBSRVNTVVJFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLk5PTkUsXG4gICAgICB2YWx1ZTogOTguMDY2NSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG5cbiAgICAvLyBFbGVjdHJpYyBjaGFyZ2VcbiAgICBjb3Vsb21iOiB7XG4gICAgICBuYW1lOiAnY291bG9tYicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0NIQVJHRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIEM6IHtcbiAgICAgIG5hbWU6ICdDJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfQ0hBUkdFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIEVsZWN0cmljIGNhcGFjaXRhbmNlXG4gICAgZmFyYWQ6IHtcbiAgICAgIG5hbWU6ICdmYXJhZCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0NBUEFDSVRBTkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkxPTkcsXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgRjoge1xuICAgICAgbmFtZTogJ0YnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTEVDVFJJQ19DQVBBQ0lUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBFbGVjdHJpYyBwb3RlbnRpYWxcbiAgICB2b2x0OiB7XG4gICAgICBuYW1lOiAndm9sdCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX1BPVEVOVElBTCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIFY6IHtcbiAgICAgIG5hbWU6ICdWJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfUE9URU5USUFMLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIEVsZWN0cmljIHJlc2lzdGFuY2VcbiAgICBvaG06IHtcbiAgICAgIG5hbWU6ICdvaG0nLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5FTEVDVFJJQ19SRVNJU1RBTkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JUTE9ORywgICAgLy8gQm90aCBNb2htIGFuZCBtZWdhb2htIGFyZSBhY2NlcHRhYmxlXG4gICAgICB2YWx1ZTogMSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgLypcbiAgICAgKiBVbmljb2RlIGJyZWFrcyBpbiBicm93c2VycyBpZiBjaGFyc2V0IGlzIG5vdCBzcGVjaWZpZWRcbiAgICDOqToge1xuICAgICAgbmFtZTogJ86pJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfUkVTSVNUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAqL1xuICAgIC8vIEVsZWN0cmljIGluZHVjdGFuY2VcbiAgICBoZW5yeToge1xuICAgICAgbmFtZTogJ2hlbnJ5JyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfSU5EVUNUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIEg6IHtcbiAgICAgIG5hbWU6ICdIJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfSU5EVUNUQU5DRSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICAvLyBFbGVjdHJpYyBjb25kdWN0YW5jZVxuICAgIHNpZW1lbnM6IHtcbiAgICAgIG5hbWU6ICdzaWVtZW5zJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuRUxFQ1RSSUNfQ09ORFVDVEFOQ0UsXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBTOiB7XG4gICAgICBuYW1lOiAnUycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkVMRUNUUklDX0NPTkRVQ1RBTkNFLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIE1hZ25ldGljIGZsdXhcbiAgICB3ZWJlcjoge1xuICAgICAgbmFtZTogJ3dlYmVyJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuTUFHTkVUSUNfRkxVWCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5MT05HLFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIFdiOiB7XG4gICAgICBuYW1lOiAnV2InLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQUdORVRJQ19GTFVYLFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLlNIT1JULFxuICAgICAgdmFsdWU6IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIC8vIE1hZ25ldGljIGZsdXggZGVuc2l0eVxuICAgIHRlc2xhOiB7XG4gICAgICBuYW1lOiAndGVzbGEnLFxuICAgICAgYmFzZTogQkFTRV9VTklUUy5NQUdORVRJQ19GTFVYX0RFTlNJVFksXG4gICAgICBwcmVmaXhlczogUFJFRklYRVMuTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBUOiB7XG4gICAgICBuYW1lOiAnVCcsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLk1BR05FVElDX0ZMVVhfREVOU0lUWSxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcblxuICAgIC8vIEJpbmFyeVxuICAgIGI6IHtcbiAgICAgIG5hbWU6ICdiJyxcbiAgICAgIGJhc2U6IEJBU0VfVU5JVFMuQklULFxuICAgICAgcHJlZml4ZXM6IFBSRUZJWEVTLkJJTkFSWV9TSE9SVCxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBiaXRzOiB7XG4gICAgICBuYW1lOiAnYml0cycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkJJVCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5CSU5BUllfTE9ORyxcbiAgICAgIHZhbHVlOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBCOiB7XG4gICAgICBuYW1lOiAnQicsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkJJVCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5CSU5BUllfU0hPUlQsXG4gICAgICB2YWx1ZTogOCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgYnl0ZXM6IHtcbiAgICAgIG5hbWU6ICdieXRlcycsXG4gICAgICBiYXNlOiBCQVNFX1VOSVRTLkJJVCxcbiAgICAgIHByZWZpeGVzOiBQUkVGSVhFUy5CSU5BUllfTE9ORyxcbiAgICAgIHZhbHVlOiA4LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9O1xuXG4gIC8vIGFsaWFzZXMgKGZvcm1lcmx5IHBsdXJhbHMpXG4gIHZhciBBTElBU0VTID0ge1xuICAgIG1ldGVyczogJ21ldGVyJyxcbiAgICBpbmNoZXM6ICdpbmNoJyxcbiAgICBmZWV0OiAnZm9vdCcsXG4gICAgeWFyZHM6ICd5YXJkJyxcbiAgICBtaWxlczogJ21pbGUnLFxuICAgIGxpbmtzOiAnbGluaycsXG4gICAgcm9kczogJ3JvZCcsXG4gICAgY2hhaW5zOiAnY2hhaW4nLFxuICAgIGFuZ3N0cm9tczogJ2FuZ3N0cm9tJyxcblxuICAgIGx0OiAnbCcsXG4gICAgbGl0cmVzOiAnbGl0cmUnLFxuICAgIGxpdGVyOiAnbGl0cmUnLFxuICAgIGxpdGVyczogJ2xpdHJlJyxcbiAgICB0ZWFzcG9vbnM6ICd0ZWFzcG9vbicsXG4gICAgdGFibGVzcG9vbnM6ICd0YWJsZXNwb29uJyxcbiAgICBtaW5pbXM6ICdtaW5pbScsXG4gICAgZmx1aWRkcmFtczogJ2ZsdWlkZHJhbScsXG4gICAgZmx1aWRvdW5jZXM6ICdmbHVpZG91bmNlJyxcbiAgICBnaWxsczogJ2dpbGwnLFxuICAgIGN1cHM6ICdjdXAnLFxuICAgIHBpbnRzOiAncGludCcsXG4gICAgcXVhcnRzOiAncXVhcnQnLFxuICAgIGdhbGxvbnM6ICdnYWxsb24nLFxuICAgIGJlZXJiYXJyZWxzOiAnYmVlcmJhcnJlbCcsXG4gICAgb2lsYmFycmVsczogJ29pbGJhcnJlbCcsXG4gICAgaG9nc2hlYWRzOiAnaG9nc2hlYWQnLFxuICAgIGd0dHM6ICdndHQnLFxuXG4gICAgZ3JhbXM6ICdncmFtJyxcbiAgICB0b25zOiAndG9uJyxcbiAgICB0b25uZXM6ICd0b25uZScsXG4gICAgZ3JhaW5zOiAnZ3JhaW4nLFxuICAgIGRyYW1zOiAnZHJhbScsXG4gICAgb3VuY2VzOiAnb3VuY2UnLFxuICAgIHBvdW5kbWFzc2VzOiAncG91bmRtYXNzJyxcbiAgICBodW5kcmVkd2VpZ2h0czogJ2h1bmRyZWR3ZWlnaHQnLFxuICAgIHN0aWNrczogJ3N0aWNrJyxcbiAgICBsYjogJ2xibScsXG4gICAgbGJzOiAnbGJtJyxcblx0XG4gICAga2lwczogJ2tpcCcsXG5cbiAgICBhY3JlczogJ2FjcmUnLFxuICAgIGhlY3RhcmVzOiAnaGVjdGFyZScsXG4gICAgc3FmZWV0OiAnc3FmdCcsXG4gICAgc3F5YXJkOiAnc3F5ZCcsXG4gICAgc3FtaWxlOiAnc3FtaScsXG4gICAgc3FtaWxlczogJ3NxbWknLFxuXG4gICAgbW1oZzogJ21tSGcnLFxuICAgIG1taDJvOiAnbW1IMk8nLFxuICAgIGNtaDJvOiAnY21IMk8nLFxuXG4gICAgc2Vjb25kczogJ3NlY29uZCcsXG4gICAgc2VjczogJ3NlY29uZCcsXG4gICAgbWludXRlczogJ21pbnV0ZScsXG4gICAgbWluczogJ21pbnV0ZScsXG4gICAgaG91cnM6ICdob3VyJyxcbiAgICBocjogJ2hvdXInLFxuICAgIGhyczogJ2hvdXInLFxuICAgIGRheXM6ICdkYXknLFxuICAgIHdlZWtzOiAnd2VlaycsXG4gICAgbW9udGhzOiAnbW9udGgnLFxuICAgIHllYXJzOiAneWVhcicsXG5cbiAgICBoZXJ0ejogJ2hlcnR6JyxcblxuICAgIHJhZGlhbnM6ICdyYWQnLFxuICAgIGRlZ3JlZTogJ2RlZycsXG4gICAgZGVncmVlczogJ2RlZycsXG4gICAgZ3JhZGlhbjogJ2dyYWQnLFxuICAgIGdyYWRpYW5zOiAnZ3JhZCcsXG4gICAgY3ljbGVzOiAnY3ljbGUnLFxuICAgIGFyY3NlY29uZDogJ2FyY3NlYycsXG4gICAgYXJjc2Vjb25kczogJ2FyY3NlYycsXG4gICAgYXJjbWludXRlOiAnYXJjbWluJyxcbiAgICBhcmNtaW51dGVzOiAnYXJjbWluJyxcblxuICAgIEJUVXM6ICdCVFUnLFxuICAgIHdhdHRzOiAnd2F0dCcsXG4gICAgam91bGVzOiAnam91bGUnLFxuXG4gICAgYW1wZXJlczogJ2FtcGVyZScsXG4gICAgY291bG9tYnM6ICdjb3Vsb21iJyxcbiAgICB2b2x0czogJ3ZvbHQnLFxuICAgIG9obXM6ICdvaG0nLFxuICAgIGZhcmFkczogJ2ZhcmFkJyxcbiAgICB3ZWJlcnM6ICd3ZWJlcicsXG4gICAgdGVzbGFzOiAndGVzbGEnLFxuICAgIGVsZWN0cm9udm9sdHM6ICdlbGVjdHJvbnZvbHQnLFxuICAgIG1vbGVzOiAnbW9sZSdcblxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHZhbHVlcyBmb3IgdGhlIGFuZ2xlIHVuaXRzLlxuICAgKiBWYWx1ZSBpcyBjYWxjdWxhdGVkIGFzIG51bWJlciBvciBCaWdOdW1iZXIgZGVwZW5kaW5nIG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7e251bWJlcjogJ251bWJlcicgfCAnQmlnTnVtYmVyJ319IGNvbmZpZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlQW5nbGVWYWx1ZXMgKGNvbmZpZykge1xuICAgIGlmIChjb25maWcubnVtYmVyID09PSAnQmlnTnVtYmVyJykge1xuICAgICAgdmFyIHBpID0gY29uc3RhbnRzLnBpKHR5cGUuQmlnTnVtYmVyKTtcbiAgICAgIFVOSVRTLnJhZC52YWx1ZSA9IG5ldyB0eXBlLkJpZ051bWJlcigxKTtcbiAgICAgIFVOSVRTLmRlZy52YWx1ZSA9IHBpLmRpdigxODApOyAgICAgICAgLy8gMiAqIHBpIC8gMzYwO1xuICAgICAgVU5JVFMuZ3JhZC52YWx1ZSA9IHBpLmRpdigyMDApOyAgICAgICAvLyAyICogcGkgLyA0MDA7XG4gICAgICBVTklUUy5jeWNsZS52YWx1ZSA9IHBpLnRpbWVzKDIpOyAgICAgIC8vIDIgKiBwaVxuICAgICAgVU5JVFMuYXJjc2VjLnZhbHVlID0gcGkuZGl2KDY0ODAwMCk7ICAvLyAyICogcGkgLyAzNjAgLyAzNjAwXG4gICAgICBVTklUUy5hcmNtaW4udmFsdWUgPSBwaS5kaXYoMTA4MDApOyAgIC8vIDIgKiBwaSAvIDM2MCAvIDYwXG4gICAgfVxuICAgIGVsc2UgeyAvLyBudW1iZXJcbiAgICAgIFVOSVRTLnJhZC52YWx1ZSA9IDE7XG4gICAgICBVTklUUy5kZWcudmFsdWUgPSBNYXRoLlBJIC8gMTgwOyAgICAgICAgLy8gMiAqIHBpIC8gMzYwO1xuICAgICAgVU5JVFMuZ3JhZC52YWx1ZSA9IE1hdGguUEkgLyAyMDA7ICAgICAgIC8vIDIgKiBwaSAvIDQwMDtcbiAgICAgIFVOSVRTLmN5Y2xlLnZhbHVlID0gTWF0aC5QSSAqIDI7ICAgICAgICAvLyAyICogcGlcbiAgICAgIFVOSVRTLmFyY3NlYy52YWx1ZSA9IE1hdGguUEkgLyA2NDgwMDA7ICAvLyAyICogcGkgLyAzNjAgLyAzNjAwO1xuICAgICAgVU5JVFMuYXJjbWluLnZhbHVlID0gTWF0aC5QSSAvIDEwODAwOyAgIC8vIDIgKiBwaSAvIDM2MCAvIDYwO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFwcGx5IHRoZSBhbmdsZSB2YWx1ZXMgbm93XG4gIGNhbGN1bGF0ZUFuZ2xlVmFsdWVzKGNvbmZpZyk7XG5cbiAgLy8gcmVjYWxjdWxhdGUgdGhlIHZhbHVlcyBvbiBjaGFuZ2Ugb2YgY29uZmlndXJhdGlvblxuICBtYXRoLm9uKCdjb25maWcnLCBmdW5jdGlvbiAoY3VyciwgcHJldikge1xuICAgIGlmIChjdXJyLm51bWJlciAhPT0gcHJldi5udW1iZXIpIHtcbiAgICAgIGNhbGN1bGF0ZUFuZ2xlVmFsdWVzKGN1cnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEEgdW5pdCBzeXN0ZW0gaXMgYSBzZXQgb2YgZGltZW5zaW9uYWxseSBpbmRlcGVuZGVudCBiYXNlIHVuaXRzIHBsdXMgYSBzZXQgb2YgZGVyaXZlZCB1bml0cywgZm9ybWVkIGJ5IG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpc2lvbiBvZiB0aGUgYmFzZSB1bml0cywgdGhhdCBhcmUgYnkgY29udmVudGlvbiB1c2VkIHdpdGggdGhlIHVuaXQgc3lzdGVtLlxuICAgKiBBIHVzZXIgcGVyaGFwcyBjb3VsZCBpc3N1ZSBhIGNvbW1hbmQgdG8gc2VsZWN0IGEgcHJlZmVycmVkIHVuaXQgc3lzdGVtLCBvciB1c2UgdGhlIGRlZmF1bHQgKHNlZSBiZWxvdykuXG4gICAqIEF1dG8gdW5pdCBzeXN0ZW06IFRoZSBkZWZhdWx0IHVuaXQgc3lzdGVtIGlzIHVwZGF0ZWQgb24gdGhlIGZseSBhbnl0aW1lIGEgdW5pdCBpcyBwYXJzZWQuIFRoZSBjb3JyZXNwb25kaW5nIHVuaXQgaW4gdGhlIGRlZmF1bHQgdW5pdCBzeXN0ZW0gaXMgdXBkYXRlZCwgc28gdGhhdCBhbnN3ZXJzIGFyZSBnaXZlbiBpbiB0aGUgc2FtZSB1bml0cyB0aGUgdXNlciBzdXBwbGllcy5cbiAgICovXG4gIHZhciBVTklUX1NZU1RFTVMgPSB7XG4gICAgc2k6IHtcbiAgICAgIC8vIEJhc2UgdW5pdHNcbiAgICAgIE5PTkU6ICAgICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRfTk9ORSwgcHJlZml4OiBQUkVGSVhFUy5OT05FWycnXX0sXG4gICAgICBMRU5HVEg6ICAgICAgICAgICAgICAgIHt1bml0OiBVTklUUy5tLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIE1BU1M6ICAgICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLmcsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnayddfSwgXG4gICAgICBUSU1FOiAgICAgICAgICAgICAgICAgIHt1bml0OiBVTklUUy5zLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG4gICAgICBDVVJSRU5UOiAgICAgICAgICAgICAgIHt1bml0OiBVTklUUy5BLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG4gICAgICBURU1QRVJBVFVSRTogICAgICAgICAgIHt1bml0OiBVTklUUy5LLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG4gICAgICBMVU1JTk9VU19JTlRFTlNJVFk6ICAgIHt1bml0OiBVTklUUy5jZCwgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG4gICAgICBBTU9VTlRfT0ZfU1VCU1RBTkNFOiAgIHt1bml0OiBVTklUUy5tb2wsIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG4gICAgICBBTkdMRTogICAgICAgICAgICAgICAgIHt1bml0OiBVTklUUy5yYWQsIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG4gICAgICBCSVQ6ICAgICAgICAgICAgICAgICAgIHt1bml0OiBVTklUUy5iaXQsIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSwgXG5cbiAgICAgIC8vIERlcml2ZWQgdW5pdHNcbiAgICAgIEZPUkNFOiAgICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLk4sICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LCBcbiAgICAgIEVORVJHWTogICAgICAgICAgICAgICAge3VuaXQ6IFVOSVRTLkosICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgUE9XRVI6ICAgICAgICAgICAgICAgICB7dW5pdDogVU5JVFMuVywgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBQUkVTU1VSRTogICAgICAgICAgICAgIHt1bml0OiBVTklUUy5QYSwgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIEVMRUNUUklDX0NIQVJHRTogICAgICAge3VuaXQ6IFVOSVRTLkMsICAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgRUxFQ1RSSUNfQ0FQQUNJVEFOQ0U6ICB7dW5pdDogVU5JVFMuRiwgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBFTEVDVFJJQ19QT1RFTlRJQUw6ICAgIHt1bml0OiBVTklUUy5WLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIEVMRUNUUklDX1JFU0lTVEFOQ0U6ICAge3VuaXQ6IFVOSVRTLm9obSwgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgRUxFQ1RSSUNfSU5EVUNUQU5DRTogICB7dW5pdDogVU5JVFMuSCwgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBFTEVDVFJJQ19DT05EVUNUQU5DRTogIHt1bml0OiBVTklUUy5TLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfSxcbiAgICAgIE1BR05FVElDX0ZMVVg6ICAgICAgICAge3VuaXQ6IFVOSVRTLldiLCAgcHJlZml4OiBQUkVGSVhFUy5TSE9SVFsnJ119LFxuICAgICAgTUFHTkVUSUNfRkxVWF9ERU5TSVRZOiB7dW5pdDogVU5JVFMuVCwgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX0sXG4gICAgICBGUkVRVUVOQ1k6ICAgICAgICAgICAgIHt1bml0OiBVTklUUy5IeiwgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfVxuICAgIH1cbiAgfTtcblxuICAvLyBDbG9uZSB0byBjcmVhdGUgdGhlIG90aGVyIHVuaXQgc3lzdGVtc1xuICBVTklUX1NZU1RFTVMuY2dzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShVTklUX1NZU1RFTVMuc2kpKTtcbiAgVU5JVF9TWVNURU1TLmNncy5MRU5HVEggPSB7dW5pdDogVU5JVFMubSwgICBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWydjJ119O1xuICBVTklUX1NZU1RFTVMuY2dzLk1BU1MgPSAgIHt1bml0OiBVTklUUy5nLCAgIHByZWZpeDogUFJFRklYRVMuU0hPUlRbJyddfTtcbiAgVU5JVF9TWVNURU1TLmNncy5GT1JDRSA9ICB7dW5pdDogVU5JVFMuZHluLCBwcmVmaXg6IFBSRUZJWEVTLlNIT1JUWycnXX07XG4gIFVOSVRfU1lTVEVNUy5jZ3MuRU5FUkdZID0ge3VuaXQ6IFVOSVRTLmVyZywgcHJlZml4OiBQUkVGSVhFUy5OT05FWycnXX07XG4gIC8vIHRoZXJlIGFyZSB3aG9sbHkgNCB1bmlxdWUgY2dzIHN5c3RlbXMgZm9yIGVsZWN0cmljaXR5IGFuZCBtYWduZXRpc20sXG4gIC8vIHNvIGxldCdzIG5vdCB3b3JyeSBhYm91dCBpdCB1bmxlc3Mgc29tZWJvZHkgY29tcGxhaW5zXG4gIFxuICBVTklUX1NZU1RFTVMudXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFVOSVRfU1lTVEVNUy5zaSkpO1xuICBVTklUX1NZU1RFTVMudXMuTEVOR1RIID0gICAgICB7dW5pdDogVU5JVFMuZnQsICAgcHJlZml4OiBQUkVGSVhFUy5OT05FWycnXX07XG4gIFVOSVRfU1lTVEVNUy51cy5NQVNTID0gICAgICAgIHt1bml0OiBVTklUUy5sYm0sICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfTtcbiAgVU5JVF9TWVNURU1TLnVzLlRFTVBFUkFUVVJFID0ge3VuaXQ6IFVOSVRTLmRlZ0YsIHByZWZpeDogUFJFRklYRVMuTk9ORVsnJ119O1xuICBVTklUX1NZU1RFTVMudXMuRk9SQ0UgPSAgICAgICB7dW5pdDogVU5JVFMubGJmLCAgcHJlZml4OiBQUkVGSVhFUy5OT05FWycnXX07XG4gIFVOSVRfU1lTVEVNUy51cy5FTkVSR1kgPSAgICAgIHt1bml0OiBVTklUUy5CVFUsICBwcmVmaXg6IFBSRUZJWEVTLkJUVVsnJ119O1xuICBVTklUX1NZU1RFTVMudXMuUE9XRVIgPSAgICAgICB7dW5pdDogVU5JVFMuaHAsICAgcHJlZml4OiBQUkVGSVhFUy5OT05FWycnXX07XG4gIFVOSVRfU1lTVEVNUy51cy5QUkVTU1VSRSA9ICAgIHt1bml0OiBVTklUUy5wc2ksICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddfTtcblxuICAvLyBBZGQgYWRkaXRpb25hbCB1bml0IHN5c3RlbXMgaGVyZS5cblxuXG5cbiAgLy8gQ2hvb3NlIGEgdW5pdCBzeXN0ZW0gdG8gc2VlZCB0aGUgYXV0byB1bml0IHN5c3RlbS5cbiAgVU5JVF9TWVNURU1TLmF1dG8gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFVOSVRfU1lTVEVNUy5zaSkpO1xuXG4gIC8vIFNldCB0aGUgY3VycmVudCB1bml0IHN5c3RlbVxuICB2YXIgY3VycmVudFVuaXRTeXN0ZW0gPSBVTklUX1NZU1RFTVMuYXV0bztcblxuICAvKipcbiAgICogU2V0IGEgdW5pdCBzeXN0ZW0gZm9yIGZvcm1hdHRpbmcgZGVyaXZlZCB1bml0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSBUaGUgbmFtZSBvZiB0aGUgdW5pdCBzeXN0ZW0uXG4gICAqL1xuICBVbml0LnNldFVuaXRTeXN0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYoVU5JVF9TWVNURU1TLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjdXJyZW50VW5pdFN5c3RlbSA9IFVOSVRfU1lTVEVNU1tuYW1lXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaXQgc3lzdGVtICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdC4gQ2hvaWNlcyBhcmU6ICcgKyBPYmplY3Qua2V5cyhVTklUX1NZU1RFTVMpLmpvaW4oJywgJykpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHVuaXQgc3lzdGVtLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW50IHVuaXQgc3lzdGVtLlxuICAgKi9cbiAgVW5pdC5nZXRVbml0U3lzdGVtID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciBrZXkgaW4gVU5JVF9TWVNURU1TKSB7XG4gICAgICBpZihVTklUX1NZU1RFTVNba2V5XSA9PT0gY3VycmVudFVuaXRTeXN0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRlcnMgdG8gY29udmVydCBmcm9tIG51bWJlciB0byBhbiBvdGhlciBudW1lcmljIHR5cGUgbGlrZSBCaWdOdW1iZXJcbiAgICogb3IgRnJhY3Rpb25cbiAgICovXG4gIFVuaXQudHlwZUNvbnZlcnRlcnMgPSB7XG4gICAgQmlnTnVtYmVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlLkJpZ051bWJlcih4ICsgJycpOyAvLyBzdHJpbmdpZnkgdG8gcHJldmVudCBjb25zdHJ1Y3RvciBlcnJvclxuICAgIH0sXG5cbiAgICBGcmFjdGlvbjogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZS5GcmFjdGlvbih4KTtcbiAgICB9LFxuXG4gICAgQ29tcGxleDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICBudW1iZXI6IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSByaWdodCBjb252ZXJ0b3IgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB3aXRoIHRoZSB0eXBlXG4gICAqIG9mIHByb3ZpZGVkIGV4YW1wbGVWYWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgICBBIHN0cmluZyAnbnVtYmVyJywgJ0JpZ051bWJlcicsIG9yICdGcmFjdGlvbidcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBJbiBjYXNlIG9mIGFuIHVua25vd24gdHlwZSxcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBVbml0Ll9nZXROdW1iZXJDb252ZXJ0ZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICghVW5pdC50eXBlQ29udmVydGVyc1t0eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFVuaXQudHlwZUNvbnZlcnRlcnNbdHlwZV07XG4gIH07XG5cbiAgLy8gQWRkIGRpbWVuc2lvbnMgdG8gZWFjaCBidWlsdC1pbiB1bml0XG4gIGZvciAodmFyIGtleSBpbiBVTklUUykge1xuICAgIHZhciB1bml0ID0gVU5JVFNba2V5XTtcbiAgICB1bml0LmRpbWVuc2lvbnMgPSB1bml0LmJhc2UuZGltZW5zaW9ucztcbiAgfSAgICBcblxuICAvLyBDcmVhdGUgYWxpYXNlc1xuICBmb3IgKHZhciBuYW1lIGluIEFMSUFTRVMpIHtcbiAgICBpZihBTElBU0VTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB2YXIgdW5pdCA9IFVOSVRTW0FMSUFTRVNbbmFtZV1dO1xuICAgICAgdmFyIGFsaWFzID0ge307XG4gICAgICBmb3IodmFyIGtleSBpbiB1bml0KSB7XG4gICAgICAgIGlmKHVuaXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGFsaWFzW2tleV0gPSB1bml0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFsaWFzLm5hbWUgPSBuYW1lO1xuICAgICAgVU5JVFNbbmFtZV0gPSBhbGlhcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRVbml0TmFtZUlzVmFsaWQobmFtZSkge1xuICAgIGZvcih2YXIgaT0wOyBpPG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbmFtZS5jaGFyQXQoaSk7XG4gICAgICAgXG4gICAgICB2YXIgaXNWYWxpZEFscGhhID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIC9eW2EtekEtWl0kLy50ZXN0KHApO1xuICAgICAgfTtcblxuICAgICAgdmFyIGlzRGlnaXQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gKGMgPj0gJzAnICYmIGMgPD0gJzknKTtcbiAgICAgIH1cblxuICAgICAgaWYoaSA9PT0gMCAmJiAhaXNWYWxpZEFscGhhKGMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdCBuYW1lIChtdXN0IGJlZ2luIHdpdGggYWxwaGEgY2hhcmFjdGVyKTogXCInICsgbmFtZSArICdcIicpO1xuXG4gICAgICBpZihpID4gMCAmJiAhKCBpc1ZhbGlkQWxwaGEoYylcbiAgICAgICAgICAgICAgICAgIHx8IGlzRGlnaXQoYykpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdCBuYW1lIChvbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkKTogXCInICsgbmFtZSArICdcIicpO1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIGNyZWF0ZVVuaXRTaW5nbGUuXG4gICAqIEV4YW1wbGU6IFxuICAgKiAgY3JlYXRlVW5pdCh7XG4gICAqICAgIGZvbzogeyB9LFxuICAgKiAgICBiYXI6IHtcbiAgICogICAgICBkZWZpbml0aW9uOiAna2cvZm9vJyxcbiAgICogICAgICBhbGlhc2VzOiBbJ2JhJywgJ2JhcnInLCAnYmFycyddLFxuICAgKiAgICAgIG9mZnNldDogMjAwXG4gICAqICAgIH0sXG4gICAqICAgIGJhejogJzQgYmFyJ1xuICAgKiAgfSwgXG4gICAqICB7XG4gICAqICAgIG92ZXJyaWRlOiB0cnVlO1xuICAgKiAgfSk7XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogICAgICBPYmplY3QgbWFwLiBFYWNoIGtleSBiZWNvbWVzIGEgdW5pdCB3aGljaCBpcyBkZWZpbmVkIGJ5IGl0cyB2YWx1ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIFVuaXQuY3JlYXRlVW5pdCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuICAgIFxuICAgIGlmKHR5cGVvZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNyZWF0ZVVuaXQgZXhwZWN0cyBmaXJzdCBwYXJhbWV0ZXIgdG8gYmUgb2YgdHlwZSAnT2JqZWN0J1wiKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIHVuaXRzIGFuZCBhbGlhc2VzIHdlIGFyZSBvdmVycmlkaW5nXG4gICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJyaWRlKSB7XG4gICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBVbml0LmRlbGV0ZVVuaXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpba2V5XS5hbGlhc2VzKSB7XG4gICAgICAgICAgZm9yKHZhciBpPTA7IGk8b2JqW2tleV0uYWxpYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgVW5pdC5kZWxldGVVbml0KG9ialtrZXldLmFsaWFzZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHRyYXZlcnNlIG11bHRpcGxlIHRpbWVzIHVudGlsIGFsbCB1bml0cyBoYXZlIGJlZW4gYWRkZWRcbiAgICB2YXIgbGFzdFVuaXQ7XG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBsYXN0VW5pdCA9IFVuaXQuY3JlYXRlVW5pdFNpbmdsZShrZXksIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhc3RVbml0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1c2VyLWRlZmluZWQgdW5pdCBhbmQgcmVnaXN0ZXIgaXQgd2l0aCB0aGUgVW5pdCB0eXBlLlxuICAgKiBFeGFtcGxlOiBcbiAgICogIGNyZWF0ZVVuaXRTaW5nbGUoJ2tub3QnLCAnMC41MTQ0NDQ0NDQgbS9zJylcbiAgICogIGNyZWF0ZVVuaXRTaW5nbGUoJ2FjcmUnLCBuZXcgVW5pdCg0MzU2MCwgJ2Z0XjInKSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICBUaGUgbmFtZSBvZiB0aGUgbmV3IHVuaXQuIE11c3QgYmUgdW5pcXVlLiBFeGFtcGxlOiAna25vdCdcbiAgICogQHBhcmFtIHtzdHJpbmcsIFVuaXR9IGRlZmluaXRpb24gICAgICBEZWZpbml0aW9uIG9mIHRoZSB1bml0IGluIHRlcm1zIG9mIGV4aXN0aW5nIHVuaXRzLiBGb3IgZXhhbXBsZSwgJzAuNTE0NDQ0NDQ0IG0gLyBzJy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAob3B0aW9uYWwpIEFuIG9iamVjdCBjb250YWluaW5nIGFueSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqICAgICBwcmVmaXhlcyB7c3RyaW5nfSBcIm5vbmVcIiwgXCJzaG9ydFwiLCBcImxvbmdcIiwgXCJiaW5hcnlfc2hvcnRcIiwgb3IgXCJiaW5hcnlfbG9uZ1wiLiBUaGUgZGVmYXVsdCBpcyBcIm5vbmVcIi5cbiAgICogICAgIGFsaWFzZXMge0FycmF5fSBBcnJheSBvZiBzdHJpbmdzLiBFeGFtcGxlOiBbJ2tub3RzJywgJ2t0JywgJ2t0cyddXG4gICAqICAgICBvZmZzZXQge051bWVyaWN9IEFuIG9mZnNldCB0byBhcHBseSB3aGVuIGNvbnZlcnRpbmcgZnJvbSB0aGUgdW5pdC4gRm9yIGV4YW1wbGUsIHRoZSBvZmZzZXQgZm9yIGNlbHNpdXMgaXMgMjczLjE1IGFuZCB0aGUgb2Zmc2V0IGZvciBmYXJoZW5oZWl0IGlzIDQ1OS42Ny4gRGVmYXVsdCBpcyAwLlxuICAgKlxuICAgKiBAcmV0dXJuIHtVbml0fSBcbiAgICovXG4gIFVuaXQuY3JlYXRlVW5pdFNpbmdsZSA9IGZ1bmN0aW9uKG5hbWUsIG9iaiwgb3B0aW9ucykge1xuXG4gICAgaWYodHlwZW9mKG9iaikgPT09ICd1bmRlZmluZWQnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgb2JqID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmKHR5cGVvZihuYW1lKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjcmVhdGVVbml0U2luZ2xlIGV4cGVjdHMgZmlyc3QgcGFyYW1ldGVyIHRvIGJlIG9mIHR5cGUgJ3N0cmluZydcIik7XG4gICAgfVxuICAgXG4gICAgLy8gQ2hlY2sgY29sbGlzaW9ucyB3aXRoIGV4aXN0aW5nIHVuaXRzXG4gICAgaWYoVU5JVFMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSB1bml0IFwiJyArIG5hbWUgKyAnXCI6IGEgdW5pdCB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFZhbGlkYXRlIG5hbWUgZm9yIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBidWlsdC1pbiBmdW5jdGlvbnMgKGxpa2UgYWJzIG9yIGNvcywgZm9yIGV4YW1wbGUpLCBhbmQgZm9yIGFjY2VwdGFibGUgdmFyaWFibGUgbmFtZXMuIEZvciBleGFtcGxlLCAnNDInIGlzIHByb2JhYmx5IG5vdCBhIHZhbGlkIHVuaXQuIE5vciBpcyAnJScsIHNpbmNlIGl0IGlzIGFsc28gYW4gb3BlcmF0b3IuXG5cbiAgICBhc3NlcnRVbml0TmFtZUlzVmFsaWQobmFtZSk7XG5cbiAgICB2YXIgZGVmVW5pdCA9IG51bGw7ICAgLy8gVGhlIFVuaXQgZnJvbSB3aGljaCB0aGUgbmV3IHVuaXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgIHZhciBhbGlhc2VzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGRlZmluaXRpb247XG4gICAgdmFyIHByZWZpeGVzO1xuICAgIGlmKG9iaiAmJiBvYmoudHlwZSA9PT0gJ1VuaXQnKSB7XG4gICAgICBkZWZVbml0ID0gb2JqLmNsb25lKCk7XG4gICAgfVxuICAgIGVsc2UgaWYodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZihvYmogIT09ICcnKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBvYmo7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYodHlwZW9mKG9iaikgPT09ICdvYmplY3QnKSB7XG4gICAgICBkZWZpbml0aW9uID0gb2JqLmRlZmluaXRpb247XG4gICAgICBwcmVmaXhlcyA9IG9iai5wcmVmaXhlczsgXG4gICAgICBvZmZzZXQgPSBvYmoub2Zmc2V0O1xuICAgICAgYWxpYXNlcyA9IG9iai5hbGlhc2VzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgdW5pdCBcIicgKyBuYW1lICsgJ1wiIGZyb20gXCInICsgb2JqLnRvU3RyaW5nKCkgKyAnXCI6IGV4cGVjdGluZyBcInN0cmluZ1wiIG9yIFwiVW5pdFwiIG9yIFwiT2JqZWN0XCInKTtcbiAgICB9XG5cbiAgICBpZihhbGlhc2VzKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8YWxpYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihVTklUUy5oYXNPd25Qcm9wZXJ0eShhbGlhc2VzW2ldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhbGlhcyBcIicgKyBhbGlhc2VzW2ldICsgJ1wiOiBhIHVuaXQgd2l0aCB0aGF0IG5hbWUgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRlZmluaXRpb24gJiYgdHlwZW9mKGRlZmluaXRpb24pID09PSAnc3RyaW5nJyAmJiAhZGVmVW5pdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVmVW5pdCA9IFVuaXQucGFyc2UoZGVmaW5pdGlvbiwge2FsbG93Tm9Vbml0czogdHJ1ZX0pO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV4Lm1lc3NhZ2UgPSAnQ291bGQgbm90IGNyZWF0ZSB1bml0IFwiJyArIG5hbWUgKyAnXCIgZnJvbSBcIicgKyBkZWZpbml0aW9uICsgJ1wiOiAnICsgZXgubWVzc2FnZTtcbiAgICAgICAgdGhyb3coZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi50eXBlID09PSAnVW5pdCcpIHtcbiAgICAgIGRlZlVuaXQgPSBkZWZpbml0aW9uLmNsb25lKCk7XG4gICAgfVxuXG4gICAgYWxpYXNlcyA9IGFsaWFzZXMgfHwgW107XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgaWYocHJlZml4ZXMgJiYgcHJlZml4ZXMudG9VcHBlckNhc2UpIFxuICAgICAgcHJlZml4ZXMgPSBQUkVGSVhFU1twcmVmaXhlcy50b1VwcGVyQ2FzZSgpXSB8fCBQUkVGSVhFUy5OT05FO1xuICAgIGVsc2VcbiAgICAgIHByZWZpeGVzID0gUFJFRklYRVMuTk9ORTtcblxuXG4gICAgLy8gSWYgZGVmVW5pdCBpcyBudWxsLCBpdCBpcyBiZWNhdXNlIHRoZSB1c2VyIGRpZCBub3RcbiAgICAvLyBzcGVjaWZ5IGEgZGVmaW50aW9uLiBTbyBjcmVhdGUgYSBuZXcgYmFzZSBkaW1lbnNpb24uXG4gICAgdmFyIG5ld1VuaXQgPSB7fTtcbiAgICBpZighZGVmVW5pdCkge1xuICAgICAgLy8gQWRkIGEgbmV3IGJhc2UgZGltZW5zaW9uXG4gICAgICB2YXIgYmFzZU5hbWUgPSBuYW1lICsgXCJfU1RVRkZcIjsgICAvLyBmb28gLS0+IGZvb19TVFVGRiwgb3IgdGhlIGVzc2VuY2Ugb2YgZm9vXG4gICAgICBpZihCQVNFX0RJTUVOU0lPTlMuaW5kZXhPZihiYXNlTmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgbmV3IGJhc2UgdW5pdCBcIicgKyBuYW1lICsgJ1wiOiBhIGJhc2UgdW5pdCB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0cyAoYW5kIGNhbm5vdCBiZSBvdmVycmlkZGVuKScpO1xuICAgICAgfVxuICAgICAgQkFTRV9ESU1FTlNJT05TLnB1c2goYmFzZU5hbWUpO1xuXG4gICAgICAvLyBQdXNoIDAgb250byBleGlzdGluZyBiYXNlIHVuaXRzXG4gICAgICBmb3IodmFyIGIgaW4gQkFTRV9VTklUUykge1xuICAgICAgICBpZihCQVNFX1VOSVRTLmhhc093blByb3BlcnR5KGIpKSB7XG4gICAgICAgICAgQkFTRV9VTklUU1tiXS5kaW1lbnNpb25zW0JBU0VfRElNRU5TSU9OUy5sZW5ndGgtMV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgbmV3IGJhc2UgdW5pdFxuICAgICAgdmFyIG5ld0Jhc2VVbml0ID0geyBkaW1lbnNpb25zOiBbXSB9O1xuICAgICAgZm9yKHZhciBpPTA7IGk8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0Jhc2VVbml0LmRpbWVuc2lvbnNbaV0gPSAwO1xuICAgICAgfVxuICAgICAgbmV3QmFzZVVuaXQuZGltZW5zaW9uc1tCQVNFX0RJTUVOU0lPTlMubGVuZ3RoLTFdID0gMTtcbiAgICAgIG5ld0Jhc2VVbml0LmtleSA9IGJhc2VOYW1lO1xuICAgICAgQkFTRV9VTklUU1tiYXNlTmFtZV0gPSBuZXdCYXNlVW5pdDtcbiAgICAgICBcbiAgICAgIG5ld1VuaXQgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICBkaW1lbnNpb25zOiBCQVNFX1VOSVRTW2Jhc2VOYW1lXS5kaW1lbnNpb25zLnNsaWNlKDApLFxuICAgICAgICBwcmVmaXhlczogcHJlZml4ZXMsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBiYXNlOiBiYXNlTmFtZVxuICAgICAgfTtcblxuICAgICAgY3VycmVudFVuaXRTeXN0ZW1bYmFzZU5hbWVdID0ge1xuICAgICAgICB1bml0OiBuZXdVbml0LFxuICAgICAgICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddXG4gICAgICB9O1xuXG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICBuZXdVbml0ID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogZGVmVW5pdC52YWx1ZSxcbiAgICAgICAgZGltZW5zaW9uczogZGVmVW5pdC5kaW1lbnNpb25zLnNsaWNlKDApLFxuICAgICAgICBwcmVmaXhlczogcHJlZml4ZXMsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGJhc2UgaWYgbm8gbWF0Y2hpbmcgYmFzZSBleGlzdHNcbiAgICAgIHZhciBhbnlNYXRjaCA9IGZhbHNlO1xuICAgICAgZm9yKHZhciBpIGluIEJBU0VfVU5JVFMpIHtcbiAgICAgICAgaWYoQkFTRV9VTklUUy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgZm9yKHZhciBqPTA7IGo8QkFTRV9ESU1FTlNJT05TLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoKG5ld1VuaXQuZGltZW5zaW9uc1tqXSB8fCAwKSAtIChCQVNFX1VOSVRTW2ldLmRpbWVuc2lvbnNbal0gfHwgMCkpID4gMWUtMTIpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKG1hdGNoKSB7XG4gICAgICAgICAgICBhbnlNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCFhbnlNYXRjaCkge1xuICAgICAgICB2YXIgYmFzZU5hbWUgPSBuYW1lICsgXCJfU1RVRkZcIjsgICAvLyBmb28gLS0+IGZvb19TVFVGRiwgb3IgdGhlIGVzc2VuY2Ugb2YgZm9vXG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IGJhc2UgdW5pdFxuICAgICAgICB2YXIgbmV3QmFzZVVuaXQgPSB7IGRpbWVuc2lvbnM6IGRlZlVuaXQuZGltZW5zaW9ucy5zbGljZSgwKSB9O1xuICAgICAgICBuZXdCYXNlVW5pdC5rZXkgPSBiYXNlTmFtZTtcbiAgICAgICAgQkFTRV9VTklUU1tiYXNlTmFtZV0gPSBuZXdCYXNlVW5pdDtcblxuICAgICAgICBjdXJyZW50VW5pdFN5c3RlbVtiYXNlTmFtZV0gPSB7XG4gICAgICAgICAgdW5pdDogbmV3VW5pdCxcbiAgICAgICAgICBwcmVmaXg6IFBSRUZJWEVTLk5PTkVbJyddXG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3VW5pdC5iYXNlID0gYmFzZU5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVW5pdC5VTklUU1tuYW1lXSA9IG5ld1VuaXQ7XG5cbiAgICBmb3IgKHZhciBpPTA7IGk8YWxpYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFsaWFzTmFtZSA9IGFsaWFzZXNbaV07XG4gICAgICB2YXIgYWxpYXMgPSB7fTtcbiAgICAgIGZvcih2YXIga2V5IGluIG5ld1VuaXQpIHtcbiAgICAgICAgaWYobmV3VW5pdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgYWxpYXNba2V5XSA9IG5ld1VuaXRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWxpYXMubmFtZSA9IGFsaWFzTmFtZTtcbiAgICAgIFVuaXQuVU5JVFNbYWxpYXNOYW1lXSA9IGFsaWFzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVW5pdChudWxsLCBuYW1lKTtcbiAgfTtcblxuICBVbml0LmRlbGV0ZVVuaXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIFVuaXQuVU5JVFNbbmFtZV07XG4gIH07XG5cblxuICBVbml0LlBSRUZJWEVTID0gUFJFRklYRVM7XG4gIFVuaXQuQkFTRV9VTklUUyA9IEJBU0VfVU5JVFM7XG4gIFVuaXQuVU5JVFMgPSBVTklUUztcbiAgVW5pdC5VTklUX1NZU1RFTVMgPSBVTklUX1NZU1RFTVM7XG5cbiAgcmV0dXJuIFVuaXQ7XG59XG5cbmV4cG9ydHMubmFtZSA9ICdVbml0JztcbmV4cG9ydHMucGF0aCA9ICd0eXBlJztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLm1hdGggPSB0cnVlOyAvLyByZXF1ZXN0IGFjY2VzcyB0byB0aGUgbWF0aCBuYW1lc3BhY2VcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgdXNpbmcgbWV0aG9kcyB0b1ByZWNpc2lvbiwgdG9GaXhlZCwgdG9FeHBvbmVudGlhbC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE51bWJlckZvcm1hdHRlciAodmFsdWUpIHtcbiAgLy8gcGFyc2UgdGhlIGlucHV0IHZhbHVlXG4gIHZhciBtYXRjaCA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKS5tYXRjaCgvXjAqPygtPykoXFxkK1xcLj9cXGQqKShlKFsrLV0/XFxkKykpPyQvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBudW1iZXInKTtcbiAgfVxuXG4gIHZhciBzaWduICAgICAgICAgPSBtYXRjaFsxXTtcbiAgdmFyIGNvZWZmaWNpZW50cyA9IG1hdGNoWzJdO1xuICB2YXIgZXhwb25lbnQgICAgID0gcGFyc2VGbG9hdChtYXRjaFs0XSB8fCAnMCcpO1xuXG4gIHZhciBkb3QgPSBjb2VmZmljaWVudHMuaW5kZXhPZignLicpO1xuICBleHBvbmVudCArPSAoZG90ICE9PSAtMSkgPyAoZG90IC0gMSkgOiAoY29lZmZpY2llbnRzLmxlbmd0aCAtIDEpO1xuXG4gIHRoaXMuc2lnbiA9IHNpZ247XG4gIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzXG4gICAgICAucmVwbGFjZSgnLicsICcnKSAgLy8gcmVtb3ZlIHRoZSBkb3QgKG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgcmVtb3ZpbmcgbGVhZGluZyB6ZXJvcylcbiAgICAgIC5yZXBsYWNlKC9eMCovLCBmdW5jdGlvbiAoemVyb3MpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVyb3MsIGFkZCB0aGVpciBjb3VudCB0byB0aGUgZXhwb25lbnRcbiAgICAgICAgZXhwb25lbnQgLT0gemVyb3MubGVuZ3RoO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KVxuICAgICAgLnJlcGxhY2UoLzAqJC8sICcnKSAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3NcbiAgICAgIC5zcGxpdCgnJylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGQpO1xuICAgICAgfSk7XG5cbiAgaWYgKHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuY29lZmZpY2llbnRzLnB1c2goMCk7XG4gICAgZXhwb25lbnQrKztcbiAgfVxuXG4gIHRoaXMuZXhwb25lbnQgPSBleHBvbmVudDtcbn1cblxuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGVuZ2luZWVyaW5nIG5vdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gICAgICAgIE9wdGlvbmFsIG51bWJlciBvZiBkZWNpbWFscyBhZnRlciB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsIHBvaW50LiBaZXJvIGJ5IGRlZmF1bHQuXG4gKi9cbk51bWJlckZvcm1hdHRlci5wcm90b3R5cGUudG9FbmdpbmVlcmluZyA9IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuICB2YXIgcm91bmRlZCA9IHRoaXMucm91bmREaWdpdHMocHJlY2lzaW9uKTtcblxuICB2YXIgZSA9IHJvdW5kZWQuZXhwb25lbnQ7XG4gIHZhciBjID0gcm91bmRlZC5jb2VmZmljaWVudHM7XG5cbiAgLy8gZmluZCBuZWFyZXN0IGxvd2VyIG11bHRpcGxlIG9mIDMgZm9yIGV4cG9uZW50XG4gIHZhciBuZXdFeHAgPSBlICUgMyA9PT0gMCA/IGUgOiAoZSA8IDAgPyAoZSAtIDMpIC0gKGUgJSAzKSA6IGUgLSAoZSAlIDMpKTtcblxuICAvLyBjb25jYXRlbmF0ZSBjb2VmZmljaWVudHMgd2l0aCBuZWNlc3NhcnkgemVyb3NcbiAgdmFyIHNpZ25pZmljYW5kc0RpZmYgPSBlID49IDAgPyBlIDogTWF0aC5hYnMobmV3RXhwKTtcblxuICAvLyBhZGQgemVyb3MgaWYgbmVjZXNzYXJ5IChmb3IgZXg6IDFlKzgpXG4gIGlmIChjLmxlbmd0aCAtIDEgPCBzaWduaWZpY2FuZHNEaWZmKSBjID0gYy5jb25jYXQoemVyb3Moc2lnbmlmaWNhbmRzRGlmZiAtIChjLmxlbmd0aCAtIDEpKSk7XG5cbiAgLy8gZmluZCBkaWZmZXJlbmNlIGluIGV4cG9uZW50c1xuICB2YXIgZXhwRGlmZiA9IE1hdGguYWJzKGUgLSBuZXdFeHApO1xuXG4gIHZhciBkZWNpbWFsSWR4ID0gMTtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIC8vIHB1c2ggZGVjaW1hbCBpbmRleCBvdmVyIGJ5IGV4cERpZmYgdGltZXNcbiAgd2hpbGUgKC0tZXhwRGlmZiA+PSAwKSBkZWNpbWFsSWR4Kys7XG5cbiAgLy8gaWYgYWxsIGNvZWZmaWNpZW50IHZhbHVlcyBhcmUgemVybyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZG9uJ3QgYWRkIGEgZGVjaW1hbCB2YWx1ZS4gXG4gIC8vIG90aGVyd2lzZSBjb25jYXQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgY29lZmZpY2llbnRzXG4gIHZhciBkZWNpbWFscyA9IGMuc2xpY2UoZGVjaW1hbElkeCkuam9pbignJyk7XG4gIHZhciBkZWNpbWFsVmFsID0gZGVjaW1hbHMubWF0Y2goL1sxLTldLykgPyAoJy4nICsgZGVjaW1hbHMpIDogJyc7XG5cbiAgc3RyID0gYy5zbGljZSgwLCBkZWNpbWFsSWR4KS5qb2luKCcnKSArIGRlY2ltYWxWYWw7XG5cbiAgc3RyICs9ICdlJyArIChlID49IDAgPyAnKycgOiAnJykgKyBuZXdFeHAudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHJvdW5kZWQuc2lnbiArIHN0cjtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgd2l0aCBmaXhlZCBub3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdICAgICAgICBPcHRpb25hbCBudW1iZXIgb2YgZGVjaW1hbHMgYWZ0ZXIgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCBwb2ludC4gWmVybyBieSBkZWZhdWx0LlxuICovXG5OdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLnRvRml4ZWQgPSBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XG4gIHZhciByb3VuZGVkID0gdGhpcy5yb3VuZERpZ2l0cyh0aGlzLmV4cG9uZW50ICsgMSArIChwcmVjaXNpb24gfHwgMCkpO1xuICB2YXIgYyA9IHJvdW5kZWQuY29lZmZpY2llbnRzO1xuICB2YXIgcCA9IHJvdW5kZWQuZXhwb25lbnQgKyAxOyAvLyBleHBvbmVudCBtYXkgaGF2ZSBjaGFuZ2VkXG5cbiAgLy8gYXBwZW5kIHplcm9zIGlmIG5lZWRlZFxuICB2YXIgcHAgPSBwICsgKHByZWNpc2lvbiB8fCAwKTtcbiAgaWYgKGMubGVuZ3RoIDwgcHApIHtcbiAgICBjID0gYy5jb25jYXQoemVyb3MocHAgLSBjLmxlbmd0aCkpO1xuICB9XG5cbiAgLy8gcHJlcGVuZCB6ZXJvcyBpZiBuZWVkZWRcbiAgaWYgKHAgPCAwKSB7XG4gICAgYyA9IHplcm9zKC1wICsgMSkuY29uY2F0KGMpO1xuICAgIHAgPSAxO1xuICB9XG5cbiAgLy8gaW5zZXJ0IGEgZG90IGlmIG5lZWRlZFxuICBpZiAocHJlY2lzaW9uKSB7XG4gICAgYy5zcGxpY2UocCwgMCwgKHAgPT09IDApID8gJzAuJyA6ICcuJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zaWduICsgYy5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uLiBMaWtlICcxLjIzZSs1JywgJzIuM2UrMCcsICczLjUwMGUtMydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uXSAgTnVtYmVyIG9mIGRpZ2l0cyBpbiBmb3JtYXR0ZWQgb3V0cHV0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBkaWdpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdXNlZC5cbiAqL1xuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKHByZWNpc2lvbikge1xuICAvLyByb3VuZCBpZiBuZWVkZWQsIGVsc2UgY3JlYXRlIGEgY2xvbmVcbiAgdmFyIHJvdW5kZWQgPSBwcmVjaXNpb24gPyB0aGlzLnJvdW5kRGlnaXRzKHByZWNpc2lvbikgOiB0aGlzLmNsb25lKCk7XG4gIHZhciBjID0gcm91bmRlZC5jb2VmZmljaWVudHM7XG4gIHZhciBlID0gcm91bmRlZC5leHBvbmVudDtcblxuICAvLyBhcHBlbmQgemVyb3MgaWYgbmVlZGVkXG4gIGlmIChjLmxlbmd0aCA8IHByZWNpc2lvbikge1xuICAgIGMgPSBjLmNvbmNhdCh6ZXJvcyhwcmVjaXNpb24gLSBjLmxlbmd0aCkpO1xuICB9XG5cbiAgLy8gZm9ybWF0IGFzIGBDLkNDQ2UrRUVFYCBvciBgQy5DQ0NlLUVFRWBcbiAgdmFyIGZpcnN0ID0gYy5zaGlmdCgpO1xuICByZXR1cm4gdGhpcy5zaWduICsgZmlyc3QgKyAoYy5sZW5ndGggPiAwID8gKCcuJyArIGMuam9pbignJykpIDogJycpICtcbiAgICAgICdlJyArIChlID49IDAgPyAnKycgOiAnJykgKyBlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgd2l0aCBhIGNlcnRhaW4gcHJlY2lzaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj11bmRlZmluZWRdIE9wdGlvbmFsIG51bWJlciBvZiBkaWdpdHMuXG4gKiBAcGFyYW0ge3tsb3dlcjogbnVtYmVyIHwgdW5kZWZpbmVkLCB1cHBlcjogbnVtYmVyIHwgdW5kZWZpbmVkfX0gW29wdGlvbnNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGRlZmF1bHQ6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXIgPSAxZS0zIChleGNsKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyID0gMWUrNSAoaW5jbClcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgb3B0aW9ucykge1xuICAvLyBkZXRlcm1pbmUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIGZvciBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgdmFyIGxvd2VyID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5sb3dlciAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMubG93ZXIgOiAxZS0zO1xuICB2YXIgdXBwZXIgPSAob3B0aW9ucyAmJiBvcHRpb25zLnVwcGVyICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy51cHBlciA6IDFlKzU7XG5cbiAgdmFyIGFicyA9IE1hdGguYWJzKE1hdGgucG93KDEwLCB0aGlzLmV4cG9uZW50KSk7XG4gIGlmIChhYnMgPCBsb3dlciB8fCBhYnMgPj0gdXBwZXIpIHtcbiAgICAvLyBleHBvbmVudGlhbCBub3RhdGlvblxuICAgIHJldHVybiB0aGlzLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcm91bmRlZCA9IHByZWNpc2lvbiA/IHRoaXMucm91bmREaWdpdHMocHJlY2lzaW9uKSA6IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYyA9IHJvdW5kZWQuY29lZmZpY2llbnRzO1xuICAgIHZhciBlID0gcm91bmRlZC5leHBvbmVudDtcblxuICAgIC8vIGFwcGVuZCB0cmFpbGluZyB6ZXJvc1xuICAgIGlmIChjLmxlbmd0aCA8IHByZWNpc2lvbikge1xuICAgICAgYyA9IGMuY29uY2F0KHplcm9zKHByZWNpc2lvbiAtIGMubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIHRyYWlsaW5nIHplcm9zXG4gICAgLy8gVE9ETzogc2ltcGxpZnkgdGhlIG5leHQgc3RhdGVtZW50XG4gICAgYyA9IGMuY29uY2F0KHplcm9zKGUgLSBjLmxlbmd0aCArIDEgK1xuICAgICAgICAoYy5sZW5ndGggPCBwcmVjaXNpb24gPyBwcmVjaXNpb24gLSBjLmxlbmd0aCA6IDApKSk7XG5cbiAgICAvLyBwcmVwZW5kIHplcm9zXG4gICAgYyA9IHplcm9zKC1lKS5jb25jYXQoYyk7XG5cbiAgICB2YXIgZG90ID0gZSA+IDAgPyBlIDogMDtcbiAgICBpZiAoZG90IDwgYy5sZW5ndGggLSAxKSB7XG4gICAgICBjLnNwbGljZShkb3QgKyAxLCAwLCAnLicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNpZ24gKyBjLmpvaW4oJycpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZXRlIGEgY2xvbmUgb2YgdGhlIE51bWJlckZvcm1hdHRlclxuICogQHJldHVybiB7TnVtYmVyRm9ybWF0dGVyfSBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE51bWJlckZvcm1hdHRlclxuICovXG5OdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xvbmUgPSBuZXcgTnVtYmVyRm9ybWF0dGVyKCcwJyk7XG4gIGNsb25lLnNpZ24gPSB0aGlzLnNpZ247XG4gIGNsb25lLmNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzLnNsaWNlKDApO1xuICBjbG9uZS5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogUm91bmQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgYSBudW1iZXIgKlxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAgQSBwb3NpdGl2ZSBpbnRlZ2VyXG4gKiBAcmV0dXJuIHtOdW1iZXJGb3JtYXR0ZXJ9ICBSZXR1cm5zIGEgbmV3IE51bWJlckZvcm1hdHRlciB3aXRoIHRoZSByb3VuZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNcbiAqL1xuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5yb3VuZERpZ2l0cyA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgdmFyIHJvdW5kZWQgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBjID0gcm91bmRlZC5jb2VmZmljaWVudHM7XG5cbiAgLy8gcHJlcGVuZCB6ZXJvcyBpZiBuZWVkZWRcbiAgd2hpbGUgKHByZWNpc2lvbiA8PSAwKSB7XG4gICAgYy51bnNoaWZ0KDApO1xuICAgIHJvdW5kZWQuZXhwb25lbnQrKztcbiAgICBwcmVjaXNpb24rKztcbiAgfVxuXG4gIGlmIChjLmxlbmd0aCA+IHByZWNpc2lvbikge1xuICAgIHZhciByZW1vdmVkID0gYy5zcGxpY2UocHJlY2lzaW9uLCBjLmxlbmd0aCAtIHByZWNpc2lvbik7XG5cbiAgICBpZiAocmVtb3ZlZFswXSA+PSA1KSB7XG4gICAgICB2YXIgaSA9IHByZWNpc2lvbiAtIDE7XG4gICAgICBjW2ldKys7XG4gICAgICB3aGlsZSAoY1tpXSA9PT0gMTApIHtcbiAgICAgICAgYy5wb3AoKTtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBjLnVuc2hpZnQoMCk7XG4gICAgICAgICAgcm91bmRlZC5leHBvbmVudCsrO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgICAgIGNbaV0rKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm91bmRlZDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGZpbGxlZCB3aXRoIHplcm9zLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHplcm9zKGxlbmd0aCkge1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnIucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckZvcm1hdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG52YXIgRGltZW5zaW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9EaW1lbnNpb25FcnJvcicpO1xudmFyIEluZGV4RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9JbmRleEVycm9yJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaXplIG9mIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXkuXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgZW50cnksIGl0IGRvZXMgbm90IHZhbGlkYXRlXG4gKiB3aGV0aGVyIGFsbCBkaW1lbnNpb25zIG1hdGNoLiAodXNlIGZ1bmN0aW9uIGB2YWxpZGF0ZWAgZm9yIHRoYXQpXG4gKiBAcGFyYW0ge0FycmF5fSB4XG4gKiBAUmV0dXJuIHtOdW1iZXJbXX0gc2l6ZVxuICovXG5leHBvcnRzLnNpemUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgcyA9IFtdO1xuXG4gIHdoaWxlIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcy5wdXNoKHgubGVuZ3RoKTtcbiAgICB4ID0geFswXTtcbiAgfVxuXG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB2YWxpZGF0ZSB3aGV0aGVyIGVhY2ggZWxlbWVudCBpbiBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBoYXMgYSBzaXplIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIHNpemUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAgICBBcnJheSB0byBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyW119IHNpemUgIEFycmF5IHdpdGggdGhlIHNpemUgb2YgZWFjaCBkaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gICBDdXJyZW50IGRpbWVuc2lvblxuICogQHRocm93cyBEaW1lbnNpb25FcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ZhbGlkYXRlKGFycmF5LCBzaXplLCBkaW0pIHtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGxlbiAhPSBzaXplW2RpbV0pIHtcbiAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IobGVuLCBzaXplW2RpbV0pO1xuICB9XG5cbiAgaWYgKGRpbSA8IHNpemUubGVuZ3RoIC0gMSkge1xuICAgIC8vIHJlY3Vyc2l2ZWx5IHZhbGlkYXRlIGVhY2ggY2hpbGQgYXJyYXlcbiAgICB2YXIgZGltTmV4dCA9IGRpbSArIDE7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBhcnJheVtpXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKHNpemUubGVuZ3RoIC0gMSwgc2l6ZS5sZW5ndGgsICc8Jyk7XG4gICAgICB9XG4gICAgICBfdmFsaWRhdGUoYXJyYXlbaV0sIHNpemUsIGRpbU5leHQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBsYXN0IGRpbWVuc2lvbi4gbm9uZSBvZiB0aGUgY2hpbGRzIG1heSBiZSBhbiBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihzaXplLmxlbmd0aCArIDEsIHNpemUubGVuZ3RoLCAnPicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIHdoZXRoZXIgZWFjaCBlbGVtZW50IGluIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXkgaGFzXG4gKiBhIHNpemUgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgc2l6ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgIEFycmF5IHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgQXJyYXkgd2l0aCB0aGUgc2l6ZSBvZiBlYWNoIGRpbWVuc2lvblxuICogQHRocm93cyBEaW1lbnNpb25FcnJvclxuICovXG5leHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24oYXJyYXksIHNpemUpIHtcbiAgdmFyIGlzU2NhbGFyID0gKHNpemUubGVuZ3RoID09IDApO1xuICBpZiAoaXNTY2FsYXIpIHtcbiAgICAvLyBzY2FsYXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcihhcnJheS5sZW5ndGgsIDApO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIF92YWxpZGF0ZShhcnJheSwgc2l6ZSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGluZGV4IGlzIGFuIGludGVnZXIgbnVtYmVyIHdpdGggaW5kZXggPj0gMCBhbmQgaW5kZXggPCBsZW5ndGhcbiAqIHdoZW4gbGVuZ3RoIGlzIHByb3ZpZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggICAgWmVyby1iYXNlZCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBvZiB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0cy52YWxpZGF0ZUluZGV4ID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xuICBpZiAoIW51bWJlci5pc051bWJlcihpbmRleCkgfHwgIW51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyICh2YWx1ZTogJyArIGluZGV4ICsgJyknKTtcbiAgfVxuICBpZiAoaW5kZXggPCAwIHx8ICh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyAmJiBpbmRleCA+PSBsZW5ndGgpKSB7XG4gICAgdGhyb3cgbmV3IEluZGV4RXJyb3IoaW5kZXgsIGxlbmd0aCk7XG4gIH1cbn07XG5cbi8vIGEgY29uc3RhbnQgdXNlZCB0byBzcGVjaWZ5IGFuIHVuZGVmaW5lZCBkZWZhdWx0VmFsdWVcbmV4cG9ydHMuVU5JTklUSUFMSVpFRCA9IHt9O1xuXG4vKipcbiAqIFJlc2l6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5LiBUaGUgcmVzaXplZCBhcnJheSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICAgICAgQXJyYXkgdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc2l6ZSBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWU9MF0gIFZhbHVlIHRvIGJlIGZpbGxlZCBpbiBpbiBuZXcgZW50cmllcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVybyBieSBkZWZhdWx0LiBUbyBsZWF2ZSBuZXcgZW50cmllcyB1bmRlZmluZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZnkgYXJyYXkuVU5JTklUSUFMSVpFRCBhcyBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSAgICAgICAgIFRoZSByZXNpemVkIGFycmF5XG4gKi9cbmV4cG9ydHMucmVzaXplID0gZnVuY3Rpb24oYXJyYXksIHNpemUsIGRlZmF1bHRWYWx1ZSkge1xuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3Igc2NhbGFycywgaGF2aW5nIHNpemU9W10gP1xuXG4gIC8vIGNoZWNrIHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudHNcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSB8fCAhQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkJyk7XG4gIH1cbiAgaWYgKHNpemUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemluZyB0byBzY2FsYXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgLy8gY2hlY2sgd2hldGhlciBzaXplIGNvbnRhaW5zIHBvc2l0aXZlIGludGVnZXJzXG4gIHNpemUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIW51bWJlci5pc051bWJlcih2YWx1ZSkgfHwgIW51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzaXplLCBtdXN0IGNvbnRhaW4gcG9zaXRpdmUgaW50ZWdlcnMgJyArXG4gICAgICAgICAgJyhzaXplOiAnICsgc3RyaW5nLmZvcm1hdChzaXplKSArICcpJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyByZWN1cnNpdmVseSByZXNpemUgdGhlIGFycmF5XG4gIHZhciBfZGVmYXVsdFZhbHVlID0gKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/IGRlZmF1bHRWYWx1ZSA6IDA7XG4gIF9yZXNpemUoYXJyYXksIHNpemUsIDAsIF9kZWZhdWx0VmFsdWUpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVzaXplIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgICAgICAgQXJyYXkgdG8gYmUgcmVzaXplZFxuICogQHBhcmFtIHtudW1iZXJbXX0gc2l6ZSAgICAgICBBcnJheSB3aXRoIHRoZSBzaXplIG9mIGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICAgICAgICAgIEN1cnJlbnQgZGltZW5zaW9uXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdICAgIFZhbHVlIHRvIGJlIGZpbGxlZCBpbiBpbiBuZXcgZW50cmllcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIGJ5IGRlZmF1bHQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVzaXplIChhcnJheSwgc2l6ZSwgZGltLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGk7XG4gIHZhciBlbGVtO1xuICB2YXIgb2xkTGVuID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbmV3TGVuID0gc2l6ZVtkaW1dO1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4ob2xkTGVuLCBuZXdMZW4pO1xuXG4gIC8vIGFwcGx5IG5ldyBsZW5ndGhcbiAgYXJyYXkubGVuZ3RoID0gbmV3TGVuO1xuXG4gIGlmIChkaW0gPCBzaXplLmxlbmd0aCAtIDEpIHtcbiAgICAvLyBub24tbGFzdCBkaW1lbnNpb25cbiAgICB2YXIgZGltTmV4dCA9IGRpbSArIDE7XG5cbiAgICAvLyByZXNpemUgZXhpc3RpbmcgY2hpbGQgYXJyYXlzXG4gICAgZm9yIChpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgICAvLyByZXNpemUgY2hpbGQgYXJyYXlcbiAgICAgIGVsZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtKSkge1xuICAgICAgICBlbGVtID0gW2VsZW1dOyAvLyBhZGQgYSBkaW1lbnNpb25cbiAgICAgICAgYXJyYXlbaV0gPSBlbGVtO1xuICAgICAgfVxuICAgICAgX3Jlc2l6ZShlbGVtLCBzaXplLCBkaW1OZXh0LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXcgY2hpbGQgYXJyYXlzXG4gICAgZm9yIChpID0gbWluTGVuOyBpIDwgbmV3TGVuOyBpKyspIHtcbiAgICAgIC8vIGdldCBjaGlsZCBhcnJheVxuICAgICAgZWxlbSA9IFtdO1xuICAgICAgYXJyYXlbaV0gPSBlbGVtO1xuXG4gICAgICAvLyByZXNpemUgbmV3IGNoaWxkIGFycmF5XG4gICAgICBfcmVzaXplKGVsZW0sIHNpemUsIGRpbU5leHQsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGxhc3QgZGltZW5zaW9uXG5cbiAgICAvLyByZW1vdmUgZGltZW5zaW9ucyBvZiBleGlzdGluZyB2YWx1ZXNcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICAgIHdoaWxlIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2ldWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRlZmF1bHRWYWx1ZSAhPT0gZXhwb3J0cy5VTklOSVRJQUxJWkVEKSB7XG4gICAgICAvLyBmaWxsIG5ldyBlbGVtZW50cyB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICBmb3IgKGkgPSBtaW5MZW47IGkgPCBuZXdMZW47IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTcXVlZXplIGEgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBbc2l6ZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJucyB0aGUgYXJyYXkgaXRzZWxmXG4gKi9cbmV4cG9ydHMuc3F1ZWV6ZSA9IGZ1bmN0aW9uKGFycmF5LCBzaXplKSB7XG4gIHZhciBzID0gc2l6ZSB8fCBleHBvcnRzLnNpemUoYXJyYXkpO1xuXG4gIC8vIHNxdWVlemUgb3V0ZXIgZGltZW5zaW9uc1xuICB3aGlsZSAoQXJyYXkuaXNBcnJheShhcnJheSkgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgYXJyYXkgPSBhcnJheVswXTtcbiAgICBzLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBmaW5kIHRoZSBmaXJzdCBkaW1lbnNpb24gdG8gYmUgc3F1ZWV6ZWRcbiAgdmFyIGRpbXMgPSBzLmxlbmd0aDtcbiAgd2hpbGUgKHNbZGltcyAtIDFdID09PSAxKSB7XG4gICAgZGltcy0tO1xuICB9XG5cbiAgLy8gc3F1ZWV6ZSBpbm5lciBkaW1lbnNpb25zXG4gIGlmIChkaW1zIDwgcy5sZW5ndGgpIHtcbiAgICBhcnJheSA9IF9zcXVlZXplKGFycmF5LCBkaW1zLCAwKTtcbiAgICBzLmxlbmd0aCA9IGRpbXM7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNxdWVlemUgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1zIFJlcXVpcmVkIG51bWJlciBvZiBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICBDdXJyZW50IGRpbWVuc2lvblxuICogQHJldHVybnMge0FycmF5IHwgKn0gUmV0dXJucyB0aGUgc3F1ZWV6ZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9zcXVlZXplIChhcnJheSwgZGltcywgZGltKSB7XG4gIHZhciBpLCBpaTtcblxuICBpZiAoZGltIDwgZGltcykge1xuICAgIHZhciBuZXh0ID0gZGltICsgMTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGFycmF5W2ldID0gX3NxdWVlemUoYXJyYXlbaV0sIGRpbXMsIG5leHQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB3aGlsZSAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXlbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFVuc3F1ZWV6ZSBhIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5OiBhZGQgZGltZW5zaW9ucyB3aGVuIG1pc3NpbmdcbiAqIFxuICogUGFyYW10ZXIgYHNpemVgIHdpbGwgYmUgbXV0YXRlZCB0byBtYXRjaCB0aGUgbmV3LCB1bnF1ZWV6ZWQgbWF0cml4IHNpemUuXG4gKiBcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gZGltcyAgICAgRGVzaXJlZCBudW1iZXIgb2YgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3V0ZXJdICBOdW1iZXIgb2Ygb3V0ZXIgZGltZW5zaW9ucyB0byBiZSBhZGRlZFxuICogQHBhcmFtIHtBcnJheX0gW3NpemVdICAgIEN1cnJlbnQgc2l6ZSBvZiBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJucyB0aGUgYXJyYXkgaXRzZWxmXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnVuc3F1ZWV6ZSA9IGZ1bmN0aW9uKGFycmF5LCBkaW1zLCBvdXRlciwgc2l6ZSkge1xuICB2YXIgcyA9IHNpemUgfHwgZXhwb3J0cy5zaXplKGFycmF5KTtcblxuICAvLyB1bnNxdWVlemUgb3V0ZXIgZGltZW5zaW9uc1xuICBpZiAob3V0ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyOyBpKyspIHtcbiAgICAgIGFycmF5ID0gW2FycmF5XTtcbiAgICAgIHMudW5zaGlmdCgxKTtcbiAgICB9XG4gIH1cblxuICAvLyB1bnNxdWVlemUgaW5uZXIgZGltZW5zaW9uc1xuICBhcnJheSA9IF91bnNxdWVlemUoYXJyYXksIGRpbXMsIDApO1xuICB3aGlsZSAocy5sZW5ndGggPCBkaW1zKSB7XG4gICAgcy5wdXNoKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB1bnNxdWVlemUgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1zIFJlcXVpcmVkIG51bWJlciBvZiBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZGltICBDdXJyZW50IGRpbWVuc2lvblxuICogQHJldHVybnMge0FycmF5IHwgKn0gUmV0dXJucyB0aGUgc3F1ZWV6ZWQgYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF91bnNxdWVlemUgKGFycmF5LCBkaW1zLCBkaW0pIHtcbiAgdmFyIGksIGlpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIHZhciBuZXh0ID0gZGltICsgMTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGFycmF5W2ldID0gX3Vuc3F1ZWV6ZShhcnJheVtpXSwgZGltcywgbmV4dCk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIGQgPSBkaW07IGQgPCBkaW1zOyBkKyspIHtcbiAgICAgIGFycmF5ID0gW2FycmF5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheSwgcHV0IGFsbCBlbGVtZW50cyBpbiBhIG9uZSBkaW1lbnNpb25hbFxuICogYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5ICAgQSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheVxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBUaGUgZmxhdHRlbmVkIGFycmF5ICgxIGRpbWVuc2lvbmFsKVxuICovXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgLy9pZiBub3QgYW4gYXJyYXksIHJldHVybiBhcyBpc1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgZmxhdCA9IFtdO1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gY2FsbGJhY2sodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goY2FsbGJhY2spOyAgLy90cmF2ZXJzZSB0aHJvdWdoIHN1Yi1hcnJheXMgcmVjdXJzaXZlbHlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmbGF0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZsYXQ7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzQXJyYXlcbiAqL1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24nKS5tZW1vaXplO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gQmlnTnVtYmVyICAgQmlnTnVtYmVyIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIGVcbiAqL1xuZXhwb3J0cy5lID0gbWVtb2l6ZShmdW5jdGlvbiAoQmlnTnVtYmVyKSB7XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKDEpLmV4cCgpO1xufSwgaGFzaGVyKTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgQmlnTnVtYmVyIGdvbGRlbiByYXRpbywgcGhpID0gKDErc3FydCg1KSkvMlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQmlnTnVtYmVyICAgQmlnTnVtYmVyIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBSZXR1cm5zIHBoaVxuICovXG5leHBvcnRzLnBoaSA9IG1lbW9pemUoZnVuY3Rpb24gKEJpZ051bWJlcikge1xuICByZXR1cm4gbmV3IEJpZ051bWJlcigxKS5wbHVzKG5ldyBCaWdOdW1iZXIoNSkuc3FydCgpKS5kaXYoMik7XG59LCBoYXNoZXIpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgcGkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBCaWdOdW1iZXIgICBCaWdOdW1iZXIgY29uc3RydWN0b3JcbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IFJldHVybnMgcGlcbiAqL1xuZXhwb3J0cy5waSA9IG1lbW9pemUoZnVuY3Rpb24gKEJpZ051bWJlcikge1xuICByZXR1cm4gcGkgPSBCaWdOdW1iZXIuYWNvcygtMSk7XG59LCBoYXNoZXIpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBCaWdOdW1iZXIgdGF1LCB0YXUgPSAyICogcGlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEJpZ051bWJlciAgIEJpZ051bWJlciBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge0JpZ051bWJlcn0gUmV0dXJucyB0YXVcbiAqL1xuZXhwb3J0cy50YXUgPSBtZW1vaXplKGZ1bmN0aW9uIChCaWdOdW1iZXIpIHtcbiAgcmV0dXJuIGV4cG9ydHMucGkoQmlnTnVtYmVyKS50aW1lcygyKTtcbn0sIGhhc2hlcik7XG5cbi8qKlxuICogQ3JlYXRlIGEgaGFzaCBmb3IgYSBCaWdOdW1iZXIgY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoZSBjcmVhdGVkIGhhcyBpc1xuICogdGhlIGNvbmZpZ3VyZWQgcHJlY2lzaW9uXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzICAgICAgICAgU3VwcG9zZWQgdG8gY29udGFpbiBhIHNpbmdsZSBlbnRyeSB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBCaWdOdW1iZXIgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge251bWJlcn0gcHJlY2lzaW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYXNoZXIgKGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3NbMF0ucHJlY2lzaW9uO1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0IGEgQmlnTnVtYmVyIHRvIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBTeW50YXg6XG4gKlxuICogICAgZm9ybWF0KHZhbHVlKVxuICogICAgZm9ybWF0KHZhbHVlLCBvcHRpb25zKVxuICogICAgZm9ybWF0KHZhbHVlLCBwcmVjaXNpb24pXG4gKiAgICBmb3JtYXQodmFsdWUsIGZuKVxuICpcbiAqIFdoZXJlOlxuICpcbiAqICAgIHtudW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICogICAge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3Qgd2l0aCBmb3JtYXR0aW5nIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBub3RhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG5vdGF0aW9uLiBDaG9vc2UgZnJvbTpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdmaXhlZCcgICAgICAgICAgQWx3YXlzIHVzZSByZWd1bGFyIG51bWJlciBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEyMy40MCcgYW5kICcxNDAwMDAwMCdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdleHBvbmVudGlhbCcgICAgQWx3YXlzIHVzZSBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJzEuMjM0ZSsyJyBhbmQgJzEuNGUrNydcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdhdXRvJyAoZGVmYXVsdCkgUmVndWxhciBudW1iZXIgbm90YXRpb24gZm9yIG51bWJlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2aW5nIGFuIGFic29sdXRlIHZhbHVlIGJldHdlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG93ZXIgYm91bmQgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGV4Y2x1ZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQnIGFuZCAnMS40ZTcnLlxuICogICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBwcmVjaXNpb24gICBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDE2IHRvIHJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkaWdpdHMgb2YgdGhlIG51bWJlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbnMgJ2V4cG9uZW50aWFsJyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLCBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSB0b3RhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbiAnZml4ZWQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSBudW1iZXIgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnQgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LCBhbmQgaXMgMCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBleHBvbmVudGlhbCBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gbG93ZXIgYW5kIHtudW1iZXJ9IHVwcGVyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGJ5IG5vdGF0aW9uICdhdXRvJyB0byBkZXRlcm1pbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0byByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWVzIGFyZSBgbG93ZXI9MWUtM2AgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cHBlcj0xZTVgLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAqICAgIHtGdW5jdGlvbn0gZm4gICAgQSBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgIGJ1aWx0LWluIG5vdGF0aW9ucy4gRnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgd2l0aCBgdmFsdWVgIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBhbmQgbXVzdCByZXR1cm4gYSBzdHJpbmcuIElzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0b1xuICogICAgICAgICAgICAgICAgICAgICBmb3JtYXQgYWxsIHZhbHVlcyBpbnNpZGUgYSBtYXRyaXggaW4gYSBwYXJ0aWN1bGFyIHdheS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICBmb3JtYXQoNi40KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzYuNCdcbiAqICAgIGZvcm1hdCgxMjQwMDAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMS4yNGU2J1xuICogICAgZm9ybWF0KDEvMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwLjMzMzMzMzMzMzMzMzMzMzMnXG4gKiAgICBmb3JtYXQoMS8zLCAzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAuMzMzJ1xuICogICAgZm9ybWF0KDIxMzg1LCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcyMTAwMCdcbiAqICAgIGZvcm1hdCgxMi4wNzEsIHtub3RhdGlvbjogJ2ZpeGVkJ30pOyAgICAgICAgICAgICAgICAvLyAnMTInXG4gKiAgICBmb3JtYXQoMi4zLCAgICB7bm90YXRpb246ICdmaXhlZCcsIHByZWNpc2lvbjogMn0pOyAgLy8gJzIuMzAnXG4gKiAgICBmb3JtYXQoNTIuOCwgICB7bm90YXRpb246ICdleHBvbmVudGlhbCd9KTsgICAgICAgICAgLy8gJzUuMjhlKzEnXG4gKlxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdCB8IEZ1bmN0aW9uIHwgbnVtYmVyfSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyIFRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gaGFuZGxlIGZvcm1hdCh2YWx1ZSwgZm4pXG4gICAgcmV0dXJuIG9wdGlvbnModmFsdWUpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZXNcbiAgaWYgKCF2YWx1ZS5pc0Zpbml0ZSgpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmlzTmFOKCkgPyAnTmFOJyA6ICh2YWx1ZS5ndCgwKSA/ICdJbmZpbml0eScgOiAnLUluZmluaXR5Jyk7XG4gIH1cblxuICAvLyBkZWZhdWx0IHZhbHVlcyBmb3Igb3B0aW9uc1xuICB2YXIgbm90YXRpb24gPSAnYXV0byc7XG4gIHZhciBwcmVjaXNpb24gPSB1bmRlZmluZWQ7XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGRldGVybWluZSBub3RhdGlvbiBmcm9tIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5ub3RhdGlvbikge1xuICAgICAgbm90YXRpb24gPSBvcHRpb25zLm5vdGF0aW9uO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBwcmVjaXNpb24gZnJvbSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgcHJlY2lzaW9uID0gb3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5wcmVjaXNpb24pIHtcbiAgICAgIHByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSB0aGUgdmFyaW91cyBub3RhdGlvbnNcbiAgc3dpdGNoIChub3RhdGlvbikge1xuICAgIGNhc2UgJ2ZpeGVkJzpcbiAgICAgIHJldHVybiBleHBvcnRzLnRvRml4ZWQodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICBjYXNlICdleHBvbmVudGlhbCc6XG4gICAgICByZXR1cm4gZXhwb3J0cy50b0V4cG9uZW50aWFsKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICAvLyBkZXRlcm1pbmUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIGZvciBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB1cHBlciBhbmQgbG93ZXIgdG8gYmUgQmlnTnVtYmVycyB0aGVtc2VsdmVzXG4gICAgICB2YXIgbG93ZXIgPSAxZS0zO1xuICAgICAgdmFyIHVwcGVyID0gMWU1O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leHBvbmVudGlhbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5leHBvbmVudGlhbC5sb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbG93ZXIgPSBvcHRpb25zLmV4cG9uZW50aWFsLmxvd2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4cG9uZW50aWFsLnVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IG9wdGlvbnMuZXhwb25lbnRpYWwudXBwZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRqdXN0IHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgKHllYWgsIHRoaXMgaXMgcXVpdGUgdHJpY2t5Li4uKVxuICAgICAgdmFyIG9sZENvbmZpZyA9IHtcbiAgICAgICAgdG9FeHBOZWc6IHZhbHVlLmNvbnN0cnVjdG9yLnRvRXhwTmVnLFxuICAgICAgICB0b0V4cFBvczogdmFsdWUuY29uc3RydWN0b3IudG9FeHBQb3NcbiAgICAgIH07XG5cbiAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLmNvbmZpZyh7XG4gICAgICAgIHRvRXhwTmVnOiBNYXRoLnJvdW5kKE1hdGgubG9nKGxvd2VyKSAvIE1hdGguTE4xMCksXG4gICAgICAgIHRvRXhwUG9zOiBNYXRoLnJvdW5kKE1hdGgubG9nKHVwcGVyKSAvIE1hdGguTE4xMClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIHplcm9cbiAgICAgIGlmICh2YWx1ZS5pc1plcm8oKSkgcmV0dXJuICcwJztcblxuICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIG91dHB1dCBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgdmFyIHN0cjtcbiAgICAgIHZhciBhYnMgPSB2YWx1ZS5hYnMoKTtcbiAgICAgIGlmIChhYnMuZ3RlKGxvd2VyKSAmJiBhYnMubHQodXBwZXIpKSB7XG4gICAgICAgIC8vIG5vcm1hbCBudW1iZXIgbm90YXRpb25cbiAgICAgICAgc3RyID0gdmFsdWUudG9TaWduaWZpY2FudERpZ2l0cyhwcmVjaXNpb24pLnRvRml4ZWQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBleHBvbmVudGlhbCBub3RhdGlvblxuICAgICAgICBzdHIgPSBleHBvcnRzLnRvRXhwb25lbnRpYWwodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oKFxcLlxcZCo/KSgwKykpKCR8ZSkvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaWdpdHMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBlID0gYXJndW1lbnRzWzRdO1xuICAgICAgICByZXR1cm4gKGRpZ2l0cyAhPT0gJy4nKSA/IGRpZ2l0cyArIGUgOiBlO1xuICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vdGF0aW9uIFwiJyArIG5vdGF0aW9uICsgJ1wiLiAnICtcbiAgICAgICAgICAnQ2hvb3NlIFwiYXV0b1wiLCBcImV4cG9uZW50aWFsXCIsIG9yIFwiZml4ZWRcIi4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JtYXQgYSBudW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24uIExpa2UgJzEuMjNlKzUnLCAnMi4zZSswJywgJzMuNTAwZS0zJ1xuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbl0gIE51bWJlciBvZiBkaWdpdHMgaW4gZm9ybWF0dGVkIG91dHB1dC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGUgbWF4aW11bSBhdmFpbGFibGUgZGlnaXRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJcbiAqL1xuZXhwb3J0cy50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgaWYgKHByZWNpc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uIC0gMSk7IC8vIE5vdGUgdGhlIG9mZnNldCBvZiBvbmVcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudG9FeHBvbmVudGlhbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGZpeGVkIG5vdGF0aW9uLlxuICogQHBhcmFtIHtCaWdOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSAgICAgICAgT3B0aW9uYWwgbnVtYmVyIG9mIGRlY2ltYWxzIGFmdGVyIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgcG9pbnQuIFplcm8gYnkgZGVmYXVsdC5cbiAqL1xuZXhwb3J0cy50b0ZpeGVkID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIHZhbHVlLnRvRml4ZWQocHJlY2lzaW9uIHx8IDApO1xuICAvLyBOb3RlOiB0aGUgKHByZWNpc2lvbiB8fCAwKSBpcyBuZWVkZWQgYXMgdGhlIHRvRml4ZWQgb2YgQmlnTnVtYmVyIGhhcyBhblxuICAvLyB1bmRlZmluZWQgZGVmYXVsdCBwcmVjaXNpb24gaW5zdGVhZCBvZiAwLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gQmlnTnVtYmVycy5cbiAqIEBwYXJhbSB7QmlnTnVtYmVyfSB4ICAgICAgIEZpcnN0IHZhbHVlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7QmlnTnVtYmVyfSB5ICAgICAgIFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge251bWJlcn0gW2Vwc2lsb25dICBUaGUgbWF4aW11bSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4geCBhbmQgeVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZXBzaWxvbiBpcyB1bmRlZmluZWQgb3IgbnVsbCwgdGhlIGZ1bmN0aW9uIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3Qgd2hldGhlciB4IGFuZCB5IGFyZSBleGFjdGx5IGVxdWFsLlxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdHdvIG51bWJlcnMgYXJlIG5lYXJseSBlcXVhbFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5lYXJseUVxdWFsKHgsIHksIGVwc2lsb24pIHtcbiAgLy8gaWYgZXBzaWxvbiBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdGVzdCB3aGV0aGVyIHggYW5kIHkgYXJlIGV4YWN0bHkgZXF1YWxcbiAgaWYgKGVwc2lsb24gPT0gbnVsbCkge1xuICAgIHJldHVybiB4LmVxKHkpO1xuICB9XG5cblxuICAvLyB1c2UgXCI9PVwiIG9wZXJhdG9yLCBoYW5kbGVzIGluZmluaXRpZXNcbiAgaWYgKHguZXEoeSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIE5hTlxuICBpZiAoeC5pc05hTigpIHx8IHkuaXNOYU4oKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQgeCBhbmQgeSBzaG91bGQgYmUgZmluaXRlXG4gIGlmKHguaXNGaW5pdGUoKSAmJiB5LmlzRmluaXRlKCkpIHtcbiAgICAvLyBjaGVjayBudW1iZXJzIGFyZSB2ZXJ5IGNsb3NlLCBuZWVkZWQgd2hlbiBjb21wYXJpbmcgbnVtYmVycyBuZWFyIHplcm9cbiAgICB2YXIgZGlmZiA9IHgubWludXMoeSkuYWJzKCk7XG4gICAgaWYgKGRpZmYuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHVzZSByZWxhdGl2ZSBlcnJvclxuICAgICAgdmFyIG1heCA9IHguY29uc3RydWN0b3IubWF4KHguYWJzKCksIHkuYWJzKCkpO1xuICAgICAgcmV0dXJuIGRpZmYubHRlKG1heC50aW1lcyhlcHNpbG9uKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5maW5pdGUgYW5kIE51bWJlciBvciBuZWdhdGl2ZSBJbmZpbml0ZSBhbmQgcG9zaXRpdmUgSW5maW5pdGUgY2FzZXNcbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSBib29sZWFuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBpc0Jvb2xlYW5cbiAqL1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdib29sZWFuJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2lzQ29sbGVjdGlvbicpO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBhcnJheSBjb250YWlucyBjb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgYXJyYXkgY29udGFpbnMgb25lIG9yIG11bHRpcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbnMgKEFycmF5cyBvciBNYXRyaWNlcykuIFJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnRhaW5zQ29sbGVjdGlvbnMgKGFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGFycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbG9vcCBvdmVyIGFsbCBlbGVtZW50cyBpbiBhIGdpdmVuIG11bHRpIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBvbiBlYWNoIG9mIHRoZSBlbGVtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXkgfCBNYXRyaXh9IGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgICAgVGhlIGNhbGxiYWNrIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggb25lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyOiB0aGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBhcnJheVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBGb3JFYWNoIChhcnJheSwgY2FsbGJhY2spIHtcbiAgaWYgKGFycmF5ICYmIGFycmF5LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGRlZXBGb3JFYWNoKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBlbGVtZW50IHdpc2UgZm9yIGVhY2ggZWxlbWVudCBpbiBhcnJheSBhbmQgYW55XG4gKiBuZXN0ZWQgYXJyYXlcbiAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgcmVzdWx0c1xuICogQHBhcmFtIHtBcnJheSB8IE1hdHJpeH0gYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTEgYW5kIHZhbHVlMiwgd2hpY2ggY29udGFpbiB0aGUgY3VycmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50IG9mIGJvdGggYXJyYXlzLlxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFplcm9zXSBJbnZva2UgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIG5vbi16ZXJvIHZhbHVlcyBvbmx5LlxuICpcbiAqIEByZXR1cm4ge0FycmF5IHwgTWF0cml4fSByZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwTWFwKGFycmF5LCBjYWxsYmFjaywgc2tpcFplcm9zKSB7XG4gIGlmIChhcnJheSAmJiAodHlwZW9mIGFycmF5Lm1hcCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAvLyBUT0RPOiByZXBsYWNlIGFycmF5Lm1hcCB3aXRoIGEgZm9yIGxvb3AgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgIHJldHVybiBhcnJheS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBkZWVwTWFwKHgsIGNhbGxiYWNrLCBza2lwWmVyb3MpO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBjYWxsYmFjayhhcnJheSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgYSBjb2xsZWN0aW9uOiBhbiBBcnJheSBvciBNYXRyaXhcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybnMge2Jvb2xlYW59IGlzQ29sbGVjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ29sbGVjdGlvbiAoeCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoeCkgfHwgKHggJiYgeC5pc01hdHJpeCA9PT0gdHJ1ZSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5U2l6ZSA9IHJlcXVpcmUoJy4uL2FycmF5Jykuc2l6ZTtcbnZhciBJbmRleEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvSW5kZXhFcnJvcicpO1xuXG4vKipcbiAqIFJlZHVjZSBhIGdpdmVuIG1hdHJpeCBvciBhcnJheSB0byBhIG5ldyBtYXRyaXggb3JcbiAqIGFycmF5IHdpdGggb25lIGxlc3MgZGltZW5zaW9uLCBhcHBseWluZyB0aGUgZ2l2ZW5cbiAqIGNhbGxiYWNrIGluIHRoZSBzZWxlY3RlZCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge0FycmF5IHwgTWF0cml4fSBtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtBcnJheSB8IE1hdHJpeH0gcmVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWF0LCBkaW0sIGNhbGxiYWNrKSB7XG4gIHZhciBzaXplID0gQXJyYXkuaXNBcnJheShtYXQpID8gYXJyYXlTaXplKG1hdCkgOiBtYXQuc2l6ZSgpO1xuICBpZiAoZGltIDwgMCB8fCAoZGltID49IHNpemUubGVuZ3RoKSkge1xuICAgIC8vIFRPRE86IHdvdWxkIGJlIG1vcmUgY2xlYXIgd2hlbiB0aHJvd2luZyBhIERpbWVuc2lvbkVycm9yIGhlcmVcbiAgICB0aHJvdyBuZXcgSW5kZXhFcnJvcihkaW0sIHNpemUubGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChtYXQgJiYgbWF0LmlzTWF0cml4ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIG1hdC5jcmVhdGUoX3JlZHVjZShtYXQudmFsdWVPZigpLCBkaW0sIGNhbGxiYWNrKSk7XG4gIH1lbHNlIHtcbiAgICByZXR1cm4gX3JlZHVjZShtYXQsIGRpbSwgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlZHVjZSBhIG1hdHJpeFxuICogQHBhcmFtIHtBcnJheX0gbWF0XG4gKiBAcGFyYW0ge251bWJlcn0gZGltXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSByZXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZWR1Y2UobWF0LCBkaW0sIGNhbGxiYWNrKXtcbiAgdmFyIGksIHJldCwgdmFsLCB0cmFuO1xuXG4gIGlmKGRpbTw9MCl7XG4gICAgaWYoICFBcnJheS5pc0FycmF5KG1hdFswXSkgKXtcbiAgICAgIHZhbCA9IG1hdFswXTtcbiAgICAgIGZvcihpPTE7IGk8bWF0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFsID0gY2FsbGJhY2sodmFsLCBtYXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9ZWxzZXtcbiAgICAgIHRyYW4gPSBfc3dpdGNoKG1hdCk7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIGZvcihpPTA7IGk8dHJhbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHJldFtpXSA9IF9yZWR1Y2UodHJhbltpXSwgZGltLTEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9ZWxzZXtcbiAgICByZXQgPSBbXTtcbiAgICBmb3IoaT0wOyBpPG1hdC5sZW5ndGg7IGkrKyl7XG4gICAgICByZXRbaV0gPSBfcmVkdWNlKG1hdFtpXSwgZGltLTEsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxuICogQHBhcmFtIHtBcnJheX0gbWF0XG4gKiBAcmV0dXJucyB7QXJyYXl9IHJldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3N3aXRjaChtYXQpe1xuICB2YXIgSSA9IG1hdC5sZW5ndGg7XG4gIHZhciBKID0gbWF0WzBdLmxlbmd0aDtcbiAgdmFyIGksIGo7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yKCBqPTA7IGo8SjsgaisrKSB7XG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIGZvciggaT0wOyBpPEk7IGkrKykge1xuICAgICAgdG1wLnB1c2gobWF0W2ldW2pdKTtcbiAgICB9XG4gICAgcmV0LnB1c2godG1wKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNjYXR0ZXIoYSwgaiwgdywgeCwgdSwgbWFyaywgYywgZiwgaW52ZXJzZSwgdXBkYXRlLCB2YWx1ZSkge1xuICAvLyBhIGFycmF5c1xuICB2YXIgYXZhbHVlcyA9IGEuX3ZhbHVlcztcbiAgdmFyIGFpbmRleCA9IGEuX2luZGV4O1xuICB2YXIgYXB0ciA9IGEuX3B0cjtcbiAgLy8gYyBhcnJheXNcbiAgdmFyIGNpbmRleCA9IGMuX2luZGV4O1xuXG4gIC8vIHZhcnNcbiAgdmFyIGssIGswLCBrMSwgaTtcblxuICAvLyBjaGVjayB3ZSBuZWVkIHRvIHByb2Nlc3MgdmFsdWVzIChwYXR0ZXJuIG1hdHJpeClcbiAgaWYgKHgpIHtcbiAgICAvLyB2YWx1ZXMgaW4galxuICAgIGZvciAoazAgPSBhcHRyW2pdLCBrMSA9IGFwdHJbaiArIDFdLCBrID0gazA7IGsgPCBrMTsgaysrKSB7XG4gICAgICAvLyByb3dcbiAgICAgIGkgPSBhaW5kZXhba107XG4gICAgICAvLyBjaGVjayB2YWx1ZSBleGlzdHMgaW4gY3VycmVudCBqXG4gICAgICBpZiAod1tpXSAhPT0gbWFyaykge1xuICAgICAgICAvLyBpIGlzIG5ldyBlbnRyeSBpbiBqXG4gICAgICAgIHdbaV0gPSBtYXJrO1xuICAgICAgICAvLyBhZGQgaSB0byBwYXR0ZXJuIG9mIENcbiAgICAgICAgY2luZGV4LnB1c2goaSk7XG4gICAgICAgIC8vIHgoaSkgPSBBLCBjaGVjayB3ZSBuZWVkIHRvIGNhbGwgZnVuY3Rpb24gdGhpcyB0aW1lXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAvLyBjb3B5IHZhbHVlIHRvIHdvcmtzcGFjZSBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgeFtpXSA9IGludmVyc2UgPyBmKGF2YWx1ZXNba10sIHZhbHVlKSA6IGYodmFsdWUsIGF2YWx1ZXNba10pO1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIHdhcyBjYWxsZWQgb24gY3VycmVudCByb3dcbiAgICAgICAgICB1W2ldID0gbWFyaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBjb3B5IHZhbHVlIHRvIHdvcmtzcGFjZVxuICAgICAgICAgIHhbaV0gPSBhdmFsdWVzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaSBleGlzdHMgaW4gQyBhbHJlYWR5XG4gICAgICAgIHhbaV0gPSBpbnZlcnNlID8gZihhdmFsdWVzW2tdLCB4W2ldKSA6IGYoeFtpXSwgYXZhbHVlc1trXSk7XG4gICAgICAgIC8vIGZ1bmN0aW9uIHdhcyBjYWxsZWQgb24gY3VycmVudCByb3dcbiAgICAgICAgdVtpXSA9IG1hcms7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHZhbHVlcyBpbiBqXG4gICAgZm9yIChrMCA9IGFwdHJbal0sIGsxID0gYXB0cltqICsgMV0sIGsgPSBrMDsgayA8IGsxOyBrKyspIHtcbiAgICAgIC8vIHJvd1xuICAgICAgaSA9IGFpbmRleFtrXTtcbiAgICAgIC8vIGNoZWNrIHZhbHVlIGV4aXN0cyBpbiBjdXJyZW50IGpcbiAgICAgIGlmICh3W2ldICE9PSBtYXJrKSB7XG4gICAgICAgIC8vIGkgaXMgbmV3IGVudHJ5IGluIGpcbiAgICAgICAgd1tpXSA9IG1hcms7XG4gICAgICAgIC8vIGFkZCBpIHRvIHBhdHRlcm4gb2YgQ1xuICAgICAgICBjaW5kZXgucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpbmRpY2F0ZSBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uIGN1cnJlbnQgcm93XG4gICAgICAgIHVbaV0gPSBtYXJrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiIsInZhciBFbWl0dGVyID0gcmVxdWlyZSgndGlueS1lbWl0dGVyJyk7XG5cbi8qKlxuICogRXh0ZW5kIGdpdmVuIG9iamVjdCB3aXRoIGVtaXR0ZXIgZnVuY3Rpb25zIGBvbmAsIGBvZmZgLCBgb25jZWAsIGBlbWl0YFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fSBvYmpcbiAqL1xuZXhwb3J0cy5taXhpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgLy8gY3JlYXRlIGV2ZW50IGVtaXR0ZXJcbiAgdmFyIGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gIC8vIGJpbmQgbWV0aG9kcyB0byBvYmogKHdlIGRvbid0IHdhbnQgdG8gZXhwb3NlIHRoZSBlbWl0dGVyLmUgQXJyYXkuLi4pXG4gIG9iai5vbiAgID0gZW1pdHRlci5vbi5iaW5kKGVtaXR0ZXIpO1xuICBvYmoub2ZmICA9IGVtaXR0ZXIub2ZmLmJpbmQoZW1pdHRlcik7XG4gIG9iai5vbmNlID0gZW1pdHRlci5vbmNlLmJpbmQoZW1pdHRlcik7XG4gIG9iai5lbWl0ID0gZW1pdHRlci5lbWl0LmJpbmQoZW1pdHRlcik7XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvLyBmdW5jdGlvbiB1dGlsc1xuXG4vKlxuICogTWVtb2l6ZSBhIGdpdmVuIGZ1bmN0aW9uIGJ5IGNhY2hpbmcgdGhlIGNvbXB1dGVkIHJlc3VsdC5cbiAqIFRoZSBjYWNoZSBvZiBhIG1lbW9pemVkIGZ1bmN0aW9uIGNhbiBiZSBjbGVhcmVkIGJ5IGRlbGV0aW5nIHRoZSBgY2FjaGVgXG4gKiBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gICAgICAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgbWVtb2l6ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE11c3QgYmUgYSBwdXJlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihhcmdzOiBBcnJheSl9IFtoYXNoZXJdICBBIGN1c3RvbSBoYXNoIGJ1aWxkZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElzIEpTT04uc3RyaW5naWZ5IGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMubWVtb2l6ZSA9IGZ1bmN0aW9uKGZuLCBoYXNoZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9pemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vaXplLmNhY2hlICE9PSAnb2JqZWN0Jykge1xuICAgICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdmFyIGhhc2ggPSBoYXNoZXIgPyBoYXNoZXIoYXJncykgOiBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICBpZiAoIShoYXNoIGluIG1lbW9pemUuY2FjaGUpKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZS5jYWNoZVtoYXNoXSA9IGZuLmFwcGx5KGZuLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW9pemUuY2FjaGVbaGFzaF07XG4gIH07XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZCBieSBhIHR5cGVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gICBBIHR5cGVkIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGV4cGVjdGVkIGFyZ3VtZW50cy5cbiAqICAgICAgICAgICAgICAgICAgUmV0dXJucyAtMSB3aGVuIG5vIHNpZ25hdHVyZXMgd2hlcmUgZm91bmQgb24gdGhlIGZ1bmN0aW9uLlxuICovXG5leHBvcnRzLm1heEFyZ3VtZW50Q291bnQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGZuLnNpZ25hdHVyZXMgfHwge30pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uIChhcmdzLCBzaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gKHNpZ25hdHVyZS5tYXRjaCgvLC9nKSB8fCBbXSkubGVuZ3RoICsgMTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGFyZ3MsIGNvdW50KTtcbiAgICAgIH0sIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5leHBvcnRzWydib29sZWFuJ10gPSByZXF1aXJlKCcuL2Jvb2xlYW4nKTtcbmV4cG9ydHNbJ2Z1bmN0aW9uJ10gPSByZXF1aXJlKCcuL2Z1bmN0aW9uJyk7XG5leHBvcnRzLm51bWJlciA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG5leHBvcnRzLm9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0Jyk7XG5leHBvcnRzLnN0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5nJyk7XG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuZXhwb3J0cy5lbWl0dGVyID0gcmVxdWlyZSgnLi9lbWl0dGVyJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc3ltYm9scyA9IHtcbiAgLy8gR1JFRUsgTEVUVEVSU1xuICBBbHBoYTogJ0EnLCAgICAgYWxwaGE6ICdcXFxcYWxwaGEnLFxuICBCZXRhOiAnQicsICAgICAgYmV0YTogJ1xcXFxiZXRhJyxcbiAgR2FtbWE6ICdcXFxcR2FtbWEnLCAgICBnYW1tYTogJ1xcXFxnYW1tYScsXG4gIERlbHRhOiAnXFxcXERlbHRhJywgICAgZGVsdGE6ICdcXFxcZGVsdGEnLFxuICBFcHNpbG9uOiAnRScsICAgZXBzaWxvbjogJ1xcXFxlcHNpbG9uJywgIHZhcmVwc2lsb246ICdcXFxcdmFyZXBzaWxvbicsXG4gIFpldGE6ICdaJywgICAgICB6ZXRhOiAnXFxcXHpldGEnLFxuICBFdGE6ICdIJywgICAgICAgZXRhOiAnXFxcXGV0YScsXG4gIFRoZXRhOiAnXFxcXFRoZXRhJywgICAgdGhldGE6ICdcXFxcdGhldGEnLCAgICB2YXJ0aGV0YTogJ1xcXFx2YXJ0aGV0YScsXG4gIElvdGE6ICdJJywgICAgICBpb3RhOiAnXFxcXGlvdGEnLFxuICBLYXBwYTogJ0snLCAgICAga2FwcGE6ICdcXFxca2FwcGEnLCAgICB2YXJrYXBwYTogJ1xcXFx2YXJrYXBwYScsXG4gIExhbWJkYTogJ1xcXFxMYW1iZGEnLCAgIGxhbWJkYTogJ1xcXFxsYW1iZGEnLFxuICBNdTogJ00nLCAgICAgICAgbXU6ICdcXFxcbXUnLFxuICBOdTogJ04nLCAgICAgICAgbnU6ICdcXFxcbnUnLFxuICBYaTogJ1xcXFxYaScsICAgICAgIHhpOiAnXFxcXHhpJyxcbiAgT21pY3JvbjogJ08nLCAgIG9taWNyb246ICdvJyxcbiAgUGk6ICdcXFxcUGknLCAgICAgICBwaTogJ1xcXFxwaScsICAgICAgIHZhcnBpOiAnXFxcXHZhcnBpJyxcbiAgUmhvOiAnUCcsICAgICAgIHJobzogJ1xcXFxyaG8nLCAgICAgIHZhcnJobzogJ1xcXFx2YXJyaG8nLFxuICBTaWdtYTogJ1xcXFxTaWdtYScsICAgIHNpZ21hOiAnXFxcXHNpZ21hJywgICAgdmFyc2lnbWE6ICdcXFxcdmFyc2lnbWEnLFxuICBUYXU6ICdUJywgICAgICAgdGF1OiAnXFxcXHRhdScsXG4gIFVwc2lsb246ICdcXFxcVXBzaWxvbicsICB1cHNpbG9uOiAnXFxcXHVwc2lsb24nLFxuICBQaGk6ICdcXFxcUGhpJywgICAgICBwaGk6ICdcXFxccGhpJywgICAgICB2YXJwaGk6ICdcXFxcdmFycGhpJyxcbiAgQ2hpOiAnWCcsICAgICAgIGNoaTogJ1xcXFxjaGknLFxuICBQc2k6ICdcXFxcUHNpJywgICAgICBwc2k6ICdcXFxccHNpJyxcbiAgT21lZ2E6ICdcXFxcT21lZ2EnLCAgICBvbWVnYTogJ1xcXFxvbWVnYScsXG4gIC8vbG9naWNcbiAgJ3RydWUnOiAnXFxcXG1hdGhybXtUcnVlfScsXG4gICdmYWxzZSc6ICdcXFxcbWF0aHJte0ZhbHNlfScsXG4gIC8vb3RoZXJcbiAgaTogJ2knLCAvL1RPRE8gdXNlIFxcaSA/P1xuICBpbmY6ICdcXFxcaW5mdHknLFxuICBJbmY6ICdcXFxcaW5mdHknLFxuICBpbmZpbml0eTogJ1xcXFxpbmZ0eScsXG4gIEluZmluaXR5OiAnXFxcXGluZnR5JyxcbiAgb286ICdcXFxcaW5mdHknLFxuICBsaW06ICdcXFxcbGltJyxcbiAgJ3VuZGVmaW5lZCc6ICdcXFxcbWF0aGJmez99J1xufTtcblxuZXhwb3J0cy5vcGVyYXRvcnMgPSB7XG4gICd0cmFuc3Bvc2UnOiAnXlxcXFx0b3AnLFxuICAnZmFjdG9yaWFsJzogJyEnLFxuICAncG93JzogJ14nLFxuICAnZG90UG93JzogJy5eXFxcXHdlZGdlJywgLy9UT0RPIGZpbmQgaWRlYWwgc29sdXRpb25cbiAgJ3VuYXJ5UGx1cyc6ICcrJyxcbiAgJ3VuYXJ5TWludXMnOiAnLScsXG4gICdiaXROb3QnOiAnficsIC8vVE9ETyBmaW5kIGlkZWFsIHNvbHV0aW9uXG4gICdub3QnOiAnXFxcXG5lZycsXG4gICdtdWx0aXBseSc6ICdcXFxcY2RvdCcsXG4gICdkaXZpZGUnOiAnXFxcXGZyYWMnLCAvL1RPRE8gaG93IHRvIGhhbmRsZSB0aGF0IHByb3Blcmx5P1xuICAnZG90TXVsdGlwbHknOiAnLlxcXFxjZG90JywgLy9UT0RPIGZpbmQgaWRlYWwgc29sdXRpb25cbiAgJ2RvdERpdmlkZSc6ICcuOicsIC8vVE9ETyBmaW5kIGlkZWFsIHNvbHV0aW9uXG4gICdtb2QnOiAnXFxcXG1vZCcsXG4gICdhZGQnOiAnKycsXG4gICdzdWJ0cmFjdCc6ICctJyxcbiAgJ3RvJzogJ1xcXFxyaWdodGFycm93JyxcbiAgJ2xlZnRTaGlmdCc6ICc8PCcsXG4gICdyaWdodEFyaXRoU2hpZnQnOiAnPj4nLFxuICAncmlnaHRMb2dTaGlmdCc6ICc+Pj4nLFxuICAnZXF1YWwnOiAnPScsXG4gICd1bmVxdWFsJzogJ1xcXFxuZXEnLFxuICAnc21hbGxlcic6ICc8JyxcbiAgJ2xhcmdlcic6ICc+JyxcbiAgJ3NtYWxsZXJFcSc6ICdcXFxcbGVxJyxcbiAgJ2xhcmdlckVxJzogJ1xcXFxnZXEnLFxuICAnYml0QW5kJzogJ1xcXFwmJyxcbiAgJ2JpdFhvcic6ICdcXFxcdW5kZXJsaW5le3x9JyxcbiAgJ2JpdE9yJzogJ3wnLFxuICAnYW5kJzogJ1xcXFx3ZWRnZScsXG4gICd4b3InOiAnXFxcXHZlZWJhcicsXG4gICdvcic6ICdcXFxcdmVlJ1xufTtcblxuZXhwb3J0cy5kZWZhdWx0VGVtcGxhdGUgPSAnXFxcXG1hdGhybXske25hbWV9fVxcXFxsZWZ0KCR7YXJnc31cXFxccmlnaHQpJztcblxudmFyIHVuaXRzID0ge1xuICBkZWc6ICdeXFxcXGNpcmMnXG59O1xuXG4vL0BwYXJhbSB7c3RyaW5nfSBuYW1lXG4vL0BwYXJhbSB7Ym9vbGVhbn0gaXNVbml0XG5leHBvcnRzLnRvU3ltYm9sID0gZnVuY3Rpb24gKG5hbWUsIGlzVW5pdCkge1xuICBpc1VuaXQgPSB0eXBlb2YgaXNVbml0ID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogaXNVbml0O1xuICBpZiAoaXNVbml0KSB7XG4gICAgaWYgKHVuaXRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdW5pdHNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiAnXFxcXG1hdGhybXsnICsgbmFtZSArICd9JztcbiAgfVxuXG4gIGlmIChleHBvcnRzLnN5bWJvbHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5zeW1ib2xzW25hbWVdO1xuICB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIC8vc3ltYm9sIHdpdGggaW5kZXggKGVnLiBhbHBoYV8xKVxuICAgIHZhciBpbmRleCA9IG5hbWUuaW5kZXhPZignXycpO1xuICAgIHJldHVybiBleHBvcnRzLnRvU3ltYm9sKG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KSkgKyAnX3snXG4gICAgICArIGV4cG9ydHMudG9TeW1ib2wobmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxKSkgKyAnfSc7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTnVtYmVyRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9OdW1iZXJGb3JtYXR0ZXInKTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdmFsdWUgaXMgYSBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlzTnVtYmVyXG4gKi9cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBudW1iZXIgaXMgaW50ZWdlclxuICogQHBhcmFtIHtudW1iZXIgfCBib29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gaXNJbnRlZ2VyXG4gKi9cbmV4cG9ydHMuaXNJbnRlZ2VyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuICAgICAgPyAodmFsdWUgPT0gTWF0aC5yb3VuZCh2YWx1ZSkpXG4gICAgICA6IGZhbHNlO1xuICAvLyBOb3RlOiB3ZSB1c2UgPT0sIG5vdCA9PT0sIGFzIHdlIGNhbiBoYXZlIEJvb2xlYW5zIGFzIHdlbGxcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaWduIG9mIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGVsc2UgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgdG8gYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIFN5bnRheDpcbiAqXG4gKiAgICBmb3JtYXQodmFsdWUpXG4gKiAgICBmb3JtYXQodmFsdWUsIG9wdGlvbnMpXG4gKiAgICBmb3JtYXQodmFsdWUsIHByZWNpc2lvbilcbiAqICAgIGZvcm1hdCh2YWx1ZSwgZm4pXG4gKlxuICogV2hlcmU6XG4gKlxuICogICAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gKiAgICB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIGZvcm1hdHRpbmcgb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IG5vdGF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIgbm90YXRpb24uIENob29zZSBmcm9tOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpeGVkJyAgICAgICAgICBBbHdheXMgdXNlIHJlZ3VsYXIgbnVtYmVyIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQwJyBhbmQgJzE0MDAwMDAwJ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgJ2V4cG9uZW50aWFsJyAgICBBbHdheXMgdXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMS4yMzRlKzInIGFuZCAnMS40ZSs3J1xuICogICAgICAgICAgICAgICAgICAgICAgICAgJ2VuZ2luZWVyaW5nJyAgICBBbHdheXMgdXNlIGVuZ2luZWVyaW5nIG5vdGF0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjRlKzAnIGFuZCAnMTQuMGUrNidcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICdhdXRvJyAoZGVmYXVsdCkgUmVndWxhciBudW1iZXIgbm90YXRpb24gZm9yIG51bWJlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGF2aW5nIGFuIGFic29sdXRlIHZhbHVlIGJldHdlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMsIGFuZCB1c2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50aWFsIG5vdGF0aW9uIGVsc2V3aGVyZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG93ZXIgYm91bmQgaXMgaW5jbHVkZWQsIHVwcGVyIGJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGV4Y2x1ZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSAnMTIzLjQnIGFuZCAnMS40ZTcnLlxuICogICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBwcmVjaXNpb24gICBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDE2IHRvIHJvdW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkaWdpdHMgb2YgdGhlIG51bWJlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbnMgJ2V4cG9uZW50aWFsJyBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nLCBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSB0b3RhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBpcyB1bmRlZmluZWQgYnkgZGVmYXVsdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW4gY2FzZSBvZiBub3RhdGlvbiAnZml4ZWQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcHJlY2lzaW9uYCBkZWZpbmVzIHRoZSBudW1iZXIgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnQgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LCBhbmQgaXMgMCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBleHBvbmVudGlhbCBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcGFyYW1ldGVycyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0gbG93ZXIgYW5kIHtudW1iZXJ9IHVwcGVyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGJ5IG5vdGF0aW9uICdhdXRvJyB0byBkZXRlcm1pbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0byByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWVzIGFyZSBgbG93ZXI9MWUtM2AgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB1cHBlcj0xZTVgLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IGFwcGxpY2FibGUgZm9yIG5vdGF0aW9uIGBhdXRvYC5cbiAqICAgIHtGdW5jdGlvbn0gZm4gICAgQSBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgIGJ1aWx0LWluIG5vdGF0aW9ucy4gRnVuY3Rpb24gYGZuYCBpcyBjYWxsZWQgd2l0aCBgdmFsdWVgIGFzXG4gKiAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBhbmQgbXVzdCByZXR1cm4gYSBzdHJpbmcuIElzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0b1xuICogICAgICAgICAgICAgICAgICAgICBmb3JtYXQgYWxsIHZhbHVlcyBpbnNpZGUgYSBtYXRyaXggaW4gYSBwYXJ0aWN1bGFyIHdheS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICBmb3JtYXQoNi40KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzYuNCdcbiAqICAgIGZvcm1hdCgxMjQwMDAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnMS4yNGU2J1xuICogICAgZm9ybWF0KDEvMyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwLjMzMzMzMzMzMzMzMzMzMzMnXG4gKiAgICBmb3JtYXQoMS8zLCAzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAuMzMzJ1xuICogICAgZm9ybWF0KDIxMzg1LCAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICcyMTAwMCdcbiAqICAgIGZvcm1hdCgxMi4wNzEsIHtub3RhdGlvbjogJ2ZpeGVkJ30pOyAgICAgICAgICAgICAgICAvLyAnMTInXG4gKiAgICBmb3JtYXQoMi4zLCAgICB7bm90YXRpb246ICdmaXhlZCcsIHByZWNpc2lvbjogMn0pOyAgLy8gJzIuMzAnXG4gKiAgICBmb3JtYXQoNTIuOCwgICB7bm90YXRpb246ICdleHBvbmVudGlhbCd9KTsgICAgICAgICAgLy8gJzUuMjhlKzEnXG4gKiAgICBmb3JtYXQoMTIzNDU2NzgsIHtub3RhdGlvbjogJ2VuZ2luZWVyaW5nJ30pOyAgICAgICAgLy8gJzEyLjM0NTY3OGUrNidcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBudW1iZXJ9IFtvcHRpb25zXVxuICogQHJldHVybiB7c3RyaW5nfSBzdHIgVGhlIGZvcm1hdHRlZCB2YWx1ZVxuICovXG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGhhbmRsZSBmb3JtYXQodmFsdWUsIGZuKVxuICAgIHJldHVybiBvcHRpb25zKHZhbHVlKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2VzXG4gIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgfVxuICBlbHNlIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgcmV0dXJuICctSW5maW5pdHknO1xuICB9XG4gIGVsc2UgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHJldHVybiAnTmFOJztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zXG4gIHZhciBub3RhdGlvbiA9ICdhdXRvJztcbiAgdmFyIHByZWNpc2lvbiA9IHVuZGVmaW5lZDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGRldGVybWluZSBub3RhdGlvbiBmcm9tIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5ub3RhdGlvbikge1xuICAgICAgbm90YXRpb24gPSBvcHRpb25zLm5vdGF0aW9uO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBwcmVjaXNpb24gZnJvbSBvcHRpb25zXG4gICAgaWYgKGV4cG9ydHMuaXNOdW1iZXIob3B0aW9ucykpIHtcbiAgICAgIHByZWNpc2lvbiA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMucHJlY2lzaW9uKSB7XG4gICAgICBwcmVjaXNpb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIHZhcmlvdXMgbm90YXRpb25zXG4gIHN3aXRjaCAobm90YXRpb24pIHtcbiAgICBjYXNlICdmaXhlZCc6XG4gICAgICByZXR1cm4gZXhwb3J0cy50b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgY2FzZSAnZXhwb25lbnRpYWwnOlxuICAgICAgcmV0dXJuIGV4cG9ydHMudG9FeHBvbmVudGlhbCh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgIGNhc2UgJ2VuZ2luZWVyaW5nJzpcbiAgICAgIHJldHVybiBleHBvcnRzLnRvRW5naW5lZXJpbmcodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHJldHVybiBleHBvcnRzXG4gICAgICAgICAgLnRvUHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24sIG9wdGlvbnMgJiYgb3B0aW9ucy5leHBvbmVudGlhbClcblxuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgIC5yZXBsYWNlKC8oKFxcLlxcZCo/KSgwKykpKCR8ZSkvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGlnaXRzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICByZXR1cm4gKGRpZ2l0cyAhPT0gJy4nKSA/IGRpZ2l0cyArIGUgOiBlO1xuICAgICAgICAgIH0pO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub3RhdGlvbiBcIicgKyBub3RhdGlvbiArICdcIi4gJyArXG4gICAgICAgICAgJ0Nob29zZSBcImF1dG9cIiwgXCJleHBvbmVudGlhbFwiLCBvciBcImZpeGVkXCIuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uLiBMaWtlICcxLjIzZSs1JywgJzIuM2UrMCcsICczLjUwMGUtMydcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dICBOdW1iZXIgb2YgZGlnaXRzIGluIGZvcm1hdHRlZCBvdXRwdXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhlIG1heGltdW0gYXZhaWxhYmxlIGRpZ2l0c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB1c2VkLlxuICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gKi9cbmV4cG9ydHMudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG5ldyBOdW1iZXJGb3JtYXR0ZXIodmFsdWUpLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIGluIGVuZ2luZWVyaW5nIG5vdGF0aW9uLiBMaWtlICcxLjIzZSs2JywgJzIuM2UrMCcsICczLjUwMGUtMydcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dICBOdW1iZXIgb2YgZGlnaXRzIGluIGZvcm1hdHRlZCBvdXRwdXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhlIG1heGltdW0gYXZhaWxhYmxlIGRpZ2l0c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB1c2VkLlxuICogQHJldHVybnMge3N0cmluZ30gc3RyXG4gKi9cbmV4cG9ydHMudG9FbmdpbmVlcmluZyA9IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG5ldyBOdW1iZXJGb3JtYXR0ZXIodmFsdWUpLnRvRW5naW5lZXJpbmcocHJlY2lzaW9uKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IGEgbnVtYmVyIHdpdGggZml4ZWQgbm90YXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdICAgICAgICBPcHRpb25hbCBudW1iZXIgb2YgZGVjaW1hbHMgYWZ0ZXIgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCBwb2ludC4gWmVybyBieSBkZWZhdWx0LlxuICovXG5leHBvcnRzLnRvRml4ZWQgPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBuZXcgTnVtYmVyRm9ybWF0dGVyKHZhbHVlKS50b0ZpeGVkKHByZWNpc2lvbik7XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIG51bWJlciB3aXRoIGEgY2VydGFpbiBwcmVjaXNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249dW5kZWZpbmVkXSBPcHRpb25hbCBudW1iZXIgb2YgZGlnaXRzLlxuICogQHBhcmFtIHt7bG93ZXI6IG51bWJlciwgdXBwZXI6IG51bWJlcn19IFtvcHRpb25zXSAgQnkgZGVmYXVsdDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyID0gMWUtMyAoZXhjbClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyID0gMWUrNSAoaW5jbClcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBOdW1iZXJGb3JtYXR0ZXIodmFsdWUpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGEgbnVtYmVyLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICogICAyLjM0IHJldHVybnMgM1xuICogICAwLjAwMzQgcmV0dXJucyAyXG4gKiAgIDEyMC41ZSszMCByZXR1cm5zIDRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn0gZGlnaXRzICAgTnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xuICovXG5leHBvcnRzLmRpZ2l0cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVxuICAgICAgLnRvRXhwb25lbnRpYWwoKVxuICAgICAgLnJlcGxhY2UoL2UuKiQvLCAnJykgICAgICAgICAgLy8gcmVtb3ZlIGV4cG9uZW50aWFsIG5vdGF0aW9uXG4gICAgICAucmVwbGFjZSggL14wXFwuPzAqfFxcLi8sICcnKSAgIC8vIHJlbW92ZSBkZWNpbWFsIHBvaW50IGFuZCBsZWFkaW5nIHplcm9zXG4gICAgICAubGVuZ3RoXG59O1xuXG4vKipcbiAqIE1pbmltdW0gbnVtYmVyIGFkZGVkIHRvIG9uZSB0aGF0IG1ha2VzIHRoZSByZXN1bHQgZGlmZmVyZW50IHRoYW4gb25lXG4gKi9cbmV4cG9ydHMuREJMX0VQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzI2MzMzNjE4MTZFLTE2O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgICAgRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgICAgU2Vjb25kIHZhbHVlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZXBzaWxvbl0gIFRoZSBtYXhpbXVtIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBlcHNpbG9uIGlzIHVuZGVmaW5lZCBvciBudWxsLCB0aGUgZnVuY3Rpb24gd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCB3aGV0aGVyIHggYW5kIHkgYXJlIGV4YWN0bHkgZXF1YWwuXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSB0d28gbnVtYmVycyBhcmUgbmVhcmx5IGVxdWFsXG4qL1xuZXhwb3J0cy5uZWFybHlFcXVhbCA9IGZ1bmN0aW9uKHgsIHksIGVwc2lsb24pIHtcbiAgLy8gaWYgZXBzaWxvbiBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdGVzdCB3aGV0aGVyIHggYW5kIHkgYXJlIGV4YWN0bHkgZXF1YWxcbiAgaWYgKGVwc2lsb24gPT0gbnVsbCkge1xuICAgIHJldHVybiB4ID09IHk7XG4gIH1cblxuICAvLyB1c2UgXCI9PVwiIG9wZXJhdG9yLCBoYW5kbGVzIGluZmluaXRpZXNcbiAgaWYgKHggPT0geSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gTmFOXG4gIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQgeCBhbmQgeSBzaG91bGQgYmUgZmluaXRlXG4gIGlmKGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpKSB7XG4gICAgLy8gY2hlY2sgbnVtYmVycyBhcmUgdmVyeSBjbG9zZSwgbmVlZGVkIHdoZW4gY29tcGFyaW5nIG51bWJlcnMgbmVhciB6ZXJvXG4gICAgdmFyIGRpZmYgPSBNYXRoLmFicyh4IC0geSk7XG4gICAgaWYgKGRpZmYgPCBleHBvcnRzLkRCTF9FUFNJTE9OKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB1c2UgcmVsYXRpdmUgZXJyb3JcbiAgICAgIHJldHVybiBkaWZmIDw9IE1hdGgubWF4KE1hdGguYWJzKHgpLCBNYXRoLmFicyh5KSkgKiBlcHNpbG9uO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluZmluaXRlIGFuZCBOdW1iZXIgb3IgbmVnYXRpdmUgSW5maW5pdGUgYW5kIHBvc2l0aXZlIEluZmluaXRlIGNhc2VzXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xvbmUgYW4gb2JqZWN0XG4gKlxuICogICAgIGNsb25lKHgpXG4gKlxuICogQ2FuIGNsb25lIGFueSBwcmltaXRpdmUgdHlwZSwgYXJyYXksIGFuZCBvYmplY3QuXG4gKiBJZiB4IGhhcyBhIGZ1bmN0aW9uIGNsb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB0byBjbG9uZSB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn0gY2xvbmVcbiAqL1xuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcblxuICAvLyBpbW11dGFibGUgcHJpbWl0aXZlIHR5cGVzXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnYm9vbGVhbicgfHxcbiAgICAgIHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICAvLyB1c2UgY2xvbmUgZnVuY3Rpb24gb2YgdGhlIG9iamVjdCB3aGVuIGF2YWlsYWJsZVxuICBpZiAodHlwZW9mIHguY2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4geC5jbG9uZSgpO1xuICB9XG5cbiAgLy8gYXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY2xvbmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHggaW5zdGFuY2VvZiBOdW1iZXIpICAgIHJldHVybiBuZXcgTnVtYmVyKHgudmFsdWVPZigpKTtcbiAgaWYgKHggaW5zdGFuY2VvZiBTdHJpbmcpICAgIHJldHVybiBuZXcgU3RyaW5nKHgudmFsdWVPZigpKTtcbiAgaWYgKHggaW5zdGFuY2VvZiBCb29sZWFuKSAgIHJldHVybiBuZXcgQm9vbGVhbih4LnZhbHVlT2YoKSk7XG4gIGlmICh4IGluc3RhbmNlb2YgRGF0ZSkgICAgICByZXR1cm4gbmV3IERhdGUoeC52YWx1ZU9mKCkpO1xuICBpZiAoeCAmJiB4LmlzQmlnTnVtYmVyID09PSB0cnVlKSByZXR1cm4geDsgLy8gYmlnbnVtYmVycyBhcmUgaW1tdXRhYmxlXG4gIGlmICh4IGluc3RhbmNlb2YgUmVnRXhwKSAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb25lICcgKyB4KTsgIC8vIFRPRE86IGNsb25lIGEgUmVnRXhwXG5cbiAgLy8gb2JqZWN0XG4gIHZhciBtID0ge307XG4gIGZvciAodmFyIGtleSBpbiB4KSB7XG4gICAgaWYgKHguaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgbVtrZXldID0gY2xvbmUoeFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmRlZXBFeHRlbmQgPSBmdW5jdGlvbiBkZWVwRXh0ZW5kIChhLCBiKSB7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kJyk7XG4gIH1cblxuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgZGVlcEV4dGVuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBEZWVwIHRlc3QgZXF1YWxpdHkgb2YgYWxsIGZpZWxkcyBpbiB0d28gcGFpcnMgb2YgYXJyYXlzIG9yIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBhXG4gKiBAcGFyYW0ge0FycmF5IHwgT2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwgKGEsIGIpIHtcbiAgdmFyIHByb3AsIGksIGxlbjtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWV4cG9ydHMuZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpIHx8ICEoYiBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHByb3AgaW4gYSkge1xuICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbmZpbHRlcmVkRm9ySW5Mb29wXG4gICAgICBpZiAoIWV4cG9ydHMuZGVlcEVxdWFsKGFbcHJvcF0sIGJbcHJvcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIGIpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgaWYgKCFleHBvcnRzLmRlZXBFcXVhbChhW3Byb3BdLCBiW3Byb3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAodHlwZW9mIGEgPT09IHR5cGVvZiBiKSAmJiAoYSA9PSBiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBlbmdpbmUgc3VwcG9ydHMgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHN1cHBvcnRlZFxuICovXG5leHBvcnRzLmNhbkRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAvLyB0ZXN0IG5lZWRlZCBmb3IgYnJva2VuIElFOCBpbXBsZW1lbnRhdGlvblxuICB0cnkge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBdHRhY2ggYSBsYXp5IGxvYWRpbmcgcHJvcGVydHkgdG8gYSBjb25zdGFudC5cbiAqIFRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIGlzIGNhbGxlZCBvbmNlIHdoZW4gdGhlIHByb3BlcnR5IGlzIGZpcnN0IHJlcXVlc3RlZC5cbiAqIE9uIG9sZGVyIGJyb3dzZXJzICg8SUU4KSwgdGhlIGZ1bmN0aW9uIHdpbGwgZmFsbCBiYWNrIHRvIGRpcmVjdCBldmFsdWF0aW9uXG4gKiBvZiB0aGUgcHJvcGVydGllcyB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgICBPYmplY3Qgd2hlcmUgdG8gYWRkIHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgICAgIFByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuICAgICBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIHByb3BlcnR5IHZhbHVlLiBDYWxsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcCwgZm4pIHtcbiAgaWYgKGV4cG9ydHMuY2FuRGVmaW5lUHJvcGVydHkoKSkge1xuICAgIHZhciBfdW5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdmFyIF92YWx1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF91bmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgX3ZhbHVlID0gZm4oKTtcbiAgICAgICAgICBfdW5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3VuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBmYWxsIGJhY2sgdG8gaW1tZWRpYXRlIGV2YWx1YXRpb25cbiAgICBvYmplY3RbcHJvcF0gPSBmbigpO1xuICB9XG59O1xuXG4vKipcbiAqIFRyYXZlcnNlIGEgcGF0aCBpbnRvIGFuIG9iamVjdC5cbiAqIFdoZW4gYSBuYW1lc3BhY2UgaXMgbWlzc2luZywgaXQgd2lsbCBiZSBjcmVhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgIEEgZG90IHNlcGFyYXRlZCBzdHJpbmcgbGlrZSAnbmFtZS5zcGFjZSdcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0IGF0IHRoZSBlbmQgb2YgdGhlIHBhdGhcbiAqL1xuZXhwb3J0cy50cmF2ZXJzZSA9IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCkge1xuICB2YXIgb2JqID0gb2JqZWN0O1xuXG4gIGlmIChwYXRoKSB7XG4gICAgdmFyIG5hbWVzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgb2JqW25hbWVdID0ge307XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIGZhY3RvcnkuIGEgZmFjdG9yeSBoYXMgZmllbGRzOlxuICpcbiAqIC0gZmFjdG9yeTogZnVuY3Rpb24gKHR5cGU6IE9iamVjdCwgY29uZmlnOiBPYmplY3QsIGxvYWQ6IGZ1bmN0aW9uLCB0eXBlZDogZnVuY3Rpb24gWywgbWF0aDogT2JqZWN0XSkgICAocmVxdWlyZWQpXG4gKiAtIG5hbWU6IHN0cmluZyAob3B0aW9uYWwpXG4gKiAtIHBhdGg6IHN0cmluZyAgICBBIGRvdCBzZXBhcmF0ZWQgcGF0aCAob3B0aW9uYWwpXG4gKiAtIG1hdGg6IGJvb2xlYW4gICBJZiB0cnVlIChmYWxzZSBieSBkZWZhdWx0KSwgdGhlIG1hdGggbmFtZXNwYWNlIGlzIHBhc3NlZFxuICogICAgICAgICAgICAgICAgICAgYXMgZmlmdGggYXJndW1lbnQgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNGYWN0b3J5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXROdW1iZXIgPSByZXF1aXJlKCcuL251bWJlcicpLmZvcm1hdDtcbnZhciBmb3JtYXRCaWdOdW1iZXIgPSByZXF1aXJlKCcuL2JpZ251bWJlci9mb3JtYXR0ZXInKS5mb3JtYXQ7XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHZhbHVlIGlzIGEgc3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBpc1N0cmluZ1xuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdGV4dCBlbmRzIHdpdGggYSBjZXJ0YWluIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gKi9cbmV4cG9ydHMuZW5kc1dpdGggPSBmdW5jdGlvbih0ZXh0LCBzZWFyY2gpIHtcbiAgdmFyIHN0YXJ0ID0gdGV4dC5sZW5ndGggLSBzZWFyY2gubGVuZ3RoO1xuICB2YXIgZW5kID0gdGV4dC5sZW5ndGg7XG4gIHJldHVybiAodGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCkgPT09IHNlYXJjaCk7XG59O1xuXG4vKipcbiAqIEZvcm1hdCBhIHZhbHVlIG9mIGFueSB0eXBlIGludG8gYSBzdHJpbmcuXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgbWF0aC5mb3JtYXQodmFsdWUpXG4gKiAgICAgbWF0aC5mb3JtYXQodmFsdWUsIHByZWNpc2lvbilcbiAqXG4gKiBXaGVuIHZhbHVlIGlzIGEgZnVuY3Rpb246XG4gKlxuICogLSBXaGVuIHRoZSBmdW5jdGlvbiBoYXMgYSBwcm9wZXJ0eSBgc3ludGF4YCwgaXQgcmV0dXJucyB0aGlzXG4gKiAgIHN5bnRheCBkZXNjcmlwdGlvbi5cbiAqIC0gSW4gb3RoZXIgY2FzZXMsIGEgc3RyaW5nIGAnZnVuY3Rpb24nYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBXaGVuIGB2YWx1ZWAgaXMgYW4gT2JqZWN0OlxuICpcbiAqIC0gV2hlbiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgcHJvcGVydHkgYGZvcm1hdGAgYmVpbmcgYSBmdW5jdGlvbiwgdGhpc1xuICogICBmdW5jdGlvbiBpcyBpbnZva2VkIGFzIGB2YWx1ZS5mb3JtYXQob3B0aW9ucylgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuICogLSBXaGVuIHRoZSBvYmplY3QgaGFzIGl0cyBvd24gYHRvU3RyaW5nYCBtZXRob2QsIHRoaXMgbWV0aG9kIGlzIGludm9rZWRcbiAqICAgYW5kIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gKiAtIEluIG90aGVyIGNhc2VzIHRoZSBmdW5jdGlvbiB3aWxsIGxvb3Agb3ZlciBhbGwgb2JqZWN0IHByb3BlcnRpZXMgYW5kXG4gKiAgIHJldHVybiBKU09OIG9iamVjdCBub3RhdGlvbiBsaWtlICd7XCJhXCI6IDIsIFwiYlwiOiAzfScuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqICAgICBtYXRoLmZvcm1hdCgyLzcpOyAgICAgICAgICAgICAgICAvLyAnMC4yODU3MTQyODU3MTQyODU3J1xuICogICAgIG1hdGguZm9ybWF0KG1hdGgucGksIDMpOyAgICAgICAgIC8vICczLjE0J1xuICogICAgIG1hdGguZm9ybWF0KG5ldyBDb21wbGV4KDIsIDMpKTsgIC8vICcyICsgM2knXG4gKiAgICAgbWF0aC5mb3JtYXQoJ2hlbGxvJyk7ICAgICAgICAgICAgLy8gJ1wiaGVsbG9cIidcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlICAgICAgICAgICAgIFZhbHVlIHRvIGJlIHN0cmluZ2lmaWVkXG4gKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IEZ1bmN0aW9ufSBbb3B0aW9uc10gIEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYi91dGlscy9udW1iZXI6Zm9ybWF0IGZvciBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uIG9mIHRoZSBhdmFpbGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyXG4gKi9cbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmb3JtYXRCaWdOdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmlzRnJhY3Rpb24gPT09IHRydWUpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5mcmFjdGlvbiAhPT0gJ2RlY2ltYWwnKSB7XG4gICAgICAvLyBvdXRwdXQgYXMgcmF0aW8sIGxpa2UgJzEvMydcbiAgICAgIHJldHVybiAodmFsdWUucyAqIHZhbHVlLm4pICsgJy8nICsgdmFsdWUuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBvdXRwdXQgYXMgZGVjaW1hbCwgbGlrZSAnMC4oMyknXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0QXJyYXkodmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGV4cG9ydHMuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN5bnRheCA/IFN0cmluZyh2YWx1ZS5zeW50YXgpIDogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5mb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5mb3JtYXQob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkgIT09IHt9LnRvU3RyaW5nKCkpIHtcbiAgICAgIC8vIHRoaXMgb2JqZWN0IGhhcyBhIG5vbi1uYXRpdmUgdG9TdHJpbmcgbWV0aG9kLCB1c2UgdGhhdCBvbmVcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBlbnRyaWVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGVudHJpZXMucHVzaCgnXCInICsga2V5ICsgJ1wiOiAnICsgZXhwb3J0cy5mb3JtYXQodmFsdWVba2V5XSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAneycgKyBlbnRyaWVzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZvcm1hdCBhbiBuLWRpbWVuc2lvbmFsIG1hdHJpeFxuICogRXhhbXBsZSBvdXRwdXQ6IFwiW1sxLCAyXSwgWzMsIDRdXVwiXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBGdW5jdGlvbn0gW29wdGlvbnNdICBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIvdXRpbHMvbnVtYmVyOmZvcm1hdCBmb3IgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiBvZiB0aGUgYXZhaWxhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gZm9ybWF0QXJyYXkgKGFycmF5LCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIHZhciBzdHIgPSAnWyc7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaSAhPSAwKSB7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgICAgc3RyICs9IGZvcm1hdEFycmF5KGFycmF5W2ldLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RyICs9ICddJztcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBleHBvcnRzLmZvcm1hdChhcnJheSwgb3B0aW9ucyk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSB2YXJpYWJsZVxuICpcbiAqICAgICB0eXBlKHgpXG4gKlxuICogVGhlIGZvbGxvd2luZyB0eXBlcyBhcmUgcmVjb2duaXplZDpcbiAqXG4gKiAgICAgJ3VuZGVmaW5lZCdcbiAqICAgICAnbnVsbCdcbiAqICAgICAnYm9vbGVhbidcbiAqICAgICAnbnVtYmVyJ1xuICogICAgICdzdHJpbmcnXG4gKiAgICAgJ0FycmF5J1xuICogICAgICdGdW5jdGlvbidcbiAqICAgICAnRGF0ZSdcbiAqICAgICAnUmVnRXhwJ1xuICogICAgICdPYmplY3QnXG4gKlxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUuIFByaW1pdGl2ZSB0eXBlcyBhcmUgbG93ZXIgY2FzZSxcbiAqICAgICAgICAgICAgICAgICAgbm9uLXByaW1pdGl2ZSB0eXBlcyBhcmUgdXBwZXItY2FtZWwtY2FzZS5cbiAqICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUgJ251bWJlcicsICdzdHJpbmcnLCAnQXJyYXknLCAnRGF0ZScuXG4gKi9cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcblxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoeCA9PT0gbnVsbCkgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgaWYgKHggaW5zdGFuY2VvZiBCb29sZWFuKSByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGlmICh4IGluc3RhbmNlb2YgTnVtYmVyKSAgcmV0dXJuICdudW1iZXInO1xuICAgIGlmICh4IGluc3RhbmNlb2YgU3RyaW5nKSAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgaWYgKHggaW5zdGFuY2VvZiBEYXRlKSAgICByZXR1cm4gJ0RhdGUnO1xuICAgIGlmICh4IGluc3RhbmNlb2YgUmVnRXhwKSAgcmV0dXJuICdSZWdFeHAnO1xuXG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpICAgIHJldHVybiAnRnVuY3Rpb24nO1xuXG4gIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhIHNjYWxhclxuICogQHBhcmFtIHhcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHggaXMgYSBzY2FsYXIsIHJldHVybnMgZmFsc2Ugd2hlblxuICogICAgICAgICAgICAgICAgICAgeCBpcyBhIE1hdHJpeCBvciBBcnJheS5cbiAqL1xuZXhwb3J0cy5pc1NjYWxhciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiAhKCh4ICYmIHguaXNNYXRyaXgpIHx8IEFycmF5LmlzQXJyYXkoeCkpO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQ29tcGxleC5qcyB2Mi4wLjEgMTEvMDIvMjAxNlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgUm9iZXJ0IEVpc2VsZSAocm9iZXJ0QHhhcmcub3JnKVxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKiovXG5cbi8qKlxuICpcbiAqIFRoaXMgY2xhc3MgYWxsb3dzIHRoZSBtYW5pcGlsYXRpb24gb2YgY29tcGxleCBudW1iZXJzLlxuICogWW91IGNhbiBwYXNzIGEgY29tcGxleCBudW1iZXIgaW4gZGlmZmVyZW50IGZvcm1hdHMuIEVpdGhlciBhcyBvYmplY3QsIGRvdWJsZSwgc3RyaW5nIG9yIHR3byBpbnRlZ2VyIHBhcmFtZXRlcnMuXG4gKlxuICogT2JqZWN0IGZvcm1cbiAqIHsgcmU6IDxyZWFsPiwgaW06IDxpbWFnaW5hcnk+IH1cbiAqIHsgYXJnOiA8YW5nbGU+LCBhYnM6IDxyYWRpdXM+IH1cbiAqIHsgcGhpOiA8YW5nbGU+LCByOiA8cmFkaXVzPiB9XG4gKlxuICogRG91YmxlIGZvcm1cbiAqIDk5LjMgLSBTaW5nbGUgZG91YmxlIHZhbHVlXG4gKlxuICogU3RyaW5nIGZvcm1cbiAqIFwiMjMuMTMzN1wiIC0gU2ltcGxlIHJlYWwgbnVtYmVyXG4gKiBcIjE1KzNpXCIgLSBhIHNpbXBsZSBjb21wbGV4IG51bWJlclxuICogXCIzLWlcIiAtIGEgc2ltcGxlIGNvbXBsZXggbnVtYmVyXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiB2YXIgYyA9IG5ldyBDb21wbGV4KFwiOTkuMys4aVwiKTtcbiAqIGMubXVsKHtyOiAzLCBpOiA5fSkuZGl2KDQuOSkuc3ViKDMsIDIpO1xuICpcbiAqL1xuXG4oZnVuY3Rpb24ocm9vdCkge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBQID0geydyZSc6IDAsICdpbSc6IDB9O1xuXG4gIE1hdGguY29zaCA9IE1hdGguY29zaCB8fCBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgKiAwLjU7XG4gIH07XG5cbiAgTWF0aC5zaW5oID0gTWF0aC5zaW5oIHx8IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAqIDAuNTtcbiAgfTtcblxuICB2YXIgcGFyc2VyX2V4aXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBTeW50YXhFcnJvcihcIkludmFsaWQgUGFyYW1cIik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgbG9nKHNxcnQoYV4yK2JeMikpIGluIGEgd2F5IHRvIGF2b2lkIG92ZXJmbG93c1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgKiBAcGFyYW0ge251bWJlcn0gYlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gbG9nSHlwb3QoYSwgYikge1xuXG4gICAgdmFyIF9hID0gTWF0aC5hYnMoYSk7XG4gICAgdmFyIF9iID0gTWF0aC5hYnMoYik7XG5cbiAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKF9iKTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKF9hKTtcbiAgICB9XG5cbiAgICBpZiAoX2EgPCAzMDAwICYmIF9iIDwgMzAwMCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKGEgKiBhICsgYiAqIGIpICogMC41O1xuICAgIH1cblxuICAgIC8qIEkgZ290IDQgaWRlYXMgdG8gY29tcHV0ZSB0aGlzIHByb3BlcnR5IHdpdGhvdXQgb3ZlcmZsb3c6XG4gICAgICpcbiAgICAgKiBUZXN0aW5nIDEwMDAwMDAgdGltZXMgd2l0aCByYW5kb20gc2FtcGxlcyBmb3IgYSxiIOKIiCBbMSwgMTAwMDAwMDAwMF0gYWdhaW5zdCBhIGJpZyBkZWNpbWFsIGxpYnJhcnkgdG8gZ2V0IGFuIGVycm9yIGVzdGltYXRlXG4gICAgICpcbiAgICAgKiAxLiBPbmx5IGVsaW1pbmF0ZSB0aGUgc3F1YXJlIHJvb3Q6IChPVkVSQUxMIEVSUk9SOiAzLjkxMjI0ODMwMzA5NTExMTZlLTExKVxuXG4gICAgIE1hdGgubG9nKGEgKiBhICsgYiAqIGIpIC8gMlxuXG4gICAgICpcbiAgICAgKlxuICAgICAqIDIuIFRyeSB0byB1c2UgdGhlIG5vbi1vdmVyZmxvd2luZyBweXRoYWdvcmFzOiAoT1ZFUkFMTCBFUlJPUjogOC44ODk3NjAwMzkyMTAxNTllLTEwKVxuXG4gICAgIHZhciBmbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgYSA9IE1hdGguYWJzKGEpO1xuICAgICBiID0gTWF0aC5hYnMoYik7XG4gICAgIHZhciB0ID0gTWF0aC5taW4oYSwgYik7XG4gICAgIGEgPSBNYXRoLm1heChhLCBiKTtcbiAgICAgdCA9IHQgLyBhO1xuXG4gICAgIHJldHVybiBNYXRoLmxvZyhhKSArIE1hdGgubG9nKDEgKyB0ICogdCkgLyAyO1xuICAgICB9O1xuXG4gICAgICogMy4gQWJ1c2UgdGhlIGlkZW50aXR5IGNvcyhhdGFuKHkveCkgPSB4IC8gc3FydCh4XjIreV4yKTogKE9WRVJBTEwgRVJST1I6IDMuNDc4MDE3ODczNzAzNzIwNGUtMTApXG5cbiAgICAgTWF0aC5sb2coYSAvIE1hdGguY29zKE1hdGguYXRhbjIoYiwgYSkpKVxuXG4gICAgICogNC4gVXNlIDMuIGFuZCBhcHBseSBsb2cgcnVsZXM6IChPVkVSQUxMIEVSUk9SOiAxLjIwMTQwODc1MDI2MjA4OTZlLTkpXG5cbiAgICAgTWF0aC5sb2coYSkgLSBNYXRoLmxvZyhNYXRoLmNvcyhNYXRoLmF0YW4yKGIsIGEpKSlcblxuICAgICAqL1xuXG4gICAgcmV0dXJuIE1hdGgubG9nKGEgLyBNYXRoLmNvcyhNYXRoLmF0YW4yKGIsIGEpKSk7XG4gIH1cblxuICB2YXIgcGFyc2UgPSBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcbiAgICAgIFBbXCJyZVwiXSA9XG4gICAgICBQW1wiaW1cIl0gPSAwO1xuICAgIH0gZWxzZSBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBQW1wicmVcIl0gPSBhO1xuICAgICAgUFtcImltXCJdID0gYjtcbiAgICB9IGVsc2Ugc3dpdGNoICh0eXBlb2YgYSkge1xuXG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG5cbiAgICAgICAgaWYgKFwiaW1cIiBpbiBhICYmIFwicmVcIiBpbiBhKSB7XG4gICAgICAgICAgUFtcInJlXCJdID0gYVtcInJlXCJdO1xuICAgICAgICAgIFBbXCJpbVwiXSA9IGFbXCJpbVwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChcImFic1wiIGluIGEgJiYgXCJhcmdcIiBpbiBhKSB7XG4gICAgICAgICAgUFtcInJlXCJdID0gYVtcImFic1wiXSAqIE1hdGguY29zKGFbXCJhcmdcIl0pO1xuICAgICAgICAgIFBbXCJpbVwiXSA9IGFbXCJhYnNcIl0gKiBNYXRoLnNpbihhW1wiYXJnXCJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChcInJcIiBpbiBhICYmIFwicGhpXCIgaW4gYSkge1xuICAgICAgICAgIFBbXCJyZVwiXSA9IGFbXCJyXCJdICogTWF0aC5jb3MoYVtcInBoaVwiXSk7XG4gICAgICAgICAgUFtcImltXCJdID0gYVtcInJcIl0gKiBNYXRoLnNpbihhW1wicGhpXCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZXJfZXhpdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG5cbiAgICAgICAgUFtcImltXCJdID0gLyogdm9pZCAqL1xuICAgICAgICBQW1wicmVcIl0gPSAwO1xuXG4gICAgICAgIHZhciB0b2tlbnMgPSBhLm1hdGNoKC9cXGQrXFwuP1xcZCplWystXT9cXGQrfFxcZCtcXC4/XFxkKnxcXC5cXGQrfC4vZyk7XG4gICAgICAgIHZhciBwbHVzID0gMTtcbiAgICAgICAgdmFyIG1pbnVzID0gMDtcblxuICAgICAgICBpZiAodG9rZW5zID09PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICB2YXIgYyA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgIGlmIChjID09PSAnICcgfHwgYyA9PT0gJ1xcdCcgfHwgYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8qIHZvaWQgKi9cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcrJykge1xuICAgICAgICAgICAgcGx1cysrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBtaW51cysrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ2knIHx8IGMgPT09ICdJJykge1xuXG4gICAgICAgICAgICBpZiAocGx1cyArIG1pbnVzID09PSAwKSB7XG4gICAgICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbnNbaSArIDFdICE9PSAnICcgJiYgIWlzTmFOKHRva2Vuc1tpICsgMV0pKSB7XG4gICAgICAgICAgICAgIFBbXCJpbVwiXSs9IHBhcnNlRmxvYXQoKG1pbnVzICUgMiA/IFwiLVwiIDogXCJcIikgKyB0b2tlbnNbaSArIDFdKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUFtcImltXCJdKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gXCItXCIgOiBcIlwiKSArIFwiMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsdXMgPSBtaW51cyA9IDA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAocGx1cyArIG1pbnVzID09PSAwIHx8IGlzTmFOKGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlcl9leGl0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbnNbaSArIDFdID09PSAnaScgfHwgdG9rZW5zW2kgKyAxXSA9PT0gJ0knKSB7XG4gICAgICAgICAgICAgIFBbXCJpbVwiXSs9IHBhcnNlRmxvYXQoKG1pbnVzICUgMiA/IFwiLVwiIDogXCJcIikgKyBjKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUFtcInJlXCJdKz0gcGFyc2VGbG9hdCgobWludXMgJSAyID8gXCItXCIgOiBcIlwiKSArIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGx1cyA9IG1pbnVzID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGlsbCBzb21ldGhpbmcgb24gdGhlIHN0YWNrXG4gICAgICAgIGlmIChwbHVzICsgbWludXMgPiAwKSB7XG4gICAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBQW1wiaW1cIl0gPSAwO1xuICAgICAgICBQW1wicmVcIl0gPSBhO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGFyc2VyX2V4aXQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4oUFtcInJlXCJdKSB8fCBpc05hTihQW1wiaW1cIl0pKSB7XG4gICAgICAvLyBJZiBhIGNhbGN1bGF0aW9uIGlzIE5hTiwgd2UgdHJlYXQgaXQgYXMgTmFOIGFuZCBkb24ndCB0aHJvd1xuICAgICAgLy9wYXJzZXJfZXhpdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcGxleChhLCBiKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGxleCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChhLCBiKTtcbiAgICB9XG5cbiAgICBwYXJzZShhLCBiKTsgLy8gbXV0YXRlcyBQXG5cbiAgICB0aGlzW1wicmVcIl0gPSBQW1wicmVcIl07XG4gICAgdGhpc1tcImltXCJdID0gUFtcImltXCJdO1xuICB9XG5cbiAgQ29tcGxleC5wcm90b3R5cGUgPSB7XG5cbiAgICBcInJlXCI6IDAsXG4gICAgXCJpbVwiOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc2lnbiBvZiBhIGNvbXBsZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcInNpZ25cIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhYnMgPSB0aGlzW1wiYWJzXCJdKCk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgdGhpc1tcInJlXCJdIC8gYWJzLFxuICAgICAgICAgICAgICB0aGlzW1wiaW1cIl0gLyBhYnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYWRkXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7IC8vIG11dGF0ZXMgUFxuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIHRoaXNbXCJyZVwiXSArIFBbXCJyZVwiXSxcbiAgICAgICAgICAgICAgdGhpc1tcImltXCJdICsgUFtcImltXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwic3ViXCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7IC8vIG11dGF0ZXMgUFxuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIHRoaXNbXCJyZVwiXSAtIFBbXCJyZVwiXSxcbiAgICAgICAgICAgICAgdGhpc1tcImltXCJdIC0gUFtcImltXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gY29tcGxleCBudW1iZXJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcIm11bFwiOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgIHBhcnNlKGEsIGIpOyAvLyBtdXRhdGVzIFBcblxuICAgICAgLy8gQmVzaWRlcyB0aGUgYWRkaXRpb24vc3VidHJhY3Rpb24sIHRoaXMgaGVscHMgaGF2aW5nIGEgc29sdXRpb24gZm9yIHJhdGlvbmFsIEluZmluaXR5XG4gICAgICBpZiAoUFsnaW0nXSA9PT0gMCAmJiB0aGlzWydpbSddID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzWydyZSddICogUFsncmUnXSwgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgdGhpc1tcInJlXCJdICogUFtcInJlXCJdIC0gdGhpc1tcImltXCJdICogUFtcImltXCJdLFxuICAgICAgICAgICAgICB0aGlzW1wicmVcIl0gKiBQW1wiaW1cIl0gKyB0aGlzW1wiaW1cIl0gKiBQW1wicmVcIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiZGl2XCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7IC8vIG11dGF0ZXMgUFxuXG4gICAgICBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgdmFyIGMgPSBQW1wicmVcIl07XG4gICAgICB2YXIgZCA9IFBbXCJpbVwiXTtcbiAgICAgIHZhciB0LCB4O1xuXG4gICAgICAvLyBEaXZpc29yIGlzIHplcm9cbiAgICAgIGlmICgwID09PSBjICYmIDAgPT09IGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgIChhICE9PSAwKSA/IChhIC8gMCkgOiAwLFxuICAgICAgICAgICAgICAgIChiICE9PSAwKSA/IChiIC8gMCkgOiAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGl2aXNvciBpcyByYXRpb25hbFxuICAgICAgaWYgKDAgPT09IGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGEgLyBjLCBiIC8gYyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhjKSA8IE1hdGguYWJzKGQpKSB7XG5cbiAgICAgICAgeCA9IGMgLyBkO1xuICAgICAgICB0ID0gYyAqIHggKyBkO1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAoYSAqIHggKyBiKSAvIHQsXG4gICAgICAgICAgICAgICAgKGIgKiB4IC0gYSkgLyB0KTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB4ID0gZCAvIGM7XG4gICAgICAgIHQgPSBkICogeCArIGM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgIChhICsgYiAqIHgpIC8gdCxcbiAgICAgICAgICAgICAgICAoYiAtIGEgKiB4KSAvIHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvd2VyIG9mIHR3byBjb21wbGV4IG51bWJlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwicG93XCI6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgcGFyc2UoYSwgYik7IC8vIG11dGF0ZXMgUFxuXG4gICAgICBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmcgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICAgICAgdmFyIGxvaCA9IGxvZ0h5cG90KGEsIGIpO1xuXG4gICAgICBpZiAoUFtcImltXCJdID09PSAwKSB7XG5cbiAgICAgICAgaWYgKGIgPT09IDAgJiYgYSA+PSAwKSB7XG5cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5wb3coYSwgUFtcInJlXCJdKSwgMCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChhID09PSAwKSB7XG5cbiAgICAgICAgICBzd2l0Y2ggKFBbXCJyZVwiXSAlIDQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGgucG93KGIsIFBbXCJyZVwiXSksIDApO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgTWF0aC5wb3coYiwgUFtcInJlXCJdKSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgtTWF0aC5wb3coYiwgUFtcInJlXCJdKSwgMCk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgwLCAtTWF0aC5wb3coYiwgUFtcInJlXCJdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIEkgY291bGRuXCJ0IGZpbmQgYSBnb29kIGZvcm11bGEsIHNvIGhlcmUgaXMgYSBkZXJpdmF0aW9uIGFuZCBvcHRpbWl6YXRpb25cbiAgICAgICAqXG4gICAgICAgKiB6XzFeel8yID0gKGEgKyBiaSleKGMgKyBkaSlcbiAgICAgICAqICAgICAgICAgPSBleHAoKGMgKyBkaSkgKiBsb2coYSArIGJpKVxuICAgICAgICogICAgICAgICA9IHBvdyhhXjIgKyBiXjIsIChjICsgZGkpIC8gMikgKiBleHAoaShjICsgZGkpYXRhbjIoYiwgYSkpXG4gICAgICAgKiA9Pi4uLlxuICAgICAgICogUmUgPSAocG93KGFeMiArIGJeMiwgYyAvIDIpICogZXhwKC1kICogYXRhbjIoYiwgYSkpKSAqIGNvcyhkICogbG9nKGFeMiArIGJeMikgLyAyICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAgICogSW0gPSAocG93KGFeMiArIGJeMiwgYyAvIDIpICogZXhwKC1kICogYXRhbjIoYiwgYSkpKSAqIHNpbihkICogbG9nKGFeMiArIGJeMikgLyAyICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAgICpcbiAgICAgICAqID0+Li4uXG4gICAgICAgKiBSZSA9IGV4cChjICogbG9nKHNxcnQoYV4yICsgYl4yKSkgLSBkICogYXRhbjIoYiwgYSkpICogY29zKGQgKiBsb2coc3FydChhXjIgKyBiXjIpKSArIGMgKiBhdGFuMihiLCBhKSlcbiAgICAgICAqIEltID0gZXhwKGMgKiBsb2coc3FydChhXjIgKyBiXjIpKSAtIGQgKiBhdGFuMihiLCBhKSkgKiBzaW4oZCAqIGxvZyhzcXJ0KGFeMiArIGJeMikpICsgYyAqIGF0YW4yKGIsIGEpKVxuICAgICAgICpcbiAgICAgICAqID0+XG4gICAgICAgKiBSZSA9IGV4cChjICogbG9nc3EyIC0gZCAqIGFyZyh6XzEpKSAqIGNvcyhkICogbG9nc3EyICsgYyAqIGFyZyh6XzEpKVxuICAgICAgICogSW0gPSBleHAoYyAqIGxvZ3NxMiAtIGQgKiBhcmcoel8xKSkgKiBzaW4oZCAqIGxvZ3NxMiArIGMgKiBhcmcoel8xKSlcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgYSA9IE1hdGguZXhwKFBbXCJyZVwiXSAqIGxvaCAtIFBbXCJpbVwiXSAqIGFyZyk7XG4gICAgICBiID0gUFtcImltXCJdICogbG9oICsgUFtcInJlXCJdICogYXJnO1xuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBhICogTWF0aC5jb3MoYiksXG4gICAgICAgICAgICAgIGEgKiBNYXRoLnNpbihiKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBzcXVhcmUgcm9vdFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJzcXJ0XCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuICAgICAgdmFyIHIgPSB0aGlzW1wiYWJzXCJdKCk7XG5cbiAgICAgIHZhciByZSwgaW07XG5cbiAgICAgIGlmIChhID49IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5zcXJ0KGEpLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPj0gMCkge1xuICAgICAgICByZSA9IDAuNSAqIE1hdGguc3FydCgyLjAgKiAociArIGEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlID0gTWF0aC5hYnMoYikgLyBNYXRoLnNxcnQoMiAqIChyIC0gYSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSA8PSAwKSB7XG4gICAgICAgIGltID0gMC41ICogTWF0aC5zcXJ0KDIuMCAqIChyIC0gYSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0gPSBNYXRoLmFicyhiKSAvIE1hdGguc3FydCgyICogKHIgKyBhKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChyZSwgYiA+PSAwID8gaW0gOiAtaW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggZXhwb25lbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiZXhwXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdG1wID0gTWF0aC5leHAodGhpc1tcInJlXCJdKTtcblxuICAgICAgaWYgKHRoaXNbXCJpbVwiXSA9PT0gMCkge1xuICAgICAgICAvL3JldHVybiBuZXcgQ29tcGxleCh0bXAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICB0bXAgKiBNYXRoLmNvcyh0aGlzW1wiaW1cIl0pLFxuICAgICAgICAgICAgICB0bXAgKiBNYXRoLnNpbih0aGlzW1wiaW1cIl0pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBuYXR1cmFsIGxvZ1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJsb2dcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG4gICAgICBcbiAgICAgIGlmIChiID09PSAwICYmIGEgPiAwKSB7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBDb21wbGV4KE1hdGgubG9nKGEpLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBsb2dIeXBvdChhLCBiKSxcbiAgICAgICAgICAgICAgTWF0aC5hdGFuMihiLCBhKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgbWFnbml0dXJlIG9mIHRoZSBjb21wbGV4IG51bWJlclxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBcImFic1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSBNYXRoLmFicyh0aGlzW1wicmVcIl0pO1xuICAgICAgdmFyIGIgPSBNYXRoLmFicyh0aGlzW1wiaW1cIl0pO1xuXG4gICAgICBpZiAoYSA8IDMwMDAgJiYgYiA8IDMwMDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdGhpc1tcInJlXCJdIC8gdGhpc1tcImltXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IHRoaXNbXCJpbVwiXSAvIHRoaXNbXCJyZVwiXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhICogTWF0aC5zcXJ0KDEgKyBiICogYik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYW5nbGUgb2YgdGhlIGNvbXBsZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIFwiYXJnXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzW1wiaW1cIl0sIHRoaXNbXCJyZVwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2luZSBvZiB0aGUgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwic2luXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGguc2luKGEpICogTWF0aC5jb3NoKGIpLFxuICAgICAgICAgICAgICBNYXRoLmNvcyhhKSAqIE1hdGguc2luaChiKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29zaW5lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNvc1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLmNvcyhhKSAqIE1hdGguY29zaChiKSxcbiAgICAgICAgICAgICAtTWF0aC5zaW4oYSkgKiBNYXRoLnNpbmgoYikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHRhbmdlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwidGFuXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IDIgKiB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IDIgKiB0aGlzW1wiaW1cIl07XG4gICAgICB2YXIgZCA9IE1hdGguY29zKGEpICsgTWF0aC5jb3NoKGIpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGguc2luKGEpIC8gZCxcbiAgICAgICAgICAgICAgTWF0aC5zaW5oKGIpIC8gZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY290YW5nZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNvdFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSAyICogdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSAyICogdGhpc1tcImltXCJdO1xuICAgICAgdmFyIGQgPSBNYXRoLmNvcyhhKSAtIE1hdGguY29zaChiKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgIC1NYXRoLnNpbihhKSAvIGQsXG4gICAgICAgICAgICAgIE1hdGguc2luaChiKSAvIGQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNlY2FudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJzZWNcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG4gICAgICB2YXIgZCA9IDAuNSAqIE1hdGguY29zaCgyICogYikgKyAwLjUgKiBNYXRoLmNvcygyICogYSk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5jb3MoYSkgKiBNYXRoLmNvc2goYikgLyBkLFxuICAgICAgICAgICAgICBNYXRoLnNpbihhKSAqIE1hdGguc2luaChiKSAvIGQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvc2VjYW5zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNzY1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gMC41ICogTWF0aC5jb3NoKDIgKiBiKSAtIDAuNSAqIE1hdGguY29zKDIgKiBhKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLnNpbihhKSAqIE1hdGguY29zaChiKSAvIGQsXG4gICAgICAgICAgICAgLU1hdGguY29zKGEpICogTWF0aC5zaW5oKGIpIC8gZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyBzaW51c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhc2luXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICB2YXIgdDEgPSBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgIGIgKiBiIC0gYSAqIGEgKyAxLFxuICAgICAgICAgICAgICAtMiAqIGEgKiBiKVsnc3FydCddKCk7XG5cbiAgICAgIHZhciB0MiA9IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICB0MVsncmUnXSAtIGIsXG4gICAgICAgICAgICAgIHQxWydpbSddICsgYSlbJ2xvZyddKCk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCh0MlsnaW0nXSwgLXQyWydyZSddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIGNvc2ludXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYWNvc1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgdmFyIHQxID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICBiICogYiAtIGEgKiBhICsgMSxcbiAgICAgICAgICAgICAgLTIgKiBhICogYilbJ3NxcnQnXSgpO1xuXG4gICAgICB2YXIgdDIgPSBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgdDFbXCJyZVwiXSAtIGIsXG4gICAgICAgICAgICAgIHQxW1wiaW1cIl0gKyBhKVsnbG9nJ10oKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGguUEkgLyAyIC0gdDJbXCJpbVwiXSwgdDJbXCJyZVwiXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhcmN1cyB0YW5nZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImF0YW5cIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIGlmIChhID09PSAwKSB7XG5cbiAgICAgICAgaWYgKGIgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoMCwgSW5maW5pdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIC1JbmZpbml0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBhICogYSArICgxLjAgLSBiKSAqICgxLjAgLSBiKTtcblxuICAgICAgdmFyIHQxID0gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICgxIC0gYiAqIGIgLSBhICogYSkgLyBkLFxuICAgICAgICAgICAgICAtMiAqIGEgLyBkKS5sb2coKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KC0wLjUgKiB0MVtcImltXCJdLCAwLjUgKiB0MVtcInJlXCJdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFyY3VzIGNvdGFuZ2VudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhY290XCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICBpZiAoYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5hdGFuMigxLCBhKSwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkID0gYSAqIGEgKyBiICogYjtcbiAgICAgIHJldHVybiAoZCAhPT0gMClcbiAgICAgICAgICAgICAgPyBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICBhIC8gZCxcbiAgICAgICAgICAgICAgICAgICAgIC1iIC8gZCkuYXRhbigpXG4gICAgICAgICAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgKGEgIT09IDApID8gYSAvIDAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIChiICE9PSAwKSA/LWIgLyAwIDogMCkuYXRhbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgc2VjYW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFzZWNcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIEluZmluaXR5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBhICogYSArIGIgKiBiO1xuICAgICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgICAgICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIGEgLyBkLFxuICAgICAgICAgICAgICAgICAgICAgIC1iIC8gZCkuYWNvcygpXG4gICAgICAgICAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgKGEgIT09IDApID8gYSAvIDAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIChiICE9PSAwKSA/LWIgLyAwIDogMCkuYWNvcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggYXJjdXMgY29zZWNhbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiYWNzY1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5QSSAvIDIsIEluZmluaXR5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBhICogYSArIGIgKiBiO1xuICAgICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgICAgICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIGEgLyBkLFxuICAgICAgICAgICAgICAgICAgICAgLWIgLyBkKS5hc2luKClcbiAgICAgICAgICAgICAgOiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgIT09IDApID8tYiAvIDAgOiAwKS5hc2luKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBzaW5oXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcInNpbmhcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gdGhpc1tcInJlXCJdO1xuICAgICAgdmFyIGIgPSB0aGlzW1wiaW1cIl07XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5zaW5oKGEpICogTWF0aC5jb3MoYiksXG4gICAgICAgICAgICAgIE1hdGguY29zaChhKSAqIE1hdGguc2luKGIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGNvc2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY29zaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICBNYXRoLmNvc2goYSkgKiBNYXRoLmNvcyhiKSxcbiAgICAgICAgICAgICAgTWF0aC5zaW5oKGEpICogTWF0aC5zaW4oYikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggdGFuaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJ0YW5oXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IDIgKiB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IDIgKiB0aGlzW1wiaW1cIl07XG4gICAgICB2YXIgZCA9IE1hdGguY29zaChhKSArIE1hdGguY29zKGIpO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGguc2luaChhKSAvIGQsXG4gICAgICAgICAgICAgIE1hdGguc2luKGIpIC8gZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBjb3RoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNvdGhcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhID0gMiAqIHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gMiAqIHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gTWF0aC5jb3NoKGEpIC0gTWF0aC5jb3MoYik7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5zaW5oKGEpIC8gZCxcbiAgICAgICAgICAgICAtTWF0aC5zaW4oYikgLyBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGNvdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiY3NjaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gTWF0aC5jb3MoMiAqIGIpIC0gTWF0aC5jb3NoKDIgKiBhKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAtMiAqIE1hdGguc2luaChhKSAqIE1hdGguY29zKGIpIC8gZCwgXG4gICAgICAgICAgICAyICogTWF0aC5jb3NoKGEpICogTWF0aC5zaW4oYikgLyBkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IHNlY2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwic2VjaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciBkID0gTWF0aC5jb3MoMiAqIGIpICsgTWF0aC5jb3NoKDIgKiBhKTtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAyICogTWF0aC5jb3NoKGEpICogTWF0aC5jb3MoYikgLyBkLCBcbiAgICAgICAgICAgICAtMiAqIE1hdGguc2luaChhKSAqIE1hdGguc2luKGIpIC8gZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhc2luaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhc2luaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHRtcCA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIHRoaXNbXCJpbVwiXSA9IC10aGlzW1wicmVcIl07XG4gICAgICB0aGlzW1wicmVcIl0gPSB0bXA7XG4gICAgICB2YXIgcmVzID0gdGhpc1tcImFzaW5cIl0oKTtcblxuICAgICAgdGhpc1tcInJlXCJdID0gLXRoaXNbXCJpbVwiXTtcbiAgICAgIHRoaXNbXCJpbVwiXSA9IHRtcDtcbiAgICAgIHRtcCA9IHJlc1tcInJlXCJdO1xuXG4gICAgICByZXNbXCJyZVwiXSA9IC1yZXNbXCJpbVwiXTtcbiAgICAgIHJlc1tcImltXCJdID0gdG1wO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFzaW5oXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFjb3NoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIHJlcyA9IHRoaXNbXCJhY29zXCJdKCk7XG4gICAgICBpZiAocmVzW1wiaW1cIl0gPD0gMCkge1xuICAgICAgICB0bXAgPSByZXNbXCJyZVwiXTtcbiAgICAgICAgcmVzW1wicmVcIl0gPSAtcmVzW1wiaW1cIl07XG4gICAgICAgIHJlc1tcImltXCJdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wID0gcmVzW1wiaW1cIl07XG4gICAgICAgIHJlc1tcImltXCJdID0gLXJlc1tcInJlXCJdO1xuICAgICAgICByZXNbXCJyZVwiXSA9IHRtcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhdGFuaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhdGFuaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgdmFyIG5vSU0gPSBhID4gMSAmJiBiID09PSAwO1xuICAgICAgdmFyIG9uZU1pbnVzID0gMSAtIGE7XG4gICAgICB2YXIgb25lUGx1cyA9IDEgKyBhO1xuICAgICAgdmFyIGQgPSBvbmVNaW51cyAqIG9uZU1pbnVzICsgYiAqIGI7XG5cbiAgICAgIHZhciB4ID0gKGQgIT09IDApXG4gICAgICAgICAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgKG9uZVBsdXMgKiBvbmVNaW51cyAtIGIgKiBiKSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgKiBvbmVNaW51cyArIG9uZVBsdXMgKiBiKSAvIGQpXG4gICAgICAgICAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgKGEgIT09IC0xKSA/IChhIC8gMCkgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIChiICE9PSAwKSA/IChiIC8gMCkgOiAwKTtcblxuICAgICAgdmFyIHRlbXAgPSB4W1wicmVcIl07XG4gICAgICB4W1wicmVcIl0gPSBsb2dIeXBvdCh4W1wicmVcIl0sIHhbXCJpbVwiXSkgLyAyO1xuICAgICAgeFtcImltXCJdID0gTWF0aC5hdGFuMih4W1wiaW1cIl0sIHRlbXApIC8gMjtcbiAgICAgIGlmIChub0lNKSB7XG4gICAgICAgIHhbXCJpbVwiXSA9IC14W1wiaW1cIl07XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFjb3RoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFjb3RoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAsIE1hdGguUEkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBhICogYSArIGIgKiBiO1xuICAgICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgICAgICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIGEgLyBkLFxuICAgICAgICAgICAgICAgICAgICAgLWIgLyBkKS5hdGFuaCgpXG4gICAgICAgICAgICAgIDogbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgKGEgIT09IDApID8gYSAvIDAgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIChiICE9PSAwKSA/LWIgLyAwIDogMCkuYXRhbmgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb21wbGV4IGFjc2NoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImFjc2NoXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYSA9IHRoaXNbXCJyZVwiXTtcbiAgICAgIHZhciBiID0gdGhpc1tcImltXCJdO1xuXG4gICAgICBpZiAoYiA9PT0gMCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAoYSAhPT0gMClcbiAgICAgICAgICAgICAgICA/IE1hdGgubG9nKGEgKyBNYXRoLnNxcnQoYSAqIGEgKyAxKSlcbiAgICAgICAgICAgICAgICA6IEluZmluaXR5LCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBhICogYSArIGIgKiBiO1xuICAgICAgcmV0dXJuIChkICE9PSAwKVxuICAgICAgICAgICAgICA/IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIGEgLyBkLFxuICAgICAgICAgICAgICAgICAgICAgIC1iIC8gZCkuYXNpbmgoKVxuICAgICAgICAgICAgICA6IG5ldyBDb21wbGV4KFxuICAgICAgICAgICAgICAgICAgICAgIChhICE9PSAwKSA/IGEgLyAwIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAoYiAhPT0gMCkgPy1iIC8gMCA6IDApLmFzaW5oKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29tcGxleCBhc2VjaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJhc2VjaFwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoSW5maW5pdHksIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGEgKiBhICsgYiAqIGI7XG4gICAgICByZXR1cm4gKGQgIT09IDApXG4gICAgICAgICAgICAgID8gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgICAgICAgICAgYSAvIGQsXG4gICAgICAgICAgICAgICAgICAgICAtYiAvIGQpLmFjb3NoKClcbiAgICAgICAgICAgICAgOiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgICAgICAgICAoYSAhPT0gMCkgPyBhIC8gMCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgKGIgIT09IDApID8tYiAvIDAgOiAwKS5hY29zaCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvbXBsZXggaW52ZXJzZSAxL3pcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiaW52ZXJzZVwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcblxuICAgICAgdmFyIGQgPSBhICogYSArIGIgKiBiO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIGEgIT09IDAgPyBhIC8gZCA6IDAsXG4gICAgICAgICAgICAgIGIgIT09IDAgPy1iIC8gZCA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBsZXh9XG4gICAgICovXG4gICAgXCJjb25qdWdhdGVcIjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleCh0aGlzW1wicmVcIl0sIC10aGlzW1wiaW1cIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZWdhdGVkIGNvbXBsZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcIm5lZ1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KC10aGlzW1wicmVcIl0sIC10aGlzW1wiaW1cIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZWlscyB0aGUgYWN0dWFsIGNvbXBsZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNlaWxcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5jZWlsKHRoaXNbXCJyZVwiXSAqIHBsYWNlcykgLyBwbGFjZXMsXG4gICAgICAgICAgICAgIE1hdGguY2VpbCh0aGlzW1wiaW1cIl0gKiBwbGFjZXMpIC8gcGxhY2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmxvb3JzIHRoZSBhY3R1YWwgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21wbGV4fVxuICAgICAqL1xuICAgIFwiZmxvb3JcIjogZnVuY3Rpb24ocGxhY2VzKSB7XG5cbiAgICAgIHBsYWNlcyA9IE1hdGgucG93KDEwLCBwbGFjZXMgfHwgMCk7XG5cbiAgICAgIHJldHVybiBuZXcgQ29tcGxleChcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzW1wicmVcIl0gKiBwbGFjZXMpIC8gcGxhY2VzLFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXNbXCJpbVwiXSAqIHBsYWNlcykgLyBwbGFjZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZWlscyB0aGUgYWN0dWFsIGNvbXBsZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcInJvdW5kXCI6IGZ1bmN0aW9uKHBsYWNlcykge1xuXG4gICAgICBwbGFjZXMgPSBNYXRoLnBvdygxMCwgcGxhY2VzIHx8IDApO1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgoXG4gICAgICAgICAgICAgIE1hdGgucm91bmQodGhpc1tcInJlXCJdICogcGxhY2VzKSAvIHBsYWNlcyxcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzW1wiaW1cIl0gKiBwbGFjZXMpIC8gcGxhY2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGNvbXBsZXggbnVtYmVyc1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgXCJlcXVhbHNcIjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICBwYXJzZShhLCBiKTsgLy8gbXV0YXRlcyBQXG5cbiAgICAgIHJldHVybiBNYXRoLmFicyhQW1wicmVcIl0gLSB0aGlzW1wicmVcIl0pIDw9IENvbXBsZXhbXCJFUFNJTE9OXCJdICYmXG4gICAgICAgICAgICAgTWF0aC5hYnMoUFtcImltXCJdIC0gdGhpc1tcImltXCJdKSA8PSBDb21wbGV4W1wiRVBTSUxPTlwiXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBhY3R1YWwgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcGxleH1cbiAgICAgKi9cbiAgICBcImNsb25lXCI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3IENvbXBsZXgodGhpc1tcInJlXCJdLCB0aGlzW1wiaW1cIl0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RyaW5nIG9mIHRoZSBhY3R1YWwgY29tcGxleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgXCJ0b1N0cmluZ1wiOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzW1wicmVcIl07XG4gICAgICB2YXIgYiA9IHRoaXNbXCJpbVwiXTtcbiAgICAgIHZhciByZXQgPSBcIlwiO1xuXG4gICAgICBpZiAoaXNOYU4oYSkgfHwgaXNOYU4oYikpIHtcbiAgICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChhICE9PSAwKSB7XG4gICAgICAgIHJldCs9IGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiICE9PSAwKSB7XG5cbiAgICAgICAgaWYgKGEgIT09IDApIHtcbiAgICAgICAgICByZXQrPSBiIDwgMCA/IFwiIC0gXCIgOiBcIiArIFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPCAwKSB7XG4gICAgICAgICAgcmV0Kz0gXCItXCI7XG4gICAgICAgIH1cblxuICAgICAgICBiID0gTWF0aC5hYnMoYik7XG5cbiAgICAgICAgaWYgKDEgIT09IGIpIHtcbiAgICAgICAgICByZXQrPSBiO1xuICAgICAgICB9XG4gICAgICAgIHJldCs9IFwiaVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJldClcbiAgICAgICAgcmV0dXJuIFwiMFwiO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3R1YWwgbnVtYmVyIGFzIGEgdmVjdG9yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgXCJ0b1ZlY3RvclwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgcmV0dXJuIFt0aGlzW1wicmVcIl0sIHRoaXNbXCJpbVwiXV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdHVhbCByZWFsIHZhbHVlIG9mIHRoZSBjdXJyZW50IG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgICAqL1xuICAgIFwidmFsdWVPZlwiOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXNbXCJpbVwiXSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpc1tcInJlXCJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY29tcGxleCBudW1iZXIgaXMgbm90IGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05hTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNOYU4odGhpc1sncmUnXSkgfHwgaXNOYU4odGhpc1snaW0nXSk7XG4gICAgfVxuICB9O1xuXG4gIENvbXBsZXhbXCJaRVJPXCJdID0gbmV3IENvbXBsZXgoMCwgMCk7XG4gIENvbXBsZXhbXCJPTkVcIl0gPSBuZXcgQ29tcGxleCgxLCAwKTtcbiAgQ29tcGxleFtcIklcIl0gPSBuZXcgQ29tcGxleCgwLCAxKTtcbiAgQ29tcGxleFtcIlBJXCJdID0gbmV3IENvbXBsZXgoTWF0aC5QSSwgMCk7XG4gIENvbXBsZXhbXCJFXCJdID0gbmV3IENvbXBsZXgoTWF0aC5FLCAwKTtcbiAgQ29tcGxleFsnRVBTSUxPTiddID0gMWUtMTY7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmVbXCJhbWRcIl0pIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIENvbXBsZXg7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gQ29tcGxleDtcbiAgfSBlbHNlIHtcbiAgICByb290W1wiQ29tcGxleFwiXSA9IENvbXBsZXg7XG4gIH1cbiAgXG59KSh0aGlzKTtcbiIsImZ1bmN0aW9uIEUgKCkge1xuXHQvLyBLZWVwIHRoaXMgZW1wdHkgc28gaXQncyBlYXNpZXIgdG8gaW5oZXJpdCBmcm9tXG4gIC8vICh2aWEgaHR0cHM6Ly9naXRodWIuY29tL2xpcHNtYWNrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9pc3N1ZXMvMylcbn1cblxuRS5wcm90b3R5cGUgPSB7XG5cdG9uOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG5cbiAgICAoZVtuYW1lXSB8fCAoZVtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgICBmbjogY2FsbGJhY2ssXG4gICAgICBjdHg6IGN0eFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25jZTogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIgKCkge1xuICAgICAgc2VsZi5vZmYobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lci5fID0gY2FsbGJhY2tcbiAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBsaXN0ZW5lciwgY3R4KTtcbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGV2dEFyci5sZW5ndGg7XG5cbiAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICB2YXIgZXZ0cyA9IGVbbmFtZV07XG4gICAgdmFyIGxpdmVFdmVudHMgPSBbXTtcblxuICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZXZ0c1tpXS5mbiAhPT0gY2FsbGJhY2sgJiYgZXZ0c1tpXS5mbi5fICE9PSBjYWxsYmFjaylcbiAgICAgICAgICBsaXZlRXZlbnRzLnB1c2goZXZ0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGZyb20gcXVldWUgdG8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgIC8vIFN1Z2dlc3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbGF6ZFxuICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9jb21taXQvYzZlYmZhYTliYzk3M2IzM2QxMTBhODRhMzA3NzQyYjdjZjk0Yzk1MyNjb21taXRjb21tZW50LTUwMjQ5MTBcblxuICAgIChsaXZlRXZlbnRzLmxlbmd0aClcbiAgICAgID8gZVtuYW1lXSA9IGxpdmVFdmVudHNcbiAgICAgIDogZGVsZXRlIGVbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFO1xuIiwiLyoqXG4gKiB0eXBlZC1mdW5jdGlvblxuICpcbiAqIFR5cGUgY2hlY2tpbmcgZm9yIEphdmFTY3JpcHQgZnVuY3Rpb25zXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2pvc2Rlam9uZy90eXBlZC1mdW5jdGlvblxuICovXG4ndXNlIHN0cmljdCc7XG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT2xkTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBPbGROb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC50eXBlZCA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIC8vIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHR5cGVkLWZ1bmN0aW9uXG4gIC8vIFRPRE86IGFsbG93IHBhc3NpbmcgY29uZmlndXJhdGlvbiwgdHlwZXMsIHRlc3RzIHZpYSB0aGUgZmFjdG9yeSBmdW5jdGlvblxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgdHlwZSB0ZXN0IGZ1bmN0aW9uIGZvciBhIHNwZWNpZmljIGRhdGEgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgICAgICAgICAgICAgIE5hbWUgb2YgYSBkYXRhIHR5cGUgbGlrZSAnbnVtYmVyJyBvciAnc3RyaW5nJ1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbihvYmo6ICopIDogYm9vbGVhbn0gIFJldHVybnMgYSB0eXBlIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGZvciBhbiB1bmtub3duIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHlwZVRlc3QobmFtZSkge1xuICAgICAgdmFyIHRlc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHR5cGVkLnR5cGVzW2ldO1xuICAgICAgICBpZiAoZW50cnkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRlc3QgPSBlbnRyeS50ZXN0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVzdCkge1xuICAgICAgICB2YXIgaGludDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVkLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZW50cnkgPSB0eXBlZC50eXBlc1tpXTtcbiAgICAgICAgICBpZiAoZW50cnkubmFtZS50b0xvd2VyQ2FzZSgpID09IG5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgaGludCA9IGVudHJ5Lm5hbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBcIicgKyBuYW1lICsgJ1wiJyArXG4gICAgICAgICAgICAoaGludCA/ICgnLiBEaWQgeW91IG1lYW4gXCInICsgaGludCArICdcIj8nKSA6ICcnKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGEgc2V0IG9mIGZ1bmN0aW9ucywgYW5kIGNoZWNrXG4gICAgICogd2hldGhlciB0aGUgbmFtZSBvZiBhbGwgZnVuY3Rpb25zIG1hdGNoIChpZiBnaXZlbilcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbj59IGZuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hbWUgKGZucykge1xuICAgICAgdmFyIG5hbWUgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gZm5zW2ldO1xuXG4gICAgICAgIC8vIG1lcmdlIGZ1bmN0aW9uIG5hbWUgd2hlbiB0aGlzIGlzIGEgdHlwZWQgZnVuY3Rpb25cbiAgICAgICAgaWYgKGZuLnNpZ25hdHVyZXMgJiYgZm4ubmFtZSAhPSAnJykge1xuICAgICAgICAgIGlmIChuYW1lID09ICcnKSB7XG4gICAgICAgICAgICBuYW1lID0gZm4ubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBmbi5uYW1lKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGdW5jdGlvbiBuYW1lcyBkbyBub3QgbWF0Y2ggKGV4cGVjdGVkOiAnICsgbmFtZSArICcsIGFjdHVhbDogJyArIGZuLm5hbWUgKyAnKScpO1xuICAgICAgICAgICAgZXJyLmRhdGEgPSB7XG4gICAgICAgICAgICAgIGFjdHVhbDogZm4ubmFtZSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBBcmd1bWVudHNFcnJvci4gQ3JlYXRlcyBtZXNzYWdlcyBsaWtlOlxuICAgICAqXG4gICAgICogICBVbmV4cGVjdGVkIHR5cGUgb2YgYXJndW1lbnQgKGV4cGVjdGVkOiAuLi4sIGFjdHVhbDogLi4uLCBpbmRleDogLi4uKVxuICAgICAqICAgVG9vIGZldyBhcmd1bWVudHMgKGV4cGVjdGVkOiAuLi4sIGluZGV4OiAuLi4pXG4gICAgICogICBUb28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGVkOiAuLi4sIGFjdHVhbDogLi4uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZuICAgICAgICAgRnVuY3Rpb24gbmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdDb3VudCAgIE51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICBDdXJyZW50IGFyZ3VtZW50IGluZGV4XG4gICAgICogQHBhcmFtIHsqfSBhY3R1YWwgICAgICAgICAgQ3VycmVudCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwZWN0ZWRdIEFuIG9wdGlvbmFsLCBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGhcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCB0eXBlcyBvbiBnaXZlbiBpbmRleFxuICAgICAqIEBleHRlbmRzIEVycm9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRXJyb3IoZm4sIGFyZ0NvdW50LCBpbmRleCwgYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgdmFyIGFjdHVhbFR5cGUgPSBnZXRUeXBlT2YoYWN0dWFsKTtcbiAgICAgIHZhciBfZXhwZWN0ZWQgPSBleHBlY3RlZCA/IGV4cGVjdGVkLnNwbGl0KCcsJykgOiBudWxsO1xuICAgICAgdmFyIF9mbiA9IChmbiB8fCAndW5uYW1lZCcpO1xuICAgICAgdmFyIGFueVR5cGUgPSBfZXhwZWN0ZWQgJiYgY29udGFpbnMoX2V4cGVjdGVkLCAnYW55Jyk7XG4gICAgICB2YXIgbWVzc2FnZTtcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBmbjogZm4sXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiBfZXhwZWN0ZWRcbiAgICAgIH07XG5cbiAgICAgIGlmIChfZXhwZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID4gaW5kZXggJiYgIWFueVR5cGUpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHR5cGVcbiAgICAgICAgICBtZXNzYWdlID0gJ1VuZXhwZWN0ZWQgdHlwZSBvZiBhcmd1bWVudCBpbiBmdW5jdGlvbiAnICsgX2ZuICtcbiAgICAgICAgICAgICAgJyAoZXhwZWN0ZWQ6ICcgKyBfZXhwZWN0ZWQuam9pbignIG9yICcpICsgJywgYWN0dWFsOiAnICsgYWN0dWFsVHlwZSArICcsIGluZGV4OiAnICsgaW5kZXggKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gdG9vIGZldyBhcmd1bWVudHNcbiAgICAgICAgICBtZXNzYWdlID0gJ1RvbyBmZXcgYXJndW1lbnRzIGluIGZ1bmN0aW9uICcgKyBfZm4gK1xuICAgICAgICAgICAgICAnIChleHBlY3RlZDogJyArIF9leHBlY3RlZC5qb2luKCcgb3IgJykgKyAnLCBpbmRleDogJyArIGluZGV4ICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdG9vIG1hbnkgYXJndW1lbnRzXG4gICAgICAgIG1lc3NhZ2UgPSAnVG9vIG1hbnkgYXJndW1lbnRzIGluIGZ1bmN0aW9uICcgKyBfZm4gK1xuICAgICAgICAgICAgJyAoZXhwZWN0ZWQ6ICcgKyBpbmRleCArICcsIGFjdHVhbDogJyArIGFyZ0NvdW50ICsgJyknXG4gICAgICB9XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIHdpdGggZnVuY3Rpb24gcmVmZXJlbmNlcyAobG9jYWwgc2hvcnRjdXRzIHRvIGZ1bmN0aW9ucylcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9J3JlZnMnXSAgT3B0aW9uYWwgbmFtZSBmb3IgdGhlIHJlZnMsIHVzZWQgdG8gZ2VuZXJhdGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSmF2YVNjcmlwdCBjb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmcyhuYW1lKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdyZWZzJztcbiAgICAgIHRoaXMuY2F0ZWdvcmllcyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZ1bmN0aW9uIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2F0ZWdvcnk9J2ZuJ10gICAgQSBmdW5jdGlvbiBjYXRlZ29yeSwgbGlrZSAnZm4nIG9yICdzaWduYXR1cmUnXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZSwgZm9yIGV4YW1wbGUgJ2ZuMCcgb3IgJ3NpZ25hdHVyZTInXG4gICAgICovXG4gICAgUmVmcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZuLCBjYXRlZ29yeSkge1xuICAgICAgdmFyIGNhdCA9IGNhdGVnb3J5IHx8ICdmbic7XG4gICAgICBpZiAoIXRoaXMuY2F0ZWdvcmllc1tjYXRdKSB0aGlzLmNhdGVnb3JpZXNbY2F0XSA9IFtdO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNhdGVnb3JpZXNbY2F0XS5pbmRleE9mKGZuKTtcbiAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICBpbmRleCA9IHRoaXMuY2F0ZWdvcmllc1tjYXRdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzW2NhdF0ucHVzaChmbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYXQgKyBpbmRleDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvZGUgbGluZXMgZm9yIGFsbCBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29kZSBjb250YWluaW5nIGFsbCBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgICovXG4gICAgUmVmcy5wcm90b3R5cGUudG9Db2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvZGUgPSBbXTtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5uYW1lICsgJy5jYXRlZ29yaWVzJztcbiAgICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5jYXRlZ29yaWVzO1xuXG4gICAgICBmb3IgKHZhciBjYXQgaW4gY2F0ZWdvcmllcykge1xuICAgICAgICBpZiAoY2F0ZWdvcmllcy5oYXNPd25Qcm9wZXJ0eShjYXQpKSB7XG4gICAgICAgICAgdmFyIGNhdGVnb3J5ID0gY2F0ZWdvcmllc1tjYXRdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRlZ29yeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZS5wdXNoKCd2YXIgJyArIGNhdCArIGkgKyAnID0gJyArIHBhdGggKyAnW1xcJycgKyBjYXQgKyAnXFwnXVsnICsgaSArICddOycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29kZS5qb2luKCdcXG4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgUGFyYW19IHR5cGVzICAgIEEgcGFyYW1ldGVyIHR5cGUgbGlrZSAnc3RyaW5nJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXIgfCBib29sZWFuJ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhckFyZ3M9ZmFsc2VdICAgICAgICAgICAgVmFyaWFibGUgYXJndW1lbnRzIGlmIHRydWVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJhbSh0eXBlcywgdmFyQXJncykge1xuICAgICAgLy8gcGFyc2UgdGhlIHR5cGVzLCBjYW4gYmUgYSBzdHJpbmcgd2l0aCB0eXBlcyBzZXBhcmF0ZWQgYnkgcGlwZSBjaGFyYWN0ZXJzIHxcbiAgICAgIGlmICh0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHBhcnNlIHZhcmlhYmxlIGFyZ3VtZW50cyBvcGVyYXRvciAoZWxsaXBzZXMgJy4uLm51bWJlcicpXG4gICAgICAgIHZhciBfdHlwZXMgPSB0eXBlcy50cmltKCk7XG4gICAgICAgIHZhciBfdmFyQXJncyA9IF90eXBlcy5zdWJzdHIoMCwgMykgPT09ICcuLi4nO1xuICAgICAgICBpZiAoX3ZhckFyZ3MpIHtcbiAgICAgICAgICBfdHlwZXMgPSBfdHlwZXMuc3Vic3RyKDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZXMgPT09ICcnKSB7XG4gICAgICAgICAgdGhpcy50eXBlcyA9IFsnYW55J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy50eXBlcyA9IF90eXBlcy5zcGxpdCgnfCcpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy50eXBlc1tpXSA9IHRoaXMudHlwZXNbaV0udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlcykpIHtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZXMgaW5zdGFuY2VvZiBQYXJhbSkge1xuICAgICAgICByZXR1cm4gdHlwZXMuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBvciBBcnJheSBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYW4gaG9sZCBhIHR5cGUgdG8gd2hpY2ggdG8gY29udmVydCB3aGVuIGhhbmRsaW5nIHRoaXMgcGFyYW1ldGVyXG4gICAgICB0aGlzLmNvbnZlcnNpb25zID0gW107XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYmV0dGVyIEFQSSBmb3IgY29udmVyc2lvbnMsIGJlIGFibGUgdG8gYWRkIGNvbnZlcnNpb25zIHZpYSBjb25zdHJ1Y3RvciAoc3VwcG9ydCBhIG5ldyB0eXBlIE9iamVjdD8pXG5cbiAgICAgIC8vIHZhcmlhYmxlIGFyZ3VtZW50c1xuICAgICAgdGhpcy52YXJBcmdzID0gX3ZhckFyZ3MgfHwgdmFyQXJncyB8fCBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGFueSB0eXBlIGFyZ3VtZW50c1xuICAgICAgdGhpcy5hbnlUeXBlID0gdGhpcy50eXBlcy5pbmRleE9mKCdhbnknKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JkZXIgUGFyYW1zXG4gICAgICogYW55IHR5cGUgKCdhbnknKSB3aWxsIGJlIG9yZGVyZWQgbGFzdCwgYW5kIG9iamVjdCBhcyBzZWNvbmQgbGFzdCAoYXMgb3RoZXJcbiAgICAgKiB0eXBlcyBtYXkgYmUgYW4gb2JqZWN0IGFzIHdlbGwsIGxpa2UgQXJyYXkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXJhbX0gYVxuICAgICAqIEBwYXJhbSB7UGFyYW19IGJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIDEgaWYgYSA+IGIsIC0xIGlmIGEgPCBiLCBhbmQgZWxzZSAwLlxuICAgICAqL1xuICAgIFBhcmFtLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gVE9ETzogc2ltcGxpZnkgcGFyYW1ldGVyIGNvbXBhcmlzb24sIGl0J3MgYSBtZXNzXG4gICAgICBpZiAoYS5hbnlUeXBlKSByZXR1cm4gMTtcbiAgICAgIGlmIChiLmFueVR5cGUpIHJldHVybiAtMTtcblxuICAgICAgaWYgKGNvbnRhaW5zKGEudHlwZXMsICdPYmplY3QnKSkgcmV0dXJuIDE7XG4gICAgICBpZiAoY29udGFpbnMoYi50eXBlcywgJ09iamVjdCcpKSByZXR1cm4gLTE7XG5cbiAgICAgIGlmIChhLmhhc0NvbnZlcnNpb25zKCkpIHtcbiAgICAgICAgaWYgKGIuaGFzQ29udmVyc2lvbnMoKSkge1xuICAgICAgICAgIHZhciBpLCBhYywgYmM7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5jb252ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGEuY29udmVyc2lvbnNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBhYyA9IGEuY29udmVyc2lvbnNbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiLmNvbnZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYi5jb252ZXJzaW9uc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGJjID0gYi5jb252ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHR5cGVkLmNvbnZlcnNpb25zLmluZGV4T2YoYWMpIC0gdHlwZWQuY29udmVyc2lvbnMuaW5kZXhPZihiYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoYi5oYXNDb252ZXJzaW9ucygpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGJvdGggcGFyYW1zIGhhdmUgbm8gY29udmVyc2lvbnNcbiAgICAgICAgICB2YXIgYWksIGJpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVkLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZWQudHlwZXNbaV0ubmFtZSA9PT0gYS50eXBlc1swXSkge1xuICAgICAgICAgICAgICBhaSA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlZC50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVkLnR5cGVzW2ldLm5hbWUgPT09IGIudHlwZXNbMF0pIHtcbiAgICAgICAgICAgICAgYmkgPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWkgLSBiaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhpcyBwYXJhbWV0ZXJzIHR5cGVzIG92ZXJsYXAgYW4gb3RoZXIgcGFyYW1ldGVycyB0eXBlcy5cbiAgICAgKiBXaWxsIG5vdCBtYXRjaCBbJ2FueSddIHdpdGggWydudW1iZXInXVxuICAgICAqIEBwYXJhbSB7UGFyYW19IG90aGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlcmUgYXJlIG92ZXJsYXBwaW5nIHR5cGVzXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLm92ZXJsYXBwaW5nID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKG90aGVyLnR5cGVzLCB0aGlzLnR5cGVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGlzIHBhcmFtZXRlcnMgdHlwZXMgbWF0Y2hlcyBhbiBvdGhlciBwYXJhbWV0ZXJzIHR5cGVzLlxuICAgICAqIFdoZW4gYW55IG9mIHRoZSB0d28gcGFyYW1ldGVycyBjb250YWlucyBgYW55YCwgdHJ1ZSBpcyByZXR1cm5lZFxuICAgICAqIEBwYXJhbSB7UGFyYW19IG90aGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlcmUgYXJlIG1hdGNoaW5nIHR5cGVzXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFueVR5cGUgfHwgb3RoZXIuYW55VHlwZSB8fCB0aGlzLm92ZXJsYXBwaW5nKG90aGVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBwYXJhbVxuICAgICAqIEByZXR1cm5zIHtQYXJhbX0gUmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoaXMgcGFyYW1cbiAgICAgKi9cbiAgICBQYXJhbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyYW0gPSBuZXcgUGFyYW0odGhpcy50eXBlcy5zbGljZSgpLCB0aGlzLnZhckFyZ3MpO1xuICAgICAgcGFyYW0uY29udmVyc2lvbnMgPSB0aGlzLmNvbnZlcnNpb25zLnNsaWNlKCk7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciB0aGlzIHBhcmFtZXRlciBjb250YWlucyBjb252ZXJzaW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtZXRlciBjb250YWlucyBvbmUgb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUgY29udmVyc2lvbnMuXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLmhhc0NvbnZlcnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2lvbnMubGVuZ3RoID4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciB0aGlzIHBhcmFtZXRlcnMgY29udGFpbnMgYW55IG9mIHRoZSBwcm92aWRlZCB0eXBlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAgQSBNYXAgd2l0aCB0eXBlcywgbGlrZSB7J251bWJlcic6IHRydWV9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFyYW1ldGVyIGNvbnRhaW5zIGFueVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHByb3ZpZGVkIHR5cGVzXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVzW3RoaXMudHlwZXNbaV1dKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGFyYW1zIHR5cGVzLCBsaWtlICdzdHJpbmcnIG9yXG4gICAgICogJ251bWJlciB8IGJvb2xlYW4nIG9yICcuLi5udW1iZXInXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdG9Db252ZXJzaW9uXSAgIElmIHRydWUsIHRoZSByZXR1cm5lZCB0eXBlcyBzdHJpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMgdGhlIHR5cGVzIHdoZXJlIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBjb252ZXJ0IHRvLiBJZiBmYWxzZSAoZGVmYXVsdClcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIFwiZnJvbVwiIHR5cGVzIGFyZSByZXR1cm5lZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHRvQ29udmVyc2lvbikge1xuICAgICAgdmFyIHR5cGVzID0gW107XG4gICAgICB2YXIga2V5cyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSB0aGlzLmNvbnZlcnNpb25zW2ldO1xuICAgICAgICB2YXIgdHlwZSA9IHRvQ29udmVyc2lvbiAmJiBjb252ZXJzaW9uID8gY29udmVyc2lvbi50byA6IHRoaXMudHlwZXNbaV07XG4gICAgICAgIGlmICghKHR5cGUgaW4ga2V5cykpIHtcbiAgICAgICAgICBrZXlzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAodGhpcy52YXJBcmdzID8gJy4uLicgOiAnJykgKyB0eXBlcy5qb2luKCd8Jyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IFBhcmFtW119IHBhcmFtc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5IHdpdGggdGhlIHR5cGUocykgb2YgZWFjaCBwYXJhbWV0ZXIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIHdpdGggdHlwZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgICBUaGUgYWN0dWFsIGZ1bmN0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmF0dXJlKHBhcmFtcywgZm4pIHtcbiAgICAgIHZhciBfcGFyYW1zO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIF9wYXJhbXMgPSAocGFyYW1zICE9PSAnJykgPyBwYXJhbXMuc3BsaXQoJywnKSA6IFtdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgIF9wYXJhbXMgPSBwYXJhbXM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgb3IgQXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJhbXMgPSBuZXcgQXJyYXkoX3BhcmFtcy5sZW5ndGgpO1xuICAgICAgdGhpcy5hbnlUeXBlID0gZmFsc2U7XG4gICAgICB0aGlzLnZhckFyZ3MgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3BhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFyYW0gPSBuZXcgUGFyYW0oX3BhcmFtc1tpXSk7XG4gICAgICAgIHRoaXMucGFyYW1zW2ldID0gcGFyYW07XG4gICAgICAgIGlmIChwYXJhbS5hbnlUeXBlKSB7XG4gICAgICAgICAgdGhpcy5hbnlUeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gX3BhcmFtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gdGhlIGxhc3QgYXJndW1lbnRcbiAgICAgICAgICB0aGlzLnZhckFyZ3MgPSBwYXJhbS52YXJBcmdzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIG5vbi1sYXN0IGFyZ3VtZW50XG4gICAgICAgICAgaWYgKHBhcmFtLnZhckFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCB2YXJpYWJsZSBhcmd1bWVudHMgb3BlcmF0b3IgXCIuLi5cIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZuID0gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhpcyBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7U2lnbmF0dXJlfSBSZXR1cm5zIGEgY2xvbmVkIHZlcnNpb24gb2YgdGhpcyBzaWduYXR1cmVcbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5wYXJhbXMuc2xpY2UoKSwgdGhpcy5mbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZCBhIHNpZ25hdHVyZTogc3BsaXQgcGFyYW1zIHdpdGggdW5pb24gdHlwZXMgaW4gc2VwYXJhdGUgc2lnbmF0dXJlc1xuICAgICAqIEZvciBleGFtcGxlIHNwbGl0IGEgU2lnbmF0dXJlIFwic3RyaW5nIHwgbnVtYmVyXCIgaW50byB0d28gc2lnbmF0dXJlcy5cbiAgICAgKiBAcmV0dXJuIHtTaWduYXR1cmVbXX0gUmV0dXJucyBhbiBhcnJheSB3aXRoIHNpZ25hdHVyZXMgKGF0IGxlYXN0IG9uZSlcbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaWduYXR1cmVzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHJlY3Vyc2Uoc2lnbmF0dXJlLCBwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IHNpZ25hdHVyZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGksIG5ld1BhcmFtLCBjb252ZXJzaW9uO1xuXG4gICAgICAgICAgdmFyIHBhcmFtID0gc2lnbmF0dXJlLnBhcmFtc1twYXRoLmxlbmd0aF07XG4gICAgICAgICAgaWYgKHBhcmFtLnZhckFyZ3MpIHtcbiAgICAgICAgICAgIC8vIGEgdmFyaWFibGUgYXJndW1lbnQuIGRvIG5vdCBzcGxpdCB0aGUgdHlwZXMgaW4gdGhlIHBhcmFtZXRlclxuICAgICAgICAgICAgbmV3UGFyYW0gPSBwYXJhbS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgY29udmVyc2lvbnMgdG8gdGhlIHBhcmFtZXRlclxuICAgICAgICAgICAgLy8gcmVjdXJzZSBmb3IgYWxsIGNvbnZlcnNpb25zXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHlwZWQuY29udmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29udmVyc2lvbiA9IHR5cGVkLmNvbnZlcnNpb25zW2ldO1xuICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zKHBhcmFtLnR5cGVzLCBjb252ZXJzaW9uLmZyb20pICYmIGNvbnRhaW5zKHBhcmFtLnR5cGVzLCBjb252ZXJzaW9uLnRvKSkge1xuICAgICAgICAgICAgICAgIHZhciBqID0gbmV3UGFyYW0udHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFtLnR5cGVzW2pdID0gY29udmVyc2lvbi5mcm9tO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFtLmNvbnZlcnNpb25zW2pdID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWN1cnNlKHNpZ25hdHVyZSwgcGF0aC5jb25jYXQobmV3UGFyYW0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzcGxpdCBlYWNoIHR5cGUgaW4gdGhlIHBhcmFtZXRlclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmFtLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJlY3Vyc2Uoc2lnbmF0dXJlLCBwYXRoLmNvbmNhdChuZXcgUGFyYW0ocGFyYW0udHlwZXNbaV0pKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgZm9yIGFsbCBjb252ZXJzaW9uc1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGVkLmNvbnZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnZlcnNpb24gPSB0eXBlZC5jb252ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFjb250YWlucyhwYXJhbS50eXBlcywgY29udmVyc2lvbi5mcm9tKSAmJiBjb250YWlucyhwYXJhbS50eXBlcywgY29udmVyc2lvbi50bykpIHtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbSA9IG5ldyBQYXJhbShjb252ZXJzaW9uLmZyb20pO1xuICAgICAgICAgICAgICAgIG5ld1BhcmFtLmNvbnZlcnNpb25zWzBdID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZWN1cnNlKHNpZ25hdHVyZSwgcGF0aC5jb25jYXQobmV3UGFyYW0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzaWduYXR1cmVzLnB1c2gobmV3IFNpZ25hdHVyZShwYXRoLCBzaWduYXR1cmUuZm4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWN1cnNlKHRoaXMsIFtdKTtcblxuICAgICAgcmV0dXJuIHNpZ25hdHVyZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIHNpZ25hdHVyZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIHR3byBwYXJhbXMgYXJlIGVxdWFsIGFuZCBjb250YWluIGNvbnZlcnNpb25zLCB0aGV5IHdpbGwgYmUgc29ydGVkXG4gICAgICogYnkgbG93ZXN0IGluZGV4IG9mIHRoZSBmaXJzdCBjb252ZXJzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlfSBhXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmV9IGJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIDEgaWYgYSA+IGIsIC0xIGlmIGEgPCBiLCBhbmQgZWxzZSAwLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZS5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhLnBhcmFtcy5sZW5ndGggPiBiLnBhcmFtcy5sZW5ndGgpIHJldHVybiAxO1xuICAgICAgaWYgKGEucGFyYW1zLmxlbmd0aCA8IGIucGFyYW1zLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIGNvbnZlcnNpb25zXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBhLnBhcmFtcy5sZW5ndGg7IC8vIGEgYW5kIGIgaGF2ZSBlcXVhbCBhbW91bnQgb2YgcGFyYW1zXG4gICAgICB2YXIgYWMgPSAwO1xuICAgICAgdmFyIGJjID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYS5wYXJhbXNbaV0uaGFzQ29udmVyc2lvbnMoKSkgYWMrKztcbiAgICAgICAgaWYgKGIucGFyYW1zW2ldLmhhc0NvbnZlcnNpb25zKCkpIGJjKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYyA+IGJjKSByZXR1cm4gMTtcbiAgICAgIGlmIChhYyA8IGJjKSByZXR1cm4gLTE7XG5cbiAgICAgIC8vIGNvbXBhcmUgdGhlIG9yZGVyIHBlciBwYXJhbWV0ZXJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY21wID0gUGFyYW0uY29tcGFyZShhLnBhcmFtc1tpXSwgYi5wYXJhbXNbaV0pO1xuICAgICAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGFueSBvZiB0aGUgc2lnbmF0dXJlcyBwYXJhbWV0ZXJzIGhhcyBjb252ZXJzaW9uc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIGFueSBvZiB0aGUgcGFyYW1ldGVycyBjb250YWluc1xuICAgICAqICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25zLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUuaGFzQ29udmVyc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtc1tpXS5oYXNDb252ZXJzaW9ucygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIHRoaXMgc2lnbmF0dXJlIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFueSBvZiB0aGUgcGFyYW1ldGVycyBjb250YWlucyBhIHR5cGUgbGlzdGVkIGluXG4gICAgICogdHlwZWQuaWdub3JlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIHNpZ25hdHVyZSBzaG91bGQgYmUgaWdub3JlZFxuICAgICAqL1xuICAgIFNpZ25hdHVyZS5wcm90b3R5cGUuaWdub3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY3JlYXRlIGEgbWFwIHdpdGggaWdub3JlZCB0eXBlc1xuICAgICAgdmFyIHR5cGVzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmlnbm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0eXBlc1t0eXBlZC5pZ25vcmVbaV1dID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGVzdCB3aGV0aGVyIGFueSBvZiB0aGUgcGFyYW1ldGVycyBjb250YWlucyB0aGlzIHR5cGVcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5wYXJhbXNbaV0uY29udGFpbnModHlwZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIHBhdGggb2YgdGhpcyBzaWduYXR1cmUgbWF0Y2hlcyBhIGdpdmVuIHBhdGguXG4gICAgICogQHBhcmFtIHtQYXJhbVtdfSBwYXJhbXNcbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnBhcmFtc1N0YXJ0V2l0aCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYUxhc3QgPSBsYXN0KHRoaXMucGFyYW1zKTtcbiAgICAgIHZhciBiTGFzdCA9IGxhc3QocGFyYW1zKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnBhcmFtc1tpXSB8fCAoYUxhc3QudmFyQXJncyA/IGFMYXN0OiBudWxsKTtcbiAgICAgICAgdmFyIGIgPSBwYXJhbXNbaV0gICAgICB8fCAoYkxhc3QudmFyQXJncyA/IGJMYXN0OiBudWxsKTtcblxuICAgICAgICBpZiAoIWEgfHwgICFiIHx8ICFhLm1hdGNoZXMoYikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb2RlIHRvIGludm9rZSB0aGlzIHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7UmVmc30gcmVmc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIGNvZGVcbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnRvQ29kZSA9IGZ1bmN0aW9uIChyZWZzLCBwcmVmaXgpIHtcbiAgICAgIHZhciBjb2RlID0gW107XG5cbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KHRoaXMucGFyYW1zLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHRoaXMucGFyYW1zW2ldO1xuICAgICAgICB2YXIgY29udmVyc2lvbiA9IHBhcmFtLmNvbnZlcnNpb25zWzBdO1xuICAgICAgICBpZiAocGFyYW0udmFyQXJncykge1xuICAgICAgICAgIGFyZ3NbaV0gPSAndmFyQXJncyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udmVyc2lvbikge1xuICAgICAgICAgIGFyZ3NbaV0gPSByZWZzLmFkZChjb252ZXJzaW9uLmNvbnZlcnQsICdjb252ZXJ0JykgKyAnKGFyZycgKyBpICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFyZ3NbaV0gPSAnYXJnJyArIGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IHRoaXMuZm4gPyByZWZzLmFkZCh0aGlzLmZuLCAnc2lnbmF0dXJlJykgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAncmV0dXJuICcgKyByZWYgKyAnKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKTsgLy8gc2lnbmF0dXJlOiAnICsgdGhpcy5wYXJhbXMuam9pbignLCAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGUuam9pbignXFxuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBTaWduYXR1cmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmpvaW4oJywgJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgb2Ygc2lnbmF0dXJlcyB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlciBvbiBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7UGFyYW1bXX0gcGF0aFxuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlfSBbc2lnbmF0dXJlXVxuICAgICAqIEBwYXJhbSB7Tm9kZVtdfSBjaGlsZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmYWxsVGhyb3VnaD1mYWxzZV1cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOb2RlKHBhdGgsIHNpZ25hdHVyZSwgY2hpbGRzLCBmYWxsVGhyb3VnaCkge1xuICAgICAgdGhpcy5wYXRoID0gcGF0aCB8fCBbXTtcbiAgICAgIHRoaXMucGFyYW0gPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlIHx8IG51bGw7XG4gICAgICB0aGlzLmNoaWxkcyA9IGNoaWxkcyB8fCBbXTtcbiAgICAgIHRoaXMuZmFsbFRocm91Z2ggPSBmYWxsVGhyb3VnaCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBjb2RlIGZvciB0aGlzIGdyb3VwIG9mIHNpZ25hdHVyZXNcbiAgICAgKiBAcGFyYW0ge1JlZnN9IHJlZnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29kZSBhcyBzdHJpbmdcbiAgICAgKi9cbiAgICBOb2RlLnByb3RvdHlwZS50b0NvZGUgPSBmdW5jdGlvbiAocmVmcywgcHJlZml4KSB7XG4gICAgICAvLyBUT0RPOiBzcGxpdCB0aGlzIGZ1bmN0aW9uIGluIG11bHRpcGxlIGZ1bmN0aW9ucywgaXQncyB0b28gbGFyZ2VcbiAgICAgIHZhciBjb2RlID0gW107XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY29udmVyc2lvbiA9IHRoaXMucGFyYW0uY29udmVyc2lvbnNbMF07XG4gICAgICAgIHZhciBjb21tZW50ID0gJy8vIHR5cGU6ICcgKyAoY29udmVyc2lvbiA/XG4gICAgICAgICAgICAgICAgKGNvbnZlcnNpb24uZnJvbSArICcgKGNvbnZlcnQgdG8gJyArIGNvbnZlcnNpb24udG8gKyAnKScpIDpcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtKTtcblxuICAgICAgICAvLyBub24tcm9vdCBub2RlIChwYXRoIGlzIG5vbi1lbXB0eSlcbiAgICAgICAgaWYgKHRoaXMucGFyYW0udmFyQXJncykge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmFtLmFueVR5cGUpIHtcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIGFyZ3VtZW50cyB3aXRoIGFueSB0eXBlXG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJ2lmIChhcmd1bWVudHMubGVuZ3RoID4gJyArIGluZGV4ICsgJykgeycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgIHZhciB2YXJBcmdzID0gW107Jyk7XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgZm9yICh2YXIgaSA9ICcgKyBpbmRleCArICc7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgIHZhckFyZ3MucHVzaChhcmd1bWVudHNbaV0pOycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgIH0nKTtcbiAgICAgICAgICAgIGNvZGUucHVzaCh0aGlzLnNpZ25hdHVyZS50b0NvZGUocmVmcywgcHJlZml4ICsgJyAgJykpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICd9Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdmFyaWFibGUgYXJndW1lbnRzIHdpdGggYSBmaXhlZCB0eXBlXG4gICAgICAgICAgICB2YXIgZ2V0VGVzdHMgPSBmdW5jdGlvbiAodHlwZXMsIGFyZykge1xuICAgICAgICAgICAgICB2YXIgdGVzdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRlc3RzW2ldID0gcmVmcy5hZGQoZ2V0VHlwZVRlc3QodHlwZXNbaV0pLCAndGVzdCcpICsgJygnICsgYXJnICsgJyknO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0ZXN0cy5qb2luKCcgfHwgJyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBhbGxUeXBlcyA9IHRoaXMucGFyYW0udHlwZXM7XG4gICAgICAgICAgICB2YXIgZXhhY3RUeXBlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbS5jb252ZXJzaW9uc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhhY3RUeXBlcy5wdXNoKGFsbFR5cGVzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJ2lmICgnICsgZ2V0VGVzdHMoYWxsVHlwZXMsICdhcmcnICsgaW5kZXgpICsgJykgeyAnICsgY29tbWVudCk7XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgdmFyIHZhckFyZ3MgPSBbYXJnJyArIGluZGV4ICsgJ107Jyk7XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgZm9yICh2YXIgaSA9ICcgKyAoaW5kZXggKyAxKSArICc7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsnKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgIGlmICgnICsgZ2V0VGVzdHMoZXhhY3RUeXBlcywgJ2FyZ3VtZW50c1tpXScpICsgJykgeycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgICAgICB2YXJBcmdzLnB1c2goYXJndW1lbnRzW2ldKTsnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY29udmVyc2lvbl9pID0gdGhpcy5wYXJhbS5jb252ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgaWYgKGNvbnZlcnNpb25faSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gcmVmcy5hZGQoZ2V0VHlwZVRlc3QoYWxsVHlwZXNbaV0pLCAndGVzdCcpO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ID0gcmVmcy5hZGQoY29udmVyc2lvbl9pLmNvbnZlcnQsICdjb252ZXJ0Jyk7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgICAgfScpO1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnICAgIGVsc2UgaWYgKCcgKyB0ZXN0ICsgJyhhcmd1bWVudHNbaV0pKSB7Jyk7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgICAgICB2YXJBcmdzLnB1c2goJyArIGNvbnZlcnQgKyAnKGFyZ3VtZW50c1tpXSkpOycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJyAgICB9IGVsc2UgeycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgICAgICB0aHJvdyBjcmVhdGVFcnJvcihuYW1lLCBhcmd1bWVudHMubGVuZ3RoLCBpLCBhcmd1bWVudHNbaV0sIFxcJycgKyBleGFjdFR5cGVzLmpvaW4oJywnKSArICdcXCcpOycpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgICAgfScpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICcgIH0nKTtcbiAgICAgICAgICAgIGNvZGUucHVzaCh0aGlzLnNpZ25hdHVyZS50b0NvZGUocmVmcywgcHJlZml4ICsgJyAgJykpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICd9Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmFtLmFueVR5cGUpIHtcbiAgICAgICAgICAgIC8vIGFueSB0eXBlXG4gICAgICAgICAgICBjb2RlLnB1c2gocHJlZml4ICsgJy8vIHR5cGU6IGFueScpO1xuICAgICAgICAgICAgY29kZS5wdXNoKHRoaXMuX2lubmVyQ29kZShyZWZzLCBwcmVmaXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZWd1bGFyIHR5cGVcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5wYXJhbS50eXBlc1swXTtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gdHlwZSAhPT0gJ2FueScgPyByZWZzLmFkZChnZXRUeXBlVGVzdCh0eXBlKSwgJ3Rlc3QnKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnaWYgKCcgKyB0ZXN0ICsgJyhhcmcnICsgaW5kZXggKyAnKSkgeyAnICsgY29tbWVudCk7XG4gICAgICAgICAgICBjb2RlLnB1c2godGhpcy5faW5uZXJDb2RlKHJlZnMsIHByZWZpeCArICcgICcpKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnfScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJvb3Qgbm9kZSAocGF0aCBpcyBlbXB0eSlcbiAgICAgICAgY29kZS5wdXNoKHRoaXMuX2lubmVyQ29kZShyZWZzLCBwcmVmaXgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGUuam9pbignXFxuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGlubmVyIGNvZGUgZm9yIHRoaXMgZ3JvdXAgb2Ygc2lnbmF0dXJlcy5cbiAgICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIG9mIE5vZGUucHJvdG90eXBlLnRvQ29kZVxuICAgICAqIEBwYXJhbSB7UmVmc30gcmVmc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBpbm5lciBjb2RlIGFzIHN0cmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTm9kZS5wcm90b3R5cGUuX2lubmVyQ29kZSA9IGZ1bmN0aW9uIChyZWZzLCBwcmVmaXgpIHtcbiAgICAgIHZhciBjb2RlID0gW107XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvZGUucHVzaChwcmVmaXggKyAnaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09ICcgKyB0aGlzLnBhdGgubGVuZ3RoICsgJykgeycpO1xuICAgICAgICBjb2RlLnB1c2godGhpcy5zaWduYXR1cmUudG9Db2RlKHJlZnMsIHByZWZpeCArICcgICcpKTtcbiAgICAgICAgY29kZS5wdXNoKHByZWZpeCArICd9Jyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlLnB1c2godGhpcy5jaGlsZHNbaV0udG9Db2RlKHJlZnMsIHByZWZpeCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBzaG91bGRuJ3QgdGhlIHRoaXMucGFyYW0uYW55VHlwZSBjaGVjayBiZSByZWR1bmRhbnRcbiAgICAgIGlmICghdGhpcy5mYWxsVGhyb3VnaCB8fCAodGhpcy5wYXJhbSAmJiB0aGlzLnBhcmFtLmFueVR5cGUpKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25zID0gdGhpcy5fZXhjZXB0aW9ucyhyZWZzLCBwcmVmaXgpO1xuICAgICAgICBpZiAoZXhjZXB0aW9ucykge1xuICAgICAgICAgIGNvZGUucHVzaChleGNlcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29kZS5qb2luKCdcXG4nKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBjb2RlIHRvIHRocm93IGV4Y2VwdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlZnN9IHJlZnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgaW5uZXIgY29kZSBhcyBzdHJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5vZGUucHJvdG90eXBlLl9leGNlcHRpb25zID0gZnVuY3Rpb24gKHJlZnMsIHByZWZpeCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5wYXRoLmxlbmd0aDtcblxuICAgICAgaWYgKHRoaXMuY2hpbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUT0RPOiBjYW4gdGhpcyBjb25kaXRpb24gYmUgc2ltcGxpZmllZD8gKHdlIGhhdmUgYSBmYWxsLXRocm91Z2ggaGVyZSlcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBwcmVmaXggKyAnaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAnICsgaW5kZXggKyAnKSB7JyxcbiAgICAgICAgICBwcmVmaXggKyAnICB0aHJvdyBjcmVhdGVFcnJvcihuYW1lLCBhcmd1bWVudHMubGVuZ3RoLCAnICsgaW5kZXggKyAnLCBhcmd1bWVudHNbJyArIGluZGV4ICsgJ10pOycsXG4gICAgICAgICAgcHJlZml4ICsgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSB7fTtcbiAgICAgICAgdmFyIHR5cGVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jaGlsZHNbaV07XG4gICAgICAgICAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5wYXJhbS50eXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUucGFyYW0udHlwZXNbal07XG4gICAgICAgICAgICAgIGlmICghKHR5cGUgaW4ga2V5cykgJiYgIW5vZGUucGFyYW0uY29udmVyc2lvbnNbal0pIHtcbiAgICAgICAgICAgICAgICBrZXlzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZWZpeCArICd0aHJvdyBjcmVhdGVFcnJvcihuYW1lLCBhcmd1bWVudHMubGVuZ3RoLCAnICsgaW5kZXggKyAnLCBhcmd1bWVudHNbJyArIGluZGV4ICsgJ10sIFxcJycgKyB0eXBlcy5qb2luKCcsJykgKyAnXFwnKTsnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhbGwgcmF3IHNpZ25hdHVyZXMgaW50byBhbiBhcnJheSB3aXRoIGV4cGFuZGVkIFNpZ25hdHVyZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBGdW5jdGlvbj59IHJhd1NpZ25hdHVyZXNcbiAgICAgKiBAcmV0dXJuIHtTaWduYXR1cmVbXX0gUmV0dXJucyBhbiBhcnJheSB3aXRoIGV4cGFuZGVkIHNpZ25hdHVyZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVNpZ25hdHVyZXMocmF3U2lnbmF0dXJlcykge1xuICAgICAgLy8gRklYTUU6IG5lZWQgdG8gaGF2ZSBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIHNpZ25hdHVyZXMsIGRvIG5vdCBjcmVhdGUgdmlhIG9iamVjdFxuICAgICAgdmFyIHNpZ25hdHVyZTtcbiAgICAgIHZhciBrZXlzID0ge307XG4gICAgICB2YXIgc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAodmFyIHR5cGVzIGluIHJhd1NpZ25hdHVyZXMpIHtcbiAgICAgICAgaWYgKHJhd1NpZ25hdHVyZXMuaGFzT3duUHJvcGVydHkodHlwZXMpKSB7XG4gICAgICAgICAgdmFyIGZuID0gcmF3U2lnbmF0dXJlc1t0eXBlc107XG4gICAgICAgICAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZSh0eXBlcywgZm4pO1xuXG4gICAgICAgICAgaWYgKHNpZ25hdHVyZS5pZ25vcmUoKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGV4cGFuZGVkID0gc2lnbmF0dXJlLmV4cGFuZCgpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGFuZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlX2kgPSBleHBhbmRlZFtpXTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBzaWduYXR1cmVfaS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0ga2V5c1trZXldO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgICBrZXlzW2tleV0gPSBzaWduYXR1cmVfaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY21wID0gU2lnbmF0dXJlLmNvbXBhcmUoc2lnbmF0dXJlX2ksIGV4aXN0aW5nKTtcbiAgICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBpZiBzb3J0ZWQgZmlyc3RcbiAgICAgICAgICAgICAgICBrZXlzW2tleV0gPSBzaWduYXR1cmVfaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBcIicgKyBrZXkgKyAnXCIgaXMgZGVmaW5lZCB0d2ljZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVsc2U6IGp1c3QgaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnZlcnQgZnJvbSBtYXAgdG8gYXJyYXlcbiAgICAgIGZvciAoa2V5IGluIGtleXMpIHtcbiAgICAgICAgaWYgKGtleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHNpZ25hdHVyZXMucHVzaChrZXlzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG9yZGVyIHRoZSBzaWduYXR1cmVzXG4gICAgICBzaWduYXR1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5jb21wYXJlKGEsIGIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGZpbHRlciByZWR1bmRhbnQgY29udmVyc2lvbnMgZnJvbSBzaWduYXR1cmVzIHdpdGggdmFyQXJnc1xuICAgICAgLy8gVE9ETzogc2ltcGxpZnkgdGhpcyBsb29wIG9yIG1vdmUgaXQgdG8gYSBzZXBhcmF0ZSBmdW5jdGlvblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNpZ25hdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcblxuICAgICAgICBpZiAoc2lnbmF0dXJlLnZhckFyZ3MpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBzaWduYXR1cmUucGFyYW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgdmFyIHBhcmFtID0gc2lnbmF0dXJlLnBhcmFtc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgdCA9IDA7XG4gICAgICAgICAgd2hpbGUgKHQgPCBwYXJhbS50eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5jb252ZXJzaW9uc1t0XSkge1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IHBhcmFtLnR5cGVzW3RdO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IHNpZ25hdHVyZXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBvdGhlci5wYXJhbXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyICE9PSBzaWduYXR1cmUgJiZcbiAgICAgICAgICAgICAgICAgICAgcCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWlucyhwLnR5cGVzLCB0eXBlKSAmJiAhcC5jb252ZXJzaW9uc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgKGNvbnZlcnNpb24pIHR5cGUgYWxyZWFkeSBleGlzdHMsIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZXMuc3BsaWNlKHQsIDEpO1xuICAgICAgICAgICAgICAgICAgcGFyYW0uY29udmVyc2lvbnMuc3BsaWNlKHQsIDEpO1xuICAgICAgICAgICAgICAgICAgdC0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaWduYXR1cmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBhbGwgYW55IHR5cGUgc2lnbmF0dXJlc1xuICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlW119IHNpZ25hdHVyZXNcbiAgICAgKiBAcmV0dXJuIHtTaWduYXR1cmVbXX0gUmV0dXJucyBvbmx5IGFueSB0eXBlIHNpZ25hdHVyZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJBbnlUeXBlU2lnbmF0dXJlcyAoc2lnbmF0dXJlcykge1xuICAgICAgdmFyIGZpbHRlcmVkID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2lnbmF0dXJlc1tpXS5hbnlUeXBlKSB7XG4gICAgICAgICAgZmlsdGVyZWQucHVzaChzaWduYXR1cmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgbWFwIHdpdGggbm9ybWFsaXplZCBzaWduYXR1cmVzIGFzIGtleSBhbmQgdGhlIGZ1bmN0aW9uIGFzIHZhbHVlXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVbXX0gc2lnbmF0dXJlcyAgIEFuIGFycmF5IHdpdGggc3BsaXQgc2lnbmF0dXJlc1xuICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBGdW5jdGlvbj59IFJldHVybnMgYSBtYXAgd2l0aCBub3JtYWxpemVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlcyBhcyBrZXksIGFuZCB0aGUgZnVuY3Rpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBTaWduYXR1cmVzKHNpZ25hdHVyZXMpIHtcbiAgICAgIHZhciBub3JtYWxpemVkID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZS5mbiAmJiAhc2lnbmF0dXJlLmhhc0NvbnZlcnNpb25zKCkpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gc2lnbmF0dXJlLnBhcmFtcy5qb2luKCcsJyk7XG4gICAgICAgICAgbm9ybWFsaXplZFtwYXJhbXNdID0gc2lnbmF0dXJlLmZuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHNpZ25hdHVyZXMgcmVjdXJzaXZlbHkgaW4gYSBub2RlIHRyZWUuXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVbXX0gc2lnbmF0dXJlcyAgQXJyYXkgd2l0aCBleHBhbmRlZCBzaWduYXR1cmVzXG4gICAgICogQHBhcmFtIHtQYXJhbVtdfSBwYXRoICAgICAgICAgICAgVHJhdmVyc2VkIHBhdGggb2YgcGFyYW1ldGVyIHR5cGVzXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVbXX0gYW55c1xuICAgICAqIEByZXR1cm4ge05vZGV9ICAgICAgICAgICAgICAgICAgIFJldHVybnMgYSBub2RlIHRyZWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVRyZWUoc2lnbmF0dXJlcywgcGF0aCwgYW55cykge1xuICAgICAgdmFyIGksIHNpZ25hdHVyZTtcbiAgICAgIHZhciBpbmRleCA9IHBhdGgubGVuZ3RoO1xuICAgICAgdmFyIG5vZGVTaWduYXR1cmU7XG5cbiAgICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHNpZ25hdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcblxuICAgICAgICAvLyBmaWx0ZXIgdGhlIGZpcnN0IHNpZ25hdHVyZSB3aXRoIHRoZSBjb3JyZWN0IG51bWJlciBvZiBwYXJhbXNcbiAgICAgICAgaWYgKHNpZ25hdHVyZS5wYXJhbXMubGVuZ3RoID09PSBpbmRleCAmJiAhbm9kZVNpZ25hdHVyZSkge1xuICAgICAgICAgIG5vZGVTaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lnbmF0dXJlLnBhcmFtc1tpbmRleF0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmlsdGVyZWQucHVzaChzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNvcnQgdGhlIGZpbHRlcmVkIHNpZ25hdHVyZXMgYnkgcGFyYW1cbiAgICAgIGZpbHRlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFBhcmFtLmNvbXBhcmUoYS5wYXJhbXNbaW5kZXhdLCBiLnBhcmFtc1tpbmRleF0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlY3Vyc2Ugb3ZlciB0aGUgc2lnbmF0dXJlc1xuICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzaWduYXR1cmUgPSBmaWx0ZXJlZFtpXTtcbiAgICAgICAgLy8gZ3JvdXAgc2lnbmF0dXJlcyB3aXRoIHRoZSBzYW1lIHBhcmFtIGF0IGN1cnJlbnQgaW5kZXhcbiAgICAgICAgdmFyIHBhcmFtID0gc2lnbmF0dXJlLnBhcmFtc1tpbmRleF07XG5cbiAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB0aGUgbmV4dCBmaWx0ZXIgbG9vcFxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cnkucGFyYW0ub3ZlcmxhcHBpbmcocGFyYW0pO1xuICAgICAgICB9KVswXTtcblxuICAgICAgICAvL3ZhciBleGlzdGluZztcbiAgICAgICAgLy9mb3IgKHZhciBqID0gMDsgaiA8IGVudHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gIGlmIChlbnRyaWVzW2pdLnBhcmFtLm92ZXJsYXBwaW5nKHBhcmFtKSkge1xuICAgICAgICAvLyAgICBleGlzdGluZyA9IGVudHJpZXNbal07XG4gICAgICAgIC8vICAgIGJyZWFrO1xuICAgICAgICAvLyAgfVxuICAgICAgICAvL31cblxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcucGFyYW0udmFyQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25mbGljdGluZyB0eXBlcyBcIicgKyBleGlzdGluZy5wYXJhbSArICdcIiBhbmQgXCInICsgcGFyYW0gKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhpc3Rpbmcuc2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgIHBhcmFtOiBwYXJhbSxcbiAgICAgICAgICAgIHNpZ25hdHVyZXM6IFtzaWduYXR1cmVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBhbGwgYW55IHR5cGUgc2lnbmF0dXJlIHRoYXQgY2FuIHN0aWxsIG1hdGNoIG91ciBjdXJyZW50IHBhdGhcbiAgICAgIHZhciBtYXRjaGluZ0FueXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhbnlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbnlzW2ldLnBhcmFtc1N0YXJ0V2l0aChwYXRoKSkge1xuICAgICAgICAgIG1hdGNoaW5nQW55cy5wdXNoKGFueXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZSBpZiB0aGVyZSBhcmUgYW55IHR5cGUgc2lnbmF0dXJlcyB0aGF0IGRvbid0IG1hdGNoIGFueSBvZiB0aGVcbiAgICAgIC8vIHNpZ25hdHVyZXMgdGhhdCB3ZSBoYXZlIGluIG91ciB0cmVlLCBpLmUuIHdlIGhhdmUgYWx0ZXJuYXRpdmVcbiAgICAgIC8vIG1hdGNoaW5nIHNpZ25hdHVyZShzKSBvdXRzaWRlIG9mIG91ciBjdXJyZW50IHRyZWUgYW5kIHdlIHNob3VsZFxuICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZW0gaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBleGNlcHRpb25cbiAgICAgIHZhciBmYWxsVGhyb3VnaCA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1hdGNoaW5nQW55cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWNvbnRhaW5zKHNpZ25hdHVyZXMsIG1hdGNoaW5nQW55c1tpXSkpIHtcbiAgICAgICAgICBmYWxsVGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgdGhlIGNoaWxkc1xuICAgICAgdmFyIGNoaWxkcyA9IG5ldyBBcnJheShlbnRyaWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICBjaGlsZHNbaV0gPSBwYXJzZVRyZWUoZW50cnkuc2lnbmF0dXJlcywgcGF0aC5jb25jYXQoZW50cnkucGFyYW0pLCBtYXRjaGluZ0FueXMpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTm9kZShwYXRoLCBub2RlU2lnbmF0dXJlLCBjaGlsZHMsIGZhbGxUaHJvdWdoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBhcnJheSBsaWtlIFsnYXJnMCcsICdhcmcxJywgJ2FyZzInXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgYXJndW1lbnRzIHRvIGdlbmVyYXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IHdpdGggYXJndW1lbnQgbmFtZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBcmdzKGNvdW50KSB7XG4gICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgd2l0aCBhbGwgYXJndW1lbnQgbmFtZXNcbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9ICdhcmcnICsgaTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcG9zZSBhIGZ1bmN0aW9uIGZyb20gc3ViLWZ1bmN0aW9ucyBlYWNoIGhhbmRsaW5nIGEgc2luZ2xlIHR5cGUgc2lnbmF0dXJlLlxuICAgICAqIFNpZ25hdHVyZXM6XG4gICAgICogICB0eXBlZChzaWduYXR1cmU6IHN0cmluZywgZm46IGZ1bmN0aW9uKVxuICAgICAqICAgdHlwZWQobmFtZTogc3RyaW5nLCBzaWduYXR1cmU6IHN0cmluZywgZm46IGZ1bmN0aW9uKVxuICAgICAqICAgdHlwZWQoc2lnbmF0dXJlczogT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPilcbiAgICAgKiAgIHR5cGVkKG5hbWU6IHN0cmluZywgc2lnbmF0dXJlczogT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPn0gc2lnbmF0dXJlc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSB0eXBlZCBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3R5cGVkKG5hbWUsIHNpZ25hdHVyZXMpIHtcbiAgICAgIHZhciByZWZzID0gbmV3IFJlZnMoKTtcblxuICAgICAgLy8gcGFyc2Ugc2lnbmF0dXJlcywgZXhwYW5kIHRoZW1cbiAgICAgIHZhciBfc2lnbmF0dXJlcyA9IHBhcnNlU2lnbmF0dXJlcyhzaWduYXR1cmVzKTtcbiAgICAgIGlmIChfc2lnbmF0dXJlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgcHJvdmlkZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIGFsbCBhbnkgdHlwZSBzaWduYXR1cmVzXG4gICAgICB2YXIgYW55cyA9IGZpbHRlckFueVR5cGVTaWduYXR1cmVzKF9zaWduYXR1cmVzKTtcblxuICAgICAgLy8gcGFyc2Ugc2lnbmF0dXJlcyBpbnRvIGEgbm9kZSB0cmVlXG4gICAgICB2YXIgbm9kZSA9IHBhcnNlVHJlZShfc2lnbmF0dXJlcywgW10sIGFueXMpO1xuXG4gICAgICAvL3ZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuICAgICAgLy9jb25zb2xlLmxvZygnUk9PVCcpO1xuICAgICAgLy9jb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qobm9kZSwgeyBkZXB0aDogbnVsbCB9KSk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGNvZGUgZm9yIHRoZSB0eXBlZCBmdW5jdGlvblxuICAgICAgdmFyIGNvZGUgPSBbXTtcbiAgICAgIHZhciBfbmFtZSA9IG5hbWUgfHwgJyc7XG4gICAgICB2YXIgX2FyZ3MgPSBnZXRBcmdzKG1heFBhcmFtcyhfc2lnbmF0dXJlcykpO1xuICAgICAgY29kZS5wdXNoKCdmdW5jdGlvbiAnICsgX25hbWUgKyAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJykgeycpO1xuICAgICAgY29kZS5wdXNoKCcgIFwidXNlIHN0cmljdFwiOycpO1xuICAgICAgY29kZS5wdXNoKCcgIHZhciBuYW1lID0gXFwnJyArIF9uYW1lICsgJ1xcJzsnKTtcbiAgICAgIGNvZGUucHVzaChub2RlLnRvQ29kZShyZWZzLCAnICAnLCBmYWxzZSkpO1xuICAgICAgY29kZS5wdXNoKCd9Jyk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGJvZHkgZm9yIHRoZSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICB2YXIgYm9keSA9IFtcbiAgICAgICAgcmVmcy50b0NvZGUoKSxcbiAgICAgICAgJ3JldHVybiAnICsgY29kZS5qb2luKCdcXG4nKVxuICAgICAgXS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gZXZhbHVhdGUgdGhlIEphdmFTY3JpcHQgY29kZSBhbmQgYXR0YWNoIGZ1bmN0aW9uIHJlZmVyZW5jZXNcbiAgICAgIHZhciBmYWN0b3J5ID0gKG5ldyBGdW5jdGlvbihyZWZzLm5hbWUsICdjcmVhdGVFcnJvcicsIGJvZHkpKTtcbiAgICAgIHZhciBmbiA9IGZhY3RvcnkocmVmcywgY3JlYXRlRXJyb3IpO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdGTlxcbicgKyBmbi50b1N0cmluZygpKTsgLy8gVE9ETzogY2xlYW51cFxuXG4gICAgICAvLyBhdHRhY2ggdGhlIHNpZ25hdHVyZXMgd2l0aCBzdWItZnVuY3Rpb25zIHRvIHRoZSBjb25zdHJ1Y3RlZCBmdW5jdGlvblxuICAgICAgZm4uc2lnbmF0dXJlcyA9IG1hcFNpZ25hdHVyZXMoX3NpZ25hdHVyZXMpO1xuXG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBwYXJhbWV0ZXJzIGluIGdpdmVucyBzaWduYXR1cmVzXG4gICAgICogQHBhcmFtIHtTaWduYXR1cmVbXX0gc2lnbmF0dXJlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYXhpbXVtIG51bWJlciBvZiBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4UGFyYW1zKHNpZ25hdHVyZXMpIHtcbiAgICAgIHZhciBtYXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ25hdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxlbiA9IHNpZ25hdHVyZXNbaV0ucGFyYW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IG1heCkge1xuICAgICAgICAgIG1heCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBvZiBhIHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSB0eXBlIG9mIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHlwZU9mKHgpIHtcbiAgICAgIHZhciBvYmo7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdHlwZWQudHlwZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5Lm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgLy8gQXJyYXkgYW5kIERhdGUgYXJlIGFsc28gT2JqZWN0LCBzbyB0ZXN0IGZvciBPYmplY3QgYWZ0ZXJ3YXJkc1xuICAgICAgICAgIG9iaiA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChlbnRyeS50ZXN0KHgpKSByZXR1cm4gZW50cnkubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhdCBsYXN0LCB0ZXN0IHdoZXRoZXIgYW4gb2JqZWN0XG4gICAgICBpZiAob2JqICYmIG9iai50ZXN0KHgpKSByZXR1cm4gb2JqLm5hbWU7XG5cbiAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCB3aGV0aGVyIGFuIGFycmF5IGNvbnRhaW5zIHNvbWUgaXRlbVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFycmF5IGNvbnRhaW5zIGl0ZW0sIGZhbHNlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhhcnJheSwgaXRlbSkge1xuICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm4geyp9IGl0ZW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0IChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8vIGRhdGEgdHlwZSB0ZXN0c1xuICAgIHZhciB0eXBlcyA9IFtcbiAgICAgIHsgbmFtZTogJ251bWJlcicsICAgIHRlc3Q6IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgfSB9LFxuICAgICAgeyBuYW1lOiAnc3RyaW5nJywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyB9IH0sXG4gICAgICB7IG5hbWU6ICdib29sZWFuJywgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdib29sZWFuJyB9IH0sXG4gICAgICB7IG5hbWU6ICdGdW5jdGlvbicsICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbid9IH0sXG4gICAgICB7IG5hbWU6ICdBcnJheScsICAgICB0ZXN0OiBBcnJheS5pc0FycmF5IH0sXG4gICAgICB7IG5hbWU6ICdEYXRlJywgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIERhdGUgfSB9LFxuICAgICAgeyBuYW1lOiAnUmVnRXhwJywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWdFeHAgfSB9LFxuICAgICAgeyBuYW1lOiAnT2JqZWN0JywgICAgdGVzdDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB9IH0sXG4gICAgICB7IG5hbWU6ICdudWxsJywgICAgICB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbnVsbCB9IH0sXG4gICAgICB7IG5hbWU6ICd1bmRlZmluZWQnLCB0ZXN0OiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gdW5kZWZpbmVkIH0gfVxuICAgIF07XG5cbiAgICAvLyBjb25maWd1cmF0aW9uXG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgLy8gdHlwZSBjb252ZXJzaW9ucy4gT3JkZXIgaXMgaW1wb3J0YW50XG4gICAgdmFyIGNvbnZlcnNpb25zID0gW107XG5cbiAgICAvLyB0eXBlcyB0byBiZSBpZ25vcmVkXG4gICAgdmFyIGlnbm9yZSA9IFtdO1xuXG4gICAgLy8gdGVtcG9yYXJ5IG9iamVjdCBmb3IgaG9sZGluZyB0eXBlcyBhbmQgY29udmVyc2lvbnMsIGZvciBjb25zdHJ1Y3RpbmdcbiAgICAvLyB0aGUgYHR5cGVkYCBmdW5jdGlvbiBpdHNlbGZcbiAgICAvLyBUT0RPOiBmaW5kIGEgbW9yZSBlbGVnYW50IHNvbHV0aW9uIGZvciB0aGlzXG4gICAgdmFyIHR5cGVkID0ge1xuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICB0eXBlczogdHlwZXMsXG4gICAgICBjb252ZXJzaW9uczogY29udmVyc2lvbnMsXG4gICAgICBpZ25vcmU6IGlnbm9yZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIHR5cGVkIGZ1bmN0aW9uIGl0c2VsZiB3aXRoIHZhcmlvdXMgc2lnbmF0dXJlc1xuICAgICAqXG4gICAgICogU2lnbmF0dXJlczpcbiAgICAgKlxuICAgICAqICAgdHlwZWQoc2lnbmF0dXJlczogT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPilcbiAgICAgKiAgIHR5cGVkKG5hbWU6IHN0cmluZywgc2lnbmF0dXJlczogT2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uPilcbiAgICAgKi9cbiAgICB0eXBlZCA9IF90eXBlZCgndHlwZWQnLCB7XG4gICAgICAnT2JqZWN0JzogZnVuY3Rpb24gKHNpZ25hdHVyZXMpIHtcbiAgICAgICAgdmFyIGZucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzaWduYXR1cmUgaW4gc2lnbmF0dXJlcykge1xuICAgICAgICAgIGlmIChzaWduYXR1cmVzLmhhc093blByb3BlcnR5KHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIGZucy5wdXNoKHNpZ25hdHVyZXNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gZ2V0TmFtZShmbnMpO1xuXG4gICAgICAgIHJldHVybiBfdHlwZWQobmFtZSwgc2lnbmF0dXJlcyk7XG4gICAgICB9LFxuICAgICAgJ3N0cmluZywgT2JqZWN0JzogX3R5cGVkLFxuICAgICAgLy8gVE9ETzogYWRkIGEgc2lnbmF0dXJlICdBcnJheS48ZnVuY3Rpb24+J1xuICAgICAgJy4uLkZ1bmN0aW9uJzogZnVuY3Rpb24gKGZucykge1xuICAgICAgICB2YXIgZXJyO1xuICAgICAgICB2YXIgbmFtZSA9IGdldE5hbWUoZm5zKTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZXMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmbiA9IGZuc1tpXTtcblxuICAgICAgICAgIC8vIHRlc3Qgd2hldGhlciB0aGlzIGlzIGEgdHlwZWQtZnVuY3Rpb25cbiAgICAgICAgICBpZiAoISh0eXBlb2YgZm4uc2lnbmF0dXJlcyA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbiBpcyBubyB0eXBlZC1mdW5jdGlvbiAoaW5kZXg6ICcgKyBpICsgJyknKTtcbiAgICAgICAgICAgIGVyci5kYXRhID0ge2luZGV4OiBpfTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtZXJnZSB0aGUgc2lnbmF0dXJlc1xuICAgICAgICAgIGZvciAodmFyIHNpZ25hdHVyZSBpbiBmbi5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBpZiAoZm4uc2lnbmF0dXJlcy5oYXNPd25Qcm9wZXJ0eShzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICAgIGlmIChzaWduYXR1cmVzLmhhc093blByb3BlcnR5KHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4uc2lnbmF0dXJlc1tzaWduYXR1cmVdICE9PSBzaWduYXR1cmVzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignU2lnbmF0dXJlIFwiJyArIHNpZ25hdHVyZSArICdcIiBpcyBkZWZpbmVkIHR3aWNlJyk7XG4gICAgICAgICAgICAgICAgICBlcnIuZGF0YSA9IHtzaWduYXR1cmU6IHNpZ25hdHVyZX07XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2U6IGJvdGggc2lnbmF0dXJlcyBwb2ludCB0byB0aGUgc2FtZSBmdW5jdGlvbiwgdGhhdCdzIGZpbmVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVzW3NpZ25hdHVyZV0gPSBmbi5zaWduYXR1cmVzW3NpZ25hdHVyZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3R5cGVkKG5hbWUsIHNpZ25hdHVyZXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHNwZWNpZmljIHNpZ25hdHVyZSBmcm9tIGEgKGNvbXBvc2VkKSB0eXBlZCBmdW5jdGlvbiwgZm9yXG4gICAgICogZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgdHlwZWQuZmluZChmbiwgWydudW1iZXInLCAnc3RyaW5nJ10pXG4gICAgICogICB0eXBlZC5maW5kKGZuLCAnbnVtYmVyLCBzdHJpbmcnKVxuICAgICAqXG4gICAgICogRnVuY3Rpb24gZmluZCBvbmx5IG9ubHkgd29ya3MgZm9yIGV4YWN0IG1hdGNoZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgICAgICAgICBBIHR5cGVkLWZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gc2lnbmF0dXJlICAgU2lnbmF0dXJlIHRvIGJlIGZvdW5kLCBjYW4gYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvciBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgbWF0Y2hpbmcgc2lnbmF0dXJlLCBvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93cyBhbiBlcnJyb3Igd2hlbiBubyBzaWduYXR1cmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kIChmbiwgc2lnbmF0dXJlKSB7XG4gICAgICBpZiAoIWZuLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24gaXMgbm8gdHlwZWQtZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsaXplIGlucHV0XG4gICAgICB2YXIgYXJyO1xuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFyciA9IHNpZ25hdHVyZS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFycltpXSA9IGFycltpXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkge1xuICAgICAgICBhcnIgPSBzaWduYXR1cmU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGFycmF5IG9yIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyID0gYXJyLmpvaW4oJywnKTtcblxuICAgICAgLy8gZmluZCBhbiBleGFjdCBtYXRjaFxuICAgICAgdmFyIG1hdGNoID0gZm4uc2lnbmF0dXJlc1tzdHJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogZXh0ZW5kIGZpbmQgdG8gbWF0Y2ggbm9uLWV4YWN0IHNpZ25hdHVyZXNcblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG5vdCBmb3VuZCAoc2lnbmF0dXJlOiAnICsgKGZuLm5hbWUgfHwgJ3VubmFtZWQnKSArICcoJyArIGFyci5qb2luKCcsICcpICsgJykpJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGdpdmVuIHZhbHVlIHRvIGFub3RoZXIgZGF0YSB0eXBlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnQgKHZhbHVlLCB0eXBlKSB7XG4gICAgICB2YXIgZnJvbSA9IGdldFR5cGVPZih2YWx1ZSk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbnZlcnNpb24gaXMgbmVlZGVkXG4gICAgICBpZiAodHlwZSA9PT0gZnJvbSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQuY29udmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSB0eXBlZC5jb252ZXJzaW9uc1tpXTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb24uZnJvbSA9PT0gZnJvbSAmJiBjb252ZXJzaW9uLnRvID09PSB0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnNpb24uY29udmVydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBmcm9tICcgKyBmcm9tICsgJyB0byAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIHR5cGVzIGFuZCBjb252ZXJzaW9ucyB0byB0aGUgZmluYWwgYHR5cGVkYCBmdW5jdGlvblxuICAgIHR5cGVkLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0eXBlZC50eXBlcyA9IHR5cGVzO1xuICAgIHR5cGVkLmNvbnZlcnNpb25zID0gY29udmVyc2lvbnM7XG4gICAgdHlwZWQuaWdub3JlID0gaWdub3JlO1xuICAgIHR5cGVkLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICB0eXBlZC5maW5kID0gZmluZDtcbiAgICB0eXBlZC5jb252ZXJ0ID0gY29udmVydDtcblxuICAgIC8vIGFkZCBhIHR5cGVcbiAgICB0eXBlZC5hZGRUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZS5uYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZS50ZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCB3aXRoIHByb3BlcnRpZXMge25hbWU6IHN0cmluZywgdGVzdDogZnVuY3Rpb259IGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIHR5cGVkLnR5cGVzLnB1c2godHlwZSk7XG4gICAgfTtcblxuICAgIC8vIGFkZCBhIGNvbnZlcnNpb25cbiAgICB0eXBlZC5hZGRDb252ZXJzaW9uID0gZnVuY3Rpb24gKGNvbnZlcnNpb24pIHtcbiAgICAgIGlmICghY29udmVyc2lvblxuICAgICAgICAgIHx8IHR5cGVvZiBjb252ZXJzaW9uLmZyb20gIT09ICdzdHJpbmcnXG4gICAgICAgICAgfHwgdHlwZW9mIGNvbnZlcnNpb24udG8gIT09ICdzdHJpbmcnXG4gICAgICAgICAgfHwgdHlwZW9mIGNvbnZlcnNpb24uY29udmVydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHtmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGNvbnZlcnQ6IGZ1bmN0aW9ufSBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICB0eXBlZC5jb252ZXJzaW9ucy5wdXNoKGNvbnZlcnNpb24pO1xuICAgIH07XG5cbiAgICByZXR1cm4gdHlwZWQ7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlKCk7XG59KSk7XG4iXX0=
